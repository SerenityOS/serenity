/*
 * Copyright (c) 2024,  Marek Kn√°pek <knapek.mar@gmail.com>
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */

#include <LibTest/TestCase.h>

#include <AK/SIMD.h>
#include <AK/SIMDExtras.h>

// See the comment in <AK/SIMDMath.h>
#pragma GCC diagnostic ignored "-Wpsabi"

TEST_CASE(item_reverse_i8x2)
{
    u8 const input[] = { 0x80, 0x81 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x2>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_i8x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x4>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_i8x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x8>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_i8x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x16>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_i8x32)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x32>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9f, 0x9e, 0x9d, 0x9c, 0x9b, 0x9a, 0x99, 0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_i16x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i16x2>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x82, 0x83, 0x80, 0x81 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_i16x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i16x4>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x86, 0x87, 0x84, 0x85, 0x82, 0x83, 0x80, 0x81 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_i16x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i16x8>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8e, 0x8f, 0x8c, 0x8d, 0x8a, 0x8b, 0x88, 0x89, 0x86, 0x87, 0x84, 0x85, 0x82, 0x83, 0x80, 0x81 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_i16x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i16x16>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9e, 0x9f, 0x9c, 0x9d, 0x9a, 0x9b, 0x98, 0x99, 0x96, 0x97, 0x94, 0x95, 0x92, 0x93, 0x90, 0x91, 0x8e, 0x8f, 0x8c, 0x8d, 0x8a, 0x8b, 0x88, 0x89, 0x86, 0x87, 0x84, 0x85, 0x82, 0x83, 0x80, 0x81 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_c8x2)
{
    u8 const input[] = { 0x80, 0x81 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x2>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_c8x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x4>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_c8x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x8>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_c8x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x16>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_c8x32)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x32>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9f, 0x9e, 0x9d, 0x9c, 0x9b, 0x9a, 0x99, 0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_i32x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i32x2>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x84, 0x85, 0x86, 0x87, 0x80, 0x81, 0x82, 0x83 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_i32x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i32x4>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8c, 0x8d, 0x8e, 0x8f, 0x88, 0x89, 0x8a, 0x8b, 0x84, 0x85, 0x86, 0x87, 0x80, 0x81, 0x82, 0x83 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_i32x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i32x8>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9c, 0x9d, 0x9e, 0x9f, 0x98, 0x99, 0x9a, 0x9b, 0x94, 0x95, 0x96, 0x97, 0x90, 0x91, 0x92, 0x93, 0x8c, 0x8d, 0x8e, 0x8f, 0x88, 0x89, 0x8a, 0x8b, 0x84, 0x85, 0x86, 0x87, 0x80, 0x81, 0x82, 0x83 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_i64x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i64x2>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_i64x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i64x4>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_u8x2)
{
    u8 const input[] = { 0x80, 0x81 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x2>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_u8x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x4>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_u8x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x8>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_u8x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x16>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_u8x32)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x32>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9f, 0x9e, 0x9d, 0x9c, 0x9b, 0x9a, 0x99, 0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_u16x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u16x2>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x82, 0x83, 0x80, 0x81 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_u16x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u16x4>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x86, 0x87, 0x84, 0x85, 0x82, 0x83, 0x80, 0x81 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_u16x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u16x8>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8e, 0x8f, 0x8c, 0x8d, 0x8a, 0x8b, 0x88, 0x89, 0x86, 0x87, 0x84, 0x85, 0x82, 0x83, 0x80, 0x81 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_u16x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u16x16>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9e, 0x9f, 0x9c, 0x9d, 0x9a, 0x9b, 0x98, 0x99, 0x96, 0x97, 0x94, 0x95, 0x92, 0x93, 0x90, 0x91, 0x8e, 0x8f, 0x8c, 0x8d, 0x8a, 0x8b, 0x88, 0x89, 0x86, 0x87, 0x84, 0x85, 0x82, 0x83, 0x80, 0x81 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_u32x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u32x2>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x84, 0x85, 0x86, 0x87, 0x80, 0x81, 0x82, 0x83 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_u32x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u32x4>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8c, 0x8d, 0x8e, 0x8f, 0x88, 0x89, 0x8a, 0x8b, 0x84, 0x85, 0x86, 0x87, 0x80, 0x81, 0x82, 0x83 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_u32x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u32x8>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9c, 0x9d, 0x9e, 0x9f, 0x98, 0x99, 0x9a, 0x9b, 0x94, 0x95, 0x96, 0x97, 0x90, 0x91, 0x92, 0x93, 0x8c, 0x8d, 0x8e, 0x8f, 0x88, 0x89, 0x8a, 0x8b, 0x84, 0x85, 0x86, 0x87, 0x80, 0x81, 0x82, 0x83 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_u64x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u64x2>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(item_reverse_u64x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u64x4>(&input[0]);
    v = AK::SIMD::item_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_i8x2)
{
    u8 const input[] = { 0x80, 0x81 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x2>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_i8x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x4>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_i8x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x8>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_i8x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x16>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_i8x32)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x32>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9f, 0x9e, 0x9d, 0x9c, 0x9b, 0x9a, 0x99, 0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_i16x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i16x2>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_i16x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i16x4>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_i16x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i16x8>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_i16x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i16x16>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9f, 0x9e, 0x9d, 0x9c, 0x9b, 0x9a, 0x99, 0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_c8x2)
{
    u8 const input[] = { 0x80, 0x81 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x2>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_c8x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x4>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_c8x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x8>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_c8x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x16>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_c8x32)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x32>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9f, 0x9e, 0x9d, 0x9c, 0x9b, 0x9a, 0x99, 0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_i32x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i32x2>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_i32x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i32x4>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_i32x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i32x8>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9f, 0x9e, 0x9d, 0x9c, 0x9b, 0x9a, 0x99, 0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_i64x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i64x2>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_i64x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i64x4>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9f, 0x9e, 0x9d, 0x9c, 0x9b, 0x9a, 0x99, 0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_u8x2)
{
    u8 const input[] = { 0x80, 0x81 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x2>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_u8x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x4>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_u8x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x8>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_u8x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x16>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_u8x32)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x32>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9f, 0x9e, 0x9d, 0x9c, 0x9b, 0x9a, 0x99, 0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_u16x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u16x2>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_u16x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u16x4>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_u16x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u16x8>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_u16x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u16x16>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9f, 0x9e, 0x9d, 0x9c, 0x9b, 0x9a, 0x99, 0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_u32x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u32x2>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_u32x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u32x4>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_u32x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u32x8>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9f, 0x9e, 0x9d, 0x9c, 0x9b, 0x9a, 0x99, 0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_u64x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u64x2>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(byte_reverse_u64x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u64x4>(&input[0]);
    v = AK::SIMD::byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x9f, 0x9e, 0x9d, 0x9c, 0x9b, 0x9a, 0x99, 0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_i8x2)
{
    u8 const input[] = { 0x80, 0x81 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x2>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_i8x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x4>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81, 0x82, 0x83 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_i8x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x8>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_i8x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x16>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_i8x32)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i8x32>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_i16x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i16x2>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x81, 0x80, 0x83, 0x82 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_i16x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i16x4>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x81, 0x80, 0x83, 0x82, 0x85, 0x84, 0x87, 0x86 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_i16x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i16x8>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x81, 0x80, 0x83, 0x82, 0x85, 0x84, 0x87, 0x86, 0x89, 0x88, 0x8b, 0x8a, 0x8d, 0x8c, 0x8f, 0x8e };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_i16x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i16x16>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x81, 0x80, 0x83, 0x82, 0x85, 0x84, 0x87, 0x86, 0x89, 0x88, 0x8b, 0x8a, 0x8d, 0x8c, 0x8f, 0x8e, 0x91, 0x90, 0x93, 0x92, 0x95, 0x94, 0x97, 0x96, 0x99, 0x98, 0x9b, 0x9a, 0x9d, 0x9c, 0x9f, 0x9e };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_c8x2)
{
    u8 const input[] = { 0x80, 0x81 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x2>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_c8x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x4>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81, 0x82, 0x83 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_c8x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x8>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_c8x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x16>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_c8x32)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::c8x32>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_i32x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i32x2>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x83, 0x82, 0x81, 0x80, 0x87, 0x86, 0x85, 0x84 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_i32x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i32x4>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x83, 0x82, 0x81, 0x80, 0x87, 0x86, 0x85, 0x84, 0x8b, 0x8a, 0x89, 0x88, 0x8f, 0x8e, 0x8d, 0x8c };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_i32x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i32x8>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x83, 0x82, 0x81, 0x80, 0x87, 0x86, 0x85, 0x84, 0x8b, 0x8a, 0x89, 0x88, 0x8f, 0x8e, 0x8d, 0x8c, 0x93, 0x92, 0x91, 0x90, 0x97, 0x96, 0x95, 0x94, 0x9b, 0x9a, 0x99, 0x98, 0x9f, 0x9e, 0x9d, 0x9c };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_i64x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i64x2>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_i64x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::i64x4>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x9f, 0x9e, 0x9d, 0x9c, 0x9b, 0x9a, 0x99, 0x98 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_u8x2)
{
    u8 const input[] = { 0x80, 0x81 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x2>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_u8x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x4>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81, 0x82, 0x83 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_u8x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x8>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_u8x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x16>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_u8x32)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u8x32>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_u16x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u16x2>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x81, 0x80, 0x83, 0x82 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_u16x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u16x4>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x81, 0x80, 0x83, 0x82, 0x85, 0x84, 0x87, 0x86 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_u16x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u16x8>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x81, 0x80, 0x83, 0x82, 0x85, 0x84, 0x87, 0x86, 0x89, 0x88, 0x8b, 0x8a, 0x8d, 0x8c, 0x8f, 0x8e };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_u16x16)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u16x16>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x81, 0x80, 0x83, 0x82, 0x85, 0x84, 0x87, 0x86, 0x89, 0x88, 0x8b, 0x8a, 0x8d, 0x8c, 0x8f, 0x8e, 0x91, 0x90, 0x93, 0x92, 0x95, 0x94, 0x97, 0x96, 0x99, 0x98, 0x9b, 0x9a, 0x9d, 0x9c, 0x9f, 0x9e };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_u32x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87 };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u32x2>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x83, 0x82, 0x81, 0x80, 0x87, 0x86, 0x85, 0x84 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_u32x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u32x4>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x83, 0x82, 0x81, 0x80, 0x87, 0x86, 0x85, 0x84, 0x8b, 0x8a, 0x89, 0x88, 0x8f, 0x8e, 0x8d, 0x8c };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_u32x8)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u32x8>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x83, 0x82, 0x81, 0x80, 0x87, 0x86, 0x85, 0x84, 0x8b, 0x8a, 0x89, 0x88, 0x8f, 0x8e, 0x8d, 0x8c, 0x93, 0x92, 0x91, 0x90, 0x97, 0x96, 0x95, 0x94, 0x9b, 0x9a, 0x99, 0x98, 0x9f, 0x9e, 0x9d, 0x9c };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_u64x2)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u64x2>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}

TEST_CASE(elementwise_byte_reverse_u64x4)
{
    u8 const input[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f };
    auto v = AK::SIMD::load_unaligned<AK::SIMD::u64x4>(&input[0]);
    v = AK::SIMD::elementwise_byte_reverse(v);
    u8 result[sizeof(input)] {};
    AK::SIMD::store_unaligned(&result[0], v);

    u8 const expected[] = { 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x9f, 0x9e, 0x9d, 0x9c, 0x9b, 0x9a, 0x99, 0x98 };
    for (int i = 0; i != static_cast<int>(sizeof(result)); ++i) {
        EXPECT_EQ(result[i], expected[i]);
    }
}
