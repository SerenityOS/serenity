/*
 * Copyright (c) 2018-2020, Andreas Kling <kling@serenityos.org>
 * Copyright (c) 2021, Maxime Friess <M4x1me@pm.me>
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */

#include <AK/ScopeGuard.h>
#include <AK/String.h>
#include <AK/Vector.h>
#include <errno.h>
#include <errno_codes.h>
#include <grp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

extern "C" {

static FILE* s_stream = nullptr;
static unsigned s_line_number = 0;

void setgrent()
{
    s_line_number = 0;
    if (s_stream) {
        rewind(s_stream);
    } else {
        s_stream = fopen("/etc/group", "r");
        if (!s_stream) {
            perror("open /etc/group");
        }
    }
}

void endgrent()
{
    s_line_number = 0;
    if (s_stream) {
        fclose(s_stream);
        s_stream = nullptr;
    }
}

struct group* getgrgid(gid_t gid)
{
    setgrent();
    ScopeGuard guard = [] { endgrent(); };
    while (auto* gr = getgrent()) {
        if (gr->gr_gid == gid)
            return gr;
    }
    return nullptr;
}

struct group* getgrnam(char const* name)
{
    setgrent();
    ScopeGuard guard = [] { endgrent(); };
    while (auto* gr = getgrent()) {
        if (!strcmp(gr->gr_name, name))
            return gr;
    }
    return nullptr;
}

static bool parse_grpdb_entry(char* buffer, size_t buffer_size, struct group& group_entry)
{
    size_t line_length = strlen(buffer);

    for (size_t i = 0; i < line_length; ++i) {
        auto& ch = buffer[i];
        if (ch == '\r' || ch == '\n')
            line_length = i;
        if (ch == ':' || ch == '\r' || ch == '\n')
            ch = '\0';
    }

    auto line = StringView { buffer, line_length };
    auto parts = line.split_view('\0', SplitBehavior::KeepEmpty);
    if (parts.size() != 4) {
        warnln("parse_grpdb_entry(): Malformed entry on line {}: '{}' has {} parts", s_line_number, line, parts.size());
        return false;
    }

    auto name = parts[0];
    auto passwd = parts[1];
    auto& gid_string = parts[2];
    StringView members_string = parts[3];

    auto gid = gid_string.to_uint();
    if (!gid.has_value()) {
        warnln("parse_grpdb_entry(): Malformed GID on line {}", s_line_number);
        return false;
    }

    // Generate table of members pointers.
    Vector<char const*> members_ptrs;
    auto members = members_string.split_view(',');
    members_ptrs.clear_with_capacity();
    members_ptrs.ensure_capacity(members.size() + 1);
    for (auto& member : members) {
        members_ptrs.append(member.characters_without_null_termination());
    }
    members_ptrs.append(nullptr);

    // Convert remaining commas to null terminators. Last gr_mem entry uses the whole line's null terminator.
    // 3 for 3 null terminators.
    size_t members_position = name.length() + passwd.length() + gid_string.length() + 3;
    for (size_t i = members_position; i < line_length; i++)
        if (buffer[i] == ',')
            buffer[i] = '\0';

    // Must have room at the end of the buffer for the new table.
    // Remaining space is one byte past null terminator generated by original line.
    size_t bytes_used = line_length + 1;
    size_t ptrs_size = sizeof(char const*) * members_ptrs.size();

    if (bytes_used + ptrs_size < buffer_size) {
        char* buffer_remaining = buffer + bytes_used;
        memcpy(buffer_remaining, members_ptrs.data(), ptrs_size);

        group_entry.gr_gid = gid.value();
        group_entry.gr_name = const_cast<char*>(name.characters_without_null_termination());
        group_entry.gr_passwd = const_cast<char*>(passwd.characters_without_null_termination());
        group_entry.gr_mem = reinterpret_cast<char**>(buffer_remaining);

        return true;
    } else {
        warnln("parse_grpdb_entry(): Provided buffer too small to fit table for gr_mem");
        errno = ERANGE;
        return false;
    }
}

struct group* getgrent()
{
    static struct group group_entry;
    static char buffer[1024];
    struct group* result;
    if (getgrent_r(&group_entry, buffer, sizeof(buffer), &result) < 0)
        return nullptr;
    return result;
}

int getgrent_r(struct group* group_buf, char* buffer, size_t buffer_size, struct group** group_entry_ptr)
{
    if (!s_stream)
        setgrent();

    while (true) {
        if (!s_stream || feof(s_stream)) {
            errno = EIO;
            return -1;
        }

        if (ferror(s_stream)) {
            warnln("getgrent_r(): Read error: {}", strerror(ferror(s_stream)));
            errno = EIO;
            return -1;
        }

        ++s_line_number;
        char* s = fgets(buffer, buffer_size, s_stream);

        // Silently tolerate an empty line at the end.
        if ((!s || !s[0]) && feof(s_stream)) {
            *group_entry_ptr = nullptr;
            return 0;
        }

        if (strlen(s) == buffer_size - 1) {
            errno = ERANGE;
            return -1;
        }

        if (parse_grpdb_entry(buffer, buffer_size, *group_buf)) {
            *group_entry_ptr = group_buf;
            return 0;
        }
        // Otherwise, proceed to the next line.
    }
}

int initgroups(char const* user, gid_t extra_gid)
{
    size_t count = 0;
    gid_t gids[32];
    bool extra_gid_added = false;
    setgrent();
    while (auto* gr = getgrent()) {
        for (auto* mem = gr->gr_mem; *mem; ++mem) {
            if (!strcmp(*mem, user)) {
                gids[count++] = gr->gr_gid;
                if (gr->gr_gid == extra_gid)
                    extra_gid_added = true;
                break;
            }
        }
    }
    endgrent();
    if (!extra_gid_added)
        gids[count++] = extra_gid;
    return setgroups(count, gids);
}

int putgrent(const struct group* group, FILE* stream)
{
    if (!group || !stream || !group->gr_name || !group->gr_passwd) {
        errno = EINVAL;
        return -1;
    }

    auto is_valid_field = [](char const* str) {
        return str && !strpbrk(str, ":\n");
    };

    if (!is_valid_field(group->gr_name) || !is_valid_field(group->gr_passwd)) {
        errno = EINVAL;
        return -1;
    }

    int nwritten = fprintf(stream, "%s:%s:%u:", group->gr_name, group->gr_passwd, group->gr_gid);
    if (!nwritten || nwritten < 0) {
        errno = ferror(stream);
        return -1;
    }

    if (group->gr_mem) {
        for (size_t i = 0; group->gr_mem[i] != nullptr; i++) {
            nwritten = fprintf(stream, i == 0 ? "%s" : ",%s", group->gr_mem[i]);
            if (!nwritten || nwritten < 0) {
                errno = ferror(stream);
                return -1;
            }
        }
    }

    nwritten = fprintf(stream, "\n");
    if (!nwritten || nwritten < 0) {
        errno = ferror(stream);
        return -1;
    }

    return 0;
}
}
