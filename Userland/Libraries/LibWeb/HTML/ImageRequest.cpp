/*
 * Copyright (c) 2023, Andreas Kling <kling@serenityos.org>
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */

#include <AK/HashTable.h>
#include <LibGfx/Bitmap.h>
#include <LibWeb/Fetch/Fetching/Fetching.h>
#include <LibWeb/Fetch/Infrastructure/FetchAlgorithms.h>
#include <LibWeb/Fetch/Infrastructure/FetchController.h>
#include <LibWeb/Fetch/Infrastructure/HTTP/Responses.h>
#include <LibWeb/HTML/AnimatedBitmapDecodedImageData.h>
#include <LibWeb/HTML/DecodedImageData.h>
#include <LibWeb/HTML/ImageRequest.h>
#include <LibWeb/HTML/ListOfAvailableImages.h>
#include <LibWeb/Platform/ImageCodecPlugin.h>
#include <LibWeb/SVG/SVGDecodedImageData.h>

namespace Web::HTML {

JS::NonnullGCPtr<ImageRequest> ImageRequest::create(JS::Realm& realm, Page& page)
{
    return realm.heap().allocate<ImageRequest>(realm, page);
}

ImageRequest::ImageRequest(Page& page)
    : m_page(page)
{
}

ImageRequest::~ImageRequest()
{
}

void ImageRequest::visit_edges(JS::Cell::Visitor& visitor)
{
    Base::visit_edges(visitor);
    visitor.visit(m_shared_image_request);
}

// https://html.spec.whatwg.org/multipage/images.html#img-available
bool ImageRequest::is_available() const
{
    // When an image request's state is either partially available or completely available, the image request is said to be available.
    return m_state == State::PartiallyAvailable || m_state == State::CompletelyAvailable;
}

bool ImageRequest::is_fetching() const
{
    return m_shared_image_request && m_shared_image_request->is_fetching();
}

ImageRequest::State ImageRequest::state() const
{
    return m_state;
}

void ImageRequest::set_state(State state)
{
    m_state = state;
}

AK::URL const& ImageRequest::current_url() const
{
    return m_current_url;
}

void ImageRequest::set_current_url(JS::Realm& realm, AK::URL url)
{
    m_current_url = move(url);
    if (m_current_url.is_valid())
        m_shared_image_request = SharedImageRequest::get_or_create(realm, m_page, m_current_url);
}

// https://html.spec.whatwg.org/multipage/images.html#abort-the-image-request
void abort_the_image_request(JS::Realm&, ImageRequest* image_request)
{
    // 1. If image request is null, then return.
    if (!image_request)
        return;

    // 2. Forget image request's image data, if any.
    image_request->set_image_data(nullptr);

    // 3. Abort any instance of the fetching algorithm for image request,
    //    discarding any pending tasks generated by that algorithm.
    // AD-HOC: We simply don't do this, since our SharedImageRequest may be used by someone else.
}

RefPtr<DecodedImageData const> ImageRequest::image_data() const
{
    return m_image_data;
}

void ImageRequest::set_image_data(RefPtr<DecodedImageData const> data)
{
    m_image_data = move(data);
}

// https://html.spec.whatwg.org/multipage/images.html#prepare-an-image-for-presentation
void ImageRequest::prepare_for_presentation(HTMLImageElement&)
{
    // FIXME: 1. Let exifTagMap be the EXIF tags obtained from req's image data, as defined by the relevant codec. [EXIF]
    // FIXME: 2. Let physicalWidth and physicalHeight be the width and height obtained from req's image data, as defined by the relevant codec.
    // FIXME: 3. Let dimX be the value of exifTagMap's tag 0xA002 (PixelXDimension).
    // FIXME: 4. Let dimY be the value of exifTagMap's tag 0xA003 (PixelYDimension).
    // FIXME: 5. Let resX be the value of exifTagMap's tag 0x011A (XResolution).
    // FIXME: 6. Let resY be the value of exifTagMap's tag 0x011B (YResolution).
    // FIXME: 7. Let resUnit be the value of exifTagMap's tag 0x0128 (ResolutionUnit).
    // FIXME: 8. If either dimX or dimY is not a positive integer, then return.
    // FIXME: 9. If either resX or resY is not a positive floating-point number, then return.
    // FIXME: 10. If resUnit is not equal to 2 (Inch), then return.
    // FIXME: 11. Let widthFromDensity be the value of physicalWidth, multiplied by 72 and divided by resX.
    // FIXME: 12. Let heightFromDensity be the value of physicalHeight, multiplied by 72 and divided by resY.
    // FIXME: 13. If widthFromDensity is not equal to dimX or heightFromDensity is not equal to dimY, then return.
    // FIXME: 14. If req's image data is CORS-cross-origin, then set img's intrinsic dimensions to dimX and dimY, scale img's pixel data accordingly, and return.
    // FIXME: 15. Set req's preferred density-corrected dimensions to a struct with its width set to dimX and its height set to dimY.
    // FIXME: 16. Update req's img element's presentation appropriately.
}

void ImageRequest::fetch_image(JS::Realm& realm, JS::NonnullGCPtr<Fetch::Infrastructure::Request> request)
{
    VERIFY(m_shared_image_request);
    m_shared_image_request->fetch_image(realm, request);
}

void ImageRequest::add_callbacks(Function<void()> on_finish, Function<void()> on_fail)
{
    VERIFY(m_shared_image_request);
    m_shared_image_request->add_callbacks(move(on_finish), move(on_fail));
}

}
