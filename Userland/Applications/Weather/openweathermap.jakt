import extern "LibCore/Promise.h" {
    namespace Core {
        class Promise<T> {
            [[name=try_create]]
            public extern fn Promise() throws -> Promise<T>
            public extern fn await(mut this) throws -> T
        }
    }
}

use Core::Promise

import extern "AK/JsonObject.h"
import extern "AK/JsonParser.h"
import extern "AK/JsonPath.h"

import weather { Icon, Temperature, WeatherData }

type AK::ByteString implements(ThrowingFromStringLiteral) {}
// Hack!
trait OptionalHack<T> {
    fn value(this) -> T
}
type AK::Optional implements(OptionalHack<T>) {
    extern fn value(this) -> T
}

unsafe fn view(anon s: &String) -> AK::StringView {
    unsafe { cpp { "return s.view();" } }
    abort()
}

struct StringHack {
    value: String
}

class RequestData {
    public promise: Promise<StringHack>
}

struct OpenWeatherMap {
    api_key: String
    make_request: fn(anon url: StringHack) throws -> RequestData

    fn search(this, query: String) throws -> WeatherData {
        let make_request = &.make_request

        let url = format("https://api.openweathermap.org/data/2.5/weather?q={}&appid={}&units=metric", query, .api_key)
        mut request = make_request(StringHack(value: url))
        let json = request.promise.await().value

        mut parser = unsafe AK::JsonParser(view(&json))
        let root = parser.parse()

        let city_name = unsafe (*at_path(
            &root
            [AK::JsonPathElement(view(&"name"))]
        ).as_string()) as! String
        let country_code = unsafe (*at_path(
            &root
            [AK::JsonPathElement(view(&"sys")), AK::JsonPathElement(view(&"country"))]
        ).as_string()) as! String

        let state = unsafe (*at_path(
            &root
            [AK::JsonPathElement(view(&"weather")), AK::JsonPathElement(0), AK::JsonPathElement(view(&"main"))]
        ).as_string()) as! String

        eprintln("State is {}", unsafe (*at_path(
            &root
            [AK::JsonPathElement(view(&"weather")), AK::JsonPathElement(0), AK::JsonPathElement(view(&"main"))]
        ).as_string()))

        let temperature = Temperature(
            current: unsafe at_path(
                &root
                [AK::JsonPathElement(view(&"main")), AK::JsonPathElement(view(&"temp"))]
            ).get_number_with_precision_loss<f64>().value(),
            min: unsafe at_path(
                &root
                [AK::JsonPathElement(view(&"main")), AK::JsonPathElement(view(&"temp_min"))]
            ).get_number_with_precision_loss<f64>().value(),
            max: unsafe at_path(
                &root
                [AK::JsonPathElement(view(&"main")), AK::JsonPathElement(view(&"temp_max"))]
            ).get_number_with_precision_loss<f64>().value(),
            feels_like: unsafe at_path(
                &root
                [AK::JsonPathElement(view(&"main")), AK::JsonPathElement(view(&"feels_like"))]
            ).get_number_with_precision_loss<f64>().value()
        )

        let icon_name = unsafe (*at_path(
            &root
            [AK::JsonPathElement(view(&"weather")), AK::JsonPathElement(0), AK::JsonPathElement(view(&"icon"))]
        ).as_string()) as! String

        return WeatherData(
            city_name
            country_code
            state
            temperature
            icon: match icon_name {
                "01d" => Icon::Clear(day: true)
                "01n" => Icon::Clear(day: false)
                "02d" => Icon::Cloudy(day: true)
                "02n" => Icon::Cloudy(day: false)
                "03d" => Icon::Cloudy(day: true)
                "03n" => Icon::Cloudy(day: false)
                "04d" => Icon::Cloudy(day: true)
                "04n" => Icon::Cloudy(day: false)
                "09d" => Icon::Rainy(day: true)
                "09n" => Icon::Rainy(day: false)
                "10d" => Icon::Rainy(day: true)
                "10n" => Icon::Rainy(day: false)
                "11d" => Icon::Thunderstorm(day: true)
                "11n" => Icon::Thunderstorm(day: false)
                "13d" => Icon::Snowy(day: true)
                "13n" => Icon::Snowy(day: false)
                "50d" => Icon::Foggy(day: true)
                "50n" => Icon::Foggy(day: false)
                else => Icon::Unknown(day: true)
            }
        )
    }

    private fn at_path(anon object: &AK::JsonValue, anon elements: [AK::JsonPathElement]) throws -> AK::JsonValue {
        mut path = AK::JsonPath()
        for element in elements {
            path.append(element)
        }
        return path.try_resolve(object)
    }
}
