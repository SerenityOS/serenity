From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: sin-ack <sin-ack@users.noreply.github.com>
Date: Sun, 16 Jul 2023 17:34:51 +0300
Subject: [PATCH] Extend support for SerenityOS target

Co-Authored-By: Linus Groh <mail@linusgroh.de>
---
 zig/lib/std/fs/Dir.zig               | 73 ++++++++++++++++++++++++++++
 zig/lib/std/zig/LibCInstallation.zig | 26 ++++++++--
 zig/src/Compilation/Config.zig       |  1 +
 3 files changed, 95 insertions(+), 5 deletions(-)

diff --git a/zig/lib/std/fs/Dir.zig b/zig/lib/std/fs/Dir.zig
index d097573122eb9d9ae0e6e78936bb8720d3a9bc91..a2baf34716f5fb8b79a6ec7d93ef579d8a42d4b5 100644
--- a/zig/lib/std/fs/Dir.zig
+++ b/zig/lib/std/fs/Dir.zig
@@ -239,6 +239,74 @@ pub const Iterator = switch (native_os) {
             self.first_iter = true;
         }
     },
+    .serenity => struct {
+        dir: Dir,
+        dir_ptr: *posix.system.DIR,
+
+        const Self = @This();
+
+        pub const Error = IteratorError;
+
+        pub fn next(self: *Self) Error!?Entry {
+            const errno_location = posix.system._errno();
+            start_over: while (true) {
+                // HACK: readdir_r currently doesn't work properly on
+                //       SerenityOS. Until it does, we need to rely on
+                //       readdir which has legacy errno behavior.
+                const saved_errno = errno_location.*;
+                errno_location.* = 0;
+                const entry = posix.system.readdir(self.dir_ptr);
+                if (entry == null) {
+                    if (errno_location.* != 0) {
+                        switch (posix.errno(-1)) {
+                            .OVERFLOW => unreachable,
+                            .BADF => unreachable,
+                            .NOENT => unreachable,
+                            else => |err| return posix.unexpectedErrno(err),
+                        }
+                    }
+
+                    // No error, just end of directory.
+                    errno_location.* = saved_errno;
+                    return null;
+                }
+
+                const name = mem.sliceTo(@as([*:0]u8, @ptrCast(&entry.?.name)), 0);
+                if (mem.eql(u8, name, ".") or mem.eql(u8, name, ".."))
+                    continue :start_over;
+
+                const stat_info = posix.fstatat(
+                    self.dir.fd,
+                    name,
+                    posix.AT.SYMLINK_NOFOLLOW,
+                ) catch |err| switch (err) {
+                    error.NameTooLong => unreachable,
+                    error.SymLinkLoop => unreachable,
+                    error.FileNotFound => unreachable, // lost the race
+                    else => |e| return e,
+                };
+                const entry_kind: Entry.Kind = switch (stat_info.mode & posix.S.IFMT) {
+                    posix.S.IFIFO => .named_pipe,
+                    posix.S.IFCHR => .character_device,
+                    posix.S.IFDIR => .directory,
+                    posix.S.IFBLK => .block_device,
+                    posix.S.IFREG => .file,
+                    posix.S.IFLNK => .sym_link,
+                    posix.S.IFSOCK => .unix_domain_socket,
+                    else => .unknown,
+                };
+                return Entry{
+                    .name = name,
+                    .kind = entry_kind,
+                };
+            }
+        }
+
+        pub fn reset(self: *Self) void {
+            // FIXME: Very small chance this may fail.
+            self.dir_ptr = posix.system.fdopendir(self.dir.fd).?;
+        }
+    },
     .haiku => struct {
         dir: Dir,
         buf: [@sizeOf(DirEnt) + posix.PATH_MAX]u8 align(@alignOf(DirEnt)),
@@ -636,6 +704,11 @@ fn iterateImpl(self: Dir, first_iter_start_value: bool) Iterator {
             .buf = undefined,
             .first_iter = first_iter_start_value,
         },
+        .serenity => return Iterator{
+            .dir = self,
+            // FIXME: Very small chance this may fail.
+            .dir_ptr = posix.system.fdopendir(self.fd).?,
+        },
         .haiku => return Iterator{
             .dir = self,
             .offset = 0,
diff --git a/zig/lib/std/zig/LibCInstallation.zig b/zig/lib/std/zig/LibCInstallation.zig
index 0414d32ee7d661c9202ad90a47c9adca637aa563..ae0cadf537cbe2bf3e48fea26b5ef4a87f4d1af5 100644
--- a/zig/lib/std/zig/LibCInstallation.zig
+++ b/zig/lib/std/zig/LibCInstallation.zig
@@ -101,7 +101,7 @@ pub fn parse(
         return error.ParseError;
     }
 
-    if (self.gcc_dir == null and os_tag == .haiku) {
+    if (self.gcc_dir == null and (os_tag == .haiku or os_tag == .serenity)) {
         log.err("gcc_dir may not be empty for {s}", .{@tagName(os_tag)});
         return error.ParseError;
     }
@@ -196,8 +196,12 @@ pub fn findNative(args: FindNativeOptions) FindError!LibCInstallation {
         try self.findNativeCrtDirWindows(args, sdk);
     } else if (is_haiku) {
         try self.findNativeIncludeDirPosix(args);
-        try self.findNativeGccDirHaiku(args);
+        try self.findNativeGccDirPosix(args);
         self.crt_dir = try args.allocator.dupeZ(u8, "/system/develop/lib");
+    } else if (is_serenity) {
+        try self.findNativeIncludeDirPosix(args);
+        try self.findNativeGccDirPosix(args);
+        self.crt_dir = try args.allocator.dupeZ(u8, "/usr/lib");
     } else if (builtin.target.os.tag.isSolarish()) {
         // There is only one libc, and its headers/libraries are always in the same spot.
         self.include_dir = try args.allocator.dupeZ(u8, "/usr/include");
@@ -308,7 +312,7 @@ fn findNativeIncludeDirPosix(self: *LibCInstallation, args: FindNativeOptions) F
     const include_dir_example_file = if (is_haiku) "posix/stdlib.h" else "stdlib.h";
     const sys_include_dir_example_file = if (is_windows)
         "sys\\types.h"
-    else if (is_haiku)
+    else if (is_haiku or is_serenity)
         "errno.h"
     else
         "sys/errno.h";
@@ -452,7 +456,7 @@ fn findNativeCrtDirPosix(self: *LibCInstallation, args: FindNativeOptions) FindE
     });
 }
 
-fn findNativeGccDirHaiku(self: *LibCInstallation, args: FindNativeOptions) FindError!void {
+fn findNativeGccDirPosix(self: *LibCInstallation, args: FindNativeOptions) FindError!void {
     self.gcc_dir = try ccPrintFileName(.{
         .allocator = args.allocator,
         .search_basename = "crtbeginS.o",
@@ -947,6 +951,17 @@ pub const CrtBasenames = struct {
                 },
                 .static_exe, .static_pie => .{},
             },
+            .serenity => switch (mode) {
+                .dynamic_lib => .{
+                    .crtbegin = "crtbeginS.o",
+                    .crtend = "crtendS.o",
+                },
+                .dynamic_exe, .dynamic_pie, .static_exe, .static_pie => .{
+                    .crt0 = "crt0.o",
+                    .crtbegin = "crtbeginS.o",
+                    .crtend = "crtendS.o",
+                },
+            },
             else => .{},
         };
     }
@@ -991,7 +1006,7 @@ pub fn resolveCrtPaths(
                 .crtn = if (crt_basenames.crtn) |basename| try crt_dir_path.join(arena, basename) else null,
             };
         },
-        .haiku => {
+        .haiku, .serenity => {
             const gcc_dir_path: Path = .{
                 .root_dir = std.Build.Cache.Directory.cwd(),
                 .sub_path = lci.gcc_dir orelse return error.LibCInstallationMissingCrtDir,
@@ -1027,5 +1042,6 @@ const Path = std.Build.Cache.Path;
 const is_darwin = builtin.target.os.tag.isDarwin();
 const is_windows = builtin.target.os.tag == .windows;
 const is_haiku = builtin.target.os.tag == .haiku;
+const is_serenity = builtin.target.os.tag == .serenity;
 
 const log = std.log.scoped(.libc_installation);
diff --git a/zig/src/Compilation/Config.zig b/zig/src/Compilation/Config.zig
index a4f8eefab7a376797bc71487f212505e5b488ced..2bc983bb28e3f8c29fe373a59ffb363aa3a2ec4c 100644
--- a/zig/src/Compilation/Config.zig
+++ b/zig/src/Compilation/Config.zig
@@ -463,6 +463,7 @@ pub fn resolve(options: Options) ResolveError!Config {
         break :b if (options.output_mode == .Exe) switch (target.os.tag) {
             .fuchsia,
             .openbsd,
+            .serenity,
             => true,
             else => target.os.tag.isDarwin(),
         } else false;
