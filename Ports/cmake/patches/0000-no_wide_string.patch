diff -urp a/Source/cmCallVisualStudioMacro.cxx b/Source/cmCallVisualStudioMacro.cxx
--- a/Source/cmCallVisualStudioMacro.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cmCallVisualStudioMacro.cxx	2021-02-11 18:43:33.119174973 +0330
@@ -61,7 +61,7 @@ HRESULT InstanceCallMacro(IDispatch* vsI
 
   if (0 != vsIDE) {
     DISPID dispid = (DISPID)-1;
-    wchar_t execute_command[] = L"ExecuteCommand";
+    char execute_command[] = "ExecuteCommand";
     OLECHAR* name = execute_command;
 
     hr =
@@ -147,7 +147,7 @@ HRESULT GetSolutionObject(IDispatch* vsI
 
   if (0 != vsIDE) {
     DISPID dispid = (DISPID)-1;
-    wchar_t solution[] = L"Solution";
+    char solution[] = "Solution";
     OLECHAR* name = solution;
 
     hr =
@@ -191,7 +191,7 @@ HRESULT GetSolutionFullName(IDispatch* v
 
   if (0 != vsSolution) {
     DISPID dispid = (DISPID)-1;
-    wchar_t full_name[] = L"FullName";
+    char full_name[] = "FullName";
     OLECHAR* name = full_name;
 
     hr = vsSolution->GetIDsOfNames(IID_NULL, &name, 1, LOCALE_USER_DEFAULT,
 
diff -urp a/Source/cmCMakePath.cxx b/Source/cmCMakePath.cxx
--- a/Source/cmCMakePath.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cmCMakePath.cxx	2021-02-12 14:39:55.144860522 +0330
@@ -123,24 +123,3 @@ void cmCMakePath::GetNativePath(std::str
 
   path = tmp.string();
 }
-void cmCMakePath::GetNativePath(std::wstring& path) const
-{
-  cm::filesystem::path tmp(this->Path);
-  tmp.make_preferred();
-
-  path = tmp.wstring();
-
-#if defined(_WIN32)
-  // Windows long filename
-  static std::wstring UNC(L"\\\\?\\UNC");
-  static std::wstring PREFIX(L"\\\\?\\");
-
-  if (this->IsAbsolute() && path.length() > _MAX_PATH - 12) {
-    if (this->HasRootName() && path[0] == L'\\') {
-      path = UNC + path.substr(1);
-    } else {
-      path = PREFIX + path;
-    }
-  }
-#endif
-}
diff -urp a/Source/cmCMakePath.h b/Source/cmCMakePath.h
--- a/Source/cmCMakePath.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cmCMakePath.h	2021-02-12 14:39:55.144860522 +0330
@@ -296,7 +296,7 @@ public:
 
   // Observers
   std::string String() const { return this->Path.string(); }
-  std::wstring WString() const { return this->Path.wstring(); }
+  std::string WString() const { return this->Path.wstring(); }
 
   string_type Native() const
   {
@@ -312,15 +312,15 @@ public:
 
     return path;
   }
-  std::wstring NativeWString() const
+  std::string NativeWString() const
   {
-    std::wstring path;
+    std::string path;
     this->GetNativePath(path);
 
     return path;
   }
   std::string GenericString() const { return this->Path.generic_string(); }
-  std::wstring GenericWString() const { return this->Path.generic_wstring(); }
+  std::string GenericWString() const { return this->Path.generic_wstring(); }
 
   // Decomposition
   cmCMakePath GetRootName() const { return this->Path.root_name(); }
@@ -449,7 +449,6 @@ private:
   }
 
   void GetNativePath(std::string& path) const;
-  void GetNativePath(std::wstring& path) const;
 
   cm::filesystem::path Path;
 };
diff -urp a/Source/cm_codecvt.cxx b/Source/cm_codecvt.cxx
--- a/Source/cm_codecvt.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cm_codecvt.cxx	2021-02-11 18:43:32.705835074 +0330
@@ -159,7 +159,7 @@ std::codecvt_base::result codecvt::Decod
   buf[lstate.buffered] = *from_next;
 
   // Convert the encoding.
-  wchar_t wbuf[2];
+  char wbuf[2];
   int wlen =
     MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, buf, size, wbuf, 2);
   if (wlen <= 0) {
@@ -194,7 +194,7 @@ std::codecvt_base::result codecvt::Decod
   State& lstate = reinterpret_cast<State&>(state);
 
   // Try converting the partial codepoint.
-  wchar_t wbuf[2];
+  char wbuf[2];
   int wlen = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, lstate.partial,
                                  lstate.buffered, wbuf, 2);
   if (wlen <= 0) {
diff -urp a/Source/cmExportCommand.cxx b/Source/cmExportCommand.cxx
--- a/Source/cmExportCommand.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cmExportCommand.cxx	2021-02-11 18:43:33.069174181 +0330
@@ -316,7 +316,7 @@ static void ReportRegistryError(cmMakefi
   std::ostringstream e;
   e << msg << "\n"
     << "  HKEY_CURRENT_USER\\" << key << "\n";
-  wchar_t winmsg[1024];
+  char winmsg[1024];
   if (FormatMessageW(
         FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 0, err,
         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), winmsg, 1024, 0) > 0) {
@@ -339,11 +339,11 @@ static void StorePackageRegistry(cmMakef
     return;
   }
 
-  std::wstring wcontent = cmsys::Encoding::ToWide(content);
+  std::string wcontent = cmsys::Encoding::ToWide(content);
   err =
     RegSetValueExW(hKey, cmsys::Encoding::ToWide(hash).c_str(), 0, REG_SZ,
                    (BYTE const*)wcontent.c_str(),
-                   static_cast<DWORD>(wcontent.size() + 1) * sizeof(wchar_t));
+                   static_cast<DWORD>(wcontent.size() + 1) * sizeof(char));
   RegCloseKey(hKey);
   if (err != ERROR_SUCCESS) {
     std::ostringstream msg;
diff -urp a/Source/cmFileCommand.cxx b/Source/cmFileCommand.cxx
--- a/Source/cmFileCommand.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cmFileCommand.cxx	2021-02-12 14:39:59.851186324 +0330
@@ -80,7 +80,7 @@ std::string fix_file_url_windows(const s
 {
   std::string ret = url;
   if (strncmp(url.c_str(), "file://", 7) == 0) {
-    std::wstring wurl = cmsys::Encoding::ToWide(url);
+    std::string wurl = cmsys::Encoding::ToWide(url);
     if (!wurl.empty()) {
       int mblen =
         WideCharToMultiByte(CP_ACP, 0, wurl.c_str(), -1, NULL, 0, NULL, NULL);
diff -urp a/Source/cmFindPackageCommand.cxx b/Source/cmFindPackageCommand.cxx
--- a/Source/cmFindPackageCommand.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cmFindPackageCommand.cxx	2021-02-11 18:43:32.892504710 +0330
@@ -1514,15 +1514,15 @@ void cmFindPackageCommand::LoadPackageRe
 void cmFindPackageCommand::LoadPackageRegistryWin(bool user, unsigned int view,
                                                   cmSearchPath& outPaths)
 {
-  std::wstring key = L"Software\\Kitware\\CMake\\Packages\\";
+  std::string key = "Software\\Kitware\\CMake\\Packages\\";
   key += cmsys::Encoding::ToWide(this->Name);
-  std::set<std::wstring> bad;
+  std::set<std::string> bad;
   HKEY hKey;
   if (RegOpenKeyExW(user ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE, key.c_str(),
                     0, KEY_QUERY_VALUE | view, &hKey) == ERROR_SUCCESS) {
     DWORD valueType = REG_NONE;
-    wchar_t name[16383]; // RegEnumValue docs limit name to 32767 _bytes_
-    std::vector<wchar_t> data(512);
+    char name[16383]; // RegEnumValue docs limit name to 32767 _bytes_
+    std::vector<char> data(512);
     bool done = false;
     DWORD index = 0;
     while (!done) {
@@ -1557,7 +1557,7 @@ void cmFindPackageCommand::LoadPackageRe
   if (user && !bad.empty() &&
       RegOpenKeyExW(HKEY_CURRENT_USER, key.c_str(), 0, KEY_SET_VALUE | view,
                     &hKey) == ERROR_SUCCESS) {
-    for (std::wstring const& v : bad) {
+    for (std::string const& v : bad) {
       RegDeleteValueW(hKey, v.c_str());
     }
     RegCloseKey(hKey);
diff -urp a/Source/cmGccDepfileLexerHelper.cxx b/Source/cmGccDepfileLexerHelper.cxx
--- a/Source/cmGccDepfileLexerHelper.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cmGccDepfileLexerHelper.cxx	2021-02-11 18:43:33.049173864 +0330
@@ -18,8 +18,8 @@
 bool cmGccDepfileLexerHelper::readFile(const char* filePath)
 {
 #ifdef _WIN32
-  wchar_t* wpath = cmsysEncoding_DupToWide(filePath);
-  FILE* file = _wfopen(wpath, L"rb");
+  char* wpath = cmsysEncoding_DupToWide(filePath);
+  FILE* file = _wfopen(wpath, "rb");
   free(wpath);
 #else
   FILE* file = fopen(filePath, "r");
diff -urp a/Source/cmGlobalVisualStudio8Generator.cxx b/Source/cmGlobalVisualStudio8Generator.cxx
--- a/Source/cmGlobalVisualStudio8Generator.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cmGlobalVisualStudio8Generator.cxx	2021-02-11 18:43:32.972505982 +0330
@@ -380,10 +380,10 @@ static cmVS7FlagTable cmVS8ExtraFlagTabl
   { "EnablePREfast", "analyze-", "", "false", 0 },
 
   // Language options
-  { "TreatWChar_tAsBuiltInType", "Zc:wchar_t", "wchar_t is a built-in type",
+  { "TreatWChar_tAsBuiltInType", "Zc:char", "char is a built-in type",
     "true", 0 },
-  { "TreatWChar_tAsBuiltInType", "Zc:wchar_t-",
-    "wchar_t is not a built-in type", "false", 0 },
+  { "TreatWChar_tAsBuiltInType", "Zc:char-",
+    "char is not a built-in type", "false", 0 },
 
   { "", "", "", "", 0 }
 };
diff -urp a/Source/cmGlobalVisualStudioGenerator.cxx b/Source/cmGlobalVisualStudioGenerator.cxx
--- a/Source/cmGlobalVisualStudioGenerator.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cmGlobalVisualStudioGenerator.cxx	2021-02-11 18:43:33.135841903 +0330
@@ -552,9 +552,9 @@ bool IsVisualStudioMacrosFileRegistered(
                   0, KEY_READ, &hkey);
   if (ERROR_SUCCESS == result) {
     // Iterate the subkeys and look for the values of interest in each subkey:
-    wchar_t subkeyname[256];
+    char subkeyname[256];
     DWORD cch_subkeyname = cm::size(subkeyname);
-    wchar_t keyclass[256];
+    char keyclass[256];
     DWORD cch_keyclass = cm::size(keyclass);
     FILETIME lastWriteTime;
     lastWriteTime.dwHighDateTime = 0;
@@ -568,19 +568,19 @@ bool IsVisualStudioMacrosFileRegistered(
       result = RegOpenKeyExW(hkey, subkeyname, 0, KEY_READ, &hsubkey);
       if (ERROR_SUCCESS == result) {
         DWORD valueType = REG_SZ;
-        wchar_t data1[256];
+        char data1[256];
         DWORD cch_data1 = sizeof(data1);
-        RegQueryValueExW(hsubkey, L"Path", 0, &valueType, (LPBYTE)data1,
+        RegQueryValueExW(hsubkey, "Path", 0, &valueType, (LPBYTE)data1,
                          &cch_data1);
 
         DWORD data2 = 0;
         DWORD cch_data2 = sizeof(data2);
-        RegQueryValueExW(hsubkey, L"Security", 0, &valueType, (LPBYTE)&data2,
+        RegQueryValueExW(hsubkey, "Security", 0, &valueType, (LPBYTE)&data2,
                          &cch_data2);
 
         DWORD data3 = 0;
         DWORD cch_data3 = sizeof(data3);
-        RegQueryValueExW(hsubkey, L"StorageFormat", 0, &valueType,
+        RegQueryValueExW(hsubkey, "StorageFormat", 0, &valueType,
                          (LPBYTE)&data3, &cch_data3);
 
         s2 = cmSystemTools::LowerCase(cmsys::Encoding::ToNarrow(data1));
@@ -643,18 +643,18 @@ bool IsVisualStudioMacrosFileRegistered(
                   0, KEY_READ, &hkey);
   if (ERROR_SUCCESS == result) {
     DWORD valueType = REG_SZ;
-    wchar_t data1[256];
+    char data1[256];
     DWORD cch_data1 = sizeof(data1);
-    RegQueryValueExW(hkey, L"Path", 0, &valueType, (LPBYTE)data1, &cch_data1);
+    RegQueryValueExW(hkey, "Path", 0, &valueType, (LPBYTE)data1, &cch_data1);
 
     DWORD data2 = 0;
     DWORD cch_data2 = sizeof(data2);
-    RegQueryValueExW(hkey, L"Security", 0, &valueType, (LPBYTE)&data2,
+    RegQueryValueExW(hkey, "Security", 0, &valueType, (LPBYTE)&data2,
                      &cch_data2);
 
     DWORD data3 = 0;
     DWORD cch_data3 = sizeof(data3);
-    RegQueryValueExW(hkey, L"StorageFormat", 0, &valueType, (LPBYTE)&data3,
+    RegQueryValueExW(hkey, "StorageFormat", 0, &valueType, (LPBYTE)&data3,
                      &cch_data3);
 
     s2 = cmSystemTools::LowerCase(cmsys::Encoding::ToNarrow(data1));
@@ -690,7 +690,7 @@ void WriteVSMacrosFileRegistryEntry(cons
   if (ERROR_SUCCESS == result) {
     // Create the subkey and set the values of interest:
     HKEY hsubkey = NULL;
-    wchar_t lpClass[] = L"";
+    char lpClass[] = "";
     result = RegCreateKeyExW(
       hkey, cmsys::Encoding::ToWide(nextAvailableSubKeyName).c_str(), 0,
       lpClass, 0, KEY_READ | KEY_WRITE, 0, &hsubkey, 0);
@@ -699,11 +699,11 @@ void WriteVSMacrosFileRegistryEntry(cons
 
       std::string s(macrosFile);
       std::replace(s.begin(), s.end(), '/', '\\');
-      std::wstring ws = cmsys::Encoding::ToWide(s);
+      std::string ws = cmsys::Encoding::ToWide(s);
 
       result =
-        RegSetValueExW(hsubkey, L"Path", 0, REG_SZ, (LPBYTE)ws.c_str(),
-                       static_cast<DWORD>(ws.size() + 1) * sizeof(wchar_t));
+        RegSetValueExW(hsubkey, "Path", 0, REG_SZ, (LPBYTE)ws.c_str(),
+                       static_cast<DWORD>(ws.size() + 1) * sizeof(char));
       if (ERROR_SUCCESS != result) {
         std::cout << "error result 1: " << result << std::endl;
         std::cout << std::endl;
@@ -712,7 +712,7 @@ void WriteVSMacrosFileRegistryEntry(cons
       // Security value is always "1" for sample macros files (seems to be "2"
       // if you put the file somewhere outside the standard VSMacros folder)
       dw = 1;
-      result = RegSetValueExW(hsubkey, L"Security", 0, REG_DWORD, (LPBYTE)&dw,
+      result = RegSetValueExW(hsubkey, "Security", 0, REG_DWORD, (LPBYTE)&dw,
                               sizeof(DWORD));
       if (ERROR_SUCCESS != result) {
         std::cout << "error result 2: " << result << std::endl;
@@ -721,7 +721,7 @@ void WriteVSMacrosFileRegistryEntry(cons
 
       // StorageFormat value is always "0" for sample macros files
       dw = 0;
-      result = RegSetValueExW(hsubkey, L"StorageFormat", 0, REG_DWORD,
+      result = RegSetValueExW(hsubkey, "StorageFormat", 0, REG_DWORD,
                               (LPBYTE)&dw, sizeof(DWORD));
       if (ERROR_SUCCESS != result) {
         std::cout << "error result 3: " << result << std::endl;
diff -urp a/Source/cmProcessOutput.cxx b/Source/cmProcessOutput.cxx
--- a/Source/cmProcessOutput.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cmProcessOutput.cxx	2021-02-11 18:43:32.995839686 +0330
@@ -91,7 +91,7 @@ bool cmProcessOutput::DecodeText(std::st
       } else {
         bool restoreDecoded = false;
         std::string firstDecoded = decoded;
-        wchar_t lastChar = 0;
+        char lastChar = 0;
         for (UINT i = 0; i < cpinfo.MaxCharSize; i++) {
           success = DoDecodeText(raw, decoded, &lastChar);
           if (success && lastChar != 0) {
@@ -141,12 +141,12 @@ bool cmProcessOutput::DecodeText(std::ve
 
 #if defined(_WIN32)
 bool cmProcessOutput::DoDecodeText(std::string raw, std::string& decoded,
-                                   wchar_t* lastChar)
+                                   char* lastChar)
 {
   bool success = false;
   const int wlength =
     MultiByteToWideChar(codepage, 0, raw.c_str(), int(raw.size()), NULL, 0);
-  auto wdata = cm::make_unique<wchar_t[]>(wlength);
+  auto wdata = cm::make_unique<char[]>(wlength);
   int r = MultiByteToWideChar(codepage, 0, raw.c_str(), int(raw.size()),
                               wdata.get(), wlength);
   if (r > 0) {
diff -urp a/Source/cmProcessOutput.h b/Source/cmProcessOutput.h
--- a/Source/cmProcessOutput.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cmProcessOutput.h	2021-02-11 18:43:33.152508833 +0330
@@ -80,6 +80,6 @@ private:
   unsigned int codepage;
   unsigned int bufferSize;
   std::vector<std::string> rawparts;
-  bool DoDecodeText(std::string raw, std::string& decoded, wchar_t* lastChar);
+  bool DoDecodeText(std::string raw, std::string& decoded, char* lastChar);
 #endif
 };
diff -urp a/Source/cmSystemTools.cxx b/Source/cmSystemTools.cxx
--- a/Source/cmSystemTools.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cmSystemTools.cxx	2021-02-11 18:43:33.025840162 +0330
@@ -128,7 +128,7 @@ static int cm_archive_read_open_file(str
                                      int block_size)
 {
 #  if cmsys_STL_HAS_WSTRING
-  std::wstring wfile = cmsys::Encoding::ToWide(file);
+  std::string wfile = cmsys::Encoding::ToWide(file);
   return archive_read_open_filename_w(a, wfile.c_str(), block_size);
 #  else
   return archive_read_open_filename(a, file, block_size);
@@ -759,7 +759,7 @@ namespace {
 class SaveRestoreFileAttributes
 {
 public:
-  SaveRestoreFileAttributes(std::wstring const& path,
+  SaveRestoreFileAttributes(std::string const& path,
                             uint32_t file_attrs_to_set);
   ~SaveRestoreFileAttributes();
 
@@ -767,15 +767,15 @@ public:
   SaveRestoreFileAttributes& operator=(SaveRestoreFileAttributes const&) =
     delete;
 
-  void SetPath(std::wstring const& path) { path_ = path; }
+  void SetPath(std::string const& path) { path_ = path; }
 
 private:
-  std::wstring path_;
+  std::string path_;
   uint32_t original_attr_bits_;
 };
 
 SaveRestoreFileAttributes::SaveRestoreFileAttributes(
-  std::wstring const& path, uint32_t file_attrs_to_set)
+  std::string const& path, uint32_t file_attrs_to_set)
   : path_(path)
   , original_attr_bits_(0)
 {
@@ -809,14 +809,14 @@ struct WindowsFileRetryInit
   bool Explicit;
 };
 
-WindowsFileRetryInit InitWindowsFileRetry(wchar_t const* const values[2],
+WindowsFileRetryInit InitWindowsFileRetry(char const* const values[2],
                                           unsigned int const defaults[2])
 {
   unsigned int data[2] = { 0, 0 };
   HKEY const keys[2] = { HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE };
   for (int k = 0; k < 2; ++k) {
     HKEY hKey;
-    if (RegOpenKeyExW(keys[k], L"Software\\Kitware\\CMake\\Config", 0,
+    if (RegOpenKeyExW(keys[k], "Software\\Kitware\\CMake\\Config", 0,
                       KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS) {
       for (int v = 0; v < 2; ++v) {
         DWORD dwData, dwType, dwSize = 4;
@@ -839,16 +839,16 @@ WindowsFileRetryInit InitWindowsFileRetr
 
 WindowsFileRetryInit InitWindowsFileRetry()
 {
-  static wchar_t const* const values[2] = { L"FilesystemRetryCount",
-                                            L"FilesystemRetryDelay" };
+  static char const* const values[2] = { "FilesystemRetryCount",
+                                            "FilesystemRetryDelay" };
   static unsigned int const defaults[2] = { 5, 500 };
   return InitWindowsFileRetry(values, defaults);
 }
 
 WindowsFileRetryInit InitWindowsDirectoryRetry()
 {
-  static wchar_t const* const values[2] = { L"FilesystemDirectoryRetryCount",
-                                            L"FilesystemDirectoryRetryDelay" };
+  static char const* const values[2] = { "FilesystemDirectoryRetryCount",
+                                            "FilesystemDirectoryRetryDelay" };
   static unsigned int const defaults[2] = { 120, 500 };
   WindowsFileRetryInit dirInit = InitWindowsFileRetry(values, defaults);
   if (dirInit.Explicit) {
@@ -861,7 +861,7 @@ WindowsFileRetryInit InitWindowsDirector
   return dirInit;
 }
 
-cmSystemTools::WindowsFileRetry GetWindowsRetry(std::wstring const& path)
+cmSystemTools::WindowsFileRetry GetWindowsRetry(std::string const& path)
 {
   // If we are performing a directory operation, then try and get the
   // appropriate timing info.
@@ -946,7 +946,7 @@ void cmSystemTools::InitializeLibUV()
 
 #ifdef _WIN32
 namespace {
-bool cmMoveFile(std::wstring const& oldname, std::wstring const& newname)
+bool cmMoveFile(std::string const& oldname, std::string const& newname)
 {
   // Not only ignore any previous error, but clear any memory of it.
   SetLastError(0);
@@ -965,9 +965,9 @@ bool cmSystemTools::RenameFile(const std
 #  ifndef INVALID_FILE_ATTRIBUTES
 #    define INVALID_FILE_ATTRIBUTES ((DWORD)-1)
 #  endif
-  std::wstring const oldname_wstr =
+  std::string const oldname_wstr =
     SystemTools::ConvertToWindowsExtendedPath(oldname);
-  std::wstring const newname_wstr =
+  std::string const newname_wstr =
     SystemTools::ConvertToWindowsExtendedPath(newname);
 
   /* Windows MoveFileEx may not replace read-only or in-use files.  If it
@@ -2082,7 +2082,7 @@ void cmSystemTools::FindCMakeResources(c
   std::string exe_dir;
 #if defined(_WIN32) && !defined(__CYGWIN__)
   (void)argv0; // ignore this on windows
-  wchar_t modulepath[_MAX_PATH];
+  char modulepath[_MAX_PATH];
   ::GetModuleFileNameW(NULL, modulepath, sizeof(modulepath));
   std::string path = cmsys::Encoding::ToNarrow(modulepath);
   std::string realPath =
diff -urp a/Source/cmVSSetupHelper.cxx b/Source/cmVSSetupHelper.cxx
--- a/Source/cmVSSetupHelper.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cmVSSetupHelper.cxx	2021-02-12 14:39:59.854519416 +0330
@@ -47,10 +47,10 @@ const CLSID CLSID_SetupConfiguration = {
 #endif
 
 const WCHAR* Win10SDKComponent =
-  L"Microsoft.VisualStudio.Component.Windows10SDK";
+  "Microsoft.VisualStudio.Component.Windows10SDK";
 const WCHAR* Win81SDKComponent =
-  L"Microsoft.VisualStudio.Component.Windows81SDK";
-const WCHAR* ComponentType = L"Component";
+  "Microsoft.VisualStudio.Component.Windows81SDK";
+const WCHAR* ComponentType = "Component";
 
 std::string VSInstanceInfo::GetInstallLocation() const
 {
@@ -124,13 +124,13 @@ bool cmVSSetupAPIHelper::CheckInstalledC
     return ret;
   }
 
-  std::wstring id = std::wstring(bstrId);
-  std::wstring type = std::wstring(bstrType);
+  std::string id = std::string(bstrId);
+  std::string type = std::string(bstrType);
 
   // Checks for any version of Win10 SDK. The version is appended at the end of
   // the
   // component name ex: Microsoft.VisualStudio.Component.Windows10SDK.10240
-  if (id.find(Win10SDKComponent) != std::wstring::npos &&
+  if (id.find(Win10SDKComponent) != std::string::npos &&
       type.compare(ComponentType) == 0) {
     bWin10SDK = true;
     ret = true;
@@ -154,7 +154,7 @@ bool cmVSSetupAPIHelper::GetVSInstanceIn
 
   SmartBSTR bstrId;
   if (SUCCEEDED(pInstance->GetInstanceId(&bstrId))) {
-    vsInstanceInfo.InstanceId = std::wstring(bstrId);
+    vsInstanceInfo.InstanceId = std::string(bstrId);
   } else {
     return false;
   }
@@ -169,7 +169,7 @@ bool cmVSSetupAPIHelper::GetVSInstanceIn
   if (FAILED(pInstance->GetInstallationVersion(&bstrVersion))) {
     return false;
   } else {
-    vsInstanceInfo.Version = std::wstring(bstrVersion);
+    vsInstanceInfo.Version = std::string(bstrVersion);
     if (FAILED(setupHelper->ParseVersion(bstrVersion, &ullVersion))) {
       vsInstanceInfo.ullVersion = 0;
     } else {
@@ -183,7 +183,7 @@ bool cmVSSetupAPIHelper::GetVSInstanceIn
     if (FAILED(pInstance->GetInstallationPath(&bstrInstallationPath))) {
       return false;
     } else {
-      vsInstanceInfo.VSInstallLocation = std::wstring(bstrInstallationPath);
+      vsInstanceInfo.VSInstallLocation = std::string(bstrInstallationPath);
     }
   }
 
@@ -300,7 +300,7 @@ bool cmVSSetupAPIHelper::IsEWDKEnabled()
 bool cmVSSetupAPIHelper::EnumerateAndChooseVSInstance()
 {
   bool isVSInstanceExists = false;
-  if (chosenInstanceInfo.VSInstallLocation.compare(L"") != 0) {
+  if (chosenInstanceInfo.VSInstallLocation.compare("") != 0) {
     return true;
   }
 
@@ -314,9 +314,9 @@ bool cmVSSetupAPIHelper::EnumerateAndCho
       return false;
 
     chosenInstanceInfo.VSInstallLocation =
-      std::wstring(envVsInstallDir.begin(), envVsInstallDir.end());
+      std::string(envVsInstallDir.begin(), envVsInstallDir.end());
     chosenInstanceInfo.Version =
-      std::wstring(envVSVersion.begin(), envVSVersion.end());
+      std::string(envVSVersion.begin(), envVSVersion.end());
     chosenInstanceInfo.VCToolsetVersion = envVSVersion;
     chosenInstanceInfo.ullVersion = std::stoi(envVSVersion);
     chosenInstanceInfo.IsWin10SDKInstalled = true;
@@ -345,7 +345,7 @@ bool cmVSSetupAPIHelper::EnumerateAndCho
     return false;
   }
 
-  std::wstring const wantVersion = std::to_wstring(this->Version) + L'.';
+  std::string const wantVersion = std::to_wstring(this->Version) + L'.';
 
   SmartCOMPtr<ISetupInstance> instance;
   while (SUCCEEDED(enumInstances->Next(1, &instance, NULL)) && instance) {
diff -urp a/Source/cmVSSetupHelper.h b/Source/cmVSSetupHelper.h
--- a/Source/cmVSSetupHelper.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/cmVSSetupHelper.h	2021-02-11 18:43:33.159175606 +0330
@@ -84,9 +84,9 @@ private:
 
 struct VSInstanceInfo
 {
-  std::wstring InstanceId;
-  std::wstring VSInstallLocation;
-  std::wstring Version;
+  std::string InstanceId;
+  std::string VSInstallLocation;
+  std::string Version;
   std::string VCToolsetVersion;
   ULONGLONG ullVersion = 0;
   bool IsWin10SDKInstalled = false;
diff -urp a/Source/CPack/WiX/cmCPackWIXGenerator.cxx b/Source/CPack/WiX/cmCPackWIXGenerator.cxx
--- a/Source/CPack/WiX/cmCPackWIXGenerator.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/CPack/WiX/cmCPackWIXGenerator.cxx	2021-02-11 18:43:33.145842061 +0330
@@ -1008,7 +1008,7 @@ std::string cmCPackWIXGenerator::Generat
   UuidToStringW(&guid, &tmp);
 
   std::string result =
-    cmsys::Encoding::ToNarrow(reinterpret_cast<wchar_t*>(tmp));
+    cmsys::Encoding::ToNarrow(reinterpret_cast<char*>(tmp));
   RpcStringFreeW(&tmp);
 #else
   uuid_t guid;
diff -urp a/Source/kwsys/ConsoleBuf.hxx.in b/Source/kwsys/ConsoleBuf.hxx.in
--- a/Source/kwsys/ConsoleBuf.hxx.in	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/ConsoleBuf.hxx.in	2021-02-11 18:43:32.755835869 +0330
@@ -111,7 +111,7 @@ protected:
       success = false;
     }
     if (m_hOutput && !m_obuffer.empty()) {
-      const std::wstring wbuffer = getBuffer(m_obuffer);
+      const std::string wbuffer = getBuffer(m_obuffer);
       if (m_isConsoleOutput) {
         DWORD charsWritten;
         success =
@@ -149,7 +149,7 @@ protected:
       if (m_isConsoleInput) {
         // ReadConsole doesn't tell if there's more input available
         // don't support reading more characters than this
-        wchar_t wbuffer[8192];
+        char wbuffer[8192];
         DWORD charsRead;
         if (ReadConsoleW(m_hInput, wbuffer,
                          (sizeof(wbuffer) / sizeof(wbuffer[0])), &charsRead,
@@ -158,9 +158,9 @@ protected:
           _setg(true);
           return Traits::eof();
         }
-        setBuffer(std::wstring(wbuffer, charsRead), m_ibuffer);
+        setBuffer(std::string(wbuffer, charsRead), m_ibuffer);
       } else {
-        std::wstring wbuffer;
+        std::string wbuffer;
         std::string strbuffer;
         DWORD bytesRead;
         LARGE_INTEGER size;
@@ -320,7 +320,7 @@ private:
     this->setp((char_type*)m_obuffer.data(),
                (char_type*)m_obuffer.data() + m_obuffer.size());
   }
-  bool encodeOutputBuffer(const std::wstring wbuffer, std::string& buffer)
+  bool encodeOutputBuffer(const std::string wbuffer, std::string& buffer)
   {
     if (wbuffer.size() == 0) {
       buffer = std::string();
@@ -340,11 +340,11 @@ private:
     delete[] buf;
     return success;
   }
-  bool decodeInputBuffer(const std::string buffer, std::wstring& wbuffer)
+  bool decodeInputBuffer(const std::string buffer, std::string& wbuffer)
   {
     size_t length = buffer.length();
     if (length == 0) {
-      wbuffer = std::wstring();
+      wbuffer = std::string();
       return true;
     }
     int actualCodepage = m_activeInputCodepage;
@@ -359,30 +359,30 @@ private:
     }
     const size_t wlength = static_cast<size_t>(MultiByteToWideChar(
       actualCodepage, 0, data, static_cast<int>(length), nullptr, 0));
-    wchar_t* wbuf = new wchar_t[wlength];
+    char* wbuf = new char[wlength];
     const bool success =
       MultiByteToWideChar(actualCodepage, 0, data, static_cast<int>(length),
                           wbuf, static_cast<int>(wlength)) > 0
       ? true
       : false;
-    wbuffer = std::wstring(wbuf, wlength);
+    wbuffer = std::string(wbuf, wlength);
     delete[] wbuf;
     return success;
   }
-  std::wstring getBuffer(const std::basic_string<char> buffer)
+  std::string getBuffer(const std::basic_string<char> buffer)
   {
     return Encoding::ToWide(buffer);
   }
-  std::wstring getBuffer(const std::basic_string<wchar_t> buffer)
+  std::string getBuffer(const std::basic_string<char> buffer)
   {
     return buffer;
   }
-  void setBuffer(const std::wstring wbuffer, std::basic_string<char>& target)
+  void setBuffer(const std::string wbuffer, std::basic_string<char>& target)
   {
     target = Encoding::ToNarrow(wbuffer);
   }
-  void setBuffer(const std::wstring wbuffer,
-                 std::basic_string<wchar_t>& target)
+  void setBuffer(const std::string wbuffer,
+                 std::basic_string<char>& target)
   {
     target = wbuffer;
   }
@@ -390,7 +390,7 @@ private:
 }; // BasicConsoleBuf class
 
 typedef BasicConsoleBuf<char> ConsoleBuf;
-typedef BasicConsoleBuf<wchar_t> WConsoleBuf;
+typedef BasicConsoleBuf<char> WConsoleBuf;
 
 #endif
 } // KWSYS_NAMESPACE
diff -urp a/Source/kwsys/Directory.cxx b/Source/kwsys/Directory.cxx
--- a/Source/kwsys/Directory.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/Directory.cxx	2021-02-11 18:43:32.782502961 +0330
@@ -117,7 +117,7 @@ bool Directory::Load(const std::string&
 
   // Now put them into the file array
   srchHandle =
-    _wfindfirst((wchar_t*)Encoding::ToWindowsExtendedPath(buf).c_str(), &data);
+    _wfindfirst((char*)Encoding::ToWindowsExtendedPath(buf).c_str(), &data);
   delete[] buf;
 
   if (srchHandle == -1) {
@@ -148,7 +148,7 @@ unsigned long Directory::GetNumberOfFile
   struct _wfinddata_t data; // data of current file
 
   // Now put them into the file array
-  srchHandle = _wfindfirst((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
+  srchHandle = _wfindfirst((char*)Encoding::ToWide(buf).c_str(), &data);
   delete[] buf;
 
   if (srchHandle == -1) {
diff -urp a/Source/kwsys/DynamicLoader.cxx b/Source/kwsys/DynamicLoader.cxx
--- a/Source/kwsys/DynamicLoader.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/DynamicLoader.cxx	2021-02-11 18:43:32.762502643 +0330
@@ -263,7 +263,7 @@ DynamicLoader::SymbolPointer DynamicLoad
 
 const char* DynamicLoader::LastError()
 {
-  wchar_t lpMsgBuf[DYNLOAD_ERROR_BUFFER_SIZE + 1];
+  char lpMsgBuf[DYNLOAD_ERROR_BUFFER_SIZE + 1];
 
   DWORD error = GetLastError();
   DWORD length = FormatMessageW(
diff -urp a/Source/kwsys/EncodingC.c b/Source/kwsys/EncodingC.c
--- a/Source/kwsys/EncodingC.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/EncodingC.c	2021-02-11 18:43:32.749169097 +0330
@@ -15,7 +15,7 @@
 #  include <windows.h>
 #endif
 
-size_t kwsysEncoding_mbstowcs(wchar_t* dest, const char* str, size_t n)
+size_t kwsysEncoding_mbstowcs(char* dest, const char* str, size_t n)
 {
   if (str == 0) {
     return (size_t)-1;
@@ -29,12 +29,12 @@ size_t kwsysEncoding_mbstowcs(wchar_t* d
 #endif
 }
 
-wchar_t* kwsysEncoding_DupToWide(const char* str)
+char* kwsysEncoding_DupToWide(const char* str)
 {
-  wchar_t* ret = NULL;
+  char* ret = NULL;
   size_t length = kwsysEncoding_mbstowcs(NULL, str, 0) + 1;
   if (length > 0) {
-    ret = (wchar_t*)malloc((length) * sizeof(wchar_t));
+    ret = (char*)malloc((length) * sizeof(char));
     if (ret) {
       ret[0] = 0;
       kwsysEncoding_mbstowcs(ret, str, length);
@@ -43,7 +43,7 @@ wchar_t* kwsysEncoding_DupToWide(const c
   return ret;
 }
 
-size_t kwsysEncoding_wcstombs(char* dest, const wchar_t* str, size_t n)
+size_t kwsysEncoding_wcstombs(char* dest, const char* str, size_t n)
 {
   if (str == 0) {
     return (size_t)-1;
@@ -57,7 +57,7 @@ size_t kwsysEncoding_wcstombs(char* dest
 #endif
 }
 
-char* kwsysEncoding_DupToNarrow(const wchar_t* str)
+char* kwsysEncoding_DupToNarrow(const char* str)
 {
   char* ret = NULL;
   size_t length = kwsysEncoding_wcstombs(0, str, 0) + 1;
diff -urp a/Source/kwsys/EncodingCXX.cxx b/Source/kwsys/EncodingCXX.cxx
--- a/Source/kwsys/EncodingCXX.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/EncodingCXX.cxx	2021-02-12 14:39:55.148193613 +0330
@@ -68,16 +68,6 @@ Encoding::CommandLineArguments::CommandL
   this->argv_[ac] = nullptr;
 }
 
-Encoding::CommandLineArguments::CommandLineArguments(int ac,
-                                                     wchar_t const* const* av)
-{
-  this->argv_.resize(ac + 1);
-  for (int i = 0; i < ac; i++) {
-    this->argv_[i] = kwsysEncoding_DupToNarrow(av[i]);
-  }
-  this->argv_[ac] = nullptr;
-}
-
 Encoding::CommandLineArguments::~CommandLineArguments()
 {
   for (size_t i = 0; i < this->argv_.size(); i++) {
@@ -124,19 +114,19 @@ char const* const* Encoding::CommandLine
 
 #if KWSYS_STL_HAS_WSTRING
 
-std::wstring Encoding::ToWide(const std::string& str)
+std::string Encoding::ToWide(const std::string& str)
 {
-  std::wstring wstr;
+  std::string wstr;
 #  if defined(_WIN32)
   const int wlength =
     MultiByteToWideChar(KWSYS_ENCODING_DEFAULT_CODEPAGE, 0, str.data(),
                         int(str.size()), nullptr, 0);
   if (wlength > 0) {
-    wchar_t* wdata = new wchar_t[wlength];
+    char* wdata = new char[wlength];
     int r = MultiByteToWideChar(KWSYS_ENCODING_DEFAULT_CODEPAGE, 0, str.data(),
                                 int(str.size()), wdata, wlength);
     if (r > 0) {
-      wstr = std::wstring(wdata, wlength);
+      wstr = std::string(wdata, wlength);
     }
     delete[] wdata;
   }
@@ -150,14 +140,14 @@ std::wstring Encoding::ToWide(const std:
     nullPos = str.find('\0', pos);
     if (nullPos != std::string::npos) {
       pos = nullPos + 1;
-      wstr += wchar_t('\0');
+      wstr += char('\0');
     }
   } while (nullPos != std::string::npos);
 #  endif
   return wstr;
 }
 
-std::string Encoding::ToNarrow(const std::wstring& str)
+std::string Encoding::ToNarrow(const std::string& str)
 {
   std::string nstr;
 #  if defined(_WIN32)
@@ -181,7 +171,7 @@ std::string Encoding::ToNarrow(const std
     if (pos < str.size() && str.at(pos) != '\0') {
       nstr += ToNarrow(str.c_str() + pos);
     }
-    nullPos = str.find(wchar_t('\0'), pos);
+    nullPos = str.find(char('\0'), pos);
     if (nullPos != std::string::npos) {
       pos = nullPos + 1;
       nstr += '\0';
@@ -191,12 +181,12 @@ std::string Encoding::ToNarrow(const std
   return nstr;
 }
 
-std::wstring Encoding::ToWide(const char* cstr)
+std::string Encoding::ToWide(const char* cstr)
 {
-  std::wstring wstr;
+  std::string wstr;
   size_t length = kwsysEncoding_mbstowcs(nullptr, cstr, 0) + 1;
   if (length > 0) {
-    std::vector<wchar_t> wchars(length);
+    std::vector<char> wchars(length);
     if (kwsysEncoding_mbstowcs(&wchars[0], cstr, length) > 0) {
       wstr = &wchars[0];
     }
@@ -204,7 +194,7 @@ std::wstring Encoding::ToWide(const char
   return wstr;
 }
 
-std::string Encoding::ToNarrow(const wchar_t* wcstr)
+std::string Encoding::ToNarrow(const char* wcstr)
 {
   std::string str;
   size_t length = kwsysEncoding_wcstombs(nullptr, wcstr, 0) + 1;
@@ -219,19 +209,19 @@ std::string Encoding::ToNarrow(const wch
 
 #  if defined(_WIN32)
 // Convert local paths to UNC style paths
-std::wstring Encoding::ToWindowsExtendedPath(std::string const& source)
+std::string Encoding::ToWindowsExtendedPath(std::string const& source)
 {
   return ToWindowsExtendedPath(ToWide(source));
 }
 
 // Convert local paths to UNC style paths
-std::wstring Encoding::ToWindowsExtendedPath(const char* source)
+std::string Encoding::ToWindowsExtendedPath(const char* source)
 {
   return ToWindowsExtendedPath(ToWide(source));
 }
 
 // Convert local paths to UNC style paths
-std::wstring Encoding::ToWindowsExtendedPath(std::wstring const& wsource)
+std::string Encoding::ToWindowsExtendedPath(std::string const& wsource)
 {
   // Resolve any relative paths
   DWORD wfull_len;
@@ -239,7 +229,7 @@ std::wstring Encoding::ToWindowsExtended
   /* The +3 is a workaround for a bug in some versions of GetFullPathNameW that
    * won't return a large enough buffer size if the input is too small */
   wfull_len = GetFullPathNameW(wsource.c_str(), 0, nullptr, nullptr) + 3;
-  std::vector<wchar_t> wfull(wfull_len);
+  std::vector<char> wfull(wfull_len);
   GetFullPathNameW(wsource.c_str(), wfull_len, &wfull[0], nullptr);
 
   /* This should get the correct size without any extra padding from the
@@ -248,7 +238,7 @@ std::wstring Encoding::ToWindowsExtended
 
   if (wfull_len >= 2 && isalpha(wfull[0]) &&
       wfull[1] == L':') { /* C:\Foo\bar\FooBar.txt */
-    return L"\\\\?\\" + std::wstring(&wfull[0]);
+    return "\\\\?\\" + std::string(&wfull[0]);
   } else if (wfull_len >= 2 && wfull[0] == L'\\' &&
              wfull[1] == L'\\') { /* Starts with \\ */
     if (wfull_len >= 4 && wfull[2] == L'?' &&
@@ -256,24 +246,24 @@ std::wstring Encoding::ToWindowsExtended
       if (wfull_len >= 8 && wfull[4] == L'U' && wfull[5] == L'N' &&
           wfull[6] == L'C' &&
           wfull[7] == L'\\') { /* \\?\UNC\Foo\bar\FooBar.txt */
-        return std::wstring(&wfull[0]);
+        return std::string(&wfull[0]);
       } else if (wfull_len >= 6 && isalpha(wfull[4]) &&
                  wfull[5] == L':') { /* \\?\C:\Foo\bar\FooBar.txt */
-        return std::wstring(&wfull[0]);
+        return std::string(&wfull[0]);
       } else if (wfull_len >= 5) { /* \\?\Foo\bar\FooBar.txt */
-        return L"\\\\?\\UNC\\" + std::wstring(&wfull[4]);
+        return "\\\\?\\UNC\\" + std::string(&wfull[4]);
       }
     } else if (wfull_len >= 4 && wfull[2] == L'.' &&
                wfull[3] == L'\\') { /* Starts with \\.\ a device name */
       if (wfull_len >= 6 && isalpha(wfull[4]) &&
           wfull[5] == L':') { /* \\.\C:\Foo\bar\FooBar.txt */
-        return L"\\\\?\\" + std::wstring(&wfull[4]);
+        return "\\\\?\\" + std::string(&wfull[4]);
       } else if (wfull_len >=
                  5) { /* \\.\Foo\bar\ Device name is left unchanged */
-        return std::wstring(&wfull[0]);
+        return std::string(&wfull[0]);
       }
     } else if (wfull_len >= 3) { /* \\Foo\bar\FooBar.txt */
-      return L"\\\\?\\UNC\\" + std::wstring(&wfull[2]);
+      return "\\\\?\\UNC\\" + std::string(&wfull[2]);
     }
   }
 
diff -urp a/Source/kwsys/Encoding.h.in b/Source/kwsys/Encoding.h.in
--- a/Source/kwsys/Encoding.h.in	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/Encoding.h.in	2021-02-11 18:43:32.759169256 +0330
@@ -31,22 +31,22 @@ extern "C" {
    On Windows, UTF-8 is assumed, and on other platforms,
    the current locale is assumed.
    */
-kwsysEXPORT size_t kwsysEncoding_mbstowcs(wchar_t* dest, const char* src,
+kwsysEXPORT size_t kwsysEncoding_mbstowcs(char* dest, const char* src,
                                           size_t n);
 
 /* Convert a narrow string to a wide string.
    This can return NULL if the conversion fails. */
-kwsysEXPORT wchar_t* kwsysEncoding_DupToWide(const char* src);
+kwsysEXPORT char* kwsysEncoding_DupToWide(const char* src);
 
 /* Convert a wide string to a narrow string.
    On Windows, UTF-8 is assumed, and on other platforms,
    the current locale is assumed. */
-kwsysEXPORT size_t kwsysEncoding_wcstombs(char* dest, const wchar_t* src,
+kwsysEXPORT size_t kwsysEncoding_wcstombs(char* dest, const char* src,
                                           size_t n);
 
 /* Convert a wide string to a narrow string.
    This can return NULL if the conversion fails. */
-kwsysEXPORT char* kwsysEncoding_DupToNarrow(const wchar_t* str);
+kwsysEXPORT char* kwsysEncoding_DupToNarrow(const char* str);
 
 #if defined(__cplusplus)
 } /* extern "C" */
diff -urp a/Source/kwsys/Encoding.hxx.in b/Source/kwsys/Encoding.hxx.in
--- a/Source/kwsys/Encoding.hxx.in	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/Encoding.hxx.in	2021-02-12 14:39:55.148193613 +0330
@@ -27,9 +27,6 @@ public:
     // in the encoding used by this module.
     CommandLineArguments(int argc, char const* const* argv);
 
-    // Construct CommandLineArguments with the given
-    // argc and wide argv.  This is useful if wmain() is used.
-    CommandLineArguments(int argc, wchar_t const* const* argv);
     ~CommandLineArguments();
     CommandLineArguments(const CommandLineArguments&);
     CommandLineArguments& operator=(const CommandLineArguments&);
@@ -42,7 +39,7 @@ public:
   };
 
   /**
-   * Convert between char and wchar_t
+   * Convert between char and char
    */
 
 #if @KWSYS_NAMESPACE@_STL_HAS_WSTRING
@@ -50,14 +47,14 @@ public:
   // Convert a narrow string to a wide string.
   // On Windows, UTF-8 is assumed, and on other platforms,
   // the current locale is assumed.
-  static std::wstring ToWide(const std::string& str);
-  static std::wstring ToWide(const char* str);
+  static std::string ToWide(const std::string& str);
+  static std::string ToWide(const char* str);
 
   // Convert a wide string to a narrow string.
   // On Windows, UTF-8 is assumed, and on other platforms,
   // the current locale is assumed.
-  static std::string ToNarrow(const std::wstring& str);
-  static std::string ToNarrow(const wchar_t* str);
+  static std::string ToNarrow(const std::string& str);
+  static std::string ToNarrow(const char* str);
 
 #  if defined(_WIN32)
   /**
@@ -67,9 +64,8 @@ public:
    * will be prefixed with \\?\UNC\. All output will also be converted to
    * absolute paths with Windows-style backslashes.
    **/
-  static std::wstring ToWindowsExtendedPath(std::string const&);
-  static std::wstring ToWindowsExtendedPath(const char* source);
-  static std::wstring ToWindowsExtendedPath(std::wstring const& wsource);
+  static std::string ToWindowsExtendedPath(std::string const&);
+  static std::string ToWindowsExtendedPath(const char* source);
 #  endif
 
 #endif // @KWSYS_NAMESPACE@_STL_HAS_WSTRING
diff -urp a/Source/kwsys/FStream.hxx.in b/Source/kwsys/FStream.hxx.in
--- a/Source/kwsys/FStream.hxx.in	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/FStream.hxx.in	2021-02-11 18:43:32.765836028 +0330
@@ -33,7 +33,7 @@ public:
   typedef std::basic_filebuf<CharType, Traits> my_base_type;
   basic_filebuf* open(char const* s, std::ios_base::openmode mode)
   {
-    const std::wstring wstr = Encoding::ToWindowsExtendedPath(s);
+    const std::string wstr = Encoding::ToWindowsExtendedPath(s);
     return static_cast<basic_filebuf*>(my_base_type::open(wstr.c_str(), mode));
   }
 #    endif
@@ -41,28 +41,28 @@ public:
 
 #  else
 
-inline std::wstring getcmode(const std::ios_base::openmode mode)
+inline std::string getcmode(const std::ios_base::openmode mode)
 {
-  std::wstring cmode;
+  std::string cmode;
   bool plus = false;
   if (mode & std::ios_base::app) {
-    cmode += L"a";
+    cmode += "a";
     plus = mode & std::ios_base::in ? true : false;
   } else if (mode & std::ios_base::trunc ||
              (mode & std::ios_base::out && (mode & std::ios_base::in) == 0)) {
-    cmode += L"w";
+    cmode += "w";
     plus = mode & std::ios_base::in ? true : false;
   } else {
-    cmode += L"r";
+    cmode += "r";
     plus = mode & std::ios_base::out ? true : false;
   }
   if (plus) {
-    cmode += L"+";
+    cmode += "+";
   }
   if (mode & std::ios_base::binary) {
-    cmode += L"b";
+    cmode += "b";
   } else {
-    cmode += L"t";
+    cmode += "t";
   }
   return cmode;
 };
@@ -93,9 +93,9 @@ public:
 #  if defined(_MSC_VER)
     const bool success = buf_->open(file_name, mode) != 0;
 #  else
-    const std::wstring wstr = Encoding::ToWindowsExtendedPath(file_name);
+    const std::string wstr = Encoding::ToWindowsExtendedPath(file_name);
     bool success = false;
-    std::wstring cmode = getcmode(mode);
+    std::string cmode = getcmode(mode);
     file_ = _wfopen(wstr.c_str(), cmode.c_str());
     if (file_) {
       if (buf_) {
diff -urp a/Source/kwsys/kwsysPlatformTestsCXX.cxx b/Source/kwsys/kwsysPlatformTestsCXX.cxx
--- a/Source/kwsys/kwsysPlatformTestsCXX.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/kwsysPlatformTestsCXX.cxx	2021-02-12 14:39:59.854519416 +0330
@@ -156,7 +156,7 @@ int main()
 
 #ifdef TEST_KWSYS_STL_HAS_WSTRING
 #  include <string>
-void f(std::wstring*)
+void f(std::string*)
 {
 }
 int main()
diff -urp a/Source/kwsys/ProcessWin32.c b/Source/kwsys/ProcessWin32.c
--- a/Source/kwsys/ProcessWin32.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/ProcessWin32.c	2021-02-11 18:43:32.785836347 +0330
@@ -202,14 +202,14 @@ struct kwsysProcess_s
   int State;
 
   /* The command lines to execute.  */
-  wchar_t** Commands;
+  char** Commands;
   int NumberOfCommands;
 
   /* The exit code of each command.  */
   DWORD* CommandExitCodes;
 
   /* The working directory for the child process.  */
-  wchar_t* WorkingDirectory;
+  char* WorkingDirectory;
 
   /* Whether to create the child as a detached process.  */
   int OptionDetach;
@@ -301,7 +301,7 @@ struct kwsysProcess_s
 
   /* Real working directory of our own process.  */
   DWORD RealWorkingDirectoryLength;
-  wchar_t* RealWorkingDirectory;
+  char* RealWorkingDirectory;
 
   /* Own handles for the child's ends of the pipes in the parent process.
      Used temporarily during process creation.  */
@@ -549,7 +549,7 @@ int kwsysProcess_SetCommand(kwsysProcess
 int kwsysProcess_AddCommand(kwsysProcess* cp, char const* const* command)
 {
   int newNumberOfCommands;
-  wchar_t** newCommands;
+  char** newCommands;
 
   /* Make sure we have a command to add.  */
   if (!cp || !command || !*command) {
@@ -559,7 +559,7 @@ int kwsysProcess_AddCommand(kwsysProcess
   /* Allocate a new array for command pointers.  */
   newNumberOfCommands = cp->NumberOfCommands + 1;
   if (!(newCommands =
-          (wchar_t**)malloc(sizeof(wchar_t*) * newNumberOfCommands))) {
+          (char**)malloc(sizeof(char*) * newNumberOfCommands))) {
     /* Out of memory.  */
     return 0;
   }
@@ -664,11 +664,11 @@ int kwsysProcess_SetWorkingDirectory(kws
     cp->WorkingDirectory = 0;
   }
   if (dir && dir[0]) {
-    wchar_t* wdir = kwsysEncoding_DupToWide(dir);
+    char* wdir = kwsysEncoding_DupToWide(dir);
     /* We must convert the working directory to a full path.  */
     DWORD length = GetFullPathNameW(wdir, 0, 0, 0);
     if (length > 0) {
-      wchar_t* work_dir = malloc(length * sizeof(wchar_t));
+      char* work_dir = malloc(length * sizeof(char));
       if (!work_dir) {
         free(wdir);
         return 0;
@@ -968,7 +968,7 @@ void kwsysProcess_Execute(kwsysProcess*
   /* Setup the stdin pipe for the first process.  */
   if (cp->PipeFileSTDIN) {
     /* Create a handle to read a file for stdin.  */
-    wchar_t* wstdin = kwsysEncoding_DupToWide(cp->PipeFileSTDIN);
+    char* wstdin = kwsysEncoding_DupToWide(cp->PipeFileSTDIN);
     DWORD error;
     cp->PipeChildStd[0] =
       CreateFileW(wstdin, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, 0,
@@ -1630,7 +1630,7 @@ int kwsysProcessInitialize(kwsysProcess*
     cp->RealWorkingDirectoryLength = GetCurrentDirectoryW(0, 0);
     if (cp->RealWorkingDirectoryLength > 0) {
       cp->RealWorkingDirectory =
-        malloc(cp->RealWorkingDirectoryLength * sizeof(wchar_t));
+        malloc(cp->RealWorkingDirectoryLength * sizeof(char));
       if (!cp->RealWorkingDirectory) {
         return 0;
       }
@@ -1796,7 +1796,7 @@ void kwsysProcessDestroy(kwsysProcess* c
 DWORD kwsysProcessSetupOutputPipeFile(PHANDLE phandle, const char* name)
 {
   HANDLE fout;
-  wchar_t* wname;
+  char* wname;
   DWORD error;
   if (!name) {
     return ERROR_INVALID_PARAMETER;
@@ -1857,7 +1857,7 @@ void kwsysProcessCleanup(kwsysProcess* c
     /* Construct an error message if one has not been provided already.  */
     if (cp->ErrorMessage[0] == 0) {
       /* Format the error message.  */
-      wchar_t err_msg[KWSYSPE_PIPE_BUFFER_SIZE];
+      char err_msg[KWSYSPE_PIPE_BUFFER_SIZE];
       DWORD length = FormatMessageW(
         FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 0, error,
         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), err_msg,
@@ -2347,7 +2347,7 @@ static int kwsysProcess_List__New_NT4(kw
      loaded in this program.  This does not actually increment the
      reference count to the module so we do not need to close the
      handle.  */
-  HMODULE hNT = GetModuleHandleW(L"ntdll.dll");
+  HMODULE hNT = GetModuleHandleW("ntdll.dll");
   if (hNT) {
     /* Get pointers to the needed API functions.  */
     self->P_ZwQuerySystemInformation =
@@ -2428,7 +2428,7 @@ static int kwsysProcess_List__New_Snapsh
      loaded in this program.  This does not actually increment the
      reference count to the module so we do not need to close the
      handle.  */
-  HMODULE hKernel = GetModuleHandleW(L"kernel32.dll");
+  HMODULE hKernel = GetModuleHandleW("kernel32.dll");
   if (hKernel) {
     self->P_CreateToolhelp32Snapshot =
       ((CreateToolhelp32SnapshotType)GetProcAddress(
diff -urp a/Source/kwsys/SystemInformation.cxx b/Source/kwsys/SystemInformation.cxx
--- a/Source/kwsys/SystemInformation.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/SystemInformation.cxx	2021-02-12 14:39:59.854519416 +0330
@@ -2559,7 +2559,7 @@ bool SystemInformationImplementation::Re
     HKEY hKey = nullptr;
     LONG err =
       RegOpenKeyExW(HKEY_LOCAL_MACHINE,
-                    L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0", 0,
+                    "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0", 0,
                     KEY_READ, &hKey);
 
     if (ERROR_SUCCESS == err) {
@@ -2568,7 +2568,7 @@ bool SystemInformationImplementation::Re
       DWORD dwSize = sizeof(DWORD);
 
       err =
-        RegQueryValueExW(hKey, L"~MHz", 0, &dwType, (LPBYTE)&data, &dwSize);
+        RegQueryValueExW(hKey, "~MHz", 0, &dwType, (LPBYTE)&data, &dwSize);
 
       if (ERROR_SUCCESS == err) {
         this->CPUSpeedInMHz = (float)data;
@@ -3836,7 +3836,7 @@ double SystemInformationImplementation::
   typedef BOOL(WINAPI * GetSystemTimesType)(LPFILETIME, LPFILETIME,
                                             LPFILETIME);
   static GetSystemTimesType pGetSystemTimes =
-    (GetSystemTimesType)GetProcAddress(GetModuleHandleW(L"kernel32"),
+    (GetSystemTimesType)GetProcAddress(GetModuleHandleW("kernel32"),
                                        "GetSystemTimes");
   FILETIME idleTime, kernelTime, userTime;
   if (pGetSystemTimes && pGetSystemTimes(&idleTime, &kernelTime, &userTime)) {
@@ -4383,7 +4383,7 @@ void SystemInformationImplementation::CP
     PSYSTEM_LOGICAL_PROCESSOR_INFORMATION, PDWORD);
   static GetLogicalProcessorInformationType pGetLogicalProcessorInformation =
     (GetLogicalProcessorInformationType)GetProcAddress(
-      GetModuleHandleW(L"kernel32"), "GetLogicalProcessorInformation");
+      GetModuleHandleW("kernel32"), "GetLogicalProcessorInformation");
 
   if (!pGetLogicalProcessorInformation) {
     // Fallback to approximate implementation on ancient Windows versions.
@@ -5267,21 +5267,21 @@ bool SystemInformationImplementation::Qu
 #  endif // VER_NT_WORKSTATION
       {
         HKEY hKey;
-        wchar_t szProductType[80];
+        char szProductType[80];
         DWORD dwBufLen;
 
         // Query the registry to retrieve information.
         RegOpenKeyExW(HKEY_LOCAL_MACHINE,
-                      L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions", 0,
+                      "SYSTEM\\CurrentControlSet\\Control\\ProductOptions", 0,
                       KEY_QUERY_VALUE, &hKey);
-        RegQueryValueExW(hKey, L"ProductType", nullptr, nullptr,
+        RegQueryValueExW(hKey, "ProductType", nullptr, nullptr,
                          (LPBYTE)szProductType, &dwBufLen);
         RegCloseKey(hKey);
 
-        if (lstrcmpiW(L"WINNT", szProductType) == 0) {
+        if (lstrcmpiW("WINNT", szProductType) == 0) {
           this->OSRelease += " Professional";
         }
-        if (lstrcmpiW(L"LANMANNT", szProductType) == 0) {
+        if (lstrcmpiW("LANMANNT", szProductType) == 0) {
           // Decide between Windows 2000 Advanced Server and Windows .NET
           // Enterprise Server.
           if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1) {
@@ -5290,7 +5290,7 @@ bool SystemInformationImplementation::Qu
             this->OSRelease += " Server";
           }
         }
-        if (lstrcmpiW(L"SERVERNT", szProductType) == 0) {
+        if (lstrcmpiW("SERVERNT", szProductType) == 0) {
           // Decide between Windows 2000 Advanced Server and Windows .NET
           // Enterprise Server.
           if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1) {
@@ -5315,7 +5315,7 @@ bool SystemInformationImplementation::Qu
         LPFNPROC DLLProc;
 
         // Load the Kernel32 DLL.
-        hKernelDLL = LoadLibraryW(L"kernel32");
+        hKernelDLL = LoadLibraryW("kernel32");
         if (hKernelDLL != nullptr) {
           // Only XP and .NET Server support IsWOW64Process so... Load
           // dynamically!
diff -urp a/Source/kwsys/SystemTools.cxx b/Source/kwsys/SystemTools.cxx
--- a/Source/kwsys/SystemTools.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/SystemTools.cxx	2021-02-12 14:39:59.854519416 +0330
@@ -223,7 +223,7 @@ inline int Rmdir(const std::string& dir)
 }
 inline const char* Getcwd(char* buf, unsigned int len)
 {
-  std::vector<wchar_t> w_buf(len);
+  std::vector<char> w_buf(len);
   if (_wgetcwd(&w_buf[0], len)) {
     size_t nlen = kwsysEncoding_wcstombs(buf, &w_buf[0], len);
     if (nlen == static_cast<size_t>(-1)) {
@@ -246,9 +246,9 @@ inline int Chdir(const std::string& dir)
 inline void Realpath(const std::string& path, std::string& resolved_path,
                      std::string* errorMessage = 0)
 {
-  std::wstring tmp = KWSYS_NAMESPACE::Encoding::ToWide(path);
-  wchar_t* ptemp;
-  wchar_t fullpath[MAX_PATH];
+  std::string tmp = KWSYS_NAMESPACE::Encoding::ToWide(path);
+  char* ptemp;
+  char fullpath[MAX_PATH];
   DWORD bufferLen = GetFullPathNameW(
     tmp.c_str(), sizeof(fullpath) / sizeof(fullpath[0]), fullpath, &ptemp);
   if (bufferLen < sizeof(fullpath) / sizeof(fullpath[0])) {
@@ -351,7 +351,7 @@ double SystemTools::GetTime()
 
 /* Type of character storing the environment.  */
 #if defined(_WIN32)
-typedef wchar_t envchar;
+typedef char envchar;
 #else
 using envchar = char;
 #endif
@@ -362,8 +362,8 @@ struct kwsysEnvCompare
   bool operator()(const envchar* l, const envchar* r) const
   {
 #if defined(_WIN32)
-    const wchar_t* leq = wcschr(l, L'=');
-    const wchar_t* req = wcschr(r, L'=');
+    const char* leq = wcschr(l, L'=');
+    const char* req = wcschr(r, L'=');
     size_t llen = leq ? (leq - l) : wcslen(l);
     size_t rlen = req ? (req - r) : wcslen(r);
     if (llen == rlen) {
@@ -642,8 +642,8 @@ const char* SystemTools::GetEnv(const st
 bool SystemTools::GetEnv(const char* key, std::string& result)
 {
 #if defined(_WIN32)
-  const std::wstring wkey = Encoding::ToWide(key);
-  const wchar_t* wv = _wgetenv(wkey.c_str());
+  const std::string wkey = Encoding::ToWide(key);
+  const char* wv = _wgetenv(wkey.c_str());
   if (wv) {
     result = Encoding::ToNarrow(wv);
     return true;
@@ -666,8 +666,8 @@ bool SystemTools::GetEnv(const std::stri
 bool SystemTools::HasEnv(const char* key)
 {
 #if defined(_WIN32)
-  const std::wstring wkey = Encoding::ToWide(key);
-  const wchar_t* v = _wgetenv(wkey.c_str());
+  const std::string wkey = Encoding::ToWide(key);
+  const char* v = _wgetenv(wkey.c_str());
 #else
   const char* v = getenv(key);
 #endif
@@ -733,11 +733,11 @@ static kwsysEnvSet kwsysUnPutEnvSet;
 
 static int kwsysUnPutEnv(std::string const& env)
 {
-  std::wstring wEnv = Encoding::ToWide(env);
+  std::string wEnv = Encoding::ToWide(env);
   size_t const pos = wEnv.find('=');
   size_t const len = pos == std::string::npos ? wEnv.size() : pos;
   wEnv.resize(len + 1, L'=');
-  wchar_t* newEnv = _wcsdup(wEnv.c_str());
+  char* newEnv = _wcsdup(wEnv.c_str());
   if (!newEnv) {
     return -1;
   }
@@ -820,8 +820,8 @@ public:
   bool Put(const char* env)
   {
 #  if defined(_WIN32)
-    const std::wstring wEnv = Encoding::ToWide(env);
-    wchar_t* newEnv = _wcsdup(wEnv.c_str());
+    const std::string wEnv = Encoding::ToWide(env);
+    char* newEnv = _wcsdup(wEnv.c_str());
 #  else
     char* newEnv = strdup(env);
 #  endif
@@ -836,7 +836,7 @@ public:
   bool UnPut(const char* env)
   {
 #  if defined(_WIN32)
-    const std::wstring wEnv = Encoding::ToWide(env);
+    const std::string wEnv = Encoding::ToWide(env);
     Free oldEnv(this->Release(wEnv.c_str()));
 #  else
     Free oldEnv(this->Release(env));
@@ -872,7 +872,7 @@ FILE* SystemTools::Fopen(const std::stri
 {
 #ifdef _WIN32
   // Remove any 'e', which is supported on UNIX, but not Windows.
-  std::wstring trimmedMode = Encoding::ToWide(mode);
+  std::string trimmedMode = Encoding::ToWide(mode);
   trimmedMode.erase(std::remove(trimmedMode.begin(), trimmedMode.end(), L'e'),
                     trimmedMode.end());
   return _wfopen(Encoding::ToWindowsExtendedPath(file).c_str(),
@@ -1005,7 +1005,7 @@ static bool hasPrefix(const std::string&
 }
 
 static bool SystemToolsParseRegistryKey(const std::string& key,
-                                        HKEY& primaryKey, std::wstring& second,
+                                        HKEY& primaryKey, std::string& second,
                                         std::string* valuename)
 {
   size_t start = key.find('\\');
@@ -1040,7 +1040,7 @@ static DWORD SystemToolsMakeRegistryMode
 {
   // only add the modes when on a system that supports Wow64.
   static FARPROC wow64p =
-    GetProcAddress(GetModuleHandleW(L"kernel32"), "IsWow64Process");
+    GetProcAddress(GetModuleHandleW("kernel32"), "IsWow64Process");
   if (wow64p == nullptr) {
     return mode;
   }
@@ -1060,7 +1060,7 @@ bool SystemTools::GetRegistrySubKeys(con
                                      KeyWOW64 view)
 {
   HKEY primaryKey = HKEY_CURRENT_USER;
-  std::wstring second;
+  std::string second;
   if (!SystemToolsParseRegistryKey(key, primaryKey, second, nullptr)) {
     return false;
   }
@@ -1071,7 +1071,7 @@ bool SystemTools::GetRegistrySubKeys(con
                     &hKey) != ERROR_SUCCESS) {
     return false;
   } else {
-    wchar_t name[1024];
+    char name[1024];
     DWORD dwNameSize = sizeof(name) / sizeof(name[0]);
 
     DWORD i = 0;
@@ -1106,7 +1106,7 @@ bool SystemTools::ReadRegistryValue(cons
 {
   bool valueset = false;
   HKEY primaryKey = HKEY_CURRENT_USER;
-  std::wstring second;
+  std::string second;
   std::string valuename;
   if (!SystemToolsParseRegistryKey(key, primaryKey, second, &valuename)) {
     return false;
@@ -1120,14 +1120,14 @@ bool SystemTools::ReadRegistryValue(cons
   } else {
     DWORD dwType, dwSize;
     dwSize = 1023;
-    wchar_t data[1024];
+    char data[1024];
     if (RegQueryValueExW(hKey, Encoding::ToWide(valuename).c_str(), nullptr,
                          &dwType, (BYTE*)data, &dwSize) == ERROR_SUCCESS) {
       if (dwType == REG_SZ) {
         value = Encoding::ToNarrow(data);
         valueset = true;
       } else if (dwType == REG_EXPAND_SZ) {
-        wchar_t expanded[1024];
+        char expanded[1024];
         DWORD dwExpandedSize = sizeof(expanded) / sizeof(expanded[0]);
         if (ExpandEnvironmentStringsW(data, expanded, dwExpandedSize)) {
           value = Encoding::ToNarrow(expanded);
@@ -1160,7 +1160,7 @@ bool SystemTools::WriteRegistryValue(con
                                      const std::string& value, KeyWOW64 view)
 {
   HKEY primaryKey = HKEY_CURRENT_USER;
-  std::wstring second;
+  std::string second;
   std::string valuename;
   if (!SystemToolsParseRegistryKey(key, primaryKey, second, &valuename)) {
     return false;
@@ -1168,7 +1168,7 @@ bool SystemTools::WriteRegistryValue(con
 
   HKEY hKey;
   DWORD dwDummy;
-  wchar_t lpClass[] = L"";
+  char lpClass[] = "";
   if (RegCreateKeyExW(primaryKey, second.c_str(), 0, lpClass,
                       REG_OPTION_NON_VOLATILE,
                       SystemToolsMakeRegistryMode(KEY_WRITE, view), nullptr,
@@ -1176,10 +1176,10 @@ bool SystemTools::WriteRegistryValue(con
     return false;
   }
 
-  std::wstring wvalue = Encoding::ToWide(value);
+  std::string wvalue = Encoding::ToWide(value);
   if (RegSetValueExW(hKey, Encoding::ToWide(valuename).c_str(), 0, REG_SZ,
                      (CONST BYTE*)wvalue.c_str(),
-                     (DWORD)(sizeof(wchar_t) * (wvalue.size() + 1))) ==
+                     (DWORD)(sizeof(char) * (wvalue.size() + 1))) ==
       ERROR_SUCCESS) {
     return true;
   }
@@ -1204,7 +1204,7 @@ bool SystemTools::WriteRegistryValue(con
 bool SystemTools::DeleteRegistryValue(const std::string& key, KeyWOW64 view)
 {
   HKEY primaryKey = HKEY_CURRENT_USER;
-  std::wstring second;
+  std::string second;
   std::string valuename;
   if (!SystemToolsParseRegistryKey(key, primaryKey, second, &valuename)) {
     return false;
@@ -1404,7 +1404,7 @@ int SystemTools::Stat(const std::string&
   // Ideally we should use Encoding::ToWindowsExtendedPath to support
   // long paths, but _wstat64 rejects paths with '?' in them, thinking
   // they are wildcards.
-  std::wstring const& wpath = Encoding::ToWide(path);
+  std::string const& wpath = Encoding::ToWide(path);
   return _wstat64(wpath.c_str(), buf);
 #else
   return stat(path.c_str(), buf);
@@ -2035,7 +2035,7 @@ void SystemTools::ConvertToUnixSlashes(s
 }
 
 #ifdef _WIN32
-std::wstring SystemTools::ConvertToWindowsExtendedPath(
+std::string SystemTools::ConvertToWindowsExtendedPath(
   const std::string& source)
 {
   return Encoding::ToWindowsExtendedPath(source);
@@ -2556,7 +2556,7 @@ std::string SystemTools::GetLastSystemEr
 bool SystemTools::RemoveFile(const std::string& source)
 {
 #ifdef _WIN32
-  std::wstring const& ws = Encoding::ToWindowsExtendedPath(source);
+  std::string const& ws = Encoding::ToWindowsExtendedPath(source);
   if (DeleteFileW(ws.c_str())) {
     return true;
   }
@@ -2960,7 +2960,7 @@ bool SystemTools::FileIsExecutable(const
 bool SystemTools::FileIsSymlink(const std::string& name)
 {
 #if defined(_WIN32)
-  std::wstring path = Encoding::ToWindowsExtendedPath(name);
+  std::string path = Encoding::ToWindowsExtendedPath(name);
   DWORD attr = GetFileAttributesW(path.c_str());
   if (attr != INVALID_FILE_ATTRIBUTES) {
     if ((attr & FILE_ATTRIBUTE_REPARSE_POINT) != 0) {
@@ -3971,9 +3971,9 @@ bool SystemTools::GetShortPath(const std
     tempPath.erase(0, 1);
   }
 
-  std::wstring wtempPath = Encoding::ToWide(tempPath);
+  std::string wtempPath = Encoding::ToWide(tempPath);
   DWORD ret = GetShortPathNameW(wtempPath.c_str(), nullptr, 0);
-  std::vector<wchar_t> buffer(ret);
+  std::vector<char> buffer(ret);
   if (ret != 0) {
     ret = GetShortPathNameW(wtempPath.c_str(), &buffer[0],
                             static_cast<DWORD>(buffer.size()));
@@ -4368,19 +4368,19 @@ std::string SystemTools::GetOperatingSys
       else {
         HKEY hKey;
 #  define BUFSIZE 80
-        wchar_t szProductType[BUFSIZE];
+        char szProductType[BUFSIZE];
         DWORD dwBufLen = BUFSIZE;
         LONG lRet;
 
         lRet =
           RegOpenKeyExW(HKEY_LOCAL_MACHINE,
-                        L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
+                        "SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
                         0, KEY_QUERY_VALUE, &hKey);
         if (lRet != ERROR_SUCCESS) {
           return 0;
         }
 
-        lRet = RegQueryValueExW(hKey, L"ProductType", nullptr, nullptr,
+        lRet = RegQueryValueExW(hKey, "ProductType", nullptr, nullptr,
                                 (LPBYTE)szProductType, &dwBufLen);
 
         if ((lRet != ERROR_SUCCESS) || (dwBufLen > BUFSIZE)) {
@@ -4389,13 +4389,13 @@ std::string SystemTools::GetOperatingSys
 
         RegCloseKey(hKey);
 
-        if (lstrcmpiW(L"WINNT", szProductType) == 0) {
+        if (lstrcmpiW("WINNT", szProductType) == 0) {
           res += " Workstation";
         }
-        if (lstrcmpiW(L"LANMANNT", szProductType) == 0) {
+        if (lstrcmpiW("LANMANNT", szProductType) == 0) {
           res += " Server";
         }
-        if (lstrcmpiW(L"SERVERNT", szProductType) == 0) {
+        if (lstrcmpiW("SERVERNT", szProductType) == 0) {
           res += " Advanced Server";
         }
 
@@ -4418,7 +4418,7 @@ std::string SystemTools::GetOperatingSys
 
         lRet = RegOpenKeyExW(
           HKEY_LOCAL_MACHINE,
-          L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix\\Q246009",
+          "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix\\Q246009",
           0, KEY_QUERY_VALUE, &hKey);
 
         if (lRet == ERROR_SUCCESS) {
diff -urp a/Source/kwsys/SystemTools.hxx.in b/Source/kwsys/SystemTools.hxx.in
--- a/Source/kwsys/SystemTools.hxx.in	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/SystemTools.hxx.in	2021-02-11 18:43:32.762502643 +0330
@@ -258,7 +258,7 @@ public:
 
 #ifdef _WIN32
   /** Calls Encoding::ToWindowsExtendedPath.  */
-  static std::wstring ConvertToWindowsExtendedPath(const std::string&);
+  static std::string ConvertToWindowsExtendedPath(const std::string&);
 #endif
 
   /**
diff -urp a/Source/kwsys/testConsoleBufChild.cxx b/Source/kwsys/testConsoleBufChild.cxx
--- a/Source/kwsys/testConsoleBufChild.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/testConsoleBufChild.cxx	2021-02-11 18:43:32.759169256 +0330
@@ -27,8 +27,8 @@ int main(int argc, const char* argv[])
     std::cout << argv[1] << std::endl;
     std::cerr << argv[1] << std::endl;
   } else {
-    std::string str = kwsys::Encoding::ToNarrow(std::wstring(
-      UnicodeTestString, sizeof(UnicodeTestString) / sizeof(wchar_t) - 1));
+    std::string str = kwsys::Encoding::ToNarrow(std::string(
+      UnicodeTestString, sizeof(UnicodeTestString) / sizeof(char) - 1));
     std::cout << str << std::endl;
     std::cerr << str << std::endl;
   }
diff -urp a/Source/kwsys/testConsoleBuf.cxx b/Source/kwsys/testConsoleBuf.cxx
--- a/Source/kwsys/testConsoleBuf.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/testConsoleBuf.cxx	2021-02-11 18:43:32.759169256 +0330
@@ -33,7 +33,7 @@
 #  endif
 // يونيكود
 static const WCHAR UnicodeInputTestString[] =
-  L"\u064A\u0648\u0646\u064A\u0643\u0648\u062F!";
+  "\u064A\u0648\u0646\u064A\u0643\u0648\u062F!";
 static UINT TestCodepage = KWSYS_ENCODING_DEFAULT_CODEPAGE;
 
 static const DWORD waitTimeout = 10 * 1000;
@@ -68,7 +68,7 @@ std::basic_streambuf<char>* errstream(co
   return std::cerr.rdbuf();
 }
 
-std::basic_streambuf<wchar_t>* errstream(const wchar_t* unused)
+std::basic_streambuf<char>* errstream(const char* unused)
 {
   static_cast<void>(unused);
   return std::wcerr.rdbuf();
@@ -133,7 +133,7 @@ static bool createProcess(HANDLE hIn, HA
     p--;
   *(p + 1) = 0;
   wcscat(cmd, cmdConsoleBufChild);
-  wcscat(cmd, L".exe");
+  wcscat(cmd, ".exe");
 
   bool success =
     CreateProcessW(nullptr,         // No module name (use command line)
@@ -374,9 +374,9 @@ static int testFile()
   HANDLE outFile = INVALID_HANDLE_VALUE;
   HANDLE errFile = INVALID_HANDLE_VALUE;
   try {
-    if ((inFile = createFile(L"stdinFile.txt")) == INVALID_HANDLE_VALUE ||
-        (outFile = createFile(L"stdoutFile.txt")) == INVALID_HANDLE_VALUE ||
-        (errFile = createFile(L"stderrFile.txt")) == INVALID_HANDLE_VALUE) {
+    if ((inFile = createFile("stdinFile.txt")) == INVALID_HANDLE_VALUE ||
+        (outFile = createFile("stdoutFile.txt")) == INVALID_HANDLE_VALUE ||
+        (errFile = createFile("stderrFile.txt")) == INVALID_HANDLE_VALUE) {
       throw std::runtime_error("createFile failed!");
     }
     DWORD bytesWritten = 0;
@@ -488,7 +488,7 @@ static int testConsole()
   bool newConsole = false;
   bool forceNewConsole = false;
   bool restoreConsole = false;
-  LPCWSTR TestFaceName = L"Lucida Console";
+  LPCWSTR TestFaceName = "Lucida Console";
   const DWORD TestFontFamily = 0x00000036;
   const DWORD TestFontSize = 0x000c0000;
   HKEY hConsoleKey;
@@ -518,23 +518,23 @@ static int testConsole()
 #    endif
 #  endif
   if (!isVistaOrGreater) {
-    if (RegOpenKeyExW(HKEY_CURRENT_USER, L"Console", 0, KEY_READ | KEY_WRITE,
+    if (RegOpenKeyExW(HKEY_CURRENT_USER, "Console", 0, KEY_READ | KEY_WRITE,
                       &hConsoleKey) == ERROR_SUCCESS) {
       DWORD dwordSize = sizeof(DWORD);
-      if (RegQueryValueExW(hConsoleKey, L"FontFamily", nullptr, nullptr,
+      if (RegQueryValueExW(hConsoleKey, "FontFamily", nullptr, nullptr,
                            (LPBYTE)&FontFamily, &dwordSize) == ERROR_SUCCESS) {
         if (FontFamily != TestFontFamily) {
-          RegQueryValueExW(hConsoleKey, L"FaceName", nullptr, nullptr,
+          RegQueryValueExW(hConsoleKey, "FaceName", nullptr, nullptr,
                            (LPBYTE)FaceName, &FaceNameSize);
-          RegQueryValueExW(hConsoleKey, L"FontSize", nullptr, nullptr,
+          RegQueryValueExW(hConsoleKey, "FontSize", nullptr, nullptr,
                            (LPBYTE)&FontSize, &dwordSize);
 
-          RegSetValueExW(hConsoleKey, L"FontFamily", 0, REG_DWORD,
+          RegSetValueExW(hConsoleKey, "FontFamily", 0, REG_DWORD,
                          (BYTE*)&TestFontFamily, sizeof(TestFontFamily));
-          RegSetValueExW(hConsoleKey, L"FaceName", 0, REG_SZ,
+          RegSetValueExW(hConsoleKey, "FaceName", 0, REG_SZ,
                          (BYTE*)TestFaceName,
                          (DWORD)((wcslen(TestFaceName) + 1) * sizeof(WCHAR)));
-          RegSetValueExW(hConsoleKey, L"FontSize", 0, REG_DWORD,
+          RegSetValueExW(hConsoleKey, "FontSize", 0, REG_DWORD,
                          (BYTE*)&TestFontSize, sizeof(TestFontSize));
 
           restoreConsole = true;
@@ -560,7 +560,7 @@ static int testConsole()
     securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
     securityAttributes.bInheritHandle = TRUE;
     securityAttributes.lpSecurityDescriptor = nullptr;
-    hIn = CreateFileW(L"CONIN$", GENERIC_READ | GENERIC_WRITE,
+    hIn = CreateFileW("CONIN$", GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE, &securityAttributes,
                       OPEN_EXISTING, 0, nullptr);
     if (hIn == INVALID_HANDLE_VALUE) {
@@ -568,7 +568,7 @@ static int testConsole()
       std::cerr << "CreateFile(CONIN$)" << std::endl;
       displayError(lastError);
     }
-    hOut = CreateFileW(L"CONOUT$", GENERIC_READ | GENERIC_WRITE,
+    hOut = CreateFileW("CONOUT$", GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE, &securityAttributes,
                        OPEN_EXISTING, 0, nullptr);
     if (hOut == INVALID_HANDLE_VALUE) {
@@ -587,7 +587,7 @@ static int testConsole()
     CONSOLE_FONT_INFOEX consoleFont;
     memset(&consoleFont, 0, sizeof(consoleFont));
     consoleFont.cbSize = sizeof(consoleFont);
-    HMODULE kernel32 = LoadLibraryW(L"kernel32.dll");
+    HMODULE kernel32 = LoadLibraryW("kernel32.dll");
     typedef BOOL(WINAPI * GetCurrentConsoleFontExFunc)(
       HANDLE hConsoleOutput, BOOL bMaximumWindow,
       PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
@@ -614,17 +614,17 @@ static int testConsole()
   } else {
 #  endif
     if (restoreConsole &&
-        RegOpenKeyExW(HKEY_CURRENT_USER, L"Console", 0, KEY_WRITE,
+        RegOpenKeyExW(HKEY_CURRENT_USER, "Console", 0, KEY_WRITE,
                       &hConsoleKey) == ERROR_SUCCESS) {
-      RegSetValueExW(hConsoleKey, L"FontFamily", 0, REG_DWORD,
+      RegSetValueExW(hConsoleKey, "FontFamily", 0, REG_DWORD,
                      (BYTE*)&FontFamily, sizeof(FontFamily));
       if (FaceName[0] != 0) {
-        RegSetValueExW(hConsoleKey, L"FaceName", 0, REG_SZ, (BYTE*)FaceName,
+        RegSetValueExW(hConsoleKey, "FaceName", 0, REG_SZ, (BYTE*)FaceName,
                        FaceNameSize);
       } else {
-        RegDeleteValueW(hConsoleKey, L"FaceName");
+        RegDeleteValueW(hConsoleKey, "FaceName");
       }
-      RegSetValueExW(hConsoleKey, L"FontSize", 0, REG_DWORD, (BYTE*)&FontSize,
+      RegSetValueExW(hConsoleKey, "FontSize", 0, REG_DWORD, (BYTE*)&FontSize,
                      sizeof(FontSize));
       RegCloseKey(hConsoleKey);
     }
@@ -690,34 +690,34 @@ static int testConsole()
         delete[] outputBuffer;
         throw std::runtime_error("ReadConsoleOutputCharacter failed!");
       }
-      std::wstring wideTestString = kwsys::Encoding::ToWide(encodedTestString);
+      std::string wideTestString = kwsys::Encoding::ToWide(encodedTestString);
       std::replace(wideTestString.begin(), wideTestString.end(), '\0', ' ');
-      std::wstring wideInputTestString =
+      std::string wideInputTestString =
         kwsys::Encoding::ToWide(encodedInputTestString);
       if (memcmp(outputBuffer, wideTestString.c_str(),
-                 wideTestString.size() * sizeof(wchar_t)) == 0 &&
+                 wideTestString.size() * sizeof(char)) == 0 &&
           memcmp(outputBuffer + screenBufferInfo.dwSize.X * 1,
                  wideTestString.c_str(),
-                 wideTestString.size() * sizeof(wchar_t)) == 0 &&
+                 wideTestString.size() * sizeof(char)) == 0 &&
           memcmp(outputBuffer + screenBufferInfo.dwSize.X * 2,
                  UnicodeInputTestString,
                  sizeof(UnicodeInputTestString) - sizeof(WCHAR)) == 0 &&
           memcmp(outputBuffer + screenBufferInfo.dwSize.X * 3,
                  wideInputTestString.c_str(),
-                 (wideInputTestString.size() - 1) * sizeof(wchar_t)) == 0) {
+                 (wideInputTestString.size() - 1) * sizeof(char)) == 0) {
         didFail = 0;
       } else {
         std::cerr << "Console's output didn't match expected output!"
                   << std::endl;
-        dumpBuffers<wchar_t>(wideTestString.c_str(), outputBuffer,
+        dumpBuffers<char>(wideTestString.c_str(), outputBuffer,
                              wideTestString.size());
-        dumpBuffers<wchar_t>(wideTestString.c_str(),
+        dumpBuffers<char>(wideTestString.c_str(),
                              outputBuffer + screenBufferInfo.dwSize.X * 1,
                              wideTestString.size());
-        dumpBuffers<wchar_t>(
+        dumpBuffers<char>(
           UnicodeInputTestString, outputBuffer + screenBufferInfo.dwSize.X * 2,
           (sizeof(UnicodeInputTestString) - 1) / sizeof(WCHAR));
-        dumpBuffers<wchar_t>(wideInputTestString.c_str(),
+        dumpBuffers<char>(wideInputTestString.c_str(),
                              outputBuffer + screenBufferInfo.dwSize.X * 3,
                              wideInputTestString.size() - 1);
       }
@@ -763,11 +763,11 @@ int testConsoleBuf(int, char* [])
     return 1;
   }
 
-  encodedTestString = kwsys::Encoding::ToNarrow(std::wstring(
-    UnicodeTestString, sizeof(UnicodeTestString) / sizeof(wchar_t) - 1));
+  encodedTestString = kwsys::Encoding::ToNarrow(std::string(
+    UnicodeTestString, sizeof(UnicodeTestString) / sizeof(char) - 1));
   encodedInputTestString = kwsys::Encoding::ToNarrow(
-    std::wstring(UnicodeInputTestString,
-                 sizeof(UnicodeInputTestString) / sizeof(wchar_t) - 1));
+    std::string(UnicodeInputTestString,
+                 sizeof(UnicodeInputTestString) / sizeof(char) - 1));
   encodedInputTestString += "\n";
 
   ret |= testPipe();
diff -urp a/Source/kwsys/testConsoleBuf.hxx b/Source/kwsys/testConsoleBuf.hxx
--- a/Source/kwsys/testConsoleBuf.hxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/testConsoleBuf.hxx	2021-02-11 18:43:32.762502643 +0330
@@ -3,15 +3,15 @@
 #ifndef testConsoleBuf_hxx
 #define testConsoleBuf_hxx
 
-static const wchar_t cmdConsoleBufChild[] = L"testConsoleBufChild";
+static const char cmdConsoleBufChild[] = "testConsoleBufChild";
 
-static const wchar_t BeforeInputEventName[] = L"BeforeInputEvent";
-static const wchar_t AfterOutputEventName[] = L"AfterOutputEvent";
+static const char BeforeInputEventName[] = "BeforeInputEvent";
+static const char AfterOutputEventName[] = "AfterOutputEvent";
 
 // यूनिकोड είναι здорово!
-static const wchar_t UnicodeTestString[] =
-  L"\u092F\u0942\u0928\u093F\u0915\u094B\u0921 "
-  L"\u03B5\u03AF\u03BD\0\u03B1\u03B9 "
-  L"\u0437\u0434\u043E\u0440\u043E\u0432\u043E!";
+static const char UnicodeTestString[] =
+  "\u092F\u0942\u0928\u093F\u0915\u094B\u0921 "
+  "\u03B5\u03AF\u03BD\0\u03B1\u03B9 "
+  "\u0437\u0434\u043E\u0440\u043E\u0432\u043E!";
 
 #endif
diff -urp a/Source/kwsys/testEncoding.cxx b/Source/kwsys/testEncoding.cxx
--- a/Source/kwsys/testEncoding.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/kwsys/testEncoding.cxx	2021-02-11 18:43:32.815836824 +0330
@@ -55,9 +55,9 @@ static int testHelloWorldEncoding()
   for (int i = 0; helloWorldStrings[i][0] != 0; i++) {
     std::string str = reinterpret_cast<const char*>(helloWorldStrings[i]);
     std::cout << str << std::endl;
-    std::wstring wstr = kwsys::Encoding::ToWide(str);
+    std::string wstr = kwsys::Encoding::ToWide(str);
     std::string str2 = kwsys::Encoding::ToNarrow(wstr);
-    wchar_t* c_wstr = kwsysEncoding_DupToWide(str.c_str());
+    char* c_wstr = kwsysEncoding_DupToWide(str.c_str());
     char* c_str2 = kwsysEncoding_DupToNarrow(c_wstr);
     if (!wstr.empty() && (str != str2 || strcmp(c_str2, str.c_str()) != 0)) {
       std::cout << "converted string was different: " << str2 << std::endl;
@@ -82,11 +82,11 @@ static int testRobustEncoding()
   int ret = 0;
   char cstr[] = { (char)-1, 0 };
   // this conversion could fail
-  std::wstring wstr = kwsys::Encoding::ToWide(cstr);
+  std::string wstr = kwsys::Encoding::ToWide(cstr);
 
   wstr = kwsys::Encoding::ToWide(nullptr);
   if (!wstr.empty()) {
-    const wchar_t* wcstr = wstr.c_str();
+    const char* wcstr = wstr.c_str();
     std::cout << "ToWide(NULL) returned";
     for (size_t i = 0; i < wstr.size(); i++) {
       std::cout << " " << std::hex << (int)wcstr[i];
@@ -96,7 +96,7 @@ static int testRobustEncoding()
   }
   wstr = kwsys::Encoding::ToWide("");
   if (!wstr.empty()) {
-    const wchar_t* wcstr = wstr.c_str();
+    const char* wcstr = wstr.c_str();
     std::cout << "ToWide(\"\") returned";
     for (size_t i = 0; i < wstr.size(); i++) {
       std::cout << " " << std::hex << (int)wcstr[i];
@@ -106,8 +106,8 @@ static int testRobustEncoding()
   }
 
 #ifdef _WIN32
-  // 16 bit wchar_t - we make an invalid surrogate pair
-  wchar_t cwstr[] = { 0xD801, 0xDA00, 0 };
+  // 16 bit char - we make an invalid surrogate pair
+  char cwstr[] = { 0xD801, 0xDA00, 0 };
   // this conversion could fail
   std::string win_str = kwsys::Encoding::ToNarrow(cwstr);
 #endif
@@ -118,7 +118,7 @@ static int testRobustEncoding()
     ret++;
   }
 
-  str = kwsys::Encoding::ToNarrow(L"");
+  str = kwsys::Encoding::ToNarrow("");
   if (!wstr.empty()) {
     std::cout << "ToNarrow(\"\") returned " << str << std::endl;
     ret++;
@@ -141,7 +141,7 @@ static int testWithNulls()
   strings.push_back(std::string("\0\0\0\0", 4) + "lmn" +
                     std::string("\0\0\0\0", 4));
   for (auto& string : strings) {
-    std::wstring wstr = kwsys::Encoding::ToWide(string);
+    std::string wstr = kwsys::Encoding::ToWide(string);
     std::string str = kwsys::Encoding::ToNarrow(wstr);
     std::string s(string);
     std::replace(s.begin(), s.end(), '\0', ' ');
@@ -188,7 +188,7 @@ static int testToWindowsExtendedPath()
   int ret = 0;
   if (kwsys::Encoding::ToWindowsExtendedPath(
         "L:\\Local Mojo\\Hex Power Pack\\Iffy Voodoo") !=
-      L"\\\\?\\L:\\Local Mojo\\Hex Power Pack\\Iffy Voodoo") {
+      "\\\\?\\L:\\Local Mojo\\Hex Power Pack\\Iffy Voodoo") {
     std::cout << "Problem with ToWindowsExtendedPath "
               << "\"L:\\Local Mojo\\Hex Power Pack\\Iffy Voodoo\""
               << std::endl;
@@ -197,7 +197,7 @@ static int testToWindowsExtendedPath()
 
   if (kwsys::Encoding::ToWindowsExtendedPath(
         "L:/Local Mojo/Hex Power Pack/Iffy Voodoo") !=
-      L"\\\\?\\L:\\Local Mojo\\Hex Power Pack\\Iffy Voodoo") {
+      "\\\\?\\L:\\Local Mojo\\Hex Power Pack\\Iffy Voodoo") {
     std::cout << "Problem with ToWindowsExtendedPath "
               << "\"L:/Local Mojo/Hex Power Pack/Iffy Voodoo\"" << std::endl;
     ++ret;
@@ -205,7 +205,7 @@ static int testToWindowsExtendedPath()
 
   if (kwsys::Encoding::ToWindowsExtendedPath(
         "\\\\Foo\\Local Mojo\\Hex Power Pack\\Iffy Voodoo") !=
-      L"\\\\?\\UNC\\Foo\\Local Mojo\\Hex Power Pack\\Iffy Voodoo") {
+      "\\\\?\\UNC\\Foo\\Local Mojo\\Hex Power Pack\\Iffy Voodoo") {
     std::cout << "Problem with ToWindowsExtendedPath "
               << "\"\\\\Foo\\Local Mojo\\Hex Power Pack\\Iffy Voodoo\""
               << std::endl;
@@ -214,40 +214,40 @@ static int testToWindowsExtendedPath()
 
   if (kwsys::Encoding::ToWindowsExtendedPath(
         "//Foo/Local Mojo/Hex Power Pack/Iffy Voodoo") !=
-      L"\\\\?\\UNC\\Foo\\Local Mojo\\Hex Power Pack\\Iffy Voodoo") {
+      "\\\\?\\UNC\\Foo\\Local Mojo\\Hex Power Pack\\Iffy Voodoo") {
     std::cout << "Problem with ToWindowsExtendedPath "
               << "\"//Foo/Local Mojo/Hex Power Pack/Iffy Voodoo\""
               << std::endl;
     ++ret;
   }
 
-  if (kwsys::Encoding::ToWindowsExtendedPath("//") != L"//") {
+  if (kwsys::Encoding::ToWindowsExtendedPath("//") != "//") {
     std::cout << "Problem with ToWindowsExtendedPath "
               << "\"//\"" << std::endl;
     ++ret;
   }
 
-  if (kwsys::Encoding::ToWindowsExtendedPath("\\\\.\\") != L"\\\\.\\") {
+  if (kwsys::Encoding::ToWindowsExtendedPath("\\\\.\\") != "\\\\.\\") {
     std::cout << "Problem with ToWindowsExtendedPath "
               << "\"\\\\.\\\"" << std::endl;
     ++ret;
   }
 
-  if (kwsys::Encoding::ToWindowsExtendedPath("\\\\.\\X") != L"\\\\.\\X") {
+  if (kwsys::Encoding::ToWindowsExtendedPath("\\\\.\\X") != "\\\\.\\X") {
     std::cout << "Problem with ToWindowsExtendedPath "
               << "\"\\\\.\\X\"" << std::endl;
     ++ret;
   }
 
-  if (kwsys::Encoding::ToWindowsExtendedPath("\\\\.\\X:") != L"\\\\?\\X:") {
+  if (kwsys::Encoding::ToWindowsExtendedPath("\\\\.\\X:") != "\\\\?\\X:") {
     std::cout << "Problem with ToWindowsExtendedPath "
               << "\"\\\\.\\X:\"" << std::endl;
     ++ret;
   }
 
   if (kwsys::Encoding::ToWindowsExtendedPath("\\\\.\\X:\\") !=
-      L"\\\\?\\X:\\") {
+      "\\\\?\\X:\\") {
     std::cout << "Problem with ToWindowsExtendedPath "
               << "\"\\\\.\\X:\\\"" << std::endl;
     ++ret;
   }
diff -urp a/Source/LexerParser/cmListFileLexer.c b/Source/LexerParser/cmListFileLexer.c
--- a/Source/LexerParser/cmListFileLexer.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/LexerParser/cmListFileLexer.c	2021-02-11 18:43:32.715835234 +0330
@@ -2746,8 +2746,8 @@ int cmListFileLexer_SetFileName(cmListFi
   cmListFileLexerDestroy(lexer);
   if (name) {
 #ifdef _WIN32
-    wchar_t* wname = cmsysEncoding_DupToWide(name);
-    lexer->file = _wfopen(wname, L"rb");
+    char* wname = cmsysEncoding_DupToWide(name);
+    lexer->file = _wfopen(wname, "rb");
     free(wname);
 #else
     lexer->file = fopen(name, "rb");
diff -urp a/Source/LexerParser/cmListFileLexer.in.l b/Source/LexerParser/cmListFileLexer.in.l
--- a/Source/LexerParser/cmListFileLexer.in.l	2021-01-28 18:58:45.000000000 +0330
+++ b/Source/LexerParser/cmListFileLexer.in.l	2021-02-11 18:43:32.725835393 +0330
@@ -459,8 +459,8 @@ int cmListFileLexer_SetFileName(cmListFi
   cmListFileLexerDestroy(lexer);
   if (name) {
 #ifdef _WIN32
-    wchar_t* wname = cmsysEncoding_DupToWide(name);
-    lexer->file = _wfopen(wname, L"rb");
+    char* wname = cmsysEncoding_DupToWide(name);
+    lexer->file = _wfopen(wname, "rb");
     free(wname);
 #else
     lexer->file = fopen(name, "rb");
diff -urp a/Templates/MSBuild/FlagTables/v10_CL.json b/Templates/MSBuild/FlagTables/v10_CL.json
--- a/Templates/MSBuild/FlagTables/v10_CL.json	2021-01-28 18:58:45.000000000 +0330
+++ b/Templates/MSBuild/FlagTables/v10_CL.json	2021-02-11 18:43:34.969204192 +0330
@@ -678,14 +678,14 @@
   },
   {
     "name": "TreatWChar_tAsBuiltInType",
-    "switch": "Zc:wchar_t-",
+    "switch": "Zc:char-",
     "comment": "Treat WChar_t As Built in Type",
     "value": "false",
     "flags": []
   },
   {
     "name": "TreatWChar_tAsBuiltInType",
-    "switch": "Zc:wchar_t",
+    "switch": "Zc:char",
     "comment": "Treat WChar_t As Built in Type",
     "value": "true",
     "flags": []
diff -urp a/Templates/MSBuild/FlagTables/v11_CL.json b/Templates/MSBuild/FlagTables/v11_CL.json
--- a/Templates/MSBuild/FlagTables/v11_CL.json	2021-01-28 18:58:45.000000000 +0330
+++ b/Templates/MSBuild/FlagTables/v11_CL.json	2021-02-11 18:43:34.969204192 +0330
@@ -741,14 +741,14 @@
   },
   {
     "name": "TreatWChar_tAsBuiltInType",
-    "switch": "Zc:wchar_t-",
+    "switch": "Zc:char-",
     "comment": "Treat WChar_t As Built in Type",
     "value": "false",
     "flags": []
   },
   {
     "name": "TreatWChar_tAsBuiltInType",
-    "switch": "Zc:wchar_t",
+    "switch": "Zc:char",
     "comment": "Treat WChar_t As Built in Type",
     "value": "true",
     "flags": []
diff -urp a/Templates/MSBuild/FlagTables/v12_CL.json b/Templates/MSBuild/FlagTables/v12_CL.json
--- a/Templates/MSBuild/FlagTables/v12_CL.json	2021-01-28 18:58:45.000000000 +0330
+++ b/Templates/MSBuild/FlagTables/v12_CL.json	2021-02-11 18:43:34.955870650 +0330
@@ -755,14 +755,14 @@
   },
   {
     "name": "TreatWChar_tAsBuiltInType",
-    "switch": "Zc:wchar_t-",
+    "switch": "Zc:char-",
     "comment": "Treat WChar_t As Built in Type",
     "value": "false",
     "flags": []
   },
   {
     "name": "TreatWChar_tAsBuiltInType",
-    "switch": "Zc:wchar_t",
+    "switch": "Zc:char",
     "comment": "Treat WChar_t As Built in Type",
     "value": "true",
     "flags": []
diff -urp a/Templates/MSBuild/FlagTables/v140_CL.json b/Templates/MSBuild/FlagTables/v140_CL.json
--- a/Templates/MSBuild/FlagTables/v140_CL.json	2021-01-28 18:58:45.000000000 +0330
+++ b/Templates/MSBuild/FlagTables/v140_CL.json	2021-02-11 18:43:34.965870807 +0330
@@ -762,14 +762,14 @@
   },
   {
     "name": "TreatWChar_tAsBuiltInType",
-    "switch": "Zc:wchar_t-",
+    "switch": "Zc:char-",
     "comment": "Treat WChar_t As Built in Type",
     "value": "false",
     "flags": []
   },
   {
     "name": "TreatWChar_tAsBuiltInType",
-    "switch": "Zc:wchar_t",
+    "switch": "Zc:char",
     "comment": "Treat WChar_t As Built in Type",
     "value": "true",
     "flags": []
diff -urp a/Templates/MSBuild/FlagTables/v141_CL.json b/Templates/MSBuild/FlagTables/v141_CL.json
--- a/Templates/MSBuild/FlagTables/v141_CL.json	2021-01-28 18:58:45.000000000 +0330
+++ b/Templates/MSBuild/FlagTables/v141_CL.json	2021-02-11 18:43:34.969204192 +0330
@@ -825,14 +825,14 @@
   },
   {
     "name": "TreatWChar_tAsBuiltInType",
-    "switch": "Zc:wchar_t-",
+    "switch": "Zc:char-",
     "comment": "Treat WChar_t As Built in Type",
     "value": "false",
     "flags": []
   },
   {
     "name": "TreatWChar_tAsBuiltInType",
-    "switch": "Zc:wchar_t",
+    "switch": "Zc:char",
     "comment": "Treat WChar_t As Built in Type",
     "value": "true",
     "flags": []
diff -urp a/Templates/MSBuild/FlagTables/v142_CL.json b/Templates/MSBuild/FlagTables/v142_CL.json
--- a/Templates/MSBuild/FlagTables/v142_CL.json	2021-01-28 18:58:45.000000000 +0330
+++ b/Templates/MSBuild/FlagTables/v142_CL.json	2021-02-11 18:43:34.965870807 +0330
@@ -860,14 +860,14 @@
   },
   {
     "name": "TreatWChar_tAsBuiltInType",
-    "switch": "Zc:wchar_t-",
+    "switch": "Zc:char-",
     "comment": "Treat WChar_t As Built in Type",
     "value": "false",
     "flags": []
   },
   {
     "name": "TreatWChar_tAsBuiltInType",
-    "switch": "Zc:wchar_t",
+    "switch": "Zc:char",
     "comment": "Treat WChar_t As Built in Type",
     "value": "true",
     "flags": []
diff -urp a/Tests/CMakeLib/testCMFilesystemPath.cxx b/Tests/CMakeLib/testCMFilesystemPath.cxx
--- a/Tests/CMakeLib/testCMFilesystemPath.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Tests/CMakeLib/testCMFilesystemPath.cxx	2021-02-11 18:43:30.792471215 +0330
@@ -66,7 +66,7 @@ bool testConstructors()
 #endif
   }
   {
-    std::wstring s(L"/a/b/c");
+    std::string s("/a/b/c");
     fs::path p1(s);
     fs::path p2(s.begin(), s.end());
     if (p1 != p2) {
@@ -76,7 +76,7 @@ bool testConstructors()
       result = false;
     }
 #if CM_FILESYSTEM_SOURCE_TRAITS_ITERATOR
-    std::wstring s2(s);
+    std::string s2(s);
     s2 += L'\0';
     fs::path p3(s2.begin());
     if (p1 != p3 || p3.wstring() != s) {
@@ -276,7 +276,7 @@ bool testObservers()
   }
   {
     std::string s("a//b//c");
-    std::wstring ws(L"a//b//c");
+    std::string ws("a//b//c");
     fs::path p(s);
     if (p.string() != s || p.wstring() != ws) {
       result = false;
@@ -284,9 +284,9 @@ bool testObservers()
   }
   {
     std::string s("a/b/c");
-    std::wstring ws;
+    std::string ws;
     for (auto c : s) {
-      ws += static_cast<std::wstring::value_type>(c);
+      ws += static_cast<std::string::value_type>(c);
     }
     std::string ns(s);
     std::replace(
@@ -861,7 +861,7 @@ bool testIterators()
   {
     fs::path p("/a/b/");
 #if defined(_WIN32)
-    std::vector<fs::path::string_type> ref{ L"/", L"a", L"b", L"" };
+    std::vector<fs::path::string_type> ref{ "/", "a", "b", "" };
 #else
     std::vector<fs::path::string_type> ref{ "/", "a", "b", "" };
 #endif
@@ -883,7 +883,7 @@ bool testIterators()
   {
     fs::path p("/a/b/");
 #if defined(_WIN32)
-    std::vector<fs::path::string_type> ref{ L"", L"b", L"a", L"/" };
+    std::vector<fs::path::string_type> ref{ "", "b", "a", "/" };
 #else
     std::vector<fs::path::string_type> ref{ "", "b", "a", "/" };
 #endif
diff -urp a/Tests/FindPython/display_time.c b/Tests/FindPython/display_time.c
--- a/Tests/FindPython/display_time.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Tests/FindPython/display_time.c	2021-02-11 18:43:30.875805885 +0330
@@ -9,7 +9,7 @@
 void display_time()
 {
 #if defined(PYTHON3)
-  wchar_t* program = Py_DecodeLocale("display_time", NULL);
+  char* program = Py_DecodeLocale("display_time", NULL);
   if (program == NULL) {
     fprintf(stderr, "Fatal error: cannot decode argv[0]\n");
     exit(1);
diff -urp a/Tests/Plugin/src/DynamicLoader.cxx b/Tests/Plugin/src/DynamicLoader.cxx
--- a/Tests/Plugin/src/DynamicLoader.cxx	2021-01-28 18:58:45.000000000 +0330
+++ b/Tests/Plugin/src/DynamicLoader.cxx	2021-02-11 18:43:30.512466723 +0330
@@ -94,7 +94,7 @@ DynamicLoader::LibraryHandle DynamicLoad
 {
   DynamicLoader::LibraryHandle lh;
   int length = MultiByteToWideChar(CP_UTF8, 0, libname.c_str(), -1, NULL, 0);
-  wchar_t* wchars = new wchar_t[length + 1];
+  char* wchars = new char[length + 1];
   wchars[0] = '\0';
   MultiByteToWideChar(CP_UTF8, 0, libname.c_str(), -1, wchars, length);
   lh = LoadLibraryW(wchars);
diff -urp a/Tests/VSWindowsFormsResx/WindowsFormsResx/MyForm.h b/Tests/VSWindowsFormsResx/WindowsFormsResx/MyForm.h
--- a/Tests/VSWindowsFormsResx/WindowsFormsResx/MyForm.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Tests/VSWindowsFormsResx/WindowsFormsResx/MyForm.h	2021-02-11 18:43:32.605833485 +0330
@@ -58,10 +58,10 @@ private:
     // button1
     //
     this->button1->Location = System::Drawing::Point(13, 13);
-    this->button1->Name = L"button1";
+    this->button1->Name = "button1";
     this->button1->Size = System::Drawing::Size(75, 23);
     this->button1->TabIndex = 0;
-    this->button1->Text = L"button1";
+    this->button1->Text = "button1";
     this->button1->UseVisualStyleBackColor = true;
     //
     // MyForm
@@ -70,8 +70,8 @@ private:
     this->AutoScaleMode = System::Windows::Forms::AutoScaleMode::Font;
     this->ClientSize = System::Drawing::Size(284, 261);
     this->Controls->Add(this->button1);
-    this->Name = L"MyForm";
-    this->Text = L"MyForm";
+    this->Name = "MyForm";
+    this->Text = "MyForm";
     this->ResumeLayout(false);
   }
 #pragma endregion
diff -urp a/Utilities/cmcurl/lib/curl_multibyte.c b/Utilities/cmcurl/lib/curl_multibyte.c
--- a/Utilities/cmcurl/lib/curl_multibyte.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmcurl/lib/curl_multibyte.c	2021-02-11 18:43:33.732518016 +0330
@@ -34,15 +34,15 @@
  * MultiByte conversions using Windows kernel32 library.
  */
 
-wchar_t *curlx_convert_UTF8_to_wchar(const char *str_utf8)
+char *curlx_convert_UTF8_to_wchar(const char *str_utf8)
 {
-  wchar_t *str_w = NULL;
+  char *str_w = NULL;
 
   if(str_utf8) {
     int str_w_len = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS,
                                         str_utf8, -1, NULL, 0);
     if(str_w_len > 0) {
-      str_w = malloc(str_w_len * sizeof(wchar_t));
+      str_w = malloc(str_w_len * sizeof(char));
       if(str_w) {
         if(MultiByteToWideChar(CP_UTF8, 0, str_utf8, -1, str_w,
                                str_w_len) == 0) {
@@ -56,7 +56,7 @@ wchar_t *curlx_convert_UTF8_to_wchar(con
   return str_w;
 }
 
-char *curlx_convert_wchar_to_UTF8(const wchar_t *str_w)
+char *curlx_convert_charo_UTF8(const char *str_w)
 {
   char *str_utf8 = NULL;
 
@@ -86,8 +86,8 @@ FILE *curlx_win32_fopen(const char *file
 {
 #ifdef _UNICODE
   FILE *result = NULL;
-  wchar_t *filename_w = curlx_convert_UTF8_to_wchar(filename);
-  wchar_t *mode_w = curlx_convert_UTF8_to_wchar(mode);
+  char *filename_w = curlx_convert_UTF8_to_wchar(filename);
+  char *mode_w = curlx_convert_UTF8_to_wchar(mode);
   if(filename_w && mode_w)
     result = _wfopen(filename_w, mode_w);
   free(filename_w);
@@ -103,7 +103,7 @@ int curlx_win32_stat(const char *path, s
 {
   int result = -1;
 #ifdef _UNICODE
-  wchar_t *path_w = curlx_convert_UTF8_to_wchar(path);
+  char *path_w = curlx_convert_UTF8_to_wchar(path);
 #endif /* _UNICODE */
 
 #if defined(USE_WIN32_SMALL_FILES)
@@ -133,7 +133,7 @@ int curlx_win32_access(const char *path,
 {
     int result = -1;
 #ifdef _UNICODE
-    wchar_t *path_w = curlx_convert_UTF8_to_wchar(path);
+    char *path_w = curlx_convert_UTF8_to_wchar(path);
 #endif /* _UNICODE */
 
 #if defined(_UNICODE)
diff -urp a/Utilities/cmcurl/lib/curl_multibyte.h b/Utilities/cmcurl/lib/curl_multibyte.h
--- a/Utilities/cmcurl/lib/curl_multibyte.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmcurl/lib/curl_multibyte.h	2021-02-11 18:43:33.832519600 +0330
@@ -29,8 +29,8 @@
   * MultiByte conversions using Windows kernel32 library.
   */
 
-wchar_t *curlx_convert_UTF8_to_wchar(const char *str_utf8);
-char *curlx_convert_wchar_to_UTF8(const wchar_t *str_w);
+char *curlx_convert_UTF8_to_wchar(const char *str_utf8);
+char *curlx_convert_charo_UTF8(const char *str_w);
 
 #endif /* WIN32 */
 
@@ -55,7 +55,7 @@ char *curlx_convert_wchar_to_UTF8(const
 #if defined(UNICODE) && defined(WIN32)
 
 #define curlx_convert_UTF8_to_tchar(ptr) curlx_convert_UTF8_to_wchar((ptr))
-#define curlx_convert_tchar_to_UTF8(ptr) curlx_convert_wchar_to_UTF8((ptr))
+#define curlx_convert_tchar_to_UTF8(ptr) curlx_convert_charo_UTF8((ptr))
 #define curlx_unicodefree(ptr)                          \
   do {                                                  \
     if(ptr) {                                           \
diff -urp a/Utilities/cmcurl/lib/curl_setup_once.h b/Utilities/cmcurl/lib/curl_setup_once.h
--- a/Utilities/cmcurl/lib/curl_setup_once.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmcurl/lib/curl_setup_once.h	2021-02-11 18:43:33.869186847 +0330
@@ -482,7 +482,7 @@ typedef int sig_atomic_t;
 #ifdef __VMS
 #define argv_item_t  __char_ptr32
 #elif defined(_UNICODE)
-#define argv_item_t wchar_t *
+#define argv_item_t char *
 #else
 #define argv_item_t  char *
 #endif
diff -urp a/Utilities/cmcurl/lib/curl_sspi.c b/Utilities/cmcurl/lib/curl_sspi.c
--- a/Utilities/cmcurl/lib/curl_sspi.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmcurl/lib/curl_sspi.c	2021-02-11 18:43:33.792518966 +0330
@@ -41,7 +41,7 @@ typedef PSecurityFunctionTable (APIENTRY
 /* See definition of SECURITY_ENTRYPOINT in sspi.h */
 #ifdef UNICODE
 #  ifdef _WIN32_WCE
-#    define SECURITYENTRYPOINT L"InitSecurityInterfaceW"
+#    define SECURITYENTRYPOINT "InitSecurityInterfaceW"
 #  else
 #    define SECURITYENTRYPOINT "InitSecurityInterfaceW"
 #  endif
diff -urp a/Utilities/cmcurl/lib/curlx.h b/Utilities/cmcurl/lib/curlx.h
--- a/Utilities/cmcurl/lib/curlx.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmcurl/lib/curlx.h	2021-02-11 18:43:33.722517857 +0330
@@ -57,7 +57,7 @@
 /* "curl_multibyte.h" provides these functions and macros:
 
   curlx_convert_UTF8_to_wchar()
-  curlx_convert_wchar_to_UTF8()
+  curlx_convert_charo_UTF8()
   curlx_convert_UTF8_to_tchar()
   curlx_convert_tchar_to_UTF8()
   curlx_unicodefree()
diff -urp a/Utilities/cmcurl/lib/idn_win32.c b/Utilities/cmcurl/lib/idn_win32.c
--- a/Utilities/cmcurl/lib/idn_win32.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmcurl/lib/idn_win32.c	2021-02-11 18:43:33.875853618 +0330
@@ -72,13 +72,13 @@ bool curl_win32_idn_to_ascii(const char
 {
   bool success = FALSE;
 
-  wchar_t *in_w = curlx_convert_UTF8_to_wchar(in);
+  char *in_w = curlx_convert_UTF8_to_wchar(in);
   if(in_w) {
-    wchar_t punycode[IDN_MAX_LENGTH];
+    char punycode[IDN_MAX_LENGTH];
     int chars = IdnToAscii(0, in_w, -1, punycode, IDN_MAX_LENGTH);
     free(in_w);
     if(chars) {
-      *out = curlx_convert_wchar_to_UTF8(punycode);
+      *out = curlx_convert_charo_UTF8(punycode);
       if(*out)
         success = TRUE;
     }
@@ -91,15 +91,15 @@ bool curl_win32_ascii_to_idn(const char
 {
   bool success = FALSE;
 
-  wchar_t *in_w = curlx_convert_UTF8_to_wchar(in);
+  char *in_w = curlx_convert_UTF8_to_wchar(in);
   if(in_w) {
     size_t in_len = wcslen(in_w) + 1;
-    wchar_t unicode[IDN_MAX_LENGTH];
+    char unicode[IDN_MAX_LENGTH];
     int chars = IdnToUnicode(0, in_w, curlx_uztosi(in_len),
                              unicode, IDN_MAX_LENGTH);
     free(in_w);
     if(chars) {
-      *out = curlx_convert_wchar_to_UTF8(unicode);
+      *out = curlx_convert_charo_UTF8(unicode);
       if(*out)
         success = TRUE;
     }
diff -urp a/Utilities/cmcurl/lib/memdebug.c b/Utilities/cmcurl/lib/memdebug.c
--- a/Utilities/cmcurl/lib/memdebug.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmcurl/lib/memdebug.c	2021-02-11 18:43:33.732518016 +0330
@@ -238,9 +238,9 @@ char *curl_dbg_strdup(const char *str, i
 }
 
 #if defined(WIN32) && defined(UNICODE)
-wchar_t *curl_dbg_wcsdup(const wchar_t *str, int line, const char *source)
+char *curl_dbg_wcsdup(const char *str, int line, const char *source)
 {
-  wchar_t *mem;
+  char *mem;
   size_t wsiz, bsiz;
 
   DEBUGASSERT(str != NULL);
@@ -249,7 +249,7 @@ wchar_t *curl_dbg_wcsdup(const wchar_t *
     return NULL;
 
   wsiz = wcslen(str) + 1;
-  bsiz = wsiz * sizeof(wchar_t);
+  bsiz = wsiz * sizeof(char);
 
   mem = curl_dbg_malloc(bsiz, 0, NULL); /* NULL prevents logging */
   if(mem)
diff -urp a/Utilities/cmcurl/lib/memdebug.h b/Utilities/cmcurl/lib/memdebug.h
--- a/Utilities/cmcurl/lib/memdebug.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmcurl/lib/memdebug.h	2021-02-11 18:43:33.832519600 +0330
@@ -41,7 +41,7 @@ CURL_EXTERN void *curl_dbg_realloc(void
 CURL_EXTERN void curl_dbg_free(void *ptr, int line, const char *source);
 CURL_EXTERN char *curl_dbg_strdup(const char *str, int line, const char *src);
 #if defined(WIN32) && defined(UNICODE)
-CURL_EXTERN wchar_t *curl_dbg_wcsdup(const wchar_t *str, int line,
+CURL_EXTERN char *curl_dbg_wcsdup(const char *str, int line,
                                      const char *source);
 #endif
 
diff -urp a/Utilities/cmcurl/lib/setup-win32.h b/Utilities/cmcurl/lib/setup-win32.h
--- a/Utilities/cmcurl/lib/setup-win32.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmcurl/lib/setup-win32.h	2021-02-11 18:43:33.872520232 +0330
@@ -54,7 +54,7 @@
 #  endif
 #  include <tchar.h>
 #  ifdef UNICODE
-     typedef wchar_t *(*curl_wcsdup_callback)(const wchar_t *str);
+     typedef char *(*curl_wcsdup_callback)(const char *str);
 #  endif
 #endif
 
diff -urp a/Utilities/cmcurl/lib/strerror.c b/Utilities/cmcurl/lib/strerror.c
--- a/Utilities/cmcurl/lib/strerror.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmcurl/lib/strerror.c	2021-02-11 18:43:33.752518332 +0330
@@ -660,12 +660,12 @@ get_winapi_error(int err, char *buf, siz
 
 #ifdef _WIN32_WCE
   {
-    wchar_t wbuf[256];
+    char wbuf[256];
     wbuf[0] = L'\0';
 
     if(FormatMessage((FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_IGNORE_INSERTS), NULL, err,
-                     LANG_NEUTRAL, wbuf, sizeof(wbuf)/sizeof(wchar_t), NULL)) {
+                     LANG_NEUTRAL, wbuf, sizeof(wbuf)/sizeof(char), NULL)) {
       size_t written = wcstombs(buf, wbuf, buflen - 1);
       if(written != (size_t)-1)
         buf[written] = '\0';
diff -urp a/Utilities/cmcurl/lib/system_win32.c b/Utilities/cmcurl/lib/system_win32.c
--- a/Utilities/cmcurl/lib/system_win32.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmcurl/lib/system_win32.c	2021-02-11 18:43:33.832519600 +0330
@@ -152,7 +152,7 @@ typedef HMODULE (APIENTRY *LOADLIBRARYEX
 /* See function definitions in winbase.h */
 #ifdef UNICODE
 #  ifdef _WIN32_WCE
-#    define LOADLIBARYEX  L"LoadLibraryExW"
+#    define LOADLIBARYEX  "LoadLibraryExW"
 #  else
 #    define LOADLIBARYEX  "LoadLibraryExW"
 #  endif
diff -urp a/Utilities/cmcurl/lib/vtls/schannel.c b/Utilities/cmcurl/lib/vtls/schannel.c
--- a/Utilities/cmcurl/lib/vtls/schannel.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmcurl/lib/vtls/schannel.c	2021-02-11 18:43:33.765851877 +0330
@@ -70,7 +70,7 @@
 #endif
 
 #ifndef UNISP_NAME_W
-#define UNISP_NAME_W L"Microsoft Unified Security Protocol Provider"
+#define UNISP_NAME_W "Microsoft Unified Security Protocol Provider"
 #endif
 
 #ifndef UNISP_NAME
diff -urp a/Utilities/cmcurl/lib/vtls/schannel_verify.c b/Utilities/cmcurl/lib/vtls/schannel_verify.c
--- a/Utilities/cmcurl/lib/vtls/schannel_verify.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmcurl/lib/vtls/schannel_verify.c	2021-02-11 18:43:33.769185263 +0330
@@ -384,7 +384,7 @@ static DWORD cert_get_name_string(struct
   /* Iterate over the alternate names and populate host_names. */
   for(i = 0; i < alt_name_info->cAltEntry; i++) {
     const CERT_ALT_NAME_ENTRY *entry = &alt_name_info->rgAltEntry[i];
-    wchar_t *dns_w = NULL;
+    char *dns_w = NULL;
     size_t current_length = 0;
 
     if(entry->dwAltNameChoice != CERT_ALT_NAME_DNS_NAME) {
diff -urp a/Utilities/cmexpat/lib/expat_external.h b/Utilities/cmexpat/lib/expat_external.h
--- a/Utilities/cmexpat/lib/expat_external.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmexpat/lib/expat_external.h	2021-02-11 18:43:34.099190481 +0330
@@ -129,14 +129,14 @@ extern "C" {
 #    define XML_UNICODE
 #  endif
 #  if defined(__SIZEOF_WCHAR_T__) && (__SIZEOF_WCHAR_T__ != 2)
-#    error "sizeof(wchar_t) != 2; Need -fshort-wchar for both Expat and libc"
+#    error "sizeof(char) != 2; Need -fshort-wchar for both Expat and libc"
 #  endif
 #endif
 
 #ifdef XML_UNICODE /* Information is UTF-16 encoded. */
 #  ifdef XML_UNICODE_WCHAR_T
-typedef wchar_t XML_Char;
-typedef wchar_t XML_LChar;
+typedef char XML_Char;
+typedef char XML_LChar;
 #  else
 typedef unsigned short XML_Char;
 typedef char XML_LChar;
diff -urp a/Utilities/cmexpat/lib/xmlparse.c b/Utilities/cmexpat/lib/xmlparse.c
--- a/Utilities/cmexpat/lib/xmlparse.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmexpat/lib/xmlparse.c	2021-02-11 18:43:34.095857094 +0330
@@ -157,7 +157,7 @@ typedef char ICHAR;
 #ifdef XML_UNICODE
 
 #  ifdef XML_UNICODE_WCHAR_T
-#    define XML_T(x) (const wchar_t) x
+#    define XML_T(x) (const char) x
 #    define XML_L(x) L##x
 #  else
 #    define XML_T(x) (const unsigned short)x
diff -urp a/Utilities/cmexpat/README.md b/Utilities/cmexpat/README.md
--- a/Utilities/cmexpat/README.md	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmexpat/README.md	2021-02-11 18:43:34.062523237 +0330
@@ -99,7 +99,7 @@ support this mode of compilation (yet):
 1. For UTF-16 output as unsigned short (and version/error strings as char),
    run:<br/>
    `./configure CPPFLAGS=-DXML_UNICODE --without-xmlwf`<br/>
-   For UTF-16 output as `wchar_t` (incl. version/error strings), run:<br/>
+   For UTF-16 output as `char` (incl. version/error strings), run:<br/>
    `./configure CFLAGS="-g -O2 -fshort-wchar" CPPFLAGS=-DXML_UNICODE_WCHAR_T
        --without-xmlwf`
    <br/>Note: The latter requires libc compiled with `-fshort-wchar`, as well.
@@ -165,7 +165,7 @@ EXPAT_BUILD_TESTS:BOOL=ON
 // build the xmlwf tool for expat library
 EXPAT_BUILD_TOOLS:BOOL=ON
 
-// Character type to use (char|ushort|wchar_t) [default=char]
+// Character type to use (char|ushort|char) [default=char]
 EXPAT_CHAR_TYPE:STRING=char
 
 // install expat files in cmake install target
diff -urp a/Utilities/cmlibarchive/build/cmake/config.h.in b/Utilities/cmlibarchive/build/cmake/config.h.in
--- a/Utilities/cmlibarchive/build/cmake/config.h.in	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/build/cmake/config.h.in	2021-02-12 14:39:59.857852509 +0330
@@ -931,7 +931,7 @@
 /* Define to 1 if you have the <wchar.h> header file. */
 #cmakedefine HAVE_WCHAR_H 1
 
-/* Define to 1 if the system has the type `wchar_t'. */
+/* Define to 1 if the system has the type `char'. */
 #cmakedefine HAVE_WCHAR_T 1
 
 /* Define to 1 if you have the `wcrtomb' function. */
@@ -1027,7 +1027,7 @@
 /* Define to 1 if your C compiler doesn't accept -c and -o together. */
 #cmakedefine NO_MINUS_C_MINUS_O 1
 
-/* The size of `wchar_t', as computed by sizeof. */
+/* The size of `char', as computed by sizeof. */
 #cmakedefine SIZEOF_WCHAR_T ${SIZEOF_WCHAR_T}
 
 /* Define to 1 if strerror_r returns char *. */
diff -urp a/Utilities/cmlibarchive/CMakeLists.txt b/Utilities/cmlibarchive/CMakeLists.txt
--- a/Utilities/cmlibarchive/CMakeLists.txt	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/CMakeLists.txt	2021-02-12 14:39:59.857852509 +0330
@@ -1612,7 +1612,7 @@ IF(NOT HAVE_PID_T)
   ENDIF(WIN32)
 ENDIF(NOT HAVE_PID_T)
 #
-CHECK_TYPE_SIZE(wchar_t     SIZEOF_WCHAR_T)
+CHECK_TYPE_SIZE(char     SIZEOF_WCHAR_T)
 IF(HAVE_SIZEOF_WCHAR_T)
   SET(HAVE_WCHAR_T 1)
 ENDIF(HAVE_SIZEOF_WCHAR_T)
diff -urp a/Utilities/cmlibarchive/libarchive/archive_acl.c b/Utilities/cmlibarchive/libarchive/archive_acl.c
--- a/Utilities/cmlibarchive/libarchive/archive_acl.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_acl.c	2021-02-11 18:43:34.425862296 +0330
@@ -46,7 +46,7 @@ __FBSDID("$FreeBSD$");
 
 #ifndef HAVE_WMEMCMP
 /* Good enough for simple equality testing, but not for sorting. */
-#define wmemcmp(a,b,i)  memcmp((a), (b), (i) * sizeof(wchar_t))
+#define wmemcmp(a,b,i)  memcmp((a), (b), (i) * sizeof(char))
 #endif
 
 static int	acl_special(struct archive_acl *acl,
@@ -60,17 +60,17 @@ static int	archive_acl_text_want_type(st
 static ssize_t	archive_acl_text_len(struct archive_acl *acl, int want_type,
 		    int flags, int wide, struct archive *a,
 		    struct archive_string_conv *sc);
-static int	isint_w(const wchar_t *start, const wchar_t *end, int *result);
-static int	ismode_w(const wchar_t *start, const wchar_t *end, int *result);
-static int	is_nfs4_flags_w(const wchar_t *start, const wchar_t *end,
+static int	isint_w(const char *start, const char *end, int *result);
+static int	ismode_w(const char *start, const char *end, int *result);
+static int	is_nfs4_flags_w(const char *start, const char *end,
 		    int *result);
-static int	is_nfs4_perms_w(const wchar_t *start, const wchar_t *end,
+static int	is_nfs4_perms_w(const char *start, const char *end,
 		    int *result);
-static void	next_field_w(const wchar_t **wp, const wchar_t **start,
-		    const wchar_t **end, wchar_t *sep);
-static void	append_entry_w(wchar_t **wp, const wchar_t *prefix, int type,
-		    int tag, int flags, const wchar_t *wname, int perm, int id);
-static void	append_id_w(wchar_t **wp, int id);
+static void	next_field_w(const char **wp, const char **start,
+		    const char **end, char *sep);
+static void	append_entry_w(char **wp, const char *prefix, int type,
+		    int tag, int flags, const char *wname, int perm, int id);
+static void	append_id_w(char **wp, int id);
 static int	isint(const char *start, const char *end, int *result);
 static int	ismode(const char *start, const char *end, int *result);
 static int	is_nfs4_flags(const char *start, const char *end,
@@ -86,7 +86,7 @@ static void	append_id(char **p, int id);
 static const struct {
 	const int perm;
 	const char c;
-	const wchar_t wc;
+	const char wc;
 } nfsv4_acl_perm_map[] = {
 	{ ARCHIVE_ENTRY_ACL_READ_DATA | ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, 'r',
 	    L'r' },
@@ -113,7 +113,7 @@ static const int nfsv4_acl_perm_map_size
 static const struct {
 	const int perm;
 	const char c;
-	const wchar_t wc;
+	const char wc;
 } nfsv4_acl_flag_map[] = {
 	{ ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, 'f', L'f' },
 	{ ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, 'd', L'd' },
@@ -187,7 +187,7 @@ archive_acl_add_entry(struct archive_acl
 
 int
 archive_acl_add_entry_w_len(struct archive_acl *acl,
-    int type, int permset, int tag, int id, const wchar_t *name, size_t len)
+    int type, int permset, int tag, int id, const char *name, size_t len)
 {
 	struct archive_acl_entry *ap;
 
@@ -534,7 +534,7 @@ archive_acl_text_len(struct archive_acl
     int wide, struct archive *a, struct archive_string_conv *sc) {
 	struct archive_acl_entry *ap;
 	const char *name;
-	const wchar_t *wname;
+	const char *wname;
 	int count, idlen, tmp, r;
 	ssize_t length;
 	size_t len;
@@ -660,19 +660,19 @@ archive_acl_text_len(struct archive_acl
  * Generate a wide text version of the ACL. The flags parameter controls
  * the type and style of the generated ACL.
  */
-wchar_t *
+char *
 archive_acl_to_text_w(struct archive_acl *acl, ssize_t *text_len, int flags,
     struct archive *a)
 {
 	int count;
 	ssize_t length;
 	size_t len;
-	const wchar_t *wname;
-	const wchar_t *prefix;
-	wchar_t separator;
+	const char *wname;
+	const char *prefix;
+	char separator;
 	struct archive_acl_entry *ap;
 	int id, r, want_type;
-	wchar_t *wp, *ws;
+	char *wp, *ws;
 
 	want_type = archive_acl_text_want_type(acl, flags);
 
@@ -694,7 +694,7 @@ archive_acl_to_text_w(struct archive_acl
 		separator = L'\n';
 
 	/* Now, allocate the string and actually populate it. */
-	wp = ws = (wchar_t *)malloc(length * sizeof(wchar_t));
+	wp = ws = (char *)malloc(length * sizeof(char));
 	if (wp == NULL) {
 		if (errno == ENOMEM)
 			__archive_errx(1, "No memory");
@@ -731,7 +731,7 @@ archive_acl_to_text_w(struct archive_acl
 			continue;
 		if (ap->type == ARCHIVE_ENTRY_ACL_TYPE_DEFAULT &&
 		    (flags & ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT) != 0)
-			prefix = L"default:";
+			prefix = "default:";
 		else
 			prefix = NULL;
 		r = archive_mstring_get_wcs(a, &ap->name, &wname);
@@ -766,18 +766,18 @@ archive_acl_to_text_w(struct archive_acl
 }
 
 static void
-append_id_w(wchar_t **wp, int id)
+append_id_w(char **wp, int id)
 {
 	if (id < 0)
 		id = 0;
 	if (id > 9)
 		append_id_w(wp, id / 10);
-	*(*wp)++ = L"0123456789"[id % 10];
+	*(*wp)++ = "0123456789"[id % 10];
 }
 
 static void
-append_entry_w(wchar_t **wp, const wchar_t *prefix, int type,
-    int tag, int flags, const wchar_t *wname, int perm, int id)
+append_entry_w(char **wp, const char *prefix, int type,
+    int tag, int flags, const char *wname, int perm, int id)
 {
 	int i;
 
@@ -790,36 +790,36 @@ append_entry_w(wchar_t **wp, const wchar
 		wname = NULL;
 		id = -1;
 		if ((type & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {
-			wcscpy(*wp, L"owner@");
+			wcscpy(*wp, "owner@");
 			break;
 		}
 		/* FALLTHROUGH */
 	case ARCHIVE_ENTRY_ACL_USER:
-		wcscpy(*wp, L"user");
+		wcscpy(*wp, "user");
 		break;
 	case ARCHIVE_ENTRY_ACL_GROUP_OBJ:
 		wname = NULL;
 		id = -1;
 		if ((type & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {
-			wcscpy(*wp, L"group@");
+			wcscpy(*wp, "group@");
 			break;
 		}
 		/* FALLTHROUGH */
 	case ARCHIVE_ENTRY_ACL_GROUP:
-		wcscpy(*wp, L"group");
+		wcscpy(*wp, "group");
 		break;
 	case ARCHIVE_ENTRY_ACL_MASK:
-		wcscpy(*wp, L"mask");
+		wcscpy(*wp, "mask");
 		wname = NULL;
 		id = -1;
 		break;
 	case ARCHIVE_ENTRY_ACL_OTHER:
-		wcscpy(*wp, L"other");
+		wcscpy(*wp, "other");
 		wname = NULL;
 		id = -1;
 		break;
 	case ARCHIVE_ENTRY_ACL_EVERYONE:
-		wcscpy(*wp, L"everyone@");
+		wcscpy(*wp, "everyone@");
 		wname = NULL;
 		id = -1;
 		break;
@@ -867,16 +867,16 @@ append_entry_w(wchar_t **wp, const wchar
 		*(*wp)++ = L':';
 		switch (type) {
 		case ARCHIVE_ENTRY_ACL_TYPE_ALLOW:
-			wcscpy(*wp, L"allow");
+			wcscpy(*wp, "allow");
 			break;
 		case ARCHIVE_ENTRY_ACL_TYPE_DENY:
-			wcscpy(*wp, L"deny");
+			wcscpy(*wp, "deny");
 			break;
 		case ARCHIVE_ENTRY_ACL_TYPE_AUDIT:
-			wcscpy(*wp, L"audit");
+			wcscpy(*wp, "audit");
 			break;
 		case ARCHIVE_ENTRY_ACL_TYPE_ALARM:
-			wcscpy(*wp, L"alarm");
+			wcscpy(*wp, "alarm");
 			break;
 		default:
 			break;
@@ -1134,20 +1134,20 @@ append_entry(char **p, const char *prefi
  * ARCHIVE_ENTRY_ACL_TYPE_DEFAULT unless type is ARCHIVE_ENTRY_ACL_TYPE_NFS4
  */
 int
-archive_acl_from_text_w(struct archive_acl *acl, const wchar_t *text,
+archive_acl_from_text_w(struct archive_acl *acl, const char *text,
     int want_type)
 {
 	struct {
-		const wchar_t *start;
-		const wchar_t *end;
+		const char *start;
+		const char *end;
 	} field[6], name;
 
-	const wchar_t *s, *st;
+	const char *s, *st;
 
 	int numfields, fields, n, r, sol, ret;
 	int type, types, tag, permset, id;
 	size_t len;
-	wchar_t sep;
+	char sep;
 
 	ret = ARCHIVE_OK;
 	types = 0;
@@ -1174,7 +1174,7 @@ archive_acl_from_text_w(struct archive_a
 		 */
 		fields = 0;
 		do {
-			const wchar_t *start, *end;
+			const char *start, *end;
 			next_field_w(&text, &start, &end, &sep);
 			if (fields < numfields) {
 				field[fields].start = start;
@@ -1211,7 +1211,7 @@ archive_acl_from_text_w(struct archive_a
 			s = field[0].start;
 			len = field[0].end - field[0].start;
 			if (*s == L'd' && (len == 1 || (len >= 7
-			    && wmemcmp((s + 1), L"efault", 6) == 0))) {
+			    && wmemcmp((s + 1), "efault", 6) == 0))) {
 				type = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;
 				if (len > 7)
 					field[0].start += 7;
@@ -1235,22 +1235,22 @@ archive_acl_from_text_w(struct archive_a
 			switch (*s) {
 			case L'u':
 				if (len == 1 || (len == 4
-				    && wmemcmp(st, L"ser", 3) == 0))
+				    && wmemcmp(st, "ser", 3) == 0))
 					tag = ARCHIVE_ENTRY_ACL_USER_OBJ;
 				break;
 			case L'g':
 				if (len == 1 || (len == 5
-				    && wmemcmp(st, L"roup", 4) == 0))
+				    && wmemcmp(st, "roup", 4) == 0))
 					tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;
 				break;
 			case L'o':
 				if (len == 1 || (len == 5
-				    && wmemcmp(st, L"ther", 4) == 0))
+				    && wmemcmp(st, "ther", 4) == 0))
 					tag = ARCHIVE_ENTRY_ACL_OTHER;
 				break;
 			case L'm':
 				if (len == 1 || (len == 4
-				    && wmemcmp(st, L"ask", 3) == 0))
+				    && wmemcmp(st, "ask", 3) == 0))
 					tag = ARCHIVE_ENTRY_ACL_MASK;
 				break;
 			default:
@@ -1308,21 +1308,21 @@ archive_acl_from_text_w(struct archive_a
 
 			switch (len) {
 			case 4:
-				if (wmemcmp(s, L"user", 4) == 0)
+				if (wmemcmp(s, "user", 4) == 0)
 					tag = ARCHIVE_ENTRY_ACL_USER;
 				break;
 			case 5:
-				if (wmemcmp(s, L"group", 5) == 0)
+				if (wmemcmp(s, "group", 5) == 0)
 					tag = ARCHIVE_ENTRY_ACL_GROUP;
 				break;
 			case 6:
-				if (wmemcmp(s, L"owner@", 6) == 0)
+				if (wmemcmp(s, "owner@", 6) == 0)
 					tag = ARCHIVE_ENTRY_ACL_USER_OBJ;
-				else if (wmemcmp(s, L"group@", len) == 0)
+				else if (wmemcmp(s, "group@", len) == 0)
 					tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;
 				break;
 			case 9:
-				if (wmemcmp(s, L"everyone@", 9) == 0)
+				if (wmemcmp(s, "everyone@", 9) == 0)
 					tag = ARCHIVE_ENTRY_ACL_EVERYONE;
 			default:
 				break;
@@ -1356,14 +1356,14 @@ archive_acl_from_text_w(struct archive_a
 			len = field[3 + n].end - field[3 + n].start;
 			type = 0;
 			if (len == 4) {
-				if (wmemcmp(s, L"deny", 4) == 0)
+				if (wmemcmp(s, "deny", 4) == 0)
 					type = ARCHIVE_ENTRY_ACL_TYPE_DENY;
 			} else if (len == 5) {
-				if (wmemcmp(s, L"allow", 5) == 0)
+				if (wmemcmp(s, "allow", 5) == 0)
 					type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;
-				else if (wmemcmp(s, L"audit", 5) == 0)
+				else if (wmemcmp(s, "audit", 5) == 0)
 					type = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;
-				else if (wmemcmp(s, L"alarm", 5) == 0)
+				else if (wmemcmp(s, "alarm", 5) == 0)
 					type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;
 			}
 			if (type == 0) {
@@ -1396,7 +1396,7 @@ archive_acl_from_text_w(struct archive_a
  * false otherwise.
  */
 static int
-isint_w(const wchar_t *start, const wchar_t *end, int *result)
+isint_w(const char *start, const char *end, int *result)
 {
 	int n = 0;
 	if (start >= end)
@@ -1423,9 +1423,9 @@ isint_w(const wchar_t *start, const wcha
  * false otherwise.
  */
 static int
-ismode_w(const wchar_t *start, const wchar_t *end, int *permset)
+ismode_w(const char *start, const char *end, int *permset)
 {
-	const wchar_t *p;
+	const char *p;
 
 	if (start >= end)
 		return (0);
@@ -1457,9 +1457,9 @@ ismode_w(const wchar_t *start, const wch
  * permission characters, false otherwise
  */
 static int
-is_nfs4_perms_w(const wchar_t *start, const wchar_t *end, int *permset)
+is_nfs4_perms_w(const char *start, const char *end, int *permset)
 {
-	const wchar_t *p = start;
+	const char *p = start;
 
 	while (p < end) {
 		switch (*p++) {
@@ -1520,9 +1520,9 @@ is_nfs4_perms_w(const wchar_t *start, co
  * flag characters, false otherwise
  */
 static int
-is_nfs4_flags_w(const wchar_t *start, const wchar_t *end, int *permset)
+is_nfs4_flags_w(const char *start, const char *end, int *permset)
 {
-	const wchar_t *p = start;
+	const char *p = start;
 
 	while (p < end) {
 		switch(*p++) {
@@ -1566,8 +1566,8 @@ is_nfs4_flags_w(const wchar_t *start, co
  * whitespace.
  */
 static void
-next_field_w(const wchar_t **wp, const wchar_t **start,
-    const wchar_t **end, wchar_t *sep)
+next_field_w(const char **wp, const char **start,
+    const char **end, char *sep)
 {
 	/* Skip leading whitespace to find start of field. */
 	while (**wp == L' ' || **wp == L'\t' || **wp == L'\n') {
diff -urp a/Utilities/cmlibarchive/libarchive/archive_acl_private.h b/Utilities/cmlibarchive/libarchive/archive_acl_private.h
--- a/Utilities/cmlibarchive/libarchive/archive_acl_private.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_acl_private.h	2021-02-11 18:43:34.392528437 +0330
@@ -48,7 +48,7 @@ struct archive_acl {
 	struct archive_acl_entry	*acl_head;
 	struct archive_acl_entry	*acl_p;
 	int		 acl_state;	/* See acl_next for details. */
-	wchar_t		*acl_text_w;
+	char		*acl_text_w;
 	char		*acl_text;
 	int		 acl_types;
 };
@@ -63,11 +63,11 @@ int archive_acl_next(struct archive *, s
 
 int archive_acl_add_entry(struct archive_acl *, int, int, int, int, const char *);
 int archive_acl_add_entry_w_len(struct archive_acl *,
-    int, int, int, int, const wchar_t *, size_t);
+    int, int, int, int, const char *, size_t);
 int archive_acl_add_entry_len(struct archive_acl *,
     int, int, int, int, const char *, size_t);
 
-wchar_t *archive_acl_to_text_w(struct archive_acl *, ssize_t *, int,
+char *archive_acl_to_text_w(struct archive_acl *, ssize_t *, int,
     struct archive *);
 char *archive_acl_to_text_l(struct archive_acl *, ssize_t *, int,
     struct archive_string_conv *);
@@ -75,7 +75,7 @@ char *archive_acl_to_text_l(struct archi
 /*
  * ACL text parser.
  */
-int archive_acl_from_text_w(struct archive_acl *, const wchar_t * /* wtext */,
+int archive_acl_from_text_w(struct archive_acl *, const char * /* wtext */,
     int /* type */);
 int archive_acl_from_text_l(struct archive_acl *, const char * /* text */,
     int /* type */, struct archive_string_conv *);
diff -urp a/Utilities/cmlibarchive/libarchive/archive_entry_acl.3 b/Utilities/cmlibarchive/libarchive/archive_entry_acl.3
--- a/Utilities/cmlibarchive/libarchive/archive_entry_acl.3	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_entry_acl.3	2021-02-11 18:43:34.399195209 +0330
@@ -59,7 +59,7 @@ Streaming Archive Library (libarchive, -
 .Fa "int permset"
 .Fa "int tag"
 .Fa "int qualifier"
-.Fa "const wchar_t *name"
+.Fa "const char *name"
 .Fc
 .Ft void
 .Fn archive_entry_acl_clear "struct archive_entry *a"
@@ -74,7 +74,7 @@ Streaming Archive Library (libarchive, -
 .Ft int
 .Fo archive_entry_acl_from_text_w
 .Fa "struct archive_entry *a"
-.Fa "const wchar_t *text"
+.Fa "const char *text"
 .Fa "int type"
 .Fc
 .Ft int
@@ -95,7 +95,7 @@ Streaming Archive Library (libarchive, -
 .Fa "ssize_t *len_p"
 .Fa "int flags"
 .Fc
-.Ft wchar_t *
+.Ft char *
 .Fo archive_entry_acl_to_text_w
 .Fa "struct archive_entry *a"
 .Fa "ssize_t *len_p"
diff -urp a/Utilities/cmlibarchive/libarchive/archive_entry.c b/Utilities/cmlibarchive/libarchive/archive_entry.c
--- a/Utilities/cmlibarchive/libarchive/archive_entry.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_entry.c	2021-02-11 18:43:34.392528437 +0330
@@ -117,24 +117,24 @@ __FBSDID("$FreeBSD: head/lib/libarchive/
 	} while (0)
 
 static char *	 ae_fflagstostr(unsigned long bitset, unsigned long bitclear);
-static const wchar_t	*ae_wcstofflags(const wchar_t *stringp,
+static const char	*ae_wcstofflags(const char *stringp,
 		    unsigned long *setp, unsigned long *clrp);
 static const char	*ae_strtofflags(const char *stringp,
 		    unsigned long *setp, unsigned long *clrp);
 
 #ifndef HAVE_WCSCPY
-static wchar_t * wcscpy(wchar_t *s1, const wchar_t *s2)
+static char * wcscpy(char *s1, const char *s2)
 {
-	wchar_t *dest = s1;
+	char *dest = s1;
 	while ((*s1 = *s2) != L'\0')
 		++s1, ++s2;
 	return dest;
 }
 #endif
 #ifndef HAVE_WCSLEN
-static size_t wcslen(const wchar_t *s)
+static size_t wcslen(const char *s)
 {
-	const wchar_t *p = s;
+	const char *p = s;
 	while (*p != L'\0')
 		++p;
 	return p - s;
@@ -142,7 +142,7 @@ static size_t wcslen(const wchar_t *s)
 #endif
 #ifndef HAVE_WMEMCMP
 /* Good enough for simple equality testing, but not for sorting. */
-#define wmemcmp(a,b,i)  memcmp((a), (b), (i) * sizeof(wchar_t))
+#define wmemcmp(a,b,i)  memcmp((a), (b), (i) * sizeof(char))
 #endif
 
 /****************************************************************************
@@ -435,10 +435,10 @@ archive_entry_gname_utf8(struct archive_
 }
 
 
-const wchar_t *
+const char *
 archive_entry_gname_w(struct archive_entry *entry)
 {
-	const wchar_t *p;
+	const char *p;
 	if (archive_mstring_get_wcs(entry->archive, &entry->ae_gname, &p) == 0)
 		return (p);
 	if (errno == ENOMEM)
@@ -481,10 +481,10 @@ archive_entry_hardlink_utf8(struct archi
 	return (NULL);
 }
 
-const wchar_t *
+const char *
 archive_entry_hardlink_w(struct archive_entry *entry)
 {
-	const wchar_t *p;
+	const char *p;
 	if ((entry->ae_set & AE_SET_HARDLINK) == 0)
 		return (NULL);
 	if (archive_mstring_get_wcs(
@@ -579,10 +579,10 @@ archive_entry_pathname_utf8(struct archi
 	return (NULL);
 }
 
-const wchar_t *
+const char *
 archive_entry_pathname_w(struct archive_entry *entry)
 {
-	const wchar_t *p;
+	const char *p;
 	if (archive_mstring_get_wcs(
 	    entry->archive, &entry->ae_pathname, &p) == 0)
 		return (p);
@@ -656,10 +656,10 @@ archive_entry_sourcepath(struct archive_
 	return (NULL);
 }
 
-const wchar_t *
+const char *
 archive_entry_sourcepath_w(struct archive_entry *entry)
 {
-	const wchar_t *p;
+	const char *p;
 	if (archive_mstring_get_wcs(
 	    entry->archive, &entry->ae_sourcepath, &p) == 0)
 		return (p);
@@ -700,10 +700,10 @@ archive_entry_symlink_utf8(struct archiv
 	return (NULL);
 }
 
-const wchar_t *
+const char *
 archive_entry_symlink_w(struct archive_entry *entry)
 {
-	const wchar_t *p;
+	const char *p;
 	if ((entry->ae_set & AE_SET_SYMLINK) == 0)
 		return (NULL);
 	if (archive_mstring_get_wcs(
@@ -754,10 +754,10 @@ archive_entry_uname_utf8(struct archive_
 	return (NULL);
 }
 
-const wchar_t *
+const char *
 archive_entry_uname_w(struct archive_entry *entry)
 {
-	const wchar_t *p;
+	const char *p;
 	if (archive_mstring_get_wcs(entry->archive, &entry->ae_uname, &p) == 0)
 		return (p);
 	if (errno == ENOMEM)
@@ -820,9 +820,9 @@ archive_entry_copy_fflags_text(struct ar
 		    &entry->ae_fflags_set, &entry->ae_fflags_clear));
 }
 
-const wchar_t *
+const char *
 archive_entry_copy_fflags_text_w(struct archive_entry *entry,
-    const wchar_t *flags)
+    const char *flags)
 {
 	archive_mstring_copy_wcs(&entry->ae_fflags_text, flags);
 	return (ae_wcstofflags(flags,
@@ -855,7 +855,7 @@ archive_entry_copy_gname(struct archive_
 }
 
 void
-archive_entry_copy_gname_w(struct archive_entry *entry, const wchar_t *name)
+archive_entry_copy_gname_w(struct archive_entry *entry, const char *name)
 {
 	archive_mstring_copy_wcs(&entry->ae_gname, name);
 }
@@ -925,7 +925,7 @@ archive_entry_copy_hardlink(struct archi
 }
 
 void
-archive_entry_copy_hardlink_w(struct archive_entry *entry, const wchar_t *target)
+archive_entry_copy_hardlink_w(struct archive_entry *entry, const char *target)
 {
 	archive_mstring_copy_wcs(&entry->ae_hardlink, target);
 	if (target != NULL)
@@ -1073,7 +1073,7 @@ archive_entry_copy_link(struct archive_e
 
 /* Set symlink if symlink is already set, else set hardlink. */
 void
-archive_entry_copy_link_w(struct archive_entry *entry, const wchar_t *target)
+archive_entry_copy_link_w(struct archive_entry *entry, const char *target)
 {
 	if (entry->ae_set & AE_SET_SYMLINK)
 		archive_mstring_copy_wcs(&entry->ae_symlink, target);
@@ -1163,7 +1163,7 @@ archive_entry_copy_pathname(struct archi
 }
 
 void
-archive_entry_copy_pathname_w(struct archive_entry *entry, const wchar_t *name)
+archive_entry_copy_pathname_w(struct archive_entry *entry, const char *name)
 {
 	archive_mstring_copy_wcs(&entry->ae_pathname, name);
 }
@@ -1241,7 +1241,7 @@ archive_entry_copy_sourcepath(struct arc
 }
 
 void
-archive_entry_copy_sourcepath_w(struct archive_entry *entry, const wchar_t *path)
+archive_entry_copy_sourcepath_w(struct archive_entry *entry, const char *path)
 {
 	archive_mstring_copy_wcs(&entry->ae_sourcepath, path);
 }
@@ -1283,7 +1283,7 @@ archive_entry_copy_symlink(struct archiv
 }
 
 void
-archive_entry_copy_symlink_w(struct archive_entry *entry, const wchar_t *linkname)
+archive_entry_copy_symlink_w(struct archive_entry *entry, const char *linkname)
 {
 	archive_mstring_copy_wcs(&entry->ae_symlink, linkname);
 	if (linkname != NULL)
@@ -1348,7 +1348,7 @@ archive_entry_copy_uname(struct archive_
 }
 
 void
-archive_entry_copy_uname_w(struct archive_entry *entry, const wchar_t *name)
+archive_entry_copy_uname_w(struct archive_entry *entry, const char *name)
 {
 	archive_mstring_copy_wcs(&entry->ae_uname, name);
 }
@@ -1452,7 +1452,7 @@ archive_entry_acl_add_entry(struct archi
  */
 int
 archive_entry_acl_add_entry_w(struct archive_entry *entry,
-    int type, int permset, int tag, int id, const wchar_t *name)
+    int type, int permset, int tag, int id, const char *name)
 {
 	return archive_acl_add_entry_w_len(&entry->acl,
 	    type, permset, tag, id, name, wcslen(name));
@@ -1507,7 +1507,7 @@ archive_entry_acl_next(struct archive_en
  * Generate a text version of the ACL. The flags parameter controls
  * the style of the generated ACL.
  */
-wchar_t *
+char *
 archive_entry_acl_to_text_w(struct archive_entry *entry, la_ssize_t *len,
     int flags)
 {
@@ -1534,7 +1534,7 @@ _archive_entry_acl_to_text_l(struct arch
  */
 int
 archive_entry_acl_from_text_w(struct archive_entry *entry,
-    const wchar_t *wtext, int type)
+    const char *wtext, int type)
 {
 	return (archive_acl_from_text_w(&entry->acl, wtext, type));
 }
@@ -1574,7 +1574,7 @@ archive_entry_acl_text_compat(int *flags
 }
 
 /* Deprecated */
-const wchar_t *
+const char *
 archive_entry_acl_text_w(struct archive_entry *entry, int flags)
 {
 	free(entry->acl.acl_text_w);
@@ -1696,166 +1696,166 @@ _archive_entry_acl_text_l(struct archive
 
 static const struct flag {
 	const char	*name;
-	const wchar_t	*wname;
+	const char	*wname;
 	unsigned long	 set;
 	unsigned long	 clear;
 } fileflags[] = {
 	/* Preferred (shorter) names per flag first, all prefixed by "no" */
 #ifdef SF_APPEND
-	{ "nosappnd",	L"nosappnd",		SF_APPEND,	0},
-	{ "nosappend",	L"nosappend",		SF_APPEND,	0},
+	{ "nosappnd",	"nosappnd",		SF_APPEND,	0},
+	{ "nosappend",	"nosappend",		SF_APPEND,	0},
 #endif
 #if defined(FS_APPEND_FL)			/* 'a' */
-	{ "nosappnd",	L"nosappnd",		FS_APPEND_FL,	0},
-	{ "nosappend",	L"nosappend",		FS_APPEND_FL,	0},
+	{ "nosappnd",	"nosappnd",		FS_APPEND_FL,	0},
+	{ "nosappend",	"nosappend",		FS_APPEND_FL,	0},
 #elif defined(EXT2_APPEND_FL)			/* 'a' */
-	{ "nosappnd",	L"nosappnd",		EXT2_APPEND_FL,	0},
-	{ "nosappend",	L"nosappend",		EXT2_APPEND_FL,	0},
+	{ "nosappnd",	"nosappnd",		EXT2_APPEND_FL,	0},
+	{ "nosappend",	"nosappend",		EXT2_APPEND_FL,	0},
 #endif
 #ifdef SF_ARCHIVED
-	{ "noarch",	L"noarch",		SF_ARCHIVED,	0},
-	{ "noarchived",	L"noarchived",       	SF_ARCHIVED,	0},
+	{ "noarch",	"noarch",		SF_ARCHIVED,	0},
+	{ "noarchived",	"noarchived",       	SF_ARCHIVED,	0},
 #endif
 #ifdef SF_IMMUTABLE
-	{ "noschg",	L"noschg",		SF_IMMUTABLE,	0},
-	{ "noschange",	L"noschange",		SF_IMMUTABLE,	0},
-	{ "nosimmutable",	L"nosimmutable",	SF_IMMUTABLE,	0},
+	{ "noschg",	"noschg",		SF_IMMUTABLE,	0},
+	{ "noschange",	"noschange",		SF_IMMUTABLE,	0},
+	{ "nosimmutable",	"nosimmutable",	SF_IMMUTABLE,	0},
 #endif
 #if defined(FS_IMMUTABLE_FL)			/* 'i' */
-	{ "noschg",	L"noschg",		FS_IMMUTABLE_FL,	0},
-	{ "noschange",	L"noschange",		FS_IMMUTABLE_FL,	0},
-	{ "nosimmutable",	L"nosimmutable",	FS_IMMUTABLE_FL,	0},
+	{ "noschg",	"noschg",		FS_IMMUTABLE_FL,	0},
+	{ "noschange",	"noschange",		FS_IMMUTABLE_FL,	0},
+	{ "nosimmutable",	"nosimmutable",	FS_IMMUTABLE_FL,	0},
 #elif defined(EXT2_IMMUTABLE_FL)		/* 'i' */
-	{ "noschg",	L"noschg",		EXT2_IMMUTABLE_FL,	0},
-	{ "noschange",	L"noschange",		EXT2_IMMUTABLE_FL,	0},
-	{ "nosimmutable",	L"nosimmutable",	EXT2_IMMUTABLE_FL,	0},
+	{ "noschg",	"noschg",		EXT2_IMMUTABLE_FL,	0},
+	{ "noschange",	"noschange",		EXT2_IMMUTABLE_FL,	0},
+	{ "nosimmutable",	"nosimmutable",	EXT2_IMMUTABLE_FL,	0},
 #endif
 #ifdef SF_NOUNLINK
-	{ "nosunlnk",	L"nosunlnk",		SF_NOUNLINK,	0},
-	{ "nosunlink",	L"nosunlink",		SF_NOUNLINK,	0},
+	{ "nosunlnk",	"nosunlnk",		SF_NOUNLINK,	0},
+	{ "nosunlink",	"nosunlink",		SF_NOUNLINK,	0},
 #endif
 #ifdef UF_APPEND
-	{ "nouappnd",	L"nouappnd",		UF_APPEND,	0},
-	{ "nouappend",	L"nouappend",		UF_APPEND,	0},
+	{ "nouappnd",	"nouappnd",		UF_APPEND,	0},
+	{ "nouappend",	"nouappend",		UF_APPEND,	0},
 #endif
 #ifdef UF_IMMUTABLE
-	{ "nouchg",	L"nouchg",		UF_IMMUTABLE,	0},
-	{ "nouchange",	L"nouchange",		UF_IMMUTABLE,	0},
-	{ "nouimmutable",	L"nouimmutable",	UF_IMMUTABLE,	0},
+	{ "nouchg",	"nouchg",		UF_IMMUTABLE,	0},
+	{ "nouchange",	"nouchange",		UF_IMMUTABLE,	0},
+	{ "nouimmutable",	"nouimmutable",	UF_IMMUTABLE,	0},
 #endif
 #ifdef UF_NODUMP
-	{ "nodump",	L"nodump",		0,		UF_NODUMP},
+	{ "nodump",	"nodump",		0,		UF_NODUMP},
 #endif
 #if defined(FS_NODUMP_FL)	/* 'd' */
-	{ "nodump",	L"nodump",		0,		FS_NODUMP_FL},
+	{ "nodump",	"nodump",		0,		FS_NODUMP_FL},
 #elif defined(EXT2_NODUMP_FL)
-	{ "nodump",	L"nodump",		0,		EXT2_NODUMP_FL},
+	{ "nodump",	"nodump",		0,		EXT2_NODUMP_FL},
 #endif
 #ifdef UF_OPAQUE
-	{ "noopaque",	L"noopaque",		UF_OPAQUE,	0},
+	{ "noopaque",	"noopaque",		UF_OPAQUE,	0},
 #endif
 #ifdef UF_NOUNLINK
-	{ "nouunlnk",	L"nouunlnk",		UF_NOUNLINK,	0},
-	{ "nouunlink",	L"nouunlink",		UF_NOUNLINK,	0},
+	{ "nouunlnk",	"nouunlnk",		UF_NOUNLINK,	0},
+	{ "nouunlink",	"nouunlink",		UF_NOUNLINK,	0},
 #endif
 #ifdef UF_COMPRESSED
 	/* Mac OS */
-	{ "nocompressed",	L"nocompressed",	UF_COMPRESSED,	0},
+	{ "nocompressed",	"nocompressed",	UF_COMPRESSED,	0},
 #endif
 #ifdef UF_HIDDEN
-	{ "nohidden",	L"nohidden",		UF_HIDDEN,	0},
-	{ "nouhidden",	L"nouhidden",		UF_HIDDEN,	0},
+	{ "nohidden",	"nohidden",		UF_HIDDEN,	0},
+	{ "nouhidden",	"nouhidden",		UF_HIDDEN,	0},
 #endif
 #ifdef FILE_ATTRIBUTE_HIDDEN
-	{ "nohidden",	L"nohidden",	FILE_ATTRIBUTE_HIDDEN,	0},
-	{ "nouhidden",	L"nouhidden",	FILE_ATTRIBUTE_HIDDEN,	0},
+	{ "nohidden",	"nohidden",	FILE_ATTRIBUTE_HIDDEN,	0},
+	{ "nouhidden",	"nouhidden",	FILE_ATTRIBUTE_HIDDEN,	0},
 #endif
 #ifdef UF_OFFLINE
-	{ "nooffline",	L"nooffline",		UF_OFFLINE,	0},
-	{ "nouoffline",	L"nouoffline",		UF_OFFLINE,	0},
+	{ "nooffline",	"nooffline",		UF_OFFLINE,	0},
+	{ "nouoffline",	"nouoffline",		UF_OFFLINE,	0},
 #endif
 #ifdef UF_READONLY
-	{ "nordonly",	L"nordonly",		UF_READONLY,	0},
-	{ "nourdonly",	L"nourdonly",		UF_READONLY,	0},
-	{ "noreadonly",	L"noreadonly",		UF_READONLY,	0},
+	{ "nordonly",	"nordonly",		UF_READONLY,	0},
+	{ "nourdonly",	"nourdonly",		UF_READONLY,	0},
+	{ "noreadonly",	"noreadonly",		UF_READONLY,	0},
 #endif
 #ifdef FILE_ATTRIBUTE_READONLY
-	{ "nordonly",	L"nordonly",	FILE_ATTRIBUTE_READONLY,	0},
-	{ "nourdonly",	L"nourdonly",	FILE_ATTRIBUTE_READONLY,	0},
-	{ "noreadonly",	L"noreadonly",	FILE_ATTRIBUTE_READONLY,	0},
+	{ "nordonly",	"nordonly",	FILE_ATTRIBUTE_READONLY,	0},
+	{ "nourdonly",	"nourdonly",	FILE_ATTRIBUTE_READONLY,	0},
+	{ "noreadonly",	"noreadonly",	FILE_ATTRIBUTE_READONLY,	0},
 #endif
 #ifdef UF_SPARSE
-	{ "nosparse",	L"nosparse",		UF_SPARSE,	0},
-	{ "nousparse",	L"nousparse",		UF_SPARSE,	0},
+	{ "nosparse",	"nosparse",		UF_SPARSE,	0},
+	{ "nousparse",	"nousparse",		UF_SPARSE,	0},
 #endif
 #ifdef UF_REPARSE
-	{ "noreparse",	L"noreparse",		UF_REPARSE,	0},
-	{ "noureparse",	L"noureparse",		UF_REPARSE,	0},
+	{ "noreparse",	"noreparse",		UF_REPARSE,	0},
+	{ "noureparse",	"noureparse",		UF_REPARSE,	0},
 #endif
 #ifdef UF_SYSTEM
-	{ "nosystem",	L"nosystem",		UF_SYSTEM,	0},
-	{ "nousystem",	L"nousystem",		UF_SYSTEM,	0},
+	{ "nosystem",	"nosystem",		UF_SYSTEM,	0},
+	{ "nousystem",	"nousystem",		UF_SYSTEM,	0},
 #endif
 #ifdef FILE_ATTRIBUTE_SYSTEM
-	{ "nosystem",	L"nosystem",	FILE_ATTRIBUTE_SYSTEM,	0},
-	{ "nousystem",	L"nousystem",	FILE_ATTRIBUTE_SYSTEM,	0},
+	{ "nosystem",	"nosystem",	FILE_ATTRIBUTE_SYSTEM,	0},
+	{ "nousystem",	"nousystem",	FILE_ATTRIBUTE_SYSTEM,	0},
 #endif
 #if defined(FS_UNRM_FL)		/* 'u' */
-	{ "noundel",	L"noundel",		FS_UNRM_FL,	0},
+	{ "noundel",	"noundel",		FS_UNRM_FL,	0},
 #elif defined(EXT2_UNRM_FL)
-	{ "noundel",	L"noundel",		EXT2_UNRM_FL,	0},
+	{ "noundel",	"noundel",		EXT2_UNRM_FL,	0},
 #endif
 
 #if defined(FS_COMPR_FL)	/* 'c' */
-	{ "nocompress",	L"nocompress",       	FS_COMPR_FL,	0},
+	{ "nocompress",	"nocompress",       	FS_COMPR_FL,	0},
 #elif defined(EXT2_COMPR_FL)
-	{ "nocompress",	L"nocompress",       	EXT2_COMPR_FL,	0},
+	{ "nocompress",	"nocompress",       	EXT2_COMPR_FL,	0},
 #endif
 
 #if defined(FS_NOATIME_FL)	/* 'A' */
-	{ "noatime",	L"noatime",		0,		FS_NOATIME_FL},
+	{ "noatime",	"noatime",		0,		FS_NOATIME_FL},
 #elif defined(EXT2_NOATIME_FL)
-	{ "noatime",	L"noatime",		0,		EXT2_NOATIME_FL},
+	{ "noatime",	"noatime",		0,		EXT2_NOATIME_FL},
 #endif
 #if defined(FS_DIRSYNC_FL)	/* 'D' */
-	{ "nodirsync",	L"nodirsync",		FS_DIRSYNC_FL,		0},
+	{ "nodirsync",	"nodirsync",		FS_DIRSYNC_FL,		0},
 #elif defined(EXT2_DIRSYNC_FL)
-	{ "nodirsync",	L"nodirsync",		EXT2_DIRSYNC_FL,	0},
+	{ "nodirsync",	"nodirsync",		EXT2_DIRSYNC_FL,	0},
 #endif
 #if defined(FS_JOURNAL_DATA_FL)	/* 'j' */
-	{ "nojournal-data",L"nojournal-data",	FS_JOURNAL_DATA_FL,	0},
-	{ "nojournal",	L"nojournal",		FS_JOURNAL_DATA_FL,	0},
+	{ "nojournal-data","nojournal-data",	FS_JOURNAL_DATA_FL,	0},
+	{ "nojournal",	"nojournal",		FS_JOURNAL_DATA_FL,	0},
 #elif defined(EXT3_JOURNAL_DATA_FL)
-	{ "nojournal-data",L"nojournal-data",	EXT3_JOURNAL_DATA_FL,	0},
-	{ "nojournal",	L"nojournal",		EXT3_JOURNAL_DATA_FL,	0},
+	{ "nojournal-data","nojournal-data",	EXT3_JOURNAL_DATA_FL,	0},
+	{ "nojournal",	"nojournal",		EXT3_JOURNAL_DATA_FL,	0},
 #endif
 #if defined(FS_SECRM_FL)	/* 's' */
-	{ "nosecdel",	L"nosecdel",		FS_SECRM_FL,		0},
-	{ "nosecuredeletion",L"nosecuredeletion",FS_SECRM_FL,		0},
+	{ "nosecdel",	"nosecdel",		FS_SECRM_FL,		0},
+	{ "nosecuredeletion","nosecuredeletion",FS_SECRM_FL,		0},
 #elif defined(EXT2_SECRM_FL)
-	{ "nosecdel",	L"nosecdel",		EXT2_SECRM_FL,		0},
-	{ "nosecuredeletion",L"nosecuredeletion",EXT2_SECRM_FL,		0},
+	{ "nosecdel",	"nosecdel",		EXT2_SECRM_FL,		0},
+	{ "nosecuredeletion","nosecuredeletion",EXT2_SECRM_FL,		0},
 #endif
 #if defined(FS_SYNC_FL)		/* 'S' */
-	{ "nosync",	L"nosync",		FS_SYNC_FL,		0},
+	{ "nosync",	"nosync",		FS_SYNC_FL,		0},
 #elif defined(EXT2_SYNC_FL)
-	{ "nosync",	L"nosync",		EXT2_SYNC_FL,		0},
+	{ "nosync",	"nosync",		EXT2_SYNC_FL,		0},
 #endif
 #if defined(FS_NOTAIL_FL)	/* 't' */
-	{ "notail",	L"notail",		0,		FS_NOTAIL_FL},
+	{ "notail",	"notail",		0,		FS_NOTAIL_FL},
 #elif defined(EXT2_NOTAIL_FL)
-	{ "notail",	L"notail",		0,		EXT2_NOTAIL_FL},
+	{ "notail",	"notail",		0,		EXT2_NOTAIL_FL},
 #endif
 #if defined(FS_TOPDIR_FL)	/* 'T' */
-	{ "notopdir",	L"notopdir",		FS_TOPDIR_FL,		0},
+	{ "notopdir",	"notopdir",		FS_TOPDIR_FL,		0},
 #elif defined(EXT2_TOPDIR_FL)
-	{ "notopdir",	L"notopdir",		EXT2_TOPDIR_FL,		0},
+	{ "notopdir",	"notopdir",		EXT2_TOPDIR_FL,		0},
 #endif
 #ifdef FS_NOCOW_FL	/* 'C' */
-	{ "nocow",	L"nocow",		0,	FS_NOCOW_FL},
+	{ "nocow",	"nocow",		0,	FS_NOCOW_FL},
 #endif
 #ifdef FS_PROJINHERIT_FL	/* 'P' */
-	{ "noprojinherit",L"noprojinherit",	FS_PROJINHERIT_FL,	0},
+	{ "noprojinherit","noprojinherit",	FS_PROJINHERIT_FL,	0},
 #endif
 	{ NULL,		NULL,			0,		0}
 };
@@ -1987,13 +1987,13 @@ ae_strtofflags(const char *s, unsigned l
  *	This version is also const-correct and does not modify the
  *	provided string.
  */
-static const wchar_t *
-ae_wcstofflags(const wchar_t *s, unsigned long *setp, unsigned long *clrp)
+static const char *
+ae_wcstofflags(const char *s, unsigned long *setp, unsigned long *clrp)
 {
-	const wchar_t *start, *end;
+	const char *start, *end;
 	const struct flag *flag;
 	unsigned long set, clear;
-	const wchar_t *failed;
+	const char *failed;
 
 	set = clear = 0;
 	start = s;
@@ -2053,14 +2053,14 @@ main(int argc, char **argv)
 {
 	struct archive_entry *entry = archive_entry_new();
 	unsigned long set, clear;
-	const wchar_t *remainder;
+	const char *remainder;
 
-	remainder = archive_entry_copy_fflags_text_w(entry, L"nosappnd dump archive,,,,,,,");
+	remainder = archive_entry_copy_fflags_text_w(entry, "nosappnd dump archive,,,,,,,");
 	archive_entry_fflags(entry, &set, &clear);
 
-	wprintf(L"set=0x%lX clear=0x%lX remainder='%ls'\n", set, clear, remainder);
+	wprintf("set=0x%lX clear=0x%lX remainder='%ls'\n", set, clear, remainder);
 
-	wprintf(L"new flags='%s'\n", archive_entry_fflags_text(entry));
+	wprintf("new flags='%s'\n", archive_entry_fflags_text(entry));
 	return (0);
 }
 #endif
diff -urp a/Utilities/cmlibarchive/libarchive/archive_entry.h b/Utilities/cmlibarchive/libarchive/archive_entry.h
--- a/Utilities/cmlibarchive/libarchive/archive_entry.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_entry.h	2021-02-11 18:43:34.442529226 +0330
@@ -41,7 +41,7 @@
  */
 
 #include <sys/types.h>
-#include <stddef.h>  /* for wchar_t */
+#include <stddef.h>  /* for char */
 #include <stdint.h>
 #include <time.h>
 
@@ -253,10 +253,10 @@ __LA_DECL const char	*archive_entry_ffla
 __LA_DECL la_int64_t	 archive_entry_gid(struct archive_entry *);
 __LA_DECL const char	*archive_entry_gname(struct archive_entry *);
 __LA_DECL const char	*archive_entry_gname_utf8(struct archive_entry *);
-__LA_DECL const wchar_t	*archive_entry_gname_w(struct archive_entry *);
+__LA_DECL const char	*archive_entry_gname_w(struct archive_entry *);
 __LA_DECL const char	*archive_entry_hardlink(struct archive_entry *);
 __LA_DECL const char	*archive_entry_hardlink_utf8(struct archive_entry *);
-__LA_DECL const wchar_t	*archive_entry_hardlink_w(struct archive_entry *);
+__LA_DECL const char	*archive_entry_hardlink_w(struct archive_entry *);
 __LA_DECL la_int64_t	 archive_entry_ino(struct archive_entry *);
 __LA_DECL la_int64_t	 archive_entry_ino64(struct archive_entry *);
 __LA_DECL int		 archive_entry_ino_is_set(struct archive_entry *);
@@ -267,24 +267,24 @@ __LA_DECL int		 archive_entry_mtime_is_s
 __LA_DECL unsigned int	 archive_entry_nlink(struct archive_entry *);
 __LA_DECL const char	*archive_entry_pathname(struct archive_entry *);
 __LA_DECL const char	*archive_entry_pathname_utf8(struct archive_entry *);
-__LA_DECL const wchar_t	*archive_entry_pathname_w(struct archive_entry *);
+__LA_DECL const char	*archive_entry_pathname_w(struct archive_entry *);
 __LA_DECL __LA_MODE_T	 archive_entry_perm(struct archive_entry *);
 __LA_DECL dev_t		 archive_entry_rdev(struct archive_entry *);
 __LA_DECL dev_t		 archive_entry_rdevmajor(struct archive_entry *);
 __LA_DECL dev_t		 archive_entry_rdevminor(struct archive_entry *);
 __LA_DECL const char	*archive_entry_sourcepath(struct archive_entry *);
-__LA_DECL const wchar_t	*archive_entry_sourcepath_w(struct archive_entry *);
+__LA_DECL const char	*archive_entry_sourcepath_w(struct archive_entry *);
 __LA_DECL la_int64_t	 archive_entry_size(struct archive_entry *);
 __LA_DECL int		 archive_entry_size_is_set(struct archive_entry *);
 __LA_DECL const char	*archive_entry_strmode(struct archive_entry *);
 __LA_DECL const char	*archive_entry_symlink(struct archive_entry *);
 __LA_DECL const char	*archive_entry_symlink_utf8(struct archive_entry *);
 __LA_DECL int		 archive_entry_symlink_type(struct archive_entry *);
-__LA_DECL const wchar_t	*archive_entry_symlink_w(struct archive_entry *);
+__LA_DECL const char	*archive_entry_symlink_w(struct archive_entry *);
 __LA_DECL la_int64_t	 archive_entry_uid(struct archive_entry *);
 __LA_DECL const char	*archive_entry_uname(struct archive_entry *);
 __LA_DECL const char	*archive_entry_uname_utf8(struct archive_entry *);
-__LA_DECL const wchar_t	*archive_entry_uname_w(struct archive_entry *);
+__LA_DECL const char	*archive_entry_uname_w(struct archive_entry *);
 __LA_DECL int archive_entry_is_data_encrypted(struct archive_entry *);
 __LA_DECL int archive_entry_is_metadata_encrypted(struct archive_entry *);
 __LA_DECL int archive_entry_is_encrypted(struct archive_entry *);
@@ -317,25 +317,25 @@ __LA_DECL void	archive_entry_set_fflags(
 /* Note that all recognized tokens are processed, regardless. */
 __LA_DECL const char *archive_entry_copy_fflags_text(struct archive_entry *,
 	    const char *);
-__LA_DECL const wchar_t *archive_entry_copy_fflags_text_w(struct archive_entry *,
-	    const wchar_t *);
+__LA_DECL const char *archive_entry_copy_fflags_text_w(struct archive_entry *,
+	    const char *);
 __LA_DECL void	archive_entry_set_gid(struct archive_entry *, la_int64_t);
 __LA_DECL void	archive_entry_set_gname(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_set_gname_utf8(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_copy_gname(struct archive_entry *, const char *);
-__LA_DECL void	archive_entry_copy_gname_w(struct archive_entry *, const wchar_t *);
+__LA_DECL void	archive_entry_copy_gname_w(struct archive_entry *, const char *);
 __LA_DECL int	archive_entry_update_gname_utf8(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_set_hardlink(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_set_hardlink_utf8(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_copy_hardlink(struct archive_entry *, const char *);
-__LA_DECL void	archive_entry_copy_hardlink_w(struct archive_entry *, const wchar_t *);
+__LA_DECL void	archive_entry_copy_hardlink_w(struct archive_entry *, const char *);
 __LA_DECL int	archive_entry_update_hardlink_utf8(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_set_ino(struct archive_entry *, la_int64_t);
 __LA_DECL void	archive_entry_set_ino64(struct archive_entry *, la_int64_t);
 __LA_DECL void	archive_entry_set_link(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_set_link_utf8(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_copy_link(struct archive_entry *, const char *);
-__LA_DECL void	archive_entry_copy_link_w(struct archive_entry *, const wchar_t *);
+__LA_DECL void	archive_entry_copy_link_w(struct archive_entry *, const char *);
 __LA_DECL int	archive_entry_update_link_utf8(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_set_mode(struct archive_entry *, __LA_MODE_T);
 __LA_DECL void	archive_entry_set_mtime(struct archive_entry *, time_t, long);
@@ -344,7 +344,7 @@ __LA_DECL void	archive_entry_set_nlink(s
 __LA_DECL void	archive_entry_set_pathname(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_set_pathname_utf8(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_copy_pathname(struct archive_entry *, const char *);
-__LA_DECL void	archive_entry_copy_pathname_w(struct archive_entry *, const wchar_t *);
+__LA_DECL void	archive_entry_copy_pathname_w(struct archive_entry *, const char *);
 __LA_DECL int	archive_entry_update_pathname_utf8(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_set_perm(struct archive_entry *, __LA_MODE_T);
 __LA_DECL void	archive_entry_set_rdev(struct archive_entry *, dev_t);
@@ -353,18 +353,18 @@ __LA_DECL void	archive_entry_set_rdevmin
 __LA_DECL void	archive_entry_set_size(struct archive_entry *, la_int64_t);
 __LA_DECL void	archive_entry_unset_size(struct archive_entry *);
 __LA_DECL void	archive_entry_copy_sourcepath(struct archive_entry *, const char *);
-__LA_DECL void	archive_entry_copy_sourcepath_w(struct archive_entry *, const wchar_t *);
+__LA_DECL void	archive_entry_copy_sourcepath_w(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_set_symlink(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_set_symlink_type(struct archive_entry *, int);
 __LA_DECL void	archive_entry_set_symlink_utf8(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_copy_symlink(struct archive_entry *, const char *);
-__LA_DECL void	archive_entry_copy_symlink_w(struct archive_entry *, const wchar_t *);
+__LA_DECL void	archive_entry_copy_symlink_w(struct archive_entry *, const char *);
 __LA_DECL int	archive_entry_update_symlink_utf8(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_set_uid(struct archive_entry *, la_int64_t);
 __LA_DECL void	archive_entry_set_uname(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_set_uname_utf8(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_copy_uname(struct archive_entry *, const char *);
-__LA_DECL void	archive_entry_copy_uname_w(struct archive_entry *, const wchar_t *);
+__LA_DECL void	archive_entry_copy_uname_w(struct archive_entry *, const char *);
 __LA_DECL int	archive_entry_update_uname_utf8(struct archive_entry *, const char *);
 __LA_DECL void	archive_entry_set_is_data_encrypted(struct archive_entry *, char is_encrypted);
 __LA_DECL void	archive_entry_set_is_metadata_encrypted(struct archive_entry *, char is_encrypted);
@@ -510,7 +510,7 @@ __LA_DECL int	 archive_entry_acl_add_ent
 	    int /* qual */, const char * /* name */);
 __LA_DECL int	 archive_entry_acl_add_entry_w(struct archive_entry *,
 	    int /* type */, int /* permset */, int /* tag */,
-	    int /* qual */, const wchar_t * /* name */);
+	    int /* qual */, const char * /* name */);
 
 /*
  * To retrieve the ACL, first "reset", then repeatedly ask for the
@@ -550,12 +550,12 @@ __LA_DECL int	 archive_entry_acl_next(st
 #define	ARCHIVE_ENTRY_ACL_STYLE_SEPARATOR_COMMA	0x00000008
 #define	ARCHIVE_ENTRY_ACL_STYLE_COMPACT		0x00000010
 
-__LA_DECL wchar_t *archive_entry_acl_to_text_w(struct archive_entry *,
+__LA_DECL char *archive_entry_acl_to_text_w(struct archive_entry *,
 	    la_ssize_t * /* len */, int /* flags */);
 __LA_DECL char *archive_entry_acl_to_text(struct archive_entry *,
 	    la_ssize_t * /* len */, int /* flags */);
 __LA_DECL int archive_entry_acl_from_text_w(struct archive_entry *,
-	    const wchar_t * /* wtext */, int /* type */);
+	    const char * /* wtext */, int /* type */);
 __LA_DECL int archive_entry_acl_from_text(struct archive_entry *,
 	    const char * /* text */, int /* type */);
 
@@ -564,7 +564,7 @@ __LA_DECL int archive_entry_acl_from_tex
 #define	OLD_ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT	2048
 
 /* Deprecated functions */
-__LA_DECL const wchar_t	*archive_entry_acl_text_w(struct archive_entry *,
+__LA_DECL const char	*archive_entry_acl_text_w(struct archive_entry *,
 		    int /* flags */) __LA_DEPRECATED;
 __LA_DECL const char *archive_entry_acl_text(struct archive_entry *,
 		    int /* flags */) __LA_DEPRECATED;
diff -urp a/Utilities/cmlibarchive/libarchive/archive_entry_paths.3 b/Utilities/cmlibarchive/libarchive/archive_entry_paths.3
--- a/Utilities/cmlibarchive/libarchive/archive_entry_paths.3	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_entry_paths.3	2021-02-11 18:43:34.415862139 +0330
@@ -57,14 +57,14 @@ Streaming Archive Library (libarchive, -
 .In archive_entry.h
 .Ft const char *
 .Fn archive_entry_hardlink "struct archive_entry *a"
-.Ft const wchar_t *
+.Ft const char *
 .Fn archive_entry_hardlink_w "struct archive_entry *a"
 .Ft void
 .Fn archive_entry_set_hardlink "struct archive_entry *a" "const char *path"
 .Ft void
 .Fn archive_entry_copy_hardlink "struct archive_entry *a" "const char *path"
 .Ft void
-.Fn archive_entry_copy_hardlink_w "struct archive_entry *a "const wchar_t *path"
+.Fn archive_entry_copy_hardlink_w "struct archive_entry *a "const char *path"
 .Ft int
 .Fn archive_entry_update_hardlink_utf8 "struct archive_entry *a" "const char *path"
 .Ft void
@@ -72,19 +72,19 @@ Streaming Archive Library (libarchive, -
 .Ft void
 .Fn archive_entry_copy_link "struct archive_entry *a" " const char *path"
 .Ft void
-.Fn archive_entry_copy_link_w "struct archive_entry *a" " const wchar_t *path"
+.Fn archive_entry_copy_link_w "struct archive_entry *a" " const char *path"
 .Ft int
 .Fn archive_entry_update_link_utf8 "struct archive_entry *a" " const char *path"
 .Ft const char *
 .Fn archive_entry_pathname "struct archive_entry *a"
-.Ft const wchar_t *
+.Ft const char *
 .Fn archive_entry_pathname_w "struct archive_entry *a"
 .Ft void
 .Fn archive_entry_set_pathname "struct archive_entry *a" "const char *path"
 .Ft void
 .Fn archive_entry_copy_pathname "struct archive_entry *a" "const char *path"
 .Ft void
-.Fn archive_entry_copy_pathname_w "struct archive_entry *a" "const wchar_t *path"
+.Fn archive_entry_copy_pathname_w "struct archive_entry *a" "const char *path"
 .Ft int
 .Fn archive_entry_update_pathname_utf8 "struct archive_entry *a" "const char *path"
 .Ft const char *
@@ -93,14 +93,14 @@ Streaming Archive Library (libarchive, -
 .Fn archive_entry_copy_sourcepath "struct archive_entry *a" "const char *path"
 .Ft const char *
 .Fn archive_entry_symlink "struct archive_entry *a"
-.Ft const wchar_t *
+.Ft const char *
 .Fn archive_entry_symlink_w "struct archive_entry *a"
 .Ft void
 .Fn archive_entry_set_symlink "struct archive_entry *a" "const char *path"
 .Ft void
 .Fn archive_entry_copy_symlink "struct archive_entry *a" "const char *path"
 .Ft void
-.Fn archive_entry_copy_symlink_w "struct archive_entry *a" "const wchar_t *path"
+.Fn archive_entry_copy_symlink_w "struct archive_entry *a" "const char *path"
 .Ft int
 .Fn archive_entry_update_symlink_utf8 "struct archive_entry *a" "const char *path"
 .Sh DESCRIPTION
@@ -124,10 +124,10 @@ Destination of the symbolic link.
 .El
 .Pp
 Path names can be provided in one of three different ways:
-.Bl -tag -width "wchar_t *"
+.Bl -tag -width "char *"
 .It char *
 Multibyte strings in the current locale.
-.It wchar_t *
+.It char *
 Wide character strings in the current locale.
 The accessor functions are named
 .Fn XXX_w .
diff -urp a/Utilities/cmlibarchive/libarchive/archive_entry_perms.3 b/Utilities/cmlibarchive/libarchive/archive_entry_perms.3
--- a/Utilities/cmlibarchive/libarchive/archive_entry_perms.3	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_entry_perms.3	2021-02-11 18:43:34.412528752 +0330
@@ -72,26 +72,26 @@ Streaming Archive Library (libarchive, -
 .Fn archive_entry_strmode "struct archive_entry *a"
 .Ft const char *
 .Fn archive_entry_gname "struct archive_entry *a"
-.Ft const wchar_t *
+.Ft const char *
 .Fn archive_entry_gname_w "struct archive_entry *a"
 .Ft void
 .Fn archive_entry_set_gname "struct archive_entry *a" "const char *a"
 .Ft void
 .Fn archive_entry_copy_gname "struct archive_entry *a" "const char *name"
 .Ft void
-.Fn archive_entry_copy_gname_w "struct archive_entry *a" "const wchar_t *name"
+.Fn archive_entry_copy_gname_w "struct archive_entry *a" "const char *name"
 .Ft int
 .Fn archive_entry_update_gname_utf8 "struct archive_entry *a" "const char *name"
 .Ft const char *
 .Fn archive_entry_uname "struct archive_entry *a"
-.Ft const wchar_t *
+.Ft const char *
 .Fn archive_entry_uname_w "struct archive_entry *a"
 .Ft void
 .Fn archive_entry_set_uname "struct archive_entry *a" "const char *name"
 .Ft void
 .Fn archive_entry_copy_uname "struct archive_entry *a" "const char *name"
 .Ft void
-.Fn archive_entry_copy_uname_w "struct archive_entry *a" "const wchar_t *name"
+.Fn archive_entry_copy_uname_w "struct archive_entry *a" "const char *name"
 .Ft int
 .Fn archive_entry_update_uname_utf8 "struct archive_entry *a" "const char *name"
 .Ft void
@@ -110,8 +110,8 @@ Streaming Archive Library (libarchive, -
 .Fc
 .Ft const char *
 .Fn archive_entry_copy_fflags_text "struct archive_entry *a" "const char *text"
-.Ft const wchar_t *
-.Fn archive_entry_copy_fflags_text_w "struct archive_entry *a" "const wchar_t *text"
+.Ft const char *
+.Fn archive_entry_copy_fflags_text_w "struct archive_entry *a" "const char *text"
 .Sh DESCRIPTION
 .Ss User id, group id and mode
 The functions
@@ -134,10 +134,10 @@ returns a string representation of the p
 .Xr ls 1 .
 .Ss User and group name
 User and group names can be provided in one of three different ways:
-.Bl -tag -width "wchar_t *"
+.Bl -tag -width "char *"
 .It char *
 Multibyte strings in the current locale.
-.It wchar_t *
+.It char *
 Wide character strings in the current locale.
 The accessor functions are named
 .Fn XXX_w .
diff -urp a/Utilities/cmlibarchive/libarchive/archive.h b/Utilities/cmlibarchive/libarchive/archive.h
--- a/Utilities/cmlibarchive/libarchive/archive.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive.h	2021-02-11 18:43:34.382528279 +0330
@@ -39,7 +39,7 @@
 #define	ARCHIVE_VERSION_NUMBER 3004002
 
 #include <sys/stat.h>
-#include <stddef.h>  /* for wchar_t */
+#include <stddef.h>  /* for char */
 #include <stdio.h> /* For FILE * */
 #include <time.h> /* For time_t */
 
@@ -525,7 +525,7 @@ __LA_DECL int archive_read_open_filename
 __LA_DECL int archive_read_open_filenames(struct archive *,
 		     const char **_filenames, size_t _block_size);
 __LA_DECL int archive_read_open_filename_w(struct archive *,
-		     const wchar_t *_filename, size_t _block_size);
+		     const char *_filename, size_t _block_size);
 /* archive_read_open_file() is a deprecated synonym for ..._open_filename(). */
 __LA_DECL int archive_read_open_file(struct archive *,
 		     const char *_filename, size_t _block_size) __LA_DEPRECATED;
@@ -820,7 +820,7 @@ __LA_DECL int archive_write_open(struct
 __LA_DECL int archive_write_open_fd(struct archive *, int _fd);
 __LA_DECL int archive_write_open_filename(struct archive *, const char *_file);
 __LA_DECL int archive_write_open_filename_w(struct archive *,
-		     const wchar_t *_file);
+		     const char *_file);
 /* A deprecated synonym for archive_write_open_filename() */
 __LA_DECL int archive_write_open_file(struct archive *, const char *_file)
 		__LA_DEPRECATED;
@@ -976,7 +976,7 @@ __LA_DECL int	archive_read_disk_set_unam
     void (* /* cleanup_fn */)(void *));
 /* Start traversal. */
 __LA_DECL int	archive_read_disk_open(struct archive *, const char *);
-__LA_DECL int	archive_read_disk_open_w(struct archive *, const wchar_t *);
+__LA_DECL int	archive_read_disk_open_w(struct archive *, const char *);
 /*
  * Request that current entry be visited.  If you invoke it on every
  * directory, you'll get a physical traversal.  This is ignored if the
@@ -1099,21 +1099,21 @@ __LA_DECL int	archive_match_set_inclusio
 /* Add exclusion pathname pattern. */
 __LA_DECL int	archive_match_exclude_pattern(struct archive *, const char *);
 __LA_DECL int	archive_match_exclude_pattern_w(struct archive *,
-		    const wchar_t *);
+		    const char *);
 /* Add exclusion pathname pattern from file. */
 __LA_DECL int	archive_match_exclude_pattern_from_file(struct archive *,
 		    const char *, int _nullSeparator);
 __LA_DECL int	archive_match_exclude_pattern_from_file_w(struct archive *,
-		    const wchar_t *, int _nullSeparator);
+		    const char *, int _nullSeparator);
 /* Add inclusion pathname pattern. */
 __LA_DECL int	archive_match_include_pattern(struct archive *, const char *);
 __LA_DECL int	archive_match_include_pattern_w(struct archive *,
-		    const wchar_t *);
+		    const char *);
 /* Add inclusion pathname pattern from file. */
 __LA_DECL int	archive_match_include_pattern_from_file(struct archive *,
 		    const char *, int _nullSeparator);
 __LA_DECL int	archive_match_include_pattern_from_file_w(struct archive *,
-		    const wchar_t *, int _nullSeparator);
+		    const char *, int _nullSeparator);
 /*
  * How to get statistic information for inclusion patterns.
  */
@@ -1124,7 +1124,7 @@ __LA_DECL int	archive_match_path_unmatch
 __LA_DECL int	archive_match_path_unmatched_inclusions_next(
 		    struct archive *, const char **);
 __LA_DECL int	archive_match_path_unmatched_inclusions_next_w(
-		    struct archive *, const wchar_t **);
+		    struct archive *, const char **);
 
 /*
  * Test if a file is excluded by its time stamp.
@@ -1154,12 +1154,12 @@ __LA_DECL int	archive_match_include_time
 __LA_DECL int	archive_match_include_date(struct archive *, int _flag,
 		    const char *_datestr);
 __LA_DECL int	archive_match_include_date_w(struct archive *, int _flag,
-		    const wchar_t *_datestr);
+		    const char *_datestr);
 /* Set inclusion time by a particular file. */
 __LA_DECL int	archive_match_include_file_time(struct archive *,
 		    int _flag, const char *_pathname);
 __LA_DECL int	archive_match_include_file_time_w(struct archive *,
-		    int _flag, const wchar_t *_pathname);
+		    int _flag, const char *_pathname);
 /* Add exclusion entry. */
 __LA_DECL int	archive_match_exclude_entry(struct archive *,
 		    int _flag, struct archive_entry *);
@@ -1175,10 +1175,10 @@ __LA_DECL int	archive_match_include_uid(
 __LA_DECL int	archive_match_include_gid(struct archive *, la_int64_t);
 __LA_DECL int	archive_match_include_uname(struct archive *, const char *);
 __LA_DECL int	archive_match_include_uname_w(struct archive *,
-		    const wchar_t *);
+		    const char *);
 __LA_DECL int	archive_match_include_gname(struct archive *, const char *);
 __LA_DECL int	archive_match_include_gname_w(struct archive *,
-		    const wchar_t *);
+		    const char *);
 
 /* Utility functions */
 /* Convenience function to sort a NULL terminated list of strings */
diff -urp a/Utilities/cmlibarchive/libarchive/archive_match.c b/Utilities/cmlibarchive/libarchive/archive_match.c
--- a/Utilities/cmlibarchive/libarchive/archive_match.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_match.c	2021-02-11 18:43:34.449195998 +0330
@@ -144,7 +144,7 @@ static int	add_owner_name(struct archive
 static int	add_pattern_mbs(struct archive_match *, struct match_list *,
 		    const char *);
 static int	add_pattern_wcs(struct archive_match *, struct match_list *,
-		    const wchar_t *);
+		    const char *);
 static int	cmp_key_mbs(const struct archive_rb_node *, const void *);
 static int	cmp_key_wcs(const struct archive_rb_node *, const void *);
 static int	cmp_node_mbs(const struct archive_rb_node *,
@@ -166,7 +166,7 @@ static int	match_owner_name_mbs(struct a
 		    struct match_list *, const char *);
 #else
 static int	match_owner_name_wcs(struct archive_match *,
-		    struct match_list *, const wchar_t *);
+		    struct match_list *, const char *);
 #endif
 static int	match_path_exclusion(struct archive_match *,
 		    struct match *, int, const void *);
@@ -180,10 +180,10 @@ static int	set_timefilter(struct archive
 static int	set_timefilter_pathname_mbs(struct archive_match *,
 		    int, const char *);
 static int	set_timefilter_pathname_wcs(struct archive_match *,
-		    int, const wchar_t *);
+		    int, const char *);
 static int	set_timefilter_date(struct archive_match *, int, const char *);
 static int	set_timefilter_date_w(struct archive_match *, int,
-		    const wchar_t *);
+		    const char *);
 static int	time_excluded(struct archive_match *,
 		    struct archive_entry *);
 static int	validate_time_flag(struct archive *, int, const char *);
@@ -329,7 +329,7 @@ archive_match_exclude_pattern(struct arc
 }
 
 int
-archive_match_exclude_pattern_w(struct archive *_a, const wchar_t *pattern)
+archive_match_exclude_pattern_w(struct archive *_a, const char *pattern)
 {
 	struct archive_match *a;
 	int r;
@@ -363,7 +363,7 @@ archive_match_exclude_pattern_from_file(
 
 int
 archive_match_exclude_pattern_from_file_w(struct archive *_a,
-    const wchar_t *pathname, int nullSeparator)
+    const char *pathname, int nullSeparator)
 {
 	struct archive_match *a;
 
@@ -395,7 +395,7 @@ archive_match_include_pattern(struct arc
 }
 
 int
-archive_match_include_pattern_w(struct archive *_a, const wchar_t *pattern)
+archive_match_include_pattern_w(struct archive *_a, const char *pattern)
 {
 	struct archive_match *a;
 	int r;
@@ -429,7 +429,7 @@ archive_match_include_pattern_from_file(
 
 int
 archive_match_include_pattern_from_file_w(struct archive *_a,
-    const wchar_t *pathname, int nullSeparator)
+    const char *pathname, int nullSeparator)
 {
 	struct archive_match *a;
 
@@ -530,7 +530,7 @@ archive_match_path_unmatched_inclusions_
 
 int
 archive_match_path_unmatched_inclusions_next_w(struct archive *_a,
-    const wchar_t **_p)
+    const char **_p)
 {
 	struct archive_match *a;
 	const void *v;
@@ -541,7 +541,7 @@ archive_match_path_unmatched_inclusions_
 	a = (struct archive_match *)_a;
 
 	r = match_list_unmatched_inclusions_next(a, &(a->inclusions), 0, &v);
-	*_p = (const wchar_t *)v;
+	*_p = (const char *)v;
 	return (r);
 }
 
@@ -570,7 +570,7 @@ add_pattern_mbs(struct archive_match *a,
 
 static int
 add_pattern_wcs(struct archive_match *a, struct match_list *list,
-    const wchar_t *pattern)
+    const char *pattern)
 {
 	struct match *match;
 	size_t len;
@@ -788,10 +788,10 @@ match_path_exclusion(struct archive_matc
 		if (r == 0)
 			return (archive_pathmatch(p, (const char *)pn, flag));
 	} else {
-		const wchar_t *p;
+		const char *p;
 		r = archive_mstring_get_wcs(&(a->archive), &(m->pattern), &p);
 		if (r == 0)
-			return (archive_pathmatch_w(p, (const wchar_t *)pn,
+			return (archive_pathmatch_w(p, (const char *)pn,
 				flag));
 	}
 	if (errno == ENOMEM)
@@ -819,10 +819,10 @@ match_path_inclusion(struct archive_matc
 		if (r == 0)
 			return (archive_pathmatch(p, (const char *)pn, flag));
 	} else {
-		const wchar_t *p;
+		const char *p;
 		r = archive_mstring_get_wcs(&(a->archive), &(m->pattern), &p);
 		if (r == 0)
-			return (archive_pathmatch_w(p, (const wchar_t *)pn,
+			return (archive_pathmatch_w(p, (const char *)pn,
 				flag));
 	}
 	if (errno == ENOMEM)
@@ -892,13 +892,13 @@ match_list_unmatched_inclusions_next(str
 				p = "";
 			*vp = p;
 		} else {
-			const wchar_t *p;
+			const char *p;
 			r = archive_mstring_get_wcs(&(a->archive),
 				&(m->pattern), &p);
 			if (r < 0 && errno == ENOMEM)
 				return (error_nomem(a));
 			if (p == NULL)
-				p = L"";
+				p = "";
 			*vp = p;
 		}
 		list->unmatched_next = m->next;
@@ -941,7 +941,7 @@ archive_match_include_date(struct archiv
 
 int
 archive_match_include_date_w(struct archive *_a, int flag,
-    const wchar_t *datestr)
+    const char *datestr)
 {
 	int r;
 
@@ -967,7 +967,7 @@ archive_match_include_file_time(struct a
 
 int
 archive_match_include_file_time_w(struct archive *_a, int flag,
-    const wchar_t *pathname)
+    const char *pathname)
 {
 	int r;
 
@@ -1117,7 +1117,7 @@ set_timefilter_date(struct archive_match
 
 static int
 set_timefilter_date_w(struct archive_match *a, int timetype,
-    const wchar_t *datestr)
+    const char *datestr)
 {
 	struct archive_string as;
 	time_t t;
@@ -1207,7 +1207,7 @@ set_timefilter_pathname_mbs(struct archi
 
 static int
 set_timefilter_pathname_wcs(struct archive_match *a, int timetype,
-    const wchar_t *path)
+    const char *path)
 {
 	HANDLE h;
 	WIN32_FIND_DATAW d;
@@ -1270,7 +1270,7 @@ set_timefilter_pathname_mbs(struct archi
 
 static int
 set_timefilter_pathname_wcs(struct archive_match *a, int timetype,
-    const wchar_t *path)
+    const char *path)
 {
 	struct archive_string as;
 	int r;
@@ -1336,7 +1336,7 @@ cmp_node_wcs(const struct archive_rb_nod
 {
 	struct match_file *f1 = (struct match_file *)(uintptr_t)n1;
 	struct match_file *f2 = (struct match_file *)(uintptr_t)n2;
-	const wchar_t *p1, *p2;
+	const char *p1, *p2;
 
 	archive_mstring_get_wcs(NULL, &(f1->pathname), &p1);
 	archive_mstring_get_wcs(NULL, &(f2->pathname), &p2);
@@ -1351,12 +1351,12 @@ static int
 cmp_key_wcs(const struct archive_rb_node *n, const void *key)
 {
 	struct match_file *f = (struct match_file *)(uintptr_t)n;
-	const wchar_t *p;
+	const char *p;
 
 	archive_mstring_get_wcs(NULL, &(f->pathname), &p);
 	if (p == NULL)
 		return (-1);
-	return (wcscmp(p, (const wchar_t *)key));
+	return (wcscmp(p, (const char *)key));
 }
 
 static void
@@ -1644,7 +1644,7 @@ archive_match_include_uname(struct archi
 }
 
 int
-archive_match_include_uname_w(struct archive *_a, const wchar_t *uname)
+archive_match_include_uname_w(struct archive *_a, const char *uname)
 {
 	struct archive_match *a;
 
@@ -1666,7 +1666,7 @@ archive_match_include_gname(struct archi
 }
 
 int
-archive_match_include_gname_w(struct archive *_a, const wchar_t *gname)
+archive_match_include_gname_w(struct archive *_a, const char *gname)
 {
 	struct archive_match *a;
 
@@ -1803,10 +1803,10 @@ match_owner_name_mbs(struct archive_matc
 #else
 static int
 match_owner_name_wcs(struct archive_match *a, struct match_list *list,
-    const wchar_t *name)
+    const char *name)
 {
 	struct match *m;
-	const wchar_t *p;
+	const char *p;
 
 	if (name == NULL || *name == L'\0')
 		return (0);
diff -urp a/Utilities/cmlibarchive/libarchive/archive_pathmatch.c b/Utilities/cmlibarchive/libarchive/archive_pathmatch.c
--- a/Utilities/cmlibarchive/libarchive/archive_pathmatch.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_pathmatch.c	2021-02-11 18:43:34.425862296 +0330
@@ -100,10 +100,10 @@ pm_list(const char *start, const char *e
 }
 
 static int
-pm_list_w(const wchar_t *start, const wchar_t *end, const wchar_t c, int flags)
+pm_list_w(const char *start, const char *end, const char c, int flags)
 {
-	const wchar_t *p = start;
-	wchar_t rangeStart = L'\0', nextRangeStart;
+	const char *p = start;
+	char rangeStart = L'\0', nextRangeStart;
 	int match = 1, nomatch = 0;
 
 	/* This will be used soon... */
@@ -125,7 +125,7 @@ pm_list_w(const wchar_t *start, const wc
 				if (*p == c)
 					return (match);
 			} else {
-				wchar_t rangeEnd = *++p;
+				char rangeEnd = *++p;
 				if (rangeEnd == L'\\')
 					rangeEnd = *++p;
 				if ((rangeStart <= c) && (c <= rangeEnd))
@@ -158,8 +158,8 @@ pm_slashskip(const char *s) {
 	return (s);
 }
 
-static const wchar_t *
-pm_slashskip_w(const wchar_t *s) {
+static const char *
+pm_slashskip_w(const char *s) {
 	while ((*s == L'/')
 	    || (s[0] == L'.' && s[1] == L'/')
 	    || (s[0] == L'.' && s[1] == L'\0'))
@@ -273,9 +273,9 @@ pm(const char *p, const char *s, int fla
 }
 
 static int
-pm_w(const wchar_t *p, const wchar_t *s, int flags)
+pm_w(const char *p, const char *s, int flags)
 {
-	const wchar_t *end;
+	const char *end;
 
 	/*
 	 * Ignore leading './', './/', '././', etc.
@@ -419,7 +419,7 @@ __archive_pathmatch(const char *p, const
 }
 
 int
-__archive_pathmatch_w(const wchar_t *p, const wchar_t *s, int flags)
+__archive_pathmatch_w(const char *p, const char *s, int flags)
 {
 	/* Empty pattern only matches the empty string. */
 	if (p == NULL || *p == L'\0')
diff -urp a/Utilities/cmlibarchive/libarchive/archive_pathmatch.h b/Utilities/cmlibarchive/libarchive/archive_pathmatch.h
--- a/Utilities/cmlibarchive/libarchive/archive_pathmatch.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_pathmatch.h	2021-02-11 18:43:34.392528437 +0330
@@ -44,7 +44,7 @@
  * flag above. */
 
 int __archive_pathmatch(const char *p, const char *s, int flags);
-int __archive_pathmatch_w(const wchar_t *p, const wchar_t *s, int flags);
+int __archive_pathmatch_w(const char *p, const char *s, int flags);
 
 #define archive_pathmatch(p, s, f)	__archive_pathmatch(p, s, f)
 #define archive_pathmatch_w(p, s, f)	__archive_pathmatch_w(p, s, f)
diff -urp a/Utilities/cmlibarchive/libarchive/archive_private.h b/Utilities/cmlibarchive/libarchive/archive_private.h
--- a/Utilities/cmlibarchive/libarchive/archive_private.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_private.h	2021-02-11 18:43:34.379194894 +0330
@@ -154,7 +154,7 @@ void	__archive_errx(int retvalue, const
 void	__archive_ensure_cloexec_flag(int fd);
 int	__archive_mktemp(const char *tmpdir);
 #if defined(_WIN32) && !defined(__CYGWIN__)
-int	__archive_mkstemp(wchar_t *template);
+int	__archive_mkstemp(char *template);
 #else
 int	__archive_mkstemp(char *template);
 #endif
diff -urp a/Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c b/Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
--- a/Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c	2021-02-12 14:39:59.857852509 +0330
@@ -1333,7 +1333,7 @@ archive_read_disk_open(struct archive *_
 }
 
 int
-archive_read_disk_open_w(struct archive *_a, const wchar_t *pathname)
+archive_read_disk_open_w(struct archive *_a, const char *pathname)
 {
 	struct archive_read_disk *a = (struct archive_read_disk *)_a;
 	struct archive_string path;
@@ -1344,7 +1344,7 @@ archive_read_disk_open_w(struct archive
 	    "archive_read_disk_open_w");
 	archive_clear_error(&a->archive);
 
-	/* Make a char string from a wchar_t string. */
+	/* Make a char string from a char string. */
 	archive_string_init(&path);
 	if (archive_string_append_from_wcs(&path, pathname,
 	    wcslen(pathname)) != 0) {
diff -urp a/Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c b/Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c
--- a/Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c	2021-02-11 18:43:34.362527965 +0330
@@ -72,7 +72,7 @@ __FBSDID("$FreeBSD$");
  */
 
 struct restore_time {
-	const wchar_t		*full_path;
+	const char		*full_path;
 	FILETIME		 lastWriteTime;
 	FILETIME		 lastAccessTime;
 	mode_t			 filetype;
@@ -142,7 +142,7 @@ struct tree {
 	struct archive_wstring	 path;
 
 	/* Last path element */
-	const wchar_t		*basename;
+	const char		*basename;
 	/* Leading dir length */
 	size_t			 dirname_length;
 
@@ -207,14 +207,14 @@ struct tree {
 #define	needsRestoreTimes 128
 
 static int
-tree_dir_next_windows(struct tree *t, const wchar_t *pattern);
+tree_dir_next_windows(struct tree *t, const char *pattern);
 
 /* Initiate/terminate a tree traversal. */
-static struct tree *tree_open(const wchar_t *, int, int);
-static struct tree *tree_reopen(struct tree *, const wchar_t *, int);
+static struct tree *tree_open(const char *, int, int);
+static struct tree *tree_reopen(struct tree *, const char *, int);
 static void tree_close(struct tree *);
 static void tree_free(struct tree *);
-static void tree_push(struct tree *, const wchar_t *, const wchar_t *,
+static void tree_push(struct tree *, const char *, const char *,
 		int, int64_t, int64_t, struct restore_time *);
 
 /*
@@ -254,8 +254,8 @@ static int tree_next(struct tree *);
  * current path.
  *
  */
-static const wchar_t *tree_current_path(struct tree *);
-static const wchar_t *tree_current_access_path(struct tree *);
+static const char *tree_current_path(struct tree *);
+static const char *tree_current_access_path(struct tree *);
 
 /*
  * Request the lstat() or stat() data for the current path.  Since the
@@ -283,7 +283,7 @@ static int setup_current_filesystem(stru
 static int tree_target_is_same_as_parent(struct tree *,
 		    const BY_HANDLE_FILE_INFORMATION *);
 
-static int	_archive_read_disk_open_w(struct archive *, const wchar_t *);
+static int	_archive_read_disk_open_w(struct archive *, const char *);
 static int	_archive_read_free(struct archive *);
 static int	_archive_read_close(struct archive *);
 static int	_archive_read_data_block(struct archive *,
@@ -299,10 +299,10 @@ static int	close_and_restore_time(HANDLE
 		    struct restore_time *);
 static int	setup_sparse_from_disk(struct archive_read_disk *,
 		    struct archive_entry *, HANDLE);
-static int	la_linkname_from_handle(HANDLE, wchar_t **, int *);
-static int	la_linkname_from_pathw(const wchar_t *, wchar_t **, int *);
+static int	la_linkname_from_handle(HANDLE, char **, int *);
+static int	la_linkname_from_pathw(const char *, char **, int *);
 static void	entry_symlink_from_pathw(struct archive_entry *,
-		    const wchar_t *path);
+		    const char *path);
 
 typedef struct _REPARSE_DATA_BUFFER {
 	ULONG	ReparseTag;
@@ -337,7 +337,7 @@ typedef struct _REPARSE_DATA_BUFFER {
  * outbuf is allocated in the function
  */
 static int
-la_linkname_from_handle(HANDLE h, wchar_t **linkname, int *linktype)
+la_linkname_from_handle(HANDLE h, char **linkname, int *linktype)
 {
 	DWORD inbytes;
 	REPARSE_DATA_BUFFER *buf;
@@ -345,7 +345,7 @@ la_linkname_from_handle(HANDLE h, wchar_
 	size_t len;
 	BOOL ret;
 	BYTE *indata;
-	wchar_t *tbuf;
+	char *tbuf;
 
 	ret = GetFileInformationByHandle(h, &st);
 	if (ret == 0 ||
@@ -376,7 +376,7 @@ la_linkname_from_handle(HANDLE h, wchar_
 		return (-1);
 	}
 
-	tbuf = malloc(len + 1 * sizeof(wchar_t));
+	tbuf = malloc(len + 1 * sizeof(char));
 	if (tbuf == NULL) {
 		free(indata);
 		return (-1);
@@ -386,7 +386,7 @@ la_linkname_from_handle(HANDLE h, wchar_
 	    [buf->SymbolicLinkReparseBuffer.SubstituteNameOffset], len);
 	free(indata);
 
-	tbuf[len / sizeof(wchar_t)] = L'\0';
+	tbuf[len / sizeof(char)] = L'\0';
 
 	*linkname = tbuf;
 
@@ -411,7 +411,7 @@ la_linkname_from_handle(HANDLE h, wchar_
  * Returns AE_SYMLINK_TYPE_FILE, AE_SYMLINK_TYPE_DIRECTORY or -1 on error
  */
 static int
-la_linkname_from_pathw(const wchar_t *path, wchar_t **outbuf, int *linktype)
+la_linkname_from_pathw(const char *path, char **outbuf, int *linktype)
 {
 	HANDLE h;
 	const DWORD flag = FILE_FLAG_BACKUP_SEMANTICS |
@@ -432,9 +432,9 @@ la_linkname_from_pathw(const wchar_t *pa
 }
 
 static void
-entry_symlink_from_pathw(struct archive_entry *entry, const wchar_t *path)
+entry_symlink_from_pathw(struct archive_entry *entry, const char *path)
 {
-	wchar_t *linkname = NULL;
+	char *linkname = NULL;
 	int ret, linktype;
 
 	ret = la_linkname_from_pathw(path, &linkname, &linktype);
@@ -1332,7 +1332,7 @@ archive_read_disk_open(struct archive *_
 	    "archive_read_disk_open");
 	archive_clear_error(&a->archive);
 
-	/* Make a wchar_t string from a char string. */
+	/* Make a char string from a char string. */
 	archive_string_init(&wpath);
 	if (archive_wstring_append_from_mbs(&wpath, pathname,
 	    strlen(pathname)) != 0) {
@@ -1341,7 +1341,7 @@ archive_read_disk_open(struct archive *_
 			    "Can't allocate memory");
 		else
 			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
-			    "Can't convert a path to a wchar_t string");
+			    "Can't convert a path to a char string");
 		a->archive.state = ARCHIVE_STATE_FATAL;
 		ret = ARCHIVE_FATAL;
 	} else
@@ -1352,7 +1352,7 @@ archive_read_disk_open(struct archive *_
 }
 
 int
-archive_read_disk_open_w(struct archive *_a, const wchar_t *pathname)
+archive_read_disk_open_w(struct archive *_a, const char *pathname)
 {
 	struct archive_read_disk *a = (struct archive_read_disk *)_a;
 
@@ -1365,7 +1365,7 @@ archive_read_disk_open_w(struct archive
 }
 
 static int
-_archive_read_disk_open_w(struct archive *_a, const wchar_t *pathname)
+_archive_read_disk_open_w(struct archive *_a, const char *pathname)
 {
 	struct archive_read_disk *a = (struct archive_read_disk *)_a;
 
@@ -1480,11 +1480,11 @@ archive_read_disk_current_filesystem_is_
  * If symlink is broken, statfs or statvfs will fail.
  * Use its directory path instead.
  */
-static wchar_t *
+static char *
 safe_path_for_statfs(struct tree *t)
 {
-	const wchar_t *path;
-	wchar_t *cp, *p = NULL;
+	const char *path;
+	char *cp, *p = NULL;
 
 	path = tree_current_access_path(t);
 	if (tree_current_stat(t) == NULL) {
@@ -1507,8 +1507,8 @@ static int
 setup_current_filesystem(struct archive_read_disk *a)
 {
 	struct tree *t = a->tree;
-	wchar_t vol[256];
-	wchar_t *path;
+	char vol[256];
+	char *path;
 
 	t->current_filesystem->synthetic = -1;/* Not supported */
 	path = safe_path_for_statfs(t);
@@ -1584,7 +1584,7 @@ close_and_restore_time(HANDLE h, struct
  * Add a directory path to the current stack.
  */
 static void
-tree_push(struct tree *t, const wchar_t *path, const wchar_t *full_path,
+tree_push(struct tree *t, const char *path, const char *full_path,
     int filesystem_id, int64_t dev, int64_t ino, struct restore_time *rt)
 {
 	struct tree_entry *te;
@@ -1617,7 +1617,7 @@ tree_push(struct tree *t, const wchar_t
  * Append a name to the current dir path.
  */
 static void
-tree_append(struct tree *t, const wchar_t *name, size_t name_length)
+tree_append(struct tree *t, const char *name, size_t name_length)
 {
 	size_t size_needed;
 
@@ -1654,7 +1654,7 @@ tree_append(struct tree *t, const wchar_
  * Open a directory tree for traversal.
  */
 static struct tree *
-tree_open(const wchar_t *path, int symlink_mode, int restore_time)
+tree_open(const char *path, int symlink_mode, int restore_time)
 {
 	struct tree *t;
 
@@ -1667,10 +1667,10 @@ tree_open(const wchar_t *path, int symli
 }
 
 static struct tree *
-tree_reopen(struct tree *t, const wchar_t *path, int restore_time)
+tree_reopen(struct tree *t, const char *path, int restore_time)
 {
 	struct archive_wstring ws;
-	wchar_t *pathname, *p, *base;
+	char *pathname, *p, *base;
 
 	t->flags = (restore_time != 0)?needsRestoreTimes:0;
 	t->visit_type = 0;
@@ -1689,7 +1689,7 @@ tree_reopen(struct tree *t, const wchar_
 	t->entry_remaining_bytes = 0;
 	t->initial_filesystem_id = -1;
 
-	/* Get wchar_t strings from char strings. */
+	/* Get char strings from char strings. */
 	archive_string_init(&ws);
 	archive_wstrcpy(&ws, path);
 	pathname = ws.s;
@@ -1834,7 +1834,7 @@ tree_next(struct tree *t)
 		}
 
 		if (t->stack->flags & needsFirstVisit) {
-			wchar_t *d = t->stack->name.s;
+			char *d = t->stack->name.s;
 			t->stack->flags &= ~needsFirstVisit;
 			if (!(d[0] == L'/' && d[1] == L'/' &&
 			      d[2] == L'?' && d[3] == L'/') &&
@@ -1877,7 +1877,7 @@ tree_next(struct tree *t)
 			return (t->visit_type);
 		} else if (t->stack->flags & needsOpen) {
 			t->stack->flags &= ~needsOpen;
-			r = tree_dir_next_windows(t, L"*");
+			r = tree_dir_next_windows(t, "*");
 			if (r == 0)
 				continue;
 			return (r);
@@ -1898,9 +1898,9 @@ tree_next(struct tree *t)
 }
 
 static int
-tree_dir_next_windows(struct tree *t, const wchar_t *pattern)
+tree_dir_next_windows(struct tree *t, const char *pattern)
 {
-	const wchar_t *name;
+	const char *name;
 	size_t namelen;
 	int r;
 
@@ -1967,7 +1967,7 @@ fileTimeToUtc(const FILETIME *filetime,
 }
 
 static void
-entry_copy_bhfi(struct archive_entry *entry, const wchar_t *path,
+entry_copy_bhfi(struct archive_entry *entry, const char *path,
 	const WIN32_FIND_DATAW *findData,
 	const BY_HANDLE_FILE_INFORMATION *bhfi)
 {
@@ -2006,7 +2006,7 @@ entry_copy_bhfi(struct archive_entry *en
 	} else if (bhfi->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
 		mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
 	else {
-		const wchar_t *p;
+		const char *p;
 
 		mode |= S_IFREG;
 		p = wcsrchr(path, L'.');
@@ -2152,7 +2152,7 @@ tree_target_is_same_as_parent(struct tre
 /*
  * Return the access path for the entry just returned from tree_next().
  */
-static const wchar_t *
+static const char *
 tree_current_access_path(struct tree *t)
 {
 	return (t->full_path.s);
@@ -2161,7 +2161,7 @@ tree_current_access_path(struct tree *t)
 /*
  * Return the full path for the entry just returned from tree_next().
  */
-static const wchar_t *
+static const char *
 tree_current_path(struct tree *t)
 {
 	return (t->path.s);
@@ -2223,8 +2223,8 @@ archive_read_disk_entry_from_file(struct
     struct archive_entry *entry, int fd, const struct stat *st)
 {
 	struct archive_read_disk *a = (struct archive_read_disk *)_a;
-	const wchar_t *path;
-	const wchar_t *wname;
+	const char *path;
+	const char *wname;
 	const char *name;
 	HANDLE h;
 	BY_HANDLE_FILE_INFORMATION bhfi;
diff -urp a/Utilities/cmlibarchive/libarchive/archive_read_open_filename.c b/Utilities/cmlibarchive/libarchive/archive_read_open_filename.c
--- a/Utilities/cmlibarchive/libarchive/archive_read_open_filename.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_read_open_filename.c	2021-02-11 18:43:34.452529383 +0330
@@ -79,7 +79,7 @@ struct read_file_data {
 	enum fnt_e { FNT_STDIN, FNT_MBS, FNT_WCS } filename_type;
 	union {
 		char	 m[1];/* MBS filename. */
-		wchar_t	 w[1];/* WCS filename. */
+		char	 w[1];/* WCS filename. */
 	} filename; /* Must be last! */
 };
 
@@ -156,11 +156,11 @@ no_memory:
 }
 
 int
-archive_read_open_filename_w(struct archive *a, const wchar_t *wfilename,
+archive_read_open_filename_w(struct archive *a, const char *wfilename,
     size_t block_size)
 {
 	struct read_file_data *mine = (struct read_file_data *)calloc(1,
-		sizeof(*mine) + wcslen(wfilename) * sizeof(wchar_t));
+		sizeof(*mine) + wcslen(wfilename) * sizeof(char));
 	if (!mine)
 	{
 		archive_set_error(a, ENOMEM, "No memory");
@@ -177,8 +177,8 @@ archive_read_open_filename_w(struct arch
 		wcscpy(mine->filename.w, wfilename);
 #else
 		/*
-		 * POSIX system does not support a wchar_t interface for
-		 * open() system call, so we have to translate a wchar_t
+		 * POSIX system does not support a char interface for
+		 * open() system call, so we have to translate a char
 		 * filename to multi-byte one and use it.
 		 */
 		struct archive_string fn;
@@ -221,7 +221,7 @@ file_open(struct archive *a, void *clien
 	struct read_file_data *mine = (struct read_file_data *)client_data;
 	void *buffer;
 	const char *filename = NULL;
-	const wchar_t *wfilename = NULL;
+	const char *wfilename = NULL;
 	int fd = -1;
 	int is_disk_like = 0;
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
@@ -262,7 +262,7 @@ file_open(struct archive *a, void *clien
 		wfilename = mine->filename.w;
 		fd = _wopen(wfilename, O_RDONLY | O_BINARY);
 		if (fd < 0 && errno == ENOENT) {
-			wchar_t *fullpath;
+			char *fullpath;
 			fullpath = __la_win_permissive_name_w(wfilename);
 			if (fullpath != NULL) {
 				fd = _wopen(fullpath, O_RDONLY | O_BINARY);
diff -urp a/Utilities/cmlibarchive/libarchive/archive_read_support_format_7zip.c b/Utilities/cmlibarchive/libarchive/archive_read_support_format_7zip.c
--- a/Utilities/cmlibarchive/libarchive/archive_read_support_format_7zip.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_read_support_format_7zip.c	2021-02-11 18:43:34.365861350 +0330
@@ -184,7 +184,7 @@ struct _7zip_entry {
 	size_t			 name_len;
 	unsigned char		*utf16name;
 #if defined(_WIN32) && !defined(__CYGWIN__) && defined(_DEBUG)
-	const wchar_t		*wname;
+	const char		*wname;
 #endif
 	uint32_t		 folderIndex;
 	uint32_t		 ssIndex;
@@ -2514,7 +2514,7 @@ read_Header(struct archive_read *a, stru
 			for (i = 0; i < zip->numFiles; i++) {
 				entries[i].utf16name = np;
 #if defined(_WIN32) && !defined(__CYGWIN__) && defined(_DEBUG)
-				entries[i].wname = (wchar_t *)np;
+				entries[i].wname = (char *)np;
 #endif
 
 				/* Find a terminator. */
diff -urp a/Utilities/cmlibarchive/libarchive/archive_read_support_format_cab.c b/Utilities/cmlibarchive/libarchive/archive_read_support_format_cab.c
--- a/Utilities/cmlibarchive/libarchive/archive_read_support_format_cab.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_read_support_format_cab.c	2021-02-11 18:43:34.445862611 +0330
@@ -596,7 +596,7 @@ cab_convert_path_separator_1(struct arch
 static void
 cab_convert_path_separator_2(struct cab *cab, struct archive_entry *entry)
 {
-	const wchar_t *wp;
+	const char *wp;
 	size_t i;
 
 	/* If a conversion to wide character failed, force the replacement. */
diff -urp a/Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c b/Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c
--- a/Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c	2021-02-11 18:43:34.455862768 +0330
@@ -482,7 +482,7 @@ archive_read_format_lha_read_header(stru
 	const char *signature;
 	int err;
 	struct archive_mstring conv_buffer;
-	const wchar_t *conv_buffer_p;
+	const char *conv_buffer_p;
 
 	lha_crc16_init();
 
@@ -753,7 +753,7 @@ archive_read_format_lha_read_header(stru
 static void
 lha_replace_path_separator(struct lha *lha, struct archive_entry *entry)
 {
-	const wchar_t *wp;
+	const char *wp;
 	size_t i;
 
 	if ((wp = archive_entry_pathname_w(entry)) != NULL) {
@@ -1695,7 +1695,7 @@ static int
 lha_parse_linkname(struct archive_wstring *linkname,
     struct archive_wstring *pathname)
 {
-	wchar_t *	linkptr;
+	char *	linkptr;
 	size_t 	symlen;
 
 	linkptr = wcschr(pathname->s, L'|');
diff -urp a/Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c b/Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c
--- a/Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c	2021-02-11 18:43:34.399195209 +0330
@@ -511,7 +511,7 @@ archive_read_format_tar_read_header(stru
 	static int default_dev;
 	struct tar *tar;
 	const char *p;
-	const wchar_t *wp;
+	const char *wp;
 	int r;
 	size_t l, unconsumed = 0;
 
@@ -1398,7 +1398,7 @@ read_mac_metadata_blob(struct archive_re
 	int64_t size;
 	const void *data;
 	const char *p, *name;
-	const wchar_t *wp, *wname;
+	const char *wp, *wname;
 
 	(void)h; /* UNUSED */
 
diff -urp a/Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c b/Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c
--- a/Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c	2021-02-11 18:43:34.375861508 +0330
@@ -908,7 +908,7 @@ zip_read_local_file_header(struct archiv
 {
 	const char *p;
 	const void *h;
-	const wchar_t *wp;
+	const char *wp;
 	const char *cp;
 	size_t len, filename_length, extra_length;
 	struct archive_string_conv *sconv;
diff -urp a/Utilities/cmlibarchive/libarchive/archive_string.c b/Utilities/cmlibarchive/libarchive/archive_string.c
--- a/Utilities/cmlibarchive/libarchive/archive_string.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_string.c	2021-02-11 18:43:34.372528122 +0330
@@ -68,11 +68,11 @@ __FBSDID("$FreeBSD: head/lib/libarchive/
 #include "archive_string_composition.h"
 
 #if !defined(HAVE_WMEMCPY) && !defined(wmemcpy)
-#define wmemcpy(a,b,i)  (wchar_t *)memcpy((a), (b), (i) * sizeof(wchar_t))
+#define wmemcpy(a,b,i)  (char *)memcpy((a), (b), (i) * sizeof(char))
 #endif
 
 #if !defined(HAVE_WMEMMOVE) && !defined(wmemmove)
-#define wmemmove(a,b,i)  (wchar_t *)memmove((a), (b), (i) * sizeof(wchar_t))
+#define wmemmove(a,b,i)  (char *)memmove((a), (b), (i) * sizeof(char))
 #endif
 
 #undef max
@@ -154,7 +154,7 @@ static int archive_wstring_append_from_m
     struct archive_wstring *, const char *, size_t,
     struct archive_string_conv *);
 static int archive_string_append_from_wcs_in_codepage(struct archive_string *,
-    const wchar_t *, size_t, struct archive_string_conv *);
+    const char *, size_t, struct archive_string_conv *);
 static int is_big_endian(void);
 static int strncat_in_codepage(struct archive_string *, const void *,
     size_t, struct archive_string_conv *);
@@ -213,7 +213,7 @@ archive_string_append(struct archive_str
 }
 
 static struct archive_wstring *
-archive_wstring_append(struct archive_wstring *as, const wchar_t *p, size_t s)
+archive_wstring_append(struct archive_wstring *as, const char *p, size_t s)
 {
 	if (archive_wstring_ensure(as, as->length + s + 1) == NULL)
 		return (NULL);
@@ -268,7 +268,7 @@ archive_wstring_ensure(struct archive_ws
 {
 	return (struct archive_wstring *)
 		archive_string_ensure((struct archive_string *)as,
-					s * sizeof(wchar_t));
+					s * sizeof(char));
 }
 
 /* Returns NULL on any allocation failure. */
@@ -355,10 +355,10 @@ archive_strncat(struct archive_string *a
 }
 
 struct archive_wstring *
-archive_wstrncat(struct archive_wstring *as, const wchar_t *p, size_t n)
+archive_wstrncat(struct archive_wstring *as, const char *p, size_t n)
 {
 	size_t s;
-	const wchar_t *pp;
+	const char *pp;
 
 	/* Like strlen(p), except won't examine positions beyond p[n]. */
 	s = 0;
@@ -385,7 +385,7 @@ archive_strcat(struct archive_string *as
 }
 
 struct archive_wstring *
-archive_wstrcat(struct archive_wstring *as, const wchar_t *p)
+archive_wstrcat(struct archive_wstring *as, const char *p)
 {
 	/* Ditto. */
 	return archive_wstrncat(as, p, 0x1000000);
@@ -400,7 +400,7 @@ archive_strappend_char(struct archive_st
 }
 
 struct archive_wstring *
-archive_wstrappend_wchar(struct archive_wstring *as, wchar_t c)
+archive_wstrappend_wchar(struct archive_wstring *as, char c)
 {
 	if ((as = archive_wstring_append(as, &c, 1)) == NULL)
 		__archive_errx(1, "Out of memory");
@@ -463,7 +463,7 @@ archive_wstring_append_from_mbs_in_codep
 		/*
 		 * "C" locale special processing.
 		 */
-		wchar_t *ws;
+		char *ws;
 		const unsigned char *mp;
 
 		if (NULL == archive_wstring_ensure(dest,
@@ -474,14 +474,14 @@ archive_wstring_append_from_mbs_in_codep
 		mp = (const unsigned char *)s;
 		count = 0;
 		while (count < (int)length && *mp) {
-			*ws++ = (wchar_t)*mp++;
+			*ws++ = (char)*mp++;
 			count++;
 		}
 	} else if (sc != NULL &&
 	    (sc->flag & (SCONV_NORMALIZATION_C | SCONV_NORMALIZATION_D))) {
 		/*
 		 * Normalize UTF-8 and UTF-16BE and convert it directly
-		 * to UTF-16 as wchar_t.
+		 * to UTF-16 as char.
 		 */
 		struct archive_string u16;
 		int saved_flag = sc->flag;/* save current flag. */
@@ -511,7 +511,7 @@ archive_wstring_append_from_mbs_in_codep
 			ret = archive_string_normalize_C(&u16, s, count, sc);
 		else
 			ret = archive_string_normalize_D(&u16, s, count, sc);
-		dest->s = (wchar_t *)u16.s;
+		dest->s = (char *)u16.s;
 		dest->length = u16.length >> 1;
 		dest->buffer_length = u16.buffer_length;
 		sc->flag = saved_flag;/* restore the saved flag. */
@@ -523,7 +523,7 @@ archive_wstring_append_from_mbs_in_codep
 		if (NULL == archive_wstring_ensure(dest,
 		    dest->length + count + 1))
 			return (-1);
-		wmemcpy(dest->s + dest->length, (const wchar_t *)s, count);
+		wmemcpy(dest->s + dest->length, (const char *)s, count);
 		if ((sc->flag & SCONV_FROM_UTF16BE) && !is_big_endian()) {
 			uint16_t *u16 = (uint16_t *)(dest->s + dest->length);
 			int b;
@@ -597,7 +597,7 @@ archive_wstring_append_from_mbs(struct a
 	// size_t wcs_length = len;
 	size_t mbs_length = len;
 	const char *mbs = p;
-	wchar_t *wcs;
+	char *wcs;
 #if HAVE_MBRTOWC
 	mbstate_t shift_state;
 
@@ -668,14 +668,14 @@ archive_wstring_append_from_mbs(struct a
  */
 int
 archive_string_append_from_wcs(struct archive_string *as,
-    const wchar_t *w, size_t len)
+    const char *w, size_t len)
 {
 	return archive_string_append_from_wcs_in_codepage(as, w, len, NULL);
 }
 
 static int
 archive_string_append_from_wcs_in_codepage(struct archive_string *as,
-    const wchar_t *ws, size_t len, struct archive_string_conv *sc)
+    const char *ws, size_t len, struct archive_string_conv *sc)
 {
 	BOOL defchar_used, *dp;
 	int count, ret = 0;
@@ -691,7 +691,7 @@ archive_string_append_from_wcs_in_codepa
 		/*
 		 * "C" locale special processing.
 		 */
-		const wchar_t *wp = ws;
+		const char *wp = ws;
 		char *p;
 
 		if (NULL == archive_string_ensure(as,
@@ -773,7 +773,7 @@ archive_string_append_from_wcs_in_codepa
  */
 int
 archive_string_append_from_wcs(struct archive_string *as,
-    const wchar_t *w, size_t len)
+    const char *w, size_t len)
 {
 	/* We cannot use the standard wcstombs() here because it
 	 * cannot tell us how big the output buffer should be.  So
@@ -847,7 +847,7 @@ archive_string_append_from_wcs(struct ar
  */
 int
 archive_string_append_from_wcs(struct archive_string *as,
-    const wchar_t *w, size_t len)
+    const char *w, size_t len)
 {
 	(void)as;/* UNUSED */
 	(void)w;/* UNUSED */
@@ -1846,7 +1846,7 @@ archive_string_conversion_set_opt(struct
 	switch (opt) {
 	/*
 	 * A filename in UTF-8 was made with libarchive 2.x in a wrong
-	 * assumption that wchar_t was Unicode.
+	 * assumption that char was Unicode.
 	 * This option enables simulating the assumption in order to read
 	 * that filename correctly.
 	 */
@@ -1854,7 +1854,7 @@ archive_string_conversion_set_opt(struct
 #if (defined(_WIN32) && !defined(__CYGWIN__)) \
 	 || defined(__STDC_ISO_10646__) || defined(__APPLE__)
 		/*
-		 * Nothing to do for it since wchar_t on these platforms
+		 * Nothing to do for it since char on these platforms
 		 * is really Unicode.
 		 */
 		(void)sc; /* UNUSED */
@@ -2194,7 +2194,7 @@ invalid_mbs(const void *_p, size_t n, st
 	mbtowc(NULL, NULL, 0);
 #endif
 	while (n) {
-		wchar_t wc;
+		char wc;
 
 #if HAVE_MBRTOWC
 		r = mbrtowc(&wc, p, n, &shift_state);
@@ -2597,7 +2597,7 @@ unicode_to_utf16be(char *p, size_t remai
 
 	if (uc > 0xffff) {
 		/* We have a code point that won't fit into a
-		 * wchar_t; convert it to a surrogate pair. */
+		 * char; convert it to a surrogate pair. */
 		if (remaining < 4)
 			return (0);
 		uc -= 0x10000;
@@ -2619,7 +2619,7 @@ unicode_to_utf16le(char *p, size_t remai
 
 	if (uc > 0xffff) {
 		/* We have a code point that won't fit into a
-		 * wchar_t; convert it to a surrogate pair. */
+		 * char; convert it to a surrogate pair. */
 		if (remaining < 4)
 			return (0);
 		uc -= 0x10000;
@@ -3445,7 +3445,7 @@ strncat_from_utf8_libarchive2(struct arc
 	p = as->s + as->length;
 	end = as->s + as->buffer_length - MB_CUR_MAX -1;
 	while ((n = _utf8_to_unicode(&unicode, s, len)) != 0) {
-		wchar_t wc;
+		char wc;
 
 		if (p >= end) {
 			as->length = p - as->s;
@@ -3466,7 +3466,7 @@ strncat_from_utf8_libarchive2(struct arc
 			n *= -1;
 			wc = L'?';
 		} else
-			wc = (wchar_t)unicode;
+			wc = (char)unicode;
 
 		s += n;
 		len -= n;
@@ -3935,7 +3935,7 @@ archive_mstring_get_mbs(struct archive *
 
 int
 archive_mstring_get_wcs(struct archive *a, struct archive_mstring *aes,
-    const wchar_t **wp)
+    const char **wp)
 {
 	int r, ret = 0;
 
@@ -4053,7 +4053,7 @@ archive_mstring_copy_mbs_len(struct arch
 }
 
 int
-archive_mstring_copy_wcs(struct archive_mstring *aes, const wchar_t *wcs)
+archive_mstring_copy_wcs(struct archive_mstring *aes, const char *wcs)
 {
 	return archive_mstring_copy_wcs_len(aes, wcs,
 				wcs == NULL ? 0 : wcslen(wcs));
@@ -4074,7 +4074,7 @@ archive_mstring_copy_utf8(struct archive
 }
 
 int
-archive_mstring_copy_wcs_len(struct archive_mstring *aes, const wchar_t *wcs,
+archive_mstring_copy_wcs_len(struct archive_mstring *aes, const char *wcs,
     size_t len)
 {
 	if (wcs == NULL) {
@@ -4120,7 +4120,7 @@ archive_mstring_copy_mbs_len_l(struct ar
 		/*
 		 * This case happens only when MultiByteToWideChar() cannot
 		 * handle sc->from_cp, and we have to iconv in order to
-		 * translate character-set to wchar_t,UTF-16.
+		 * translate character-set to char,UTF-16.
 		 */
 		iconv_t cd = sc->cd;
 		unsigned from_cp;
diff -urp a/Utilities/cmlibarchive/libarchive/archive_string.h b/Utilities/cmlibarchive/libarchive/archive_string.h
--- a/Utilities/cmlibarchive/libarchive/archive_string.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_string.h	2021-02-11 18:43:34.445862611 +0330
@@ -37,7 +37,7 @@
 
 #include <stdarg.h>
 #ifdef HAVE_STDLIB_H
-#include <stdlib.h>  /* required for wchar_t on some systems */
+#include <stdlib.h>  /* required for char on some systems */
 #endif
 #ifdef HAVE_STRING_H
 #include <string.h>
@@ -62,7 +62,7 @@ struct archive_string {
 };
 
 struct archive_wstring {
-	wchar_t	*s;  /* Pointer to the storage */
+	char	*s;  /* Pointer to the storage */
 	size_t	 length; /* Length of 's' in characters */
 	size_t	 buffer_length; /* Length of malloc-ed storage in bytes. */
 };
@@ -77,9 +77,9 @@ struct archive_string_conv;
 struct archive_string *
 archive_strappend_char(struct archive_string *, char);
 
-/* Ditto for a wchar_t and an archive_wstring. */
+/* Ditto for a char and an archive_wstring. */
 struct archive_wstring *
-archive_wstrappend_wchar(struct archive_wstring *, wchar_t);
+archive_wstrappend_wchar(struct archive_wstring *, char);
 
 /* Append a raw array to an archive_string, resizing as necessary */
 struct archive_string *
@@ -88,7 +88,7 @@ archive_array_append(struct archive_stri
 /* Convert a Unicode string to current locale and append the result. */
 /* Returns -1 if conversion fails. */
 int
-archive_string_append_from_wcs(struct archive_string *, const wchar_t *, size_t);
+archive_string_append_from_wcs(struct archive_string *, const char *, size_t);
 
 
 /* Create a string conversion object.
@@ -155,13 +155,13 @@ archive_wstring_ensure(struct archive_ws
 struct archive_string *
 archive_strncat(struct archive_string *, const void *, size_t);
 struct archive_wstring *
-archive_wstrncat(struct archive_wstring *, const wchar_t *, size_t);
+archive_wstrncat(struct archive_wstring *, const char *, size_t);
 
 /* Append a C string to an archive_string, resizing as necessary. */
 struct archive_string *
 archive_strcat(struct archive_string *, const void *);
 struct archive_wstring *
-archive_wstrcat(struct archive_wstring *, const wchar_t *);
+archive_wstrcat(struct archive_wstring *, const char *);
 
 /* Copy a C string to an archive_string, resizing as necessary. */
 #define	archive_strcpy(as,p) \
@@ -225,16 +225,16 @@ void	archive_mstring_clean(struct archiv
 void	archive_mstring_copy(struct archive_mstring *dest, struct archive_mstring *src);
 int archive_mstring_get_mbs(struct archive *, struct archive_mstring *, const char **);
 int archive_mstring_get_utf8(struct archive *, struct archive_mstring *, const char **);
-int archive_mstring_get_wcs(struct archive *, struct archive_mstring *, const wchar_t **);
+int archive_mstring_get_wcs(struct archive *, struct archive_mstring *, const char **);
 int	archive_mstring_get_mbs_l(struct archive_mstring *, const char **,
 	    size_t *, struct archive_string_conv *);
 int	archive_mstring_copy_mbs(struct archive_mstring *, const char *mbs);
 int	archive_mstring_copy_mbs_len(struct archive_mstring *, const char *mbs,
 	    size_t);
 int	archive_mstring_copy_utf8(struct archive_mstring *, const char *utf8);
-int	archive_mstring_copy_wcs(struct archive_mstring *, const wchar_t *wcs);
+int	archive_mstring_copy_wcs(struct archive_mstring *, const char *wcs);
 int	archive_mstring_copy_wcs_len(struct archive_mstring *,
-	    const wchar_t *wcs, size_t);
+	    const char *wcs, size_t);
 int	archive_mstring_copy_mbs_len_l(struct archive_mstring *,
 	    const char *mbs, size_t, struct archive_string_conv *);
 int     archive_mstring_update_utf8(struct archive *, struct archive_mstring *aes, const char *utf8);
diff -urp a/Utilities/cmlibarchive/libarchive/archive_string_sprintf.c b/Utilities/cmlibarchive/libarchive/archive_string_sprintf.c
--- a/Utilities/cmlibarchive/libarchive/archive_string_sprintf.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_string_sprintf.c	2021-02-11 18:43:34.449195998 +0330
@@ -95,7 +95,7 @@ archive_string_vsprintf(struct archive_s
 	intmax_t s; /* Signed integer temp. */
 	uintmax_t u; /* Unsigned integer temp. */
 	const char *p, *p2;
-	const wchar_t *pw;
+	const char *pw;
 
 	if (archive_string_ensure(as, 64) == NULL)
 		__archive_errx(1, "Out of memory");
@@ -145,9 +145,9 @@ archive_string_vsprintf(struct archive_s
 		case 's':
 			switch(long_flag) {
 			case 'l':
-				pw = va_arg(ap, wchar_t *);
+				pw = va_arg(ap, char *);
 				if (pw == NULL)
-					pw = L"(null)";
+					pw = "(null)";
 				if (archive_string_append_from_wcs(as, pw,
 				    wcslen(pw)) != 0 && errno == ENOMEM)
 					__archive_errx(1, "Out of memory");
@@ -161,9 +161,9 @@ archive_string_vsprintf(struct archive_s
 			}
 			break;
 		case 'S':
-			pw = va_arg(ap, wchar_t *);
+			pw = va_arg(ap, char *);
 			if (pw == NULL)
-				pw = L"(null)";
+				pw = "(null)";
 			if (archive_string_append_from_wcs(as, pw,
 			    wcslen(pw)) != 0 && errno == ENOMEM)
 				__archive_errx(1, "Out of memory");
diff -urp a/Utilities/cmlibarchive/libarchive/archive_util.c b/Utilities/cmlibarchive/libarchive/archive_util.c
--- a/Utilities/cmlibarchive/libarchive/archive_util.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_util.c	2021-02-11 18:43:34.399195209 +0330
@@ -219,11 +219,11 @@ __archive_errx(int retvalue, const char
  * are not secure.
  */
 static int
-__archive_mktempx(const char *tmpdir, wchar_t *template)
+__archive_mktempx(const char *tmpdir, char *template)
 {
-	static const wchar_t prefix[] = L"libarchive_";
-	static const wchar_t suffix[] = L"XXXXXXXXXX";
-	static const wchar_t num[] = {
+	static const char prefix[] = "libarchive_";
+	static const char suffix[] = "XXXXXXXXXX";
+	static const char num[] = {
 		L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7',
 		L'8', L'9', L'A', L'B', L'C', L'D', L'E', L'F',
 		L'G', L'H', L'I', L'J', L'K', L'L', L'M', L'N',
@@ -235,9 +235,9 @@ __archive_mktempx(const char *tmpdir, wc
 	};
 	HCRYPTPROV hProv;
 	struct archive_wstring temp_name;
-	wchar_t *ws;
+	char *ws;
 	DWORD attr;
-	wchar_t *xp, *ep;
+	char *xp, *ep;
 	int fd;
 
 	hProv = (HCRYPTPROV)NULL;
@@ -250,14 +250,14 @@ __archive_mktempx(const char *tmpdir, wc
 		/* Get a temporary directory. */
 		if (tmpdir == NULL) {
 			size_t l;
-			wchar_t *tmp;
+			char *tmp;
 
 			l = GetTempPathW(0, NULL);
 			if (l == 0) {
 				la_dosmaperr(GetLastError());
 				goto exit_tmpfile;
 			}
-			tmp = malloc(l*sizeof(wchar_t));
+			tmp = malloc(l*sizeof(char));
 			if (tmp == NULL) {
 				errno = ENOMEM;
 				goto exit_tmpfile;
@@ -321,12 +321,12 @@ __archive_mktempx(const char *tmpdir, wc
 	}
 
 	for (;;) {
-		wchar_t *p;
+		char *p;
 		HANDLE h;
 
 		/* Generate a random file name through CryptGenRandom(). */
 		p = xp;
-		if (!CryptGenRandom(hProv, (DWORD)(ep - p)*sizeof(wchar_t),
+		if (!CryptGenRandom(hProv, (DWORD)(ep - p)*sizeof(char),
 		    (BYTE*)p)) {
 			la_dosmaperr(GetLastError());
 			goto exit_tmpfile;
@@ -386,7 +386,7 @@ __archive_mktemp(const char *tmpdir)
 }
 
 int
-__archive_mkstemp(wchar_t *template)
+__archive_mkstemp(char *template)
 {
 	return __archive_mktempx(NULL, template);
 }
diff -urp a/Utilities/cmlibarchive/libarchive/archive_windows.c b/Utilities/cmlibarchive/libarchive/archive_windows.c
--- a/Utilities/cmlibarchive/libarchive/archive_windows.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_windows.c	2021-02-11 18:43:34.419195524 +0330
@@ -119,15 +119,15 @@ getino(struct ustat *ub)
  * characters.
  * see also http://msdn.microsoft.com/en-us/library/aa365247.aspx
  */
-wchar_t *
+char *
 __la_win_permissive_name(const char *name)
 {
-	wchar_t *wn;
-	wchar_t *ws;
+	char *wn;
+	char *ws;
 	size_t ll;
 
 	ll = strlen(name);
-	wn = malloc((ll + 1) * sizeof(wchar_t));
+	wn = malloc((ll + 1) * sizeof(char));
 	if (wn == NULL)
 		return (NULL);
 	ll = mbstowcs(wn, name, ll);
@@ -141,11 +141,11 @@ __la_win_permissive_name(const char *nam
 	return (ws);
 }
 
-wchar_t *
-__la_win_permissive_name_w(const wchar_t *wname)
+char *
+__la_win_permissive_name_w(const char *wname)
 {
-	wchar_t *wn, *wnp;
-	wchar_t *ws, *wsp;
+	char *wn, *wnp;
+	char *ws, *wsp;
 	DWORD l, len, slen;
 	int unc;
 
@@ -158,7 +158,7 @@ __la_win_permissive_name_w(const wchar_t
 	 * have to add three to the size to allocate a sufficient buffer
 	 * size for the full-pathname of the file name. */
 	l += 3;
-	wnp = malloc(l * sizeof(wchar_t));
+	wnp = malloc(l * sizeof(char));
 	if (wnp == NULL)
 		return (NULL);
 	len = GetFullPathNameW(wname, l, wnp, NULL);
@@ -181,13 +181,13 @@ __la_win_permissive_name_w(const wchar_t
 
 	unc = 0;
 	if (wnp[0] == L'\\' && wnp[1] == L'\\' && wnp[2] != L'\\') {
-		wchar_t *p = &wnp[2];
+		char *p = &wnp[2];
 
 		/* Skip server-name letters. */
 		while (*p != L'\\' && *p != L'\0')
 			++p;
 		if (*p == L'\\') {
-			wchar_t *rp = ++p;
+			char *rp = ++p;
 			/* Skip share-name letters. */
 			while (*p != L'\\' && *p != L'\0')
 				++p;
@@ -202,18 +202,18 @@ __la_win_permissive_name_w(const wchar_t
 	}
 
 	slen = 4 + (unc * 4) + len + 1;
-	ws = wsp = malloc(slen * sizeof(wchar_t));
+	ws = wsp = malloc(slen * sizeof(char));
 	if (ws == NULL) {
 		free(wn);
 		return (NULL);
 	}
 	/* prepend "\\?\" */
-	wcsncpy(wsp, L"\\\\?\\", 4);
+	wcsncpy(wsp, "\\\\?\\", 4);
 	wsp += 4;
 	slen -= 4;
 	if (unc) {
 		/* append "UNC\" ---> "\\?\UNC\" */
-		wcsncpy(wsp, L"UNC\\", 4);
+		wcsncpy(wsp, "UNC\\", 4);
 		wsp += 4;
 		slen -= 4;
 	}
@@ -232,7 +232,7 @@ la_CreateFile(const char *path, DWORD dw
     LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition,
     DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
 {
-	wchar_t *wpath;
+	char *wpath;
 	HANDLE handle;
 
 	handle = CreateFileA(path, dwDesiredAccess, dwShareMode,
@@ -291,7 +291,7 @@ int
 __la_open(const char *path, int flags, ...)
 {
 	va_list ap;
-	wchar_t *ws;
+	char *ws;
 	int r, pmode;
 	DWORD attr;
 
@@ -683,9 +683,9 @@ __la_write(int fd, const void *buf, size
  * Replace the Windows path separator '\' with '/'.
  */
 static int
-replace_pathseparator(struct archive_wstring *ws, const wchar_t *wp)
+replace_pathseparator(struct archive_wstring *ws, const char *wp)
 {
-	wchar_t *w;
+	char *w;
 	size_t path_length;
 
 	if (wp == NULL)
@@ -707,7 +707,7 @@ static int
 fix_pathseparator(struct archive_entry *entry)
 {
 	struct archive_wstring ws;
-	const wchar_t *wp;
+	const char *wp;
 	int ret = ARCHIVE_OK;
 
 	archive_string_init(&ws);
@@ -749,7 +749,7 @@ struct archive_entry *
 __la_win_entry_in_posix_pathseparator(struct archive_entry *entry)
 {
 	struct archive_entry *entry_main;
-	const wchar_t *wp;
+	const char *wp;
 	int has_backslash = 0;
 	int ret;
 
diff -urp a/Utilities/cmlibarchive/libarchive/archive_windows.h b/Utilities/cmlibarchive/libarchive/archive_windows.h
--- a/Utilities/cmlibarchive/libarchive/archive_windows.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_windows.h	2021-02-11 18:43:34.439195839 +0330
@@ -288,8 +288,8 @@ extern ssize_t	 __la_write(int fd, const
 #define WIFEXITED(sts)		((sts & 0x100) == 0)
 #define WEXITSTATUS(sts)	(sts & 0x0FF)
 
-extern wchar_t *__la_win_permissive_name(const char *name);
-extern wchar_t *__la_win_permissive_name_w(const wchar_t *wname);
+extern char *__la_win_permissive_name(const char *name);
+extern char *__la_win_permissive_name_w(const char *wname);
 extern void __la_dosmaperr(unsigned long e);
 #define la_dosmaperr(e) __la_dosmaperr(e)
 extern struct archive_entry *__la_win_entry_in_posix_pathseparator(
@@ -297,7 +297,7 @@ extern struct archive_entry *__la_win_en
 
 #if defined(HAVE_WCRTOMB) && defined(__BORLANDC__)
 typedef int mbstate_t;
-size_t wcrtomb(char *, wchar_t, mbstate_t *);
+size_t wcrtomb(char *, char, mbstate_t *);
 #endif
 
 #if defined(_MSC_VER) && _MSC_VER < 1300
diff -urp a/Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c b/Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c
--- a/Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c	2021-02-12 14:39:59.857852509 +0330
@@ -2978,7 +2978,7 @@ check_symlinks(struct archive_write_disk
 static void
 cleanup_pathname_win(char *path)
 {
-	wchar_t wc;
+	char wc;
 	char *p;
 	size_t alen, l;
 	int mb, complete, utf8;
diff -urp a/Utilities/cmlibarchive/libarchive/archive_write_disk_windows.c b/Utilities/cmlibarchive/libarchive/archive_write_disk_windows.c
--- a/Utilities/cmlibarchive/libarchive/archive_write_disk_windows.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_write_disk_windows.c	2021-02-11 18:43:34.419195524 +0330
@@ -99,7 +99,7 @@ struct fixup_entry {
 	unsigned long		 ctime_nanos;
 	unsigned long		 fflags_set;
 	int			 fixup; /* bitmask of what needs fixing */
-	wchar_t			*name;
+	char			*name;
 };
 
 /*
@@ -163,9 +163,9 @@ struct archive_write_disk {
 
 	/* Information about the object being restored right now. */
 	struct archive_entry	*entry; /* Entry being extracted. */
-	wchar_t			*name; /* Name of entry, possibly edited. */
+	char			*name; /* Name of entry, possibly edited. */
 	struct archive_wstring	 _name_data; /* backing store for 'name' */
-	wchar_t			*tmpname; /* Temporary name */
+	char			*tmpname; /* Temporary name */
 	struct archive_wstring	_tmpname_data; /* backing store for 'tmpname' */
 	/* Tasks remaining for this object. */
 	int			 todo;
@@ -207,31 +207,31 @@ struct archive_write_disk {
 #define	MINIMUM_DIR_MODE 0700
 #define	MAXIMUM_DIR_MODE 0775
 
-static int	disk_unlink(const wchar_t *);
-static int	disk_rmdir(const wchar_t *);
+static int	disk_unlink(const char *);
+static int	disk_rmdir(const char *);
 static int	check_symlinks(struct archive_write_disk *);
 static int	create_filesystem_object(struct archive_write_disk *);
 static struct fixup_entry *current_fixup(struct archive_write_disk *,
-		    const wchar_t *pathname);
+		    const char *pathname);
 static int	cleanup_pathname(struct archive_write_disk *);
-static int	create_dir(struct archive_write_disk *, wchar_t *);
-static int	create_parent_dir(struct archive_write_disk *, wchar_t *);
-static int	la_chmod(const wchar_t *, mode_t);
+static int	create_dir(struct archive_write_disk *, char *);
+static int	create_parent_dir(struct archive_write_disk *, char *);
+static int	la_chmod(const char *, mode_t);
 static int	la_mktemp(struct archive_write_disk *);
 static int	older(BY_HANDLE_FILE_INFORMATION *, struct archive_entry *);
 static int	permissive_name_w(struct archive_write_disk *);
 static int	restore_entry(struct archive_write_disk *);
 static int	set_acls(struct archive_write_disk *, HANDLE h,
-		    const wchar_t *, struct archive_acl *);
+		    const char *, struct archive_acl *);
 static int	set_xattrs(struct archive_write_disk *);
 static int	clear_nochange_fflags(struct archive_write_disk *);
 static int	set_fflags(struct archive_write_disk *);
-static int	set_fflags_platform(const wchar_t *, unsigned long,
+static int	set_fflags_platform(const char *, unsigned long,
 		    unsigned long);
 static int	set_ownership(struct archive_write_disk *);
 static int	set_mode(struct archive_write_disk *, int mode);
 static int	set_times(struct archive_write_disk *, HANDLE, int,
-		    const wchar_t *, time_t, long, time_t, long, time_t,
+		    const char *, time_t, long, time_t, long, time_t,
 		    long, time_t, long);
 static int	set_times_from_entry(struct archive_write_disk *);
 static struct fixup_entry *sort_dir_list(struct fixup_entry *p);
@@ -261,7 +261,7 @@ static ssize_t	_archive_write_disk_data_
     ((((int64_t)(bhfi)->nFileSizeHigh) << 32) + (bhfi)->nFileSizeLow)
 
 static int
-file_information(struct archive_write_disk *a, wchar_t *path,
+file_information(struct archive_write_disk *a, char *path,
     BY_HANDLE_FILE_INFORMATION *st, mode_t *mode, int sim_lstat)
 {
 	HANDLE h;
@@ -273,7 +273,7 @@ file_information(struct archive_write_di
 		h = FindFirstFileW(path, &findData);
 		if (h == INVALID_HANDLE_VALUE &&
 		    GetLastError() == ERROR_INVALID_NAME) {
-			wchar_t *full;
+			char *full;
 			full = __la_win_permissive_name_w(path);
 			h = FindFirstFileW(full, &findData);
 			free(full);
@@ -296,7 +296,7 @@ file_information(struct archive_write_di
 	    OPEN_EXISTING, flag, NULL);
 	if (h == INVALID_HANDLE_VALUE &&
 	    GetLastError() == ERROR_INVALID_NAME) {
-		wchar_t *full;
+		char *full;
 		full = __la_win_permissive_name_w(path);
 		h = CreateFileW(full, 0, 0, NULL,
 		    OPEN_EXISTING, flag, NULL);
@@ -325,7 +325,7 @@ file_information(struct archive_write_di
 	else if (st->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
 		*mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
 	else {
-		const wchar_t *p;
+		const char *p;
 
 		*mode |= S_IFREG;
 		p = wcsrchr(path, L'.');
@@ -364,8 +364,8 @@ file_information(struct archive_write_di
 static int
 permissive_name_w(struct archive_write_disk *a)
 {
-	wchar_t *wn, *wnp;
-	wchar_t *ws, *wsp;
+	char *wn, *wnp;
+	char *ws, *wsp;
 	DWORD l;
 
 	wnp = a->name;
@@ -397,7 +397,7 @@ permissive_name_w(struct archive_write_d
 		archive_wstring_ensure(&(a->_name_data), 4 + wcslen(wn) + 1);
 		a->name = a->_name_data.s;
 		/* Prepend "\\?\" */
-		archive_wstrncpy(&(a->_name_data), L"\\\\?\\", 4);
+		archive_wstrncpy(&(a->_name_data), "\\\\?\\", 4);
 		archive_wstrcat(&(a->_name_data), wn);
 		free(wn);
 		return (0);
@@ -408,13 +408,13 @@ permissive_name_w(struct archive_write_d
 	 * like "\\<server-name>\<share-name>\file". 
 	 */
 	if (wnp[0] == L'\\' && wnp[1] == L'\\' && wnp[2] != L'\\') {
-		const wchar_t *p = &wnp[2];
+		const char *p = &wnp[2];
 
 		/* Skip server-name letters. */
 		while (*p != L'\\' && *p != L'\0')
 			++p;
 		if (*p == L'\\') {
-			const wchar_t *rp = ++p;
+			const char *rp = ++p;
 			/* Skip share-name letters. */
 			while (*p != L'\\' && *p != L'\0')
 				++p;
@@ -429,7 +429,7 @@ permissive_name_w(struct archive_write_d
 				a->name = a->_name_data.s;
 				/* Prepend "\\?\UNC\" */
 				archive_wstrncpy(&(a->_name_data),
-					L"\\\\?\\UNC\\", 8);
+					"\\\\?\\UNC\\", 8);
 				archive_wstrcat(&(a->_name_data), wn+2);
 				free(wn);
 				return (0);
@@ -444,7 +444,7 @@ permissive_name_w(struct archive_write_d
 	l = GetCurrentDirectoryW(0, NULL);
 	if (l == 0)
 		return (-1);
-	ws = malloc(l * sizeof(wchar_t));
+	ws = malloc(l * sizeof(char));
 	l = GetCurrentDirectoryW(l, ws);
 	if (l == 0) {
 		free(ws);
@@ -463,7 +463,7 @@ permissive_name_w(struct archive_write_d
 			4 + 2 + wcslen(wn) + 1);
 		a->name = a->_name_data.s;
 		/* Prepend "\\?\" and drive name. */
-		archive_wstrncpy(&(a->_name_data), L"\\\\?\\", 4);
+		archive_wstrncpy(&(a->_name_data), "\\\\?\\", 4);
 		archive_wstrncat(&(a->_name_data), wsp, 2);
 		archive_wstrcat(&(a->_name_data), wn);
 		free(wsp);
@@ -484,15 +484,15 @@ permissive_name_w(struct archive_write_d
 	}
 	else if (l > 2 && wsp[0] == L'\\' && wsp[1] == L'\\' && wsp[2] != L'\\')
 	{
-		archive_wstrncpy(&(a->_name_data), L"\\\\?\\UNC\\", 8);
+		archive_wstrncpy(&(a->_name_data), "\\\\?\\UNC\\", 8);
 		archive_wstrncat(&(a->_name_data), wsp+2, l-2);
 	}
 	else
 	{
-		archive_wstrncpy(&(a->_name_data), L"\\\\?\\", 4);
+		archive_wstrncpy(&(a->_name_data), "\\\\?\\", 4);
 		archive_wstrncat(&(a->_name_data), wsp, l);
 	}
-	archive_wstrncat(&(a->_name_data), L"\\", 1);
+	archive_wstrncat(&(a->_name_data), "\\", 1);
 	archive_wstrcat(&(a->_name_data), wn);
 	a->name = a->_name_data.s;
 	free(wsp);
@@ -501,11 +501,11 @@ permissive_name_w(struct archive_write_d
 }
 
 static int
-la_chmod(const wchar_t *path, mode_t mode)
+la_chmod(const char *path, mode_t mode)
 {
 	DWORD attr;
 	BOOL r;
-	wchar_t *fullname;
+	char *fullname;
 	int ret = 0;
 
 	fullname = NULL;
@@ -545,7 +545,7 @@ la_mktemp(struct archive_write_disk *a)
 
 	archive_wstring_empty(&(a->_tmpname_data));
 	archive_wstrcpy(&(a->_tmpname_data), a->name);
-	archive_wstrcat(&(a->_tmpname_data), L".XXXXXX");
+	archive_wstrcat(&(a->_tmpname_data), ".XXXXXX");
 	a->tmpname = a->_tmpname_data.s;
 
 	fd = __archive_mkstemp(a->tmpname);
@@ -576,7 +576,7 @@ la_GetFunctionKernel32(const char *name)
 }
 
 static int
-la_CreateHardLinkW(wchar_t *linkname, wchar_t *target)
+la_CreateHardLinkW(char *linkname, char *target)
 {
 	static BOOLEAN (WINAPI *f)(LPWSTR, LPWSTR, LPSECURITY_ATTRIBUTES);
 	static int set;
@@ -598,12 +598,12 @@ la_CreateHardLinkW(wchar_t *linkname, wc
 			 (name[1] == L'N' || name[1] == L'n') &&	\
 			 (name[2] == L'C' || name[2] == L'c') &&	\
 			 name[3] == L'\\')
-		if (!wcsncmp(linkname,L"\\\\?\\", 4)) {
+		if (!wcsncmp(linkname,"\\\\?\\", 4)) {
 			linkname += 4;
 			if (IS_UNC(linkname))
 				linkname += 4;
 		}
-		if (!wcsncmp(target,L"\\\\?\\", 4)) {
+		if (!wcsncmp(target,"\\\\?\\", 4)) {
 			target += 4;
 			if (IS_UNC(target))
 				target += 4;
@@ -621,11 +621,11 @@ la_CreateHardLinkW(wchar_t *linkname, wc
  * the link target
  */
 static int
-la_CreateSymbolicLinkW(const wchar_t *linkname, const wchar_t *target,
+la_CreateSymbolicLinkW(const char *linkname, const char *target,
     int linktype) {
 	static BOOLEAN (WINAPI *f)(LPCWSTR, LPCWSTR, DWORD);
 	static int set;
-	wchar_t *ttarget, *p;
+	char *ttarget, *p;
 	int len;
 	DWORD attrs = 0;
 	DWORD flags = 0;
@@ -648,7 +648,7 @@ la_CreateSymbolicLinkW(const wchar_t *li
 	 * When writing path targets, we need to translate slashes
 	 * to backslashes
 	 */
-	ttarget = malloc((len + 1) * sizeof(wchar_t));
+	ttarget = malloc((len + 1) * sizeof(char));
 	if (ttarget == NULL)
 		return(0);
 
@@ -1381,9 +1381,9 @@ archive_write_disk_new(void)
 }
 
 static int
-disk_unlink(const wchar_t *path)
+disk_unlink(const char *path)
 {
-	wchar_t *fullname;
+	char *fullname;
 	int r;
 
 	r = _wunlink(path);
@@ -1396,9 +1396,9 @@ disk_unlink(const wchar_t *path)
 }
 
 static int
-disk_rmdir(const wchar_t *path)
+disk_rmdir(const char *path)
 {
-	wchar_t *fullname;
+	char *fullname;
 	int r;
 
 	r = _wrmdir(path);
@@ -1450,7 +1450,7 @@ restore_entry(struct archive_write_disk
 
 	if ((en == ENOTDIR || en == ENOENT)
 	    && !(a->flags & ARCHIVE_EXTRACT_NO_AUTODIR)) {
-		wchar_t *full;
+		char *full;
 		/* If the parent dir doesn't exist, try creating it. */
 		create_parent_dir(a, a->name);
 		/* Now try to create the object again. */
@@ -1652,8 +1652,8 @@ static int
 create_filesystem_object(struct archive_write_disk *a)
 {
 	/* Create the entry. */
-	const wchar_t *linkname;
-	wchar_t *fullname;
+	const char *linkname;
+	char *fullname;
 	mode_t final_mode, mode;
 	int r;
 	DWORD attrs = 0;
@@ -1662,7 +1662,7 @@ create_filesystem_object(struct archive_
 	/* Since link(2) and symlink(2) don't handle modes, we're done here. */
 	linkname = archive_entry_hardlink_w(a->entry);
 	if (linkname != NULL) {
-		wchar_t *linkfull, *namefull;
+		char *linkfull, *namefull;
 
 		linkfull = __la_win_permissive_name_w(linkname);
 		namefull = __la_win_permissive_name_w(a->name);
@@ -1736,7 +1736,7 @@ create_filesystem_object(struct archive_
 		return symlink(linkname, a->name) ? errno : 0;
 #else
 		errno = 0;
-		r = la_CreateSymbolicLinkW((const wchar_t *)a->name, linkname,
+		r = la_CreateSymbolicLinkW((const char *)a->name, linkname,
 		    archive_entry_symlink_type(a->entry));
 		if (r == 0) {
 			if (errno == 0)
@@ -2006,7 +2006,7 @@ sort_dir_list(struct fixup_entry *p)
  * structure rather than a simple list of names.
  */
 static struct fixup_entry *
-new_fixup(struct archive_write_disk *a, const wchar_t *pathname)
+new_fixup(struct archive_write_disk *a, const char *pathname)
 {
 	struct fixup_entry *fe;
 
@@ -2025,7 +2025,7 @@ new_fixup(struct archive_write_disk *a,
  * Returns a fixup structure for the current entry.
  */
 static struct fixup_entry *
-current_fixup(struct archive_write_disk *a, const wchar_t *pathname)
+current_fixup(struct archive_write_disk *a, const char *pathname)
 {
 	if (a->current_fixup == NULL)
 		a->current_fixup = new_fixup(a, pathname);
@@ -2044,8 +2044,8 @@ current_fixup(struct archive_write_disk
 static int
 check_symlinks(struct archive_write_disk *a)
 {
-	wchar_t *pn, *p;
-	wchar_t c;
+	char *pn, *p;
+	char c;
 	int r;
 	BY_HANDLE_FILE_INFORMATION st;
 	mode_t st_mode;
@@ -2153,7 +2153,7 @@ check_symlinks(struct archive_write_disk
 }
 
 static int
-guidword(wchar_t *p, int n)
+guidword(char *p, int n)
 {
 	int i;
 
@@ -2177,8 +2177,8 @@ guidword(wchar_t *p, int n)
 static int
 cleanup_pathname(struct archive_write_disk *a)
 {
-	wchar_t *dest, *src, *p, *top;
-	wchar_t separator = L'\0';
+	char *dest, *src, *p, *top;
+	char separator = L'\0';
 
 	p = a->name;
 	if (*p == L'\0') {
@@ -2349,9 +2349,9 @@ cleanup_pathname(struct archive_write_di
  * is already in mutable storage.
  */
 static int
-create_parent_dir(struct archive_write_disk *a, wchar_t *path)
+create_parent_dir(struct archive_write_disk *a, char *path)
 {
-	wchar_t *slash;
+	char *slash;
 	int r;
 
 	/* Remove tail element to obtain parent name. */
@@ -2372,11 +2372,11 @@ create_parent_dir(struct archive_write_d
  * Assumes path is in mutable storage; path is unchanged on exit.
  */
 static int
-create_dir(struct archive_write_disk *a, wchar_t *path)
+create_dir(struct archive_write_disk *a, char *path)
 {
 	BY_HANDLE_FILE_INFORMATION st;
 	struct fixup_entry *le;
-	wchar_t *slash, *base, *full;
+	char *slash, *base, *full;
 	mode_t mode_final, mode, st_mode;
 	int r;
 
@@ -2512,7 +2512,7 @@ set_ownership(struct archive_write_disk
 
 static int
 set_times(struct archive_write_disk *a,
-    HANDLE h, int mode, const wchar_t *name,
+    HANDLE h, int mode, const char *name,
     time_t atime, long atime_nanos,
     time_t birthtime, long birthtime_nanos,
     time_t mtime, long mtime_nanos,
@@ -2533,7 +2533,7 @@ set_times(struct archive_write_disk *a,
 	if (h != INVALID_HANDLE_VALUE) {
 		hw = NULL;
 	} else {
-		wchar_t *ws;
+		char *ws;
 
 		if (S_ISLNK(mode))
 			return (ARCHIVE_OK);
@@ -2695,11 +2695,11 @@ set_mode(struct archive_write_disk *a, i
 	return (r);
 }
 
-static int set_fflags_platform(const wchar_t *name, unsigned long fflags_set,
+static int set_fflags_platform(const char *name, unsigned long fflags_set,
     unsigned long fflags_clear)
 {
 	DWORD oldflags, newflags;
-	wchar_t *fullname;
+	char *fullname;
 
 	const DWORD settable_flags =
 	    FILE_ATTRIBUTE_ARCHIVE |
@@ -2750,7 +2750,7 @@ set_fflags(struct archive_write_disk *a)
 
 /* Default empty function body to satisfy mainline code. */
 static int
-set_acls(struct archive_write_disk *a, HANDLE h, const wchar_t *name,
+set_acls(struct archive_write_disk *a, HANDLE h, const char *name,
 	 struct archive_acl *acl)
 {
 	(void)a; /* UNUSED */
diff -urp a/Utilities/cmlibarchive/libarchive/archive_write_open_filename.c b/Utilities/cmlibarchive/libarchive/archive_write_open_filename.c
--- a/Utilities/cmlibarchive/libarchive/archive_write_open_filename.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_write_open_filename.c	2021-02-11 18:43:34.379194894 +0330
@@ -83,7 +83,7 @@ archive_write_open_filename(struct archi
 }
 
 int
-archive_write_open_filename_w(struct archive *a, const wchar_t *filename)
+archive_write_open_filename_w(struct archive *a, const char *filename)
 {
 
 	if (filename == NULL || filename[0] == L'\0')
@@ -119,7 +119,7 @@ open_filename(struct archive *a, int mbs
 		else
 			archive_set_error(a, ARCHIVE_ERRNO_MISC,
 			    "Can't convert '%S' to MBS",
-			    (const wchar_t *)filename);
+			    (const char *)filename);
 		return (ARCHIVE_FAILED);
 	}
 	mine->fd = -1;
@@ -134,9 +134,9 @@ file_open(struct archive *a, void *clien
 	struct write_file_data *mine;
 	struct stat st;
 #if defined(_WIN32) && !defined(__CYGWIN__)
-	wchar_t *fullpath;
+	char *fullpath;
 #endif
-	const wchar_t *wcs;
+	const char *wcs;
 	const char *mbs;
 
 	mine = (struct write_file_data *)client_data;
diff -urp a/Utilities/cmlibarchive/libarchive/archive_write_set_format_gnutar.c b/Utilities/cmlibarchive/libarchive/archive_write_set_format_gnutar.c
--- a/Utilities/cmlibarchive/libarchive/archive_write_set_format_gnutar.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_write_set_format_gnutar.c	2021-02-11 18:43:34.422528911 +0330
@@ -309,7 +309,7 @@ archive_write_gnutar_header(struct archi
 		 * the client sees the change.
 		 */
 #if defined(_WIN32) && !defined(__CYGWIN__)
-		const wchar_t *wp;
+		const char *wp;
 
 		wp = archive_entry_pathname_w(entry);
 		if (wp != NULL && wp[wcslen(wp) -1] != L'/') {
diff -urp a/Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c b/Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c
--- a/Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c	2021-02-11 18:43:34.419195524 +0330
@@ -4692,7 +4692,7 @@ cleanup_backslash_1(char *p)
 }
 
 static void
-cleanup_backslash_2(wchar_t *p)
+cleanup_backslash_2(char *p)
 {
 
 	/* Convert a path-separator from '\' to  '/' */
@@ -4824,7 +4824,7 @@ isofile_gen_utility_names(struct archive
 	 * Convert a path-separator from '\' to  '/'
 	 */
 	if (cleanup_backslash_1(file->parentdir.s) != 0) {
-		const wchar_t *wp = archive_entry_pathname_w(file->entry);
+		const char *wp = archive_entry_pathname_w(file->entry);
 		struct archive_wstring ws;
 
 		if (wp != NULL) {
@@ -4938,7 +4938,7 @@ isofile_gen_utility_names(struct archive
 		 */
 		if (archive_strlen(&(file->symlink)) > 0 &&
 		    cleanup_backslash_1(file->symlink.s) != 0) {
-			const wchar_t *wp =
+			const char *wp =
 			    archive_entry_symlink_w(file->entry);
 			struct archive_wstring ws;
 
diff -urp a/Utilities/cmlibarchive/libarchive/archive_write_set_format_mtree.c b/Utilities/cmlibarchive/libarchive/archive_write_set_format_mtree.c
--- a/Utilities/cmlibarchive/libarchive/archive_write_set_format_mtree.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_write_set_format_mtree.c	2021-02-11 18:43:34.459196155 +0330
@@ -1702,7 +1702,7 @@ cleanup_backslash_1(char *p)
 }
 
 static void
-cleanup_backslash_2(wchar_t *p)
+cleanup_backslash_2(char *p)
 {
 
 	/* Convert a path-separator from '\' to  '/' */
@@ -1732,7 +1732,7 @@ mtree_entry_setup_filenames(struct archi
 	 * Convert a path-separator from '\' to  '/'
 	 */
 	if (cleanup_backslash_1(file->pathname.s) != 0) {
-		const wchar_t *wp = archive_entry_pathname_w(entry);
+		const char *wp = archive_entry_pathname_w(entry);
 		struct archive_wstring ws;
 
 		if (wp != NULL) {
diff -urp a/Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c b/Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c
--- a/Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c	2021-02-11 18:43:34.369194737 +0330
@@ -653,7 +653,7 @@ archive_write_pax_header(struct archive_
 			 * entry so the client sees the change.
 			 */
 #if defined(_WIN32) && !defined(__CYGWIN__)
-			const wchar_t *wp;
+			const char *wp;
 
 			wp = archive_entry_pathname_w(entry_original);
 			if (wp != NULL && wp[wcslen(wp) -1] != L'/') {
diff -urp a/Utilities/cmlibarchive/libarchive/archive_write_set_format_ustar.c b/Utilities/cmlibarchive/libarchive/archive_write_set_format_ustar.c
--- a/Utilities/cmlibarchive/libarchive/archive_write_set_format_ustar.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_write_set_format_ustar.c	2021-02-11 18:43:34.375861508 +0330
@@ -276,7 +276,7 @@ archive_write_ustar_header(struct archiv
 		 * the client sees the change.
 		 */
 #if defined(_WIN32) && !defined(__CYGWIN__)
-		const wchar_t *wp;
+		const char *wp;
 
 		wp = archive_entry_pathname_w(entry);
 		if (wp != NULL && wp[wcslen(wp) -1] != L'/') {
diff -urp a/Utilities/cmlibarchive/libarchive/archive_write_set_format_v7tar.c b/Utilities/cmlibarchive/libarchive/archive_write_set_format_v7tar.c
--- a/Utilities/cmlibarchive/libarchive/archive_write_set_format_v7tar.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/archive_write_set_format_v7tar.c	2021-02-11 18:43:34.372528122 +0330
@@ -254,7 +254,7 @@ archive_write_v7tar_header(struct archiv
 		 * the client sees the change.
 		 */
 #if defined(_WIN32) && !defined(__CYGWIN__)
-		const wchar_t *wp;
+		const char *wp;
 
 		wp = archive_entry_pathname_w(entry);
 		if (wp != NULL && wp[wcslen(wp) -1] != L'/') {
diff -urp a/Utilities/cmlibarchive/libarchive/libarchive_changes.3 b/Utilities/cmlibarchive/libarchive/libarchive_changes.3
--- a/Utilities/cmlibarchive/libarchive/libarchive_changes.3	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibarchive/libarchive/libarchive_changes.3	2021-02-11 18:43:34.365861350 +0330
@@ -52,7 +52,7 @@ extends the write pipeline with another
 Libarchive2 assumed that the local platform uses
 .Tn Unicode
 as the native
-.Tn wchar_t
+.Tn char
 encoding, which is true on
 .Tn Windows ,
 modern
@@ -63,7 +63,7 @@ systems, since pax format requires
 .Tn UTF-8
 and libarchive 2 incorrectly
 assumed that
-.Tn wchar_t
+.Tn char
 strings can be easily converted to
 .Tn UTF-8 .
 .Pp
diff -urp a/Utilities/cmlibrhash/librhash/rhash.c b/Utilities/cmlibrhash/librhash/rhash.c
--- a/Utilities/cmlibrhash/librhash/rhash.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibrhash/librhash/rhash.c	2021-02-11 18:43:33.965855044 +0330
@@ -380,7 +380,7 @@ RHASH_API int rhash_file(unsigned hash_i
 #ifdef _WIN32 /* windows only function */
 #include <share.h>
 
-RHASH_API int rhash_wfile(unsigned hash_id, const wchar_t* filepath, unsigned char* result)
+RHASH_API int rhash_wfile(unsigned hash_id, const char* filepath, unsigned char* result)
 {
 	FILE* fd;
 	rhash ctx;
@@ -392,7 +392,7 @@ RHASH_API int rhash_wfile(unsigned hash_
 		return -1;
 	}
 
-	if ((fd = _wfsopen(filepath, L"rb", _SH_DENYWR)) == NULL) return -1;
+	if ((fd = _wfsopen(filepath, "rb", _SH_DENYWR)) == NULL) return -1;
 
 	if ((ctx = rhash_init(hash_id)) == NULL) {
 		fclose(fd);
diff -urp a/Utilities/cmlibrhash/librhash/rhash.h b/Utilities/cmlibrhash/librhash/rhash.h
--- a/Utilities/cmlibrhash/librhash/rhash.h	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibrhash/librhash/rhash.h	2021-02-11 18:43:33.965855044 +0330
@@ -164,7 +164,7 @@ RHASH_API int rhash_file(unsigned hash_i
  * @param result buffer to receive hash value with the lowest requested id
  * @return 0 on success, -1 on error, -1 on error and errno is set
  */
-RHASH_API int rhash_wfile(unsigned hash_id, const wchar_t* filepath, unsigned char* result);
+RHASH_API int rhash_wfile(unsigned hash_id, const char* filepath, unsigned char* result);
 #endif
 
 
diff -urp a/Utilities/cmlibuv/src/win/core.c b/Utilities/cmlibuv/src/win/core.c
--- a/Utilities/cmlibuv/src/win/core.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibuv/src/win/core.c	2021-02-11 18:43:34.115857411 +0330
@@ -71,8 +71,8 @@ UV_THREAD_LOCAL int uv__crt_assert_enabl
 
 
 #if !defined(__MINGW32__) || __MSVCRT_VERSION__ >= 0x800
-static void uv__crt_invalid_parameter_handler(const wchar_t* expression,
-    const wchar_t* function, const wchar_t * file, unsigned int line,
+static void uv__crt_invalid_parameter_handler(const char* expression,
+    const char* function, const char * file, unsigned int line,
     uintptr_t reserved) {
   /* No-op. */
 }
diff -urp a/Utilities/cmlibuv/src/win/fs.c b/Utilities/cmlibuv/src/win/fs.c
--- a/Utilities/cmlibuv/src/win/fs.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibuv/src/win/fs.c	2021-02-11 18:43:34.102523866 +0330
@@ -124,13 +124,13 @@
 
 #define MIN(a,b) (((a) < (b)) ? (a) : (b))
 
-const WCHAR JUNCTION_PREFIX[] = L"\\??\\";
+const WCHAR JUNCTION_PREFIX[] = "\\??\\";
 const WCHAR JUNCTION_PREFIX_LEN = 4;
 
-const WCHAR LONG_PATH_PREFIX[] = L"\\\\?\\";
+const WCHAR LONG_PATH_PREFIX[] = "\\\\?\\";
 const WCHAR LONG_PATH_PREFIX_LEN = 4;
 
-const WCHAR UNC_PATH_PREFIX[] = L"\\\\?\\UNC\\";
+const WCHAR UNC_PATH_PREFIX[] = "\\\\?\\UNC\\";
 const WCHAR UNC_PATH_PREFIX_LEN = 8;
 
 static int uv__file_symlink_usermode_flag = SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE;
@@ -1234,7 +1234,7 @@ typedef int (*uv__fs_mktemp_func)(uv_fs_
 /* OpenBSD original: lib/libc/stdio/mktemp.c */
 void fs__mktemp(uv_fs_t* req, uv__fs_mktemp_func func) {
   static const WCHAR *tempchars =
-    L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
+    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
   static const size_t num_chars = 62;
   static const size_t num_x = 6;
   WCHAR *cp, *ep;
@@ -1246,7 +1246,7 @@ void fs__mktemp(uv_fs_t* req, uv__fs_mkt
   path = (char*)req->path;
   len = wcslen(req->file.pathw);
   ep = req->file.pathw + len;
-  if (len < num_x || wcsncmp(ep - num_x, L"XXXXXX", num_x)) {
+  if (len < num_x || wcsncmp(ep - num_x, "XXXXXX", num_x)) {
     SET_REQ_UV_ERROR(req, UV_EINVAL, ERROR_INVALID_PARAMETER);
     goto clobber;
   }
@@ -1592,11 +1592,11 @@ void fs__opendir(uv_fs_t* req) {
   len = wcslen(pathw);
 
   if (len == 0)
-    fmt = L"./*";
+    fmt = "./*";
   else if (IS_SLASH(pathw[len - 1]))
-    fmt = L"%s*";
+    fmt = "%s*";
   else
-    fmt = L"%s\\*";
+    fmt = "%s\\*";
 
   find_path = uv__malloc(sizeof(WCHAR) * (len + 4));
   if (find_path == NULL) {
diff -urp a/Utilities/cmlibuv/src/win/fs-event.c b/Utilities/cmlibuv/src/win/fs-event.c
--- a/Utilities/cmlibuv/src/win/fs-event.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibuv/src/win/fs-event.c	2021-02-11 18:43:34.112524024 +0330
@@ -487,7 +487,7 @@ void uv_process_fs_event_req(uv_loop_t*
                 uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
               }
 
-              _snwprintf(filenamew, size, L"%s\\%.*s", handle->dirw,
+              _snwprintf(filenamew, size, "%s\\%.*s", handle->dirw,
                 file_info->FileNameLength / (DWORD)sizeof(WCHAR),
                 file_info->FileName);
 
diff -urp a/Utilities/cmlibuv/src/win/getaddrinfo.c b/Utilities/cmlibuv/src/win/getaddrinfo.c
--- a/Utilities/cmlibuv/src/win/getaddrinfo.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibuv/src/win/getaddrinfo.c	2021-02-11 18:43:34.119190796 +0330
@@ -398,7 +398,7 @@ error:
 
 int uv_if_indextoname(unsigned int ifindex, char* buffer, size_t* size) {
   NET_LUID luid;
-  wchar_t wname[NDIS_IF_MAX_STRING_SIZE + 1]; /* Add one for the NUL. */
+  char wname[NDIS_IF_MAX_STRING_SIZE + 1]; /* Add one for the NUL. */
   DWORD bufsize;
   int r;
 
diff -urp a/Utilities/cmlibuv/src/win/process.c b/Utilities/cmlibuv/src/win/process.c
--- a/Utilities/cmlibuv/src/win/process.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibuv/src/win/process.c	2021-02-11 18:43:34.109190639 +0330
@@ -43,7 +43,7 @@ typedef struct env_var {
   const size_t len; /* including null or '=' */
 } env_var_t;
 
-#define E_V(str) { L##str, L##str L"=", sizeof(str) }
+#define E_V(str) { L##str, L##str "=", sizeof(str) }
 
 static const env_var_t required_vars[] = { /* keep me sorted */
   E_V("HOMEDRIVE"),
@@ -203,7 +203,7 @@ static WCHAR* search_path_join_test(cons
   result_pos += cwd_len;
 
   /* Add a path separator if cwd didn't end with one */
-  if (cwd_len && wcsrchr(L"\\/:", result_pos[-1]) == NULL) {
+  if (cwd_len && wcsrchr("\\/:", result_pos[-1]) == NULL) {
     result_pos[0] = L'\\';
     result_pos++;
   }
@@ -213,7 +213,7 @@ static WCHAR* search_path_join_test(cons
   result_pos += dir_len;
 
   /* Add a separator if the dir didn't end with one */
-  if (dir_len && wcsrchr(L"\\/:", result_pos[-1]) == NULL) {
+  if (dir_len && wcsrchr("\\/:", result_pos[-1]) == NULL) {
     result_pos[0] = L'\\';
     result_pos++;
   }
@@ -265,7 +265,7 @@ static WCHAR* path_search_walk_ext(const
   if (name_has_ext) {
     result = search_path_join_test(dir, dir_len,
                                    name, name_len,
-                                   L"", 0,
+                                   "", 0,
                                    cwd, cwd_len);
     if (result != NULL) {
       return result;
@@ -275,7 +275,7 @@ static WCHAR* path_search_walk_ext(const
   /* Try .com extension */
   result = search_path_join_test(dir, dir_len,
                                  name, name_len,
-                                 L"com", 3,
+                                 "com", 3,
                                  cwd, cwd_len);
   if (result != NULL) {
     return result;
@@ -284,7 +284,7 @@ static WCHAR* path_search_walk_ext(const
   /* Try .exe extension */
   result = search_path_join_test(dir, dir_len,
                                  name, name_len,
-                                 L"exe", 3,
+                                 "exe", 3,
                                  cwd, cwd_len);
   if (result != NULL) {
     return result;
@@ -386,7 +386,7 @@ static WCHAR* search_path(const WCHAR *f
     dir_end = path;
 
     /* The file is really only a name; look in cwd first, then scan path */
-    result = path_search_walk_ext(L"", 0,
+    result = path_search_walk_ext("", 0,
                                   file, file_len,
                                   cwd, cwd_len,
                                   name_has_ext);
@@ -463,14 +463,14 @@ WCHAR* quote_cmd_arg(const WCHAR *source
     return target;
   }
 
-  if (NULL == wcspbrk(source, L" \t\"")) {
+  if (NULL == wcspbrk(source, " \t\"")) {
     /* No quotation needed */
     wcsncpy(target, source, len);
     target += len;
     return target;
   }
 
-  if (NULL == wcspbrk(source, L"\"\\")) {
+  if (NULL == wcspbrk(source, "\"\\")) {
     /*
      * No embedded double quotes or backlashes, so I can just wrap
      * quote marks around the whole thing.
@@ -613,11 +613,11 @@ error:
 }
 
 
-int env_strncmp(const wchar_t* a, int na, const wchar_t* b) {
-  wchar_t* a_eq;
-  wchar_t* b_eq;
-  wchar_t* A;
-  wchar_t* B;
+int env_strncmp(const char* a, int na, const char* b) {
+  char* a_eq;
+  char* b_eq;
+  char* A;
+  char* B;
   int nb;
   int r;
 
@@ -632,8 +632,8 @@ int env_strncmp(const wchar_t* a, int na
   assert(b_eq);
   nb = b_eq - b;
 
-  A = alloca((na+1) * sizeof(wchar_t));
-  B = alloca((nb+1) * sizeof(wchar_t));
+  A = alloca((na+1) * sizeof(char));
+  B = alloca((nb+1) * sizeof(char));
 
   r = LCMapStringW(LOCALE_INVARIANT, LCMAP_UPPERCASE, a, na, A, na);
   assert(r==na);
@@ -643,8 +643,8 @@ int env_strncmp(const wchar_t* a, int na
   B[nb] = L'\0';
 
   while (1) {
-    wchar_t AA = *A++;
-    wchar_t BB = *B++;
+    char AA = *A++;
+    char BB = *B++;
     if (AA < BB) {
       return -1;
     } else if (AA > BB) {
@@ -657,8 +657,8 @@ int env_strncmp(const wchar_t* a, int na
 
 
 static int qsort_wcscmp(const void *a, const void *b) {
-  wchar_t* astr = *(wchar_t* const*)a;
-  wchar_t* bstr = *(wchar_t* const*)b;
+  char* astr = *(char* const*)a;
+  char* bstr = *(char* const*)b;
   return env_strncmp(astr, -1, bstr);
 }
 
@@ -741,7 +741,7 @@ int make_program_env(char* env_block[],
   assert(env_len == 0 || env_len == (size_t) (ptr - dst_copy));
 
   /* sort our (UTF-16) copy */
-  qsort(env_copy, env_block_count-1, sizeof(wchar_t*), qsort_wcscmp);
+  qsort(env_copy, env_block_count-1, sizeof(char*), qsort_wcscmp);
 
   /* third pass: check for required variables */
   for (ptr_copy = env_copy, i = 0; i < ARRAY_SIZE(required_vars); ) {
@@ -1024,7 +1024,7 @@ int uv_spawn(uv_loop_t* loop,
   if (path == NULL) {
     DWORD path_len, r;
 
-    path_len = GetEnvironmentVariableW(L"PATH", NULL, 0);
+    path_len = GetEnvironmentVariableW("PATH", NULL, 0);
     if (path_len == 0) {
       err = GetLastError();
       goto done;
@@ -1037,7 +1037,7 @@ int uv_spawn(uv_loop_t* loop,
     }
     path = alloc_path;
 
-    r = GetEnvironmentVariableW(L"PATH", path, path_len);
+    r = GetEnvironmentVariableW("PATH", path, path_len);
     if (r == 0 || r >= path_len) {
       err = GetLastError();
       goto done;
diff -urp a/Utilities/cmlibuv/src/win/util.c b/Utilities/cmlibuv/src/win/util.c
--- a/Utilities/cmlibuv/src/win/util.c	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/cmlibuv/src/win/util.c	2021-02-11 18:43:34.119190796 +0330
@@ -548,7 +548,7 @@ int uv_uptime(double* uptime) {
 
     data_size = (DWORD) buffer_size;
     result = RegQueryValueExW(HKEY_PERFORMANCE_DATA,
-                              L"2",
+                              "2",
                               NULL,
                               NULL,
                               buffer,
@@ -580,7 +580,7 @@ int uv_uptime(double* uptime) {
 
   data_block = (PERF_DATA_BLOCK*) buffer;
 
-  if (wmemcmp(data_block->Signature, L"PERF", 4) != 0)
+  if (wmemcmp(data_block->Signature, "PERF", 4) != 0)
     goto internalError;
 
   if (data_size < data_block->HeaderLength + sizeof(*object_type))
@@ -686,7 +686,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_info
 
     len = _snwprintf(key_name,
                      ARRAY_SIZE(key_name),
-                     L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\%d",
+                     "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\%d",
                      i);
 
     assert(len > 0 && len < ARRAY_SIZE(key_name));
@@ -701,7 +701,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_info
     }
 
     err = RegQueryValueExW(processor_key,
-                           L"~MHz",
+                           "~MHz",
                            NULL,
                            NULL,
                            (BYTE*)&cpu_speed,
@@ -712,7 +712,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_info
     }
 
     err = RegQueryValueExW(processor_key,
-                           L"ProcessorNameString",
+                           "ProcessorNameString",
                            NULL,
                            NULL,
                            (BYTE*)&cpu_brand,
@@ -1195,7 +1195,7 @@ int uv_os_homedir(char* buffer, size_t*
 
 
 int uv_os_tmpdir(char* buffer, size_t* size) {
-  wchar_t *path;
+  char *path;
   DWORD bufsize;
   size_t len;
 
@@ -1209,7 +1209,7 @@ int uv_os_tmpdir(char* buffer, size_t* s
   }
   /* Include space for terminating null char. */
   len += 1;
-  path = uv__malloc(len * sizeof(wchar_t));
+  path = uv__malloc(len * sizeof(char));
   if (path == NULL) {
     return UV_ENOMEM;
   }
@@ -1368,8 +1368,8 @@ int uv__convert_utf8_to_utf16(const char
 
 int uv__getpwuid_r(uv_passwd_t* pwd) {
   HANDLE token;
-  wchar_t username[UNLEN + 1];
-  wchar_t *path;
+  char username[UNLEN + 1];
+  char *path;
   DWORD bufsize;
   int r;
 
@@ -1388,7 +1388,7 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
     return uv_translate_sys_error(r);
   }
 
-  path = uv__malloc(bufsize * sizeof(wchar_t));
+  path = uv__malloc(bufsize * sizeof(char));
   if (path == NULL) {
     CloseHandle(token);
     return UV_ENOMEM;
@@ -1445,8 +1445,8 @@ int uv_os_get_passwd(uv_passwd_t* pwd) {
 
 
 int uv_os_environ(uv_env_item_t** envitems, int* count) {
-  wchar_t* env;
-  wchar_t* penv;
+  char* env;
+  char* penv;
   int i, cnt;
   uv_env_item_t* envitem;
 
@@ -1516,10 +1516,10 @@ fail:
 
 
 int uv_os_getenv(const char* name, char* buffer, size_t* size) {
-  wchar_t fastvar[512];
-  wchar_t* var;
+  char fastvar[512];
+  char* var;
   DWORD varlen;
-  wchar_t* name_w;
+  char* name_w;
   DWORD bufsize;
   size_t len;
   int r;
@@ -1611,8 +1611,8 @@ fail:
 
 
 int uv_os_setenv(const char* name, const char* value) {
-  wchar_t* name_w;
-  wchar_t* value_w;
+  char* name_w;
+  char* value_w;
   int r;
 
   if (name == NULL || value == NULL)
@@ -1642,7 +1642,7 @@ int uv_os_setenv(const char* name, const
 
 
 int uv_os_unsetenv(const char* name) {
-  wchar_t* name_w;
+  char* name_w;
   int r;
 
   if (name == NULL)
@@ -1820,7 +1820,7 @@ int uv_os_uname(uv_utsname_t* buffer) {
   /* Populate the version field. */
   version_size = 0;
   r = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
-                    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",
+                    "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",
                     0,
                     KEY_QUERY_VALUE,
                     &registry_key);
@@ -1829,7 +1829,7 @@ int uv_os_uname(uv_utsname_t* buffer) {
     product_name_w_size = sizeof(product_name_w);
     r = RegGetValueW(registry_key,
                      NULL,
-                     L"ProductName",
+                     "ProductName",
                      RRF_RT_REG_SZ,
                      NULL,
                      (PVOID) product_name_w,
diff -urp a/Utilities/Release/WiX/CustomAction/detect_nsis_overwrite.cpp b/Utilities/Release/WiX/CustomAction/detect_nsis_overwrite.cpp
--- a/Utilities/Release/WiX/CustomAction/detect_nsis_overwrite.cpp	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/Release/WiX/CustomAction/detect_nsis_overwrite.cpp	2021-02-11 18:43:33.649183363 +0330
@@ -6,39 +6,39 @@
 #include <msi.h>
 #include <msiquery.h>
 
-std::wstring get_property(MSIHANDLE msi_handle, std::wstring const& name)
+std::string get_property(MSIHANDLE msi_handle, std::string const& name)
 {
   DWORD size = 0;
 
-  WCHAR value_buffer[] = L"";
+  WCHAR value_buffer[] = "";
   UINT status = MsiGetPropertyW(msi_handle, name.c_str(), value_buffer, &size);
 
   if (status == ERROR_MORE_DATA) {
-    std::vector<wchar_t> buffer(size + 1);
+    std::vector<char> buffer(size + 1);
     MsiGetPropertyW(msi_handle, name.c_str(), &buffer[0], &size);
-    return std::wstring(&buffer[0]);
+    return std::string(&buffer[0]);
   } else {
-    return std::wstring();
+    return std::string();
   }
 }
 
-void set_property(MSIHANDLE msi_handle, std::wstring const& name,
-                  std::wstring const& value)
+void set_property(MSIHANDLE msi_handle, std::string const& name,
+                  std::string const& value)
 {
   MsiSetPropertyW(msi_handle, name.c_str(), value.c_str());
 }
 
 extern "C" UINT __stdcall DetectNsisOverwrite(MSIHANDLE msi_handle)
 {
-  std::wstring install_root = get_property(msi_handle, L"INSTALL_ROOT");
+  std::string install_root = get_property(msi_handle, "INSTALL_ROOT");
 
-  std::wstring uninstall_exe = install_root + L"\\uninstall.exe";
+  std::string uninstall_exe = install_root + "\\uninstall.exe";
 
   bool uninstall_exe_exists =
     GetFileAttributesW(uninstall_exe.c_str()) != INVALID_FILE_ATTRIBUTES;
 
-  set_property(msi_handle, L"CMAKE_NSIS_OVERWRITE_DETECTED",
-               uninstall_exe_exists ? L"1" : L"0");
+  set_property(msi_handle, "CMAKE_NSIS_OVERWRITE_DETECTED",
+               uninstall_exe_exists ? "1" : "0");
 
   return ERROR_SUCCESS;
 }
diff -urp a/Utilities/std/cm/filesystem b/Utilities/std/cm/filesystem
--- a/Utilities/std/cm/filesystem	2021-01-28 18:58:45.000000000 +0330
+++ b/Utilities/std/cm/filesystem	2021-02-12 14:39:55.154859796 +0330
@@ -98,7 +98,7 @@ class unicode<Char, typename std::enable
 {
 public:
   // UTF32 -> UTF8
-  static std::string to_utf8(const std::wstring& str)
+  static std::string to_utf8(const std::string& str)
   {
     std::string result;
     for (auto c : str) {
@@ -114,9 +114,9 @@ public:
   }
 
   // UTF8 -> UTF32
-  static std::wstring from_utf8(const std::string& str)
+  static std::string from_utf8(const std::string& str)
   {
-    std::wstring result;
+    std::string result;
     result.reserve(str.length());
     auto iter = str.begin();
     utf8_state state = s_start;
@@ -124,29 +124,29 @@ public:
     while (iter < str.end()) {
       if ((state = decode(state, static_cast<std::uint8_t>(*iter++),
                           codepoint)) == s_start) {
-        result += static_cast<std::wstring::value_type>(codepoint);
+        result += static_cast<std::string::value_type>(codepoint);
         codepoint = 0;
       } else if (state == s_reject) {
-        result += static_cast<std::wstring::value_type>(0xfffd);
+        result += static_cast<std::string::value_type>(0xfffd);
         state = s_start;
         codepoint = 0;
       }
     }
     if (state) {
-      result += static_cast<std::wstring::value_type>(0xfffd);
+      result += static_cast<std::string::value_type>(0xfffd);
     }
     return result;
   }
-  static std::wstring from_utf8(char c)
+  static std::string from_utf8(char c)
   {
-    std::wstring result;
+    std::string result;
     utf8_state state = s_start;
     std::uint32_t codepoint = 0;
     if ((state = decode(state, static_cast<std::uint8_t>(c), codepoint)) ==
         s_start) {
-      result += static_cast<std::wstring::value_type>(codepoint);
+      result += static_cast<std::string::value_type>(codepoint);
     } else {
-      result += static_cast<std::wstring::value_type>(0xfffd);
+      result += static_cast<std::string::value_type>(0xfffd);
     }
 
     return result;
@@ -159,7 +159,7 @@ class unicode<Char, typename std::enable
 {
 public:
   // UTF16 -> UTF8
-  static std::string to_utf8(const std::wstring& str)
+  static std::string to_utf8(const std::string& str)
   {
     std::string result;
     for (auto iter = str.begin(); iter != str.end(); ++iter) {
@@ -193,9 +193,9 @@ public:
   }
 
   // UTF8 -> UTF16
-  static std::wstring from_utf8(const std::string& str)
+  static std::string from_utf8(const std::string& str)
   {
-    std::wstring result;
+    std::string result;
     result.reserve(str.length());
     auto iter = str.begin();
     utf8_state state = s_start;
@@ -204,95 +204,91 @@ public:
       if ((state = decode(state, static_cast<std::uint8_t>(*iter++),
                           codepoint)) == s_start) {
         if (codepoint <= 0xffff) {
-          result += static_cast<std::wstring::value_type>(codepoint);
+          result += static_cast<std::string::value_type>(codepoint);
         } else {
           codepoint -= 0x10000;
           result +=
-            static_cast<std::wstring::value_type>((codepoint >> 10) + 0xd800);
-          result += static_cast<std::wstring::value_type>((codepoint & 0x3ff) +
+            static_cast<std::string::value_type>((codepoint >> 10) + 0xd800);
+          result += static_cast<std::string::value_type>((codepoint & 0x3ff) +
                                                           0xdc00);
         }
         codepoint = 0;
       } else if (state == s_reject) {
-        result += static_cast<std::wstring::value_type>(0xfffd);
+        result += static_cast<std::string::value_type>(0xfffd);
         state = s_start;
         codepoint = 0;
       }
     }
     if (state) {
-      result += static_cast<std::wstring::value_type>(0xfffd);
+      result += static_cast<std::string::value_type>(0xfffd);
     }
     return result;
   }
-  static std::wstring from_utf8(char c)
+  static std::string from_utf8(char c)
   {
-    std::wstring result;
+    std::string result;
     utf8_state state = s_start;
     std::uint32_t codepoint = 0;
     if ((state = decode(state, static_cast<std::uint8_t>(c), codepoint)) ==
         s_start) {
       if (codepoint <= 0xffff) {
-        result += static_cast<std::wstring::value_type>(codepoint);
+        result += static_cast<std::string::value_type>(codepoint);
       } else {
         codepoint -= 0x10000;
         result +=
-          static_cast<std::wstring::value_type>((codepoint >> 10) + 0xd800);
+          static_cast<std::string::value_type>((codepoint >> 10) + 0xd800);
         result +=
-          static_cast<std::wstring::value_type>((codepoint & 0x3ff) + 0xdc00);
+          static_cast<std::string::value_type>((codepoint & 0x3ff) + 0xdc00);
       }
     } else {
-      result += static_cast<std::wstring::value_type>(0xfffd);
+      result += static_cast<std::string::value_type>(0xfffd);
     }
     return result;
   }
 };
 
-template <typename In, typename Out>
-class unicode_converter;
-
-template <>
-class unicode_converter<char, wchar_t>
+template <typename Char>
+class unicode<Char, typename std::enable_if<(sizeof(Char) == 1)>::type>
+  : public unicode_helper
 {
 public:
-  std::wstring operator()(const std::string& in)
+  // UTF8 -> UTF8
+  static std::string to_utf8(const std::string& str)
   {
-    return unicode<wchar_t>::from_utf8(in);
+    return str;
   }
-  std::wstring operator()(const char* in)
+  static std::string to_utf8(Char c)
   {
-    return unicode<wchar_t>::from_utf8(in);
+    return c;
   }
-  std::wstring operator()(char in) { return unicode<wchar_t>::from_utf8(in); }
-};
-template <>
-class unicode_converter<wchar_t, char>
-{
-public:
-  std::string operator()(const std::wstring& in)
+
+  // UTF8 -> UTF8
+  static std::string from_utf8(const std::string& str)
   {
-    return unicode<wchar_t>::to_utf8(in);
+    return str;
   }
-  std::string operator()(const wchar_t* in)
+  static std::string from_utf8(char c)
   {
-    return unicode<wchar_t>::to_utf8(in);
+    return std::string(1, c);
   }
-  std::string operator()(wchar_t in) { return unicode<wchar_t>::to_utf8(in); }
 };
+
+template <typename In, typename Out>
+class unicode_converter;
+
 template <>
 class unicode_converter<char, char>
 {
 public:
-  std::string operator()(const std::string& in) { return in; }
-  std::string operator()(const char* in) { return std::string(in); }
-  std::string operator()(char in) { return std::string(1, in); }
-};
-template <>
-class unicode_converter<wchar_t, wchar_t>
-{
-public:
-  std::wstring operator()(const std::wstring& in) { return in; }
-  std::wstring operator()(const wchar_t* in) { return std::wstring(in); }
-  std::wstring operator()(wchar_t in) { return std::wstring(1, in); }
+  std::string operator()(const std::string& in)
+  {
+    return unicode<char>::from_utf8(in);
+  }
+  std::string operator()(const char* in)
+  {
+    return unicode<char>::from_utf8(in);
+  }
+  std::string operator()(char in) { return unicode<char>::from_utf8(in); }
 };
 
 template <typename In>
@@ -344,50 +340,6 @@ struct string_converter<char>
     return std::basic_string<Char>(unicode_converter<char, Char>()(in));
   }
 };
-template <>
-struct string_converter<wchar_t>
-{
-  // some compilers, like gcc 4.8 does not implement the following C++11
-  // signature:
-  // std::string::string(const string&, const Allocator&)
-  // As workaround, use char* pointer.
-  template <typename Char, typename Traits, typename Alloc>
-  static std::basic_string<Char, Traits, Alloc> to(const std::wstring& in,
-                                                   const Alloc& a)
-  {
-    return std::basic_string<Char, Traits, Alloc>(
-      unicode_converter<wchar_t, Char>()(in).c_str(), a);
-  }
-  template <typename Char, typename Traits, typename Alloc>
-  static std::basic_string<Char, Traits, Alloc> to(const wchar_t* in,
-                                                   const Alloc& a)
-  {
-    return std::basic_string<Char, Traits, Alloc>(
-      unicode_converter<wchar_t, Char>()(in).c_str(), a);
-  }
-  template <typename Char, typename Traits, typename Alloc>
-  static std::basic_string<Char, Traits, Alloc> to(wchar_t in, const Alloc& a)
-  {
-    return std::basic_string<Char, Traits, Alloc>(
-      unicode_converter<wchar_t, Char>()(in).c_str(), a);
-  }
-
-  template <typename Char>
-  static std::basic_string<Char> to(const std::wstring& in)
-  {
-    return std::basic_string<Char>(unicode_converter<wchar_t, Char>()(in));
-  }
-  template <typename Char>
-  static std::basic_string<Char> to(const wchar_t* in)
-  {
-    return std::basic_string<Char>(unicode_converter<wchar_t, Char>()(in));
-  }
-  template <typename Char>
-  static std::basic_string<Char> to(wchar_t in)
-  {
-    return std::basic_string<Char>(unicode_converter<wchar_t, Char>()(in));
-  }
-};
 
 template <typename T, typename = void>
 struct source_traits
@@ -470,54 +422,6 @@ struct source_converter<char, char>
   static void set_source(std::string& p, std::string&& s) { p = std::move(s); }
 };
 
-template <>
-struct source_converter<wchar_t, char>
-{
-  template <typename Iterator>
-  static void append_range(std::string& p, Iterator b, Iterator e)
-  {
-    if (b == e) {
-      return;
-    }
-
-    std::wstring tmp(b, e);
-    std::string dest = string_converter<wchar_t>::to<char>(tmp);
-    p.append(dest.begin(), dest.end());
-  }
-  template <typename Iterator>
-  static void append_range(std::string& p, Iterator b)
-  {
-    wchar_t e = '\0';
-
-    if (*b == e) {
-      return;
-    }
-    std::wstring tmp;
-    for (; *b != e; ++b) {
-      tmp.push_back(*b);
-    }
-
-    std::string dest = string_converter<wchar_t>::to<char>(tmp);
-    p.append(dest.begin(), dest.end());
-  }
-
-  template <typename Traits, typename Alloc>
-  static void append_source(std::string& p,
-                            const std::basic_string<wchar_t, Traits, Alloc>& s)
-  {
-    append_range(p, s.begin(), s.end());
-  }
-  template <typename Source>
-  static void append_source(std::string& p, const Source& s)
-  {
-    append_range(p, s);
-  }
-
-  static void set_source(std::string& p, std::wstring&& s)
-  {
-    p = string_converter<wchar_t>::to<char>(s);
-  }
-};
 
 template <typename T>
 struct is_pathable_string : std::false_type
@@ -528,11 +432,6 @@ struct is_pathable_string<std::basic_str
   : std::true_type
 {
 };
-template <typename Traits, typename Alloc>
-struct is_pathable_string<std::basic_string<wchar_t, Traits, Alloc>>
-  : std::true_type
-{
-};
 template <>
 struct is_pathable_string<cm::string_view> : std::true_type
 {
@@ -547,10 +446,10 @@ struct is_pathable_char_array<
   T,
   cm::enable_if_t<
     std::is_same<char*, typename std::decay<T>::type>::value ||
-      std::is_same<wchar_t*, typename std::decay<T>::type>::value,
+      std::is_same<char*, typename std::decay<T>::type>::value,
     void>>
   : bool_constant<std::is_same<char*, typename std::decay<T>::type>::value ||
-                  std::is_same<wchar_t*, typename std::decay<T>::type>::value>
+                  std::is_same<char*, typename std::decay<T>::type>::value>
 {
 };
 
@@ -566,7 +465,7 @@ struct is_pathable_iterator<
       (std::is_same<char,
                     typename std::iterator_traits<
                       typename std::decay<T>::type>::value_type>::value ||
-       std::is_same<wchar_t,
+       std::is_same<char,
                     typename std::iterator_traits<
                       typename std::decay<T>::type>::value_type>::value),
     void>>
@@ -574,7 +473,7 @@ struct is_pathable_iterator<
       std::is_same<char,
                    typename std::iterator_traits<
                      typename std::decay<T>::type>::value_type>::value ||
-      std::is_same<wchar_t,
+      std::is_same<char,
                    typename std::iterator_traits<
                      typename std::decay<T>::type>::value_type>::value>
 {
@@ -616,7 +515,7 @@ class path
 
 public:
 #  if defined(_WIN32) && !defined(__CYGWIN__)
-  using value_type = wchar_t;
+  using value_type = char;
 #  else
   using value_type = char;
 #  endif
@@ -860,8 +759,8 @@ public:
     typename Alloc = std::allocator<Char>,
     cm::enable_if_t<(std::is_same<Char, char>::value &&
                      std::is_same<Traits, std::char_traits<char>>::value) ||
-                      (std::is_same<Char, wchar_t>::value &&
-                       std::is_same<Traits, std::char_traits<wchar_t>>::value),
+                      (std::is_same<Char, char>::value &&
+                       std::is_same<Traits, std::char_traits<char>>::value),
                     int> = 1>
   std::basic_string<Char, Traits, Alloc> string(const Alloc& a = Alloc()) const
   {
@@ -870,11 +769,11 @@ public:
       this->path_, a);
   }
   const std::string string() const { return this->path_; }
-  std::wstring wstring() const
+  std::string wstring() const
   {
     std::string out = this->string();
     return internals::string_converter<path_type::value_type>::to<
-      std::wstring::value_type>(out);
+      std::string::value_type>(out);
   }
 
   template <
@@ -882,8 +781,8 @@ public:
     typename Alloc = std::allocator<Char>,
     cm::enable_if_t<(std::is_same<Char, char>::value &&
                      std::is_same<Traits, std::char_traits<char>>::value) ||
-                      (std::is_same<Char, wchar_t>::value &&
-                       std::is_same<Traits, std::char_traits<wchar_t>>::value),
+                      (std::is_same<Char, char>::value &&
+                       std::is_same<Traits, std::char_traits<char>>::value),
                     int> = 1>
   std::basic_string<Char, Traits, Alloc> generic_string(
     const Alloc& a = Alloc()) const
@@ -893,11 +792,11 @@ public:
       this->get_generic(), a);
   }
   std::string generic_string() const { return this->get_generic(); }
-  std::wstring generic_wstring() const
+  std::string generic_wstring() const
   {
     auto dest = this->generic_string();
     return internals::string_converter<path_type::value_type>::to<
-      std::wstring::value_type>(dest);
+      std::string::value_type>(dest);
   }
 
   // Compare
