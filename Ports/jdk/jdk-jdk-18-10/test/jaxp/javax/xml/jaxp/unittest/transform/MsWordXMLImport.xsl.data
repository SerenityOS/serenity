<?xml version="1.0" encoding="UTF-8"?>
<!--
 *
 * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 *
 -->
 
<!-- Start of OOo2.0 import/wordml/wordml2ooo.xsl stylesheet  -->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:v="urn:schemas-microsoft-com:vml" 
    xmlns:w="http://schemas.microsoft.com/office/word/2003/wordml" 
    xmlns:wx="http://schemas.microsoft.com/office/word/2003/auxHint" 
    xmlns:o="urn:schemas-microsoft-com:office:office" 
    xmlns:aml="http://schemas.microsoft.com/aml/2001/core"
    xmlns:dt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882" 
    xmlns:dc="http://purl.org/dc/elements/1.1/"    
    xmlns:office="http://openoffice.org/2000/office"
    xmlns:style="http://openoffice.org/2000/style"
    xmlns:text="http://openoffice.org/2000/text"
    xmlns:table="http://openoffice.org/2000/table"
    xmlns:draw="http://openoffice.org/2000/drawing"
    xmlns:fo="http://www.w3.org/1999/XSL/Format"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xmlns:number="http://openoffice.org/2000/datastyle"
    xmlns:svg="http://www.w3.org/2000/svg"
    xmlns:chart="http://openoffice.org/2000/chart"
    xmlns:dr3d="http://openoffice.org/2000/dr3d"
    xmlns:math="http://www.w3.org/1998/Math/MathML"
    xmlns:form="http://openoffice.org/2000/form"
    xmlns:script="http://openoffice.org/2000/script"
    xmlns:meta="http://openoffice.org/2000/meta"
    xmlns:config="http://openoffice.org/2001/config"
    xmlns:help="http://openoffice.org/2000/help"
    exclude-result-prefixes="v w wx aml o aml dt" 
    office:version="1.0"
    >
    <xsl:output method="xml" indent="no" encoding="UTF-8" version="1.0"/>
    <!--
    <xsl:include href="../../common/measure_conversion.xsl"/>
    <xsl:include href="../common/ms2ooo_docpr.xsl"/>
    <xsl:include href="wordml2ooo_text.xsl"/>
    <xsl:include href="wordml2ooo_settings.xsl"/>
    <xsl:include href="wordml2ooo_table.xsl"/>
    <xsl:include href="wordml2ooo_page.xsl"/>
    <xsl:include href="wordml2ooo_list.xsl"/>
    <xsl:include href="wordml2ooo_draw.xsl"/>
    -->
    <xsl:key name="paragraph-style" match="w:style[@w:type = 'paragraph']" use="@w:styleId"/>
    <xsl:key name="heading-style" match="w:style[@w:type = 'paragraph' and w:pPr/w:outlineLvl]" use="@w:styleId"/>
    <xsl:template match="/">
        <xsl:apply-templates select="w:wordDocument"/>
    </xsl:template>
    <xsl:template match="w:wordDocument">
        <office:document office:class="text" office:version="1.0">
            <xsl:apply-templates select="o:DocumentProperties"/>
            <xsl:apply-templates select="w:docPr"/>
            <xsl:apply-templates select="w:fonts"/>
            <xsl:apply-templates select="w:styles"/>
            <xsl:apply-templates select="w:body"/>
        </office:document>
    </xsl:template>
    <xsl:template match="w:fonts">
        <xsl:element name="office:font-decls">
            <!-- MS Word's default font declaration, added for Writer automatically. glu -->
            <style:font-decl style:name="Arial" fo:font-family="Arial" style:font-family-generic="roman" style:font-pitch="variable"/>
            <style:font-decl style:name="Times New Roman" fo:font-family="'Times New Roman'" style:font-family-generic="roman" style:font-pitch="variable"/>
            <style:font-decl style:name="Symbol" fo:font-family="Symbol" style:font-family-generic="roman" style:font-pitch="variable" style:font-charset="x-symbol"/>
            <style:font-decl style:name="Courier New" fo:font-family="'Courier New'" style:font-family-generic="modern" style:font-pitch="fixed"/>
            <xsl:if test="not(w:font[@w:name='StarSymbol'])">
                <style:font-decl style:name="StarSymbol" fo:font-family="StarSymbol" style:font-charset="x-symbol"/>
            </xsl:if>
            <xsl:for-each select="w:font">
                <xsl:element name="style:font-decl">
                    <xsl:attribute name="style:name"><xsl:value-of select="@w:name"/></xsl:attribute>
                    <xsl:attribute name="fo:font-family"><xsl:value-of select="@w:name"/></xsl:attribute>
                    <!-- added by glu, for process special fonts e.g. Marlett, -->
                    <xsl:if test="w:charset/@w:val = '02'">
                        <xsl:attribute name="style:font-charset">x-symbol</xsl:attribute>
                    </xsl:if>
                    <xsl:if test="w:family">
                        <xsl:choose>
                            <xsl:when test="w:family/@w:val = 'Swiss'">
                                <xsl:attribute name="style:font-family-generic">swiss</xsl:attribute>
                            </xsl:when>
                            <xsl:when test="w:family/@w:val='Modern'">
                                <xsl:attribute name="style:font-family-generic">modern</xsl:attribute>
                            </xsl:when>
                            <xsl:when test="w:family/@w:val='Roman'">
                                <xsl:attribute name="style:font-family-generic">roman</xsl:attribute>
                            </xsl:when>
                            <xsl:when test="w:family/@w:val='Script'">
                                <xsl:attribute name="style:font-family-generic">script</xsl:attribute>
                            </xsl:when>
                            <xsl:when test="w:family/@w:val='Decorative'">
                                <xsl:attribute name="style:font-family-generic">decorative</xsl:attribute>
                            </xsl:when>
                            <xsl:when test="w:family/@w:val='System'">
                                <xsl:attribute name="style:font-family-generic">system</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="style:font-family-generic">system</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:if>
                    <xsl:if test="w:pitch">
                        <xsl:attribute name="style:font-pitch"><xsl:value-of select="w:pitch/@w:val"/></xsl:attribute>
                    </xsl:if>
                </xsl:element>
            </xsl:for-each>
        </xsl:element>
    </xsl:template>
    <xsl:template match="w:styles">
        <office:styles>
            <xsl:call-template name="create-default-paragraph-styles"/>
            <xsl:call-template name="create-default-text-styles"/>
            <xsl:call-template name="create-default-frame-style"/>
            <!-- StarWriter has no default style family 'list'. glu -->
            <xsl:if test="w:style[@w:type = 'paragraph' and w:pPr/w:outlineLvl and w:pPr/w:listPr]">
                <xsl:call-template name="create-outline-style"/>
            </xsl:if>
            <xsl:apply-templates select="w:style[@w:type='list']" mode="list"/>
            <xsl:apply-templates select="w:style[@w:type!='list']"/>
        </office:styles>
        <office:automatic-styles>
            <xsl:apply-templates select="/w:wordDocument/w:body//w:p" mode="style"/>
            <xsl:apply-templates select="/w:wordDocument/w:body//w:rPr[not(parent::w:pPr)]" mode="style"/>
            <xsl:apply-templates select="/w:wordDocument/w:body//w:tblPr" mode="style"/>
            <xsl:apply-templates select="/w:wordDocument/w:body//w:gridCol" mode="style"/>
            <xsl:apply-templates select="/w:wordDocument/w:body//w:trHeight" mode="style"/>
            <xsl:apply-templates select="/w:wordDocument/w:body//w:tcPr" mode="style"/>
            <xsl:apply-templates select="/w:wordDocument/w:body//w:listPr" mode="style"/>
            <xsl:apply-templates select="/w:wordDocument/w:body//w:sectPr" mode="page-master"/>
        </office:automatic-styles>
        <office:master-styles>
            <xsl:apply-templates select="/w:wordDocument/w:body//w:sectPr" mode="master-page"/>
        </office:master-styles>
    </xsl:template>
    <xsl:template match="w:style">
        <style:style>
            <xsl:attribute name="style:name"><xsl:value-of select="@w:styleId"/></xsl:attribute>
            <xsl:if test="w:basedOn">
                <xsl:attribute name="style:parent-style-name"><xsl:value-of select="w:basedOn/@w:val"/></xsl:attribute>
            </xsl:if>
            <xsl:if test="w:next">
                <xsl:attribute name="style:next-style-name"><xsl:value-of select="w:next/@w:val"/></xsl:attribute>
            </xsl:if>
            <xsl:choose>
                <xsl:when test="@w:type = 'character'">
                    <xsl:attribute name="style:family">text</xsl:attribute>
                </xsl:when>
                <!-- table, paragraph are the same as in Writer . glu -->
                <xsl:when test="@w:type">
                    <xsl:attribute name="style:family"><xsl:value-of select="@w:type"/></xsl:attribute>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:attribute name="style:family">text</xsl:attribute>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:element name="style:properties">
                <xsl:apply-templates select="w:pPr"/>
                <xsl:apply-templates select="w:rPr"/>
            </xsl:element>
        </style:style>
    </xsl:template>
    <xsl:template match="w:body">
        <xsl:element name="office:body">
            <xsl:apply-templates/>
        </xsl:element>
    </xsl:template>
    <xsl:template name="create-default-frame-style">
        <!--add for default frame style -->
        <style:style style:name="Frame" style:family="graphics">
            <style:properties text:anchor-type="paragraph" svg:x="0inch" svg:y="0inch" style:wrap="parallel" style:number-wrapped-paragraphs="no-limit" style:wrap-contour="false" style:vertical-pos="top" style:vertical-rel="paragraph-content" style:horizontal-pos="center" style:horizontal-rel="paragraph-content"/>
        </style:style>
    </xsl:template>
    
<!-- End of OOo2.0 import/wordml/wordml2ooo.xsl stylesheet  -->
<!-- Start of OOo2.0 import/wordml/wordml2ooo_draw.xsl stylesheet  -->
    <xsl:template match="w:pict">
        <xsl:choose>
            <xsl:when test="descendant::w:binData">
                <!-- Cannot load zipped Wmf file. glu <xsl:if test="not(contains(w:binData/@w:name,'.wmz'))"> -->
                <xsl:element name="draw:image">
                    <xsl:if test="v:shape/@style">
                        <xsl:if test="contains( v:shape/@style, 'margin-left:')">
                            <xsl:attribute name="svg:x"><xsl:value-of select="concat( number(substring-before( substring-after( v:shape/@style, 'margin-left:'), 'pt'))*0.0353, 'cm')"/></xsl:attribute>
                        </xsl:if>
                        <xsl:if test="contains( v:shape/@style, 'margin-top:')">
                            <xsl:attribute name="svg:y"><xsl:value-of select="concat( number(substring-before( substring-after( v:shape/@style, 'margin-top:'), 'pt'))*0.0353, 'cm')"/></xsl:attribute>
                        </xsl:if>
                        <xsl:attribute name="svg:width"><xsl:value-of select="concat( number(substring-before( substring-after( v:shape/@style, 'width:'), 'pt'))*0.0353, 'cm')"/></xsl:attribute>
                        <xsl:attribute name="svg:height"><xsl:value-of select="concat( number(substring-before( substring-after( v:shape/@style, 'height:'), 'pt'))*0.0353, 'cm')"/></xsl:attribute>
                        <xsl:variable name="anchor-type">
                            <xsl:if test="contains( v:shape/@style, 'mso-position-horizontal-relative')">
                                <xsl:value-of select="substring-before( substring-after( v:shape/@style, 'mso-position-horizontal-relative:'), ';')"/>
                            </xsl:if>
                        </xsl:variable>
                        <xsl:choose>
                            <xsl:when test="$anchor-type = 'margin'">
                                <xsl:attribute name="text:anchor-type">frame</xsl:attribute>
                            </xsl:when>
                            <xsl:when test="$anchor-type = 'page'">
                                <xsl:attribute name="text:anchor-type">page</xsl:attribute>
                            </xsl:when>
                            <xsl:when test="$anchor-type = 'char'">
                                <xsl:attribute name="text:anchor-type">as-char</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="text:anchor-type">paragraph</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                        <xsl:if test="v:shape/v:imagedata/@o:title">
                            <xsl:attribute name="draw:name"><xsl:value-of select="v:shape/v:imagedata/@o:title"/></xsl:attribute>
                        </xsl:if>
                        <xsl:element name="office:binary-data">
                            <xsl:value-of select="w:binData"/>
                        </xsl:element>
                    </xsl:if>
                </xsl:element>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="w:binData">
        <xsl:element name="office:binary-data">
            <xsl:value-of select="."/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="v:group">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="v:oval">
        <xsl:element name="draw:ellipse">
            <xsl:variable name="style" select="@style"/>
            <xsl:variable name="position" select="substring-after($style,'position:')"/>
            <xsl:variable name="positionval" select="substring-before($position,';')"/>
            <xsl:variable name="left" select="substring-after($style,'left:')"/>
            <xsl:variable name="leftval" select="substring-before($left,';')"/>
            <xsl:variable name="top" select="substring-after($style,'top:')"/>
            <xsl:variable name="topval" select="substring-before($top,';')"/>
            <xsl:variable name="width" select="substring-after($style,'width:')"/>
            <xsl:variable name="widthval" select="substring-before($width,';')"/>
            <xsl:variable name="height" select="substring-after($style,'height:')"/>
            <xsl:variable name="heightval" select="$height"/>
            <xsl:if test="$positionval = 'absolute'">
                <xsl:variable name="parentgroup" select="parent::v:group"/>
                <xsl:variable name="origin" select="$parentgroup/@coordorigin"/>
                <xsl:variable name="groupleft" select="substring-before($origin,',')"/>
                <xsl:variable name="grouptop" select="substring-after($origin,',')"/>
                <xsl:variable name="currsect" select="ancestor::wx:sect"/>
                <xsl:variable name="currsectPr" select="$currsect/descendant::w:sectPr/w:pgMar"/>
                <xsl:variable name="leftmar" select="$currsectPr/@w:left"/>
                <xsl:variable name="topmar" select="$currsectPr/@w:top"/>
                <xsl:attribute name="text:anchor-type">page</xsl:attribute>
                <xsl:attribute name="svg:width"><xsl:value-of select="(number($widthval) div 1440) * 2.54"/>cm</xsl:attribute>
                <xsl:attribute name="svg:height"><xsl:value-of select="(number($heightval) div 1440) * 2.54"/>cm</xsl:attribute>
                <xsl:attribute name="svg:x"><xsl:value-of select="(number($topval + $topmar) div 1440) * 2.54"/>cm</xsl:attribute>
                <xsl:attribute name="svg:y"><xsl:value-of select="(number($leftval + $leftmar) div 1440) * 2.54"/>cm</xsl:attribute>
            </xsl:if>
        </xsl:element>
    </xsl:template>
    <xsl:template match="v:rect">
        <xsl:element name="draw:rect">
            <xsl:variable name="style" select="@style"/>
            <xsl:variable name="position" select="substring-after($style,'position:')"/>
            <xsl:variable name="positionval" select="substring-before($position,';')"/>
            <xsl:variable name="left" select="substring-after($style,'left:')"/>
            <xsl:variable name="leftval" select="substring-before($left,';')"/>
            <xsl:variable name="top" select="substring-after($style,'top:')"/>
            <xsl:variable name="topval" select="substring-before($top,';')"/>
            <xsl:variable name="width" select="substring-after($style,'width:')"/>
            <xsl:variable name="widthval" select="substring-before($width,';')"/>
            <xsl:variable name="height" select="substring-after($style,'height:')"/>
            <xsl:variable name="heightval" select="$height"/>
            <xsl:if test="$positionval = 'absolute'">
                <xsl:variable name="parentgroup" select="parent::v:group"/>
                <xsl:variable name="origin" select="$parentgroup/@coordorigin"/>
                <xsl:variable name="groupleft" select="substring-before($origin,',')"/>
                <xsl:variable name="grouptop" select="substring-after($origin,',')"/>
                <xsl:variable name="currsect" select="ancestor::wx:sect"/>
                <xsl:variable name="currsectPr" select="$currsect/descendant::w:sectPr/w:pgMar"/>
                <xsl:variable name="leftmar" select="$currsectPr/@w:left"/>
                <xsl:variable name="topmar" select="$currsectPr/@w:top"/>
                <xsl:attribute name="text:anchor-type">page</xsl:attribute>
                <xsl:attribute name="svg:width"><xsl:value-of select="(number($widthval) div 1440) * 2.54"/>cm</xsl:attribute>
                <xsl:attribute name="svg:height"><xsl:value-of select="(number($heightval) div 1440) * 2.54"/>cm</xsl:attribute>
                <xsl:attribute name="svg:x"><xsl:value-of select="(number($topval + $topmar) div 1440) * 2.54"/>cm</xsl:attribute>
                <xsl:attribute name="svg:y"><xsl:value-of select="(number($leftval + $leftmar) div 1440) * 2.54"/>cm</xsl:attribute>
            </xsl:if>
        </xsl:element>
    </xsl:template>
<!-- End of OOo2.0 import/wordml/wordml2ooo_draw.xsl stylesheet  -->
<!-- Start of OOo2.0 import/wordml/wordml2ooo_list.xsl stylesheet  -->
    <xsl:template match="w:listPr" mode="style">
        <xsl:variable name="currlistid" select="w:ilfo/@w:val"/>
        <xsl:variable name="currlist" select="."/>
        <xsl:variable name="rootlistid" select="/w:wordDocument/w:lists/w:list[@w:ilfo=$currlistid]/w:ilst/@w:val"/>
        <xsl:variable name="rootlist" select="/w:wordDocument/w:lists/w:listDef[@w:listDefId =$rootlistid ]"/>
        <xsl:if test="not(ancestor::w:p/preceding-sibling::w:p/w:pPr/w:listPr[1]/w:ilfo/@w:val= $currlistid) and $rootlist/w:lvl ">
            <xsl:element name="text:list-style">
                <xsl:attribute name="style:name">List<xsl:value-of select="count(preceding::w:listPr)"/></xsl:attribute>
                <xsl:apply-templates select="$rootlist/w:lvl"/>
            </xsl:element>
        </xsl:if>
    </xsl:template>
    <xsl:template match="w:lvl">
        <xsl:variable name="listtype">
            <xsl:choose>
                <xsl:when test="w:nfc/@w:val">
                    <xsl:value-of select="w:nfc/@w:val"/>
                </xsl:when>
                <xsl:otherwise>0</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$listtype =23 and w:lvlPicBulletId">
                <!-- image characters. wym -->
                <xsl:element name="text:list-level-style-image">
                    <xsl:call-template name="list-styles-image"/>
                </xsl:element>
            </xsl:when>
            <xsl:when test="$listtype =23">
                <!-- nfcBullet: Bullet character. glu -->
                <xsl:element name="text:list-level-style-bullet">
                    <xsl:call-template name="list-styles-common">
                        <xsl:with-param name="listtype" select="$listtype"/>
                        <xsl:with-param name="currlevel" select="number(@w:ilvl)+1"/>
                    </xsl:call-template>
                </xsl:element>
            </xsl:when>
            <xsl:otherwise>
                <!-- all kinds of numbering characters. glu :( -->
                <xsl:element name="text:list-level-style-number">
                    <xsl:call-template name="list-styles-common">
                        <xsl:with-param name="listtype" select="$listtype"/>
                        <xsl:with-param name="currlevel" select="number(@w:ilvl)+1"/>
                    </xsl:call-template>
                </xsl:element>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="list-styles-common">
        <xsl:param name="listtype"/>
        <xsl:param name="currlevel"/>
        <xsl:variable name="startval" select="w:start/@w:val"/>
        <xsl:attribute name="text:level"><xsl:value-of select="$currlevel"/></xsl:attribute>
        <xsl:choose>
            <xsl:when test="$listtype = 23">
                <!-- bullet character. glu -->
                <xsl:attribute name="text:style-name">Bullet Symbols</xsl:attribute>
                <xsl:attribute name="text:bullet-char"><xsl:value-of select="w:lvlText/@w:val"/></xsl:attribute>
            </xsl:when>
            <xsl:when test="($listtype &gt;= 0) and ($listtype &lt; 60)">
                <xsl:attribute name="text:style-name">Numbering Symbols</xsl:attribute>
                <xsl:if test="$startval">
                    <xsl:attribute name="text:start-value"><xsl:value-of select="$startval"/></xsl:attribute>
                </xsl:if>
                <xsl:attribute name="text:display-levels"><xsl:value-of select="string-length(w:lvlText/@w:val) - string-length(translate(w:lvlText/@w:val,'%','') )"/></xsl:attribute>
                <xsl:call-template name="nfc2numformat">
                    <xsl:with-param name="nfcvalue" select="$listtype"/>
                    <xsl:with-param name="prefix" select="substring-before(w:lvlText/@w:val, '%')"/>
                    <xsl:with-param name="suffix" select="substring-after(w:lvlText/@w:val, concat('%', $currlevel) )"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:attribute name="text:style-name">Numbering Symbols</xsl:attribute>
                <xsl:if test="$startval">
                    <xsl:attribute name="text:start-value"><xsl:value-of select="$startval"/></xsl:attribute>
                </xsl:if>
                <xsl:attribute name="text:display-levels"><xsl:value-of select="string-length(w:lvlText/@w:val) - string-length(translate(w:lvlText/@w:val,'%','') )"/></xsl:attribute>
                <!-- 'none' in Word 2003. wym -->
                <xsl:attribute name="style:num-format"/>
                <xsl:attribute name="style:num-prefix"><xsl:value-of select="substring-before(w:lvlText/@w:val, '%')"/></xsl:attribute>
                <xsl:attribute name="style:num-suffix"><xsl:value-of select="substring-after(w:lvlText/@w:val, concat('%', $currlevel + 1) )"/></xsl:attribute>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:element name="style:properties">
            <xsl:choose>
                <xsl:when test="w:lvlJc/@w:val='right'">
                    <xsl:attribute name="fo:text-align">end</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:lvlJc/@w:val='center'">
                    <xsl:attribute name="fo:text-align">center</xsl:attribute>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:attribute name="fo:text-align">start</xsl:attribute>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:variable name="labelwidth">
                <xsl:choose>
                    <xsl:when test="w:pPr/w:ind/@w:hanging">
                        <xsl:call-template name="convert2cm">
                            <xsl:with-param name="value" select="concat(w:pPr/w:ind/@w:hanging,'dxa')"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:when test="w:pPr/w:ind/@w:first-line">
                        <xsl:call-template name="convert2cm">
                            <xsl:with-param name="value" select="concat('-',w:pPr/w:ind/@w:first-line,'dxa')"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>0</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:variable name="leftwidth">
                <xsl:call-template name="convert2cm">
                    <xsl:with-param name="value" select="concat(w:pPr/w:ind/@w:left,'dxa')"/>
                </xsl:call-template>
            </xsl:variable>
            <xsl:attribute name="text:space-before"><xsl:value-of select="concat(number($leftwidth)-number($labelwidth),'cm')"/></xsl:attribute>
            <xsl:attribute name="text:min-label-width"><xsl:choose><xsl:when test="$labelwidth &gt; 0"><xsl:value-of select="concat($labelwidth,'cm')"/></xsl:when><xsl:otherwise>0cm</xsl:otherwise></xsl:choose></xsl:attribute>
            <!-- In binary word translation, text:min-label-distance do not generate. So, the width of number-symbol will not effect the start position of text. But first line always start same position of second line, no indent. If text:min-label-distance generate, the look of list will change because of uncountable number-symbol's width, now use 0.25cm as default width-->
            <xsl:choose>
                <xsl:when test="w:suff/@w:val='Space'">
                    <xsl:attribute name="text:min-label-distance">0.20cm</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:pPr/w:tabs/w:tab/@w:pos">
                    <xsl:variable name="tabpos">
                        <xsl:call-template name="convert2cm">
                            <xsl:with-param name="value" select="concat(w:pPr/w:tabs/w:tab/@w:pos,'dxa')"/>
                        </xsl:call-template>
                    </xsl:variable>
                    <xsl:if test="number($tabpos) &gt; (number($leftwidth)-number($labelwidth))">
                        <xsl:attribute name="text:min-label-distance"><xsl:value-of select="concat(number($tabpos)+number($labelwidth)-number($leftwidth)-0.25,'cm')"/></xsl:attribute>
                    </xsl:if>
                </xsl:when>
            </xsl:choose>
            <!-- Find the node that corresponds to the level being processed. We can use this to determine the indentation to be used
            <xsl:variable name="currNode" select="/w:wordDocument/w:body//w:listPr[w:ilvl/@w:val = $currlevel][w:ilfo/@w:val = $currlist/w:ilfo/@w:val]"/>
            <xsl:choose>
                <xsl:when test="($currNode/wx:t/@wx:wTabBefore ) and ($currNode/wx:t/@wx:wTabAfter ) and (not($currNode/following-sibling::w:jc) or $currNode/following-sibling::w:jc/@w:val = 'left')">
                    <xsl:attribute name="text:space-before"><xsl:value-of select="(number($currNode/wx:t/@wx:wTabBefore)div 1440) * 2.54"/>cm</xsl:attribute>
                    <xsl:attribute name="text:min-label-distance"><xsl:value-of select="(number($currNode/wx:t/@wx:wTabAfter)div 1440) * 2.54"/>cm</xsl:attribute>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:attribute name="text:space-before"><xsl:value-of select="((number(w:pPr/w:ind/@w:left)  div 1440) * 2.54) "/>cm</xsl:attribute>
                    <xsl:attribute name="text:min-label-distance"><xsl:value-of select="(number($currlist/wx:t/@wx:wTabAfter) div 1440) * 2.54"/>cm</xsl:attribute>
                </xsl:otherwise>
            </xsl:choose>-->
            <xsl:if test="w:rPr/w:rFonts">
                <xsl:if test="w:rPr/w:rFonts/@w:ascii">
                    <xsl:attribute name="style:font-name"><xsl:value-of select="w:rPr/w:rFonts/@w:ascii"/></xsl:attribute>
                </xsl:if>
                <xsl:if test="w:rPr/w:rFonts/@w:fareast">
                    <xsl:attribute name="style:font-name-asian"><xsl:value-of select="w:rPr/w:rFonts/@w:fareast"/></xsl:attribute>
                </xsl:if>
                <xsl:if test="w:rPr/w:rFonts/@w:cs">
                    <xsl:attribute name="style:font-name-complex"><xsl:value-of select="w:rPr/w:rFonts/@w:cs"/></xsl:attribute>
                </xsl:if>
            </xsl:if>
        </xsl:element>
    </xsl:template>
    <xsl:template name="list-styles-image">
        <xsl:variable name="currlevel" select="number(@w:ilvl)"/>
        <xsl:attribute name="text:level"><xsl:value-of select="$currlevel+1"/></xsl:attribute>
        <xsl:variable name="picid" select="w:lvlPicBulletId/@w:val"/>
        <xsl:element name="style:properties">
            <xsl:attribute name="style:vertical-pos">middle</xsl:attribute>
            <xsl:attribute name="style:vertical-rel">line</xsl:attribute>
            <xsl:variable name="picsize" select="/descendant::w:lists/w:listPicBullet[@w:listPicBulletId=$picid]/w:pict/v:shape/@style"/>
            <xsl:attribute name="fo:width"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="substring-before(substring-after($picsize,'width:'), ';')"/></xsl:call-template><xsl:text>cm</xsl:text></xsl:attribute>
            <xsl:attribute name="fo:height"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="substring-after($picsize,'height:')"/></xsl:call-template><xsl:text>cm</xsl:text></xsl:attribute>
            <xsl:variable name="labelwidth">
                <xsl:choose>
                    <xsl:when test="w:pPr/w:ind/@w:hanging">
                        <xsl:call-template name="convert2cm">
                            <xsl:with-param name="value" select="concat(w:pPr/w:ind/@w:hanging,'dxa')"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:when test="w:pPr/w:ind/@w:first-line">
                        <xsl:call-template name="convert2cm">
                            <xsl:with-param name="value" select="concat('-',w:pPr/w:ind/@w:first-line,'dxa')"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>0</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:variable name="leftwidth">
                <xsl:call-template name="convert2cm">
                    <xsl:with-param name="value" select="concat(w:pPr/w:ind/@w:left,'dxa')"/>
                </xsl:call-template>
            </xsl:variable>
            <xsl:attribute name="text:space-before"><xsl:value-of select="concat(number($leftwidth)-number($labelwidth),'cm')"/></xsl:attribute>
            <xsl:attribute name="text:min-label-width"><xsl:choose><xsl:when test="$labelwidth &gt; 0"><xsl:value-of select="concat($labelwidth,'cm')"/></xsl:when><xsl:otherwise>0cm</xsl:otherwise></xsl:choose></xsl:attribute>
            <xsl:choose>
                <xsl:when test="w:suff/@w:val='Space'">
                    <xsl:attribute name="text:min-label-distance">0.20cm</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:pPr/w:tabs/w:tab/@w:pos">
                    <xsl:variable name="tabpos">
                        <xsl:call-template name="convert2cm">
                            <xsl:with-param name="value" select="concat(w:pPr/w:tabs/w:tab/@w:pos,'dxa')"/>
                        </xsl:call-template>
                    </xsl:variable>
                    <xsl:if test="number($tabpos) &gt; (number($leftwidth)-number($labelwidth))">
                        <xsl:attribute name="text:min-label-distance"><xsl:value-of select="concat(number($tabpos)+number($labelwidth)-number($leftwidth),'cm')"/></xsl:attribute>
                    </xsl:if>
                </xsl:when>
            </xsl:choose>
        </xsl:element>
        <office:binary-data>
            <xsl:value-of select="/descendant::w:lists/w:listPicBullet[@w:listPicBulletId=$picid]/w:pict/w:binData"/>
        </office:binary-data>
    </xsl:template>
    <!-- avoid listPr in textbox. :( glu -->
    <xsl:template match="w:p[w:pPr/w:listPr[w:ilvl and w:ilfo]]">
        <xsl:call-template name="genlist"/>
    </xsl:template>
    <xsl:template name="genlist">
        <xsl:variable name="currlistid" select="w:pPr/w:listPr/w:ilfo/@w:val"/>
        <xsl:variable name="currlistlvl" select="w:pPr/w:listPr/w:ilvl/@w:val"/>
        <xsl:variable name="firstoccur" select="/descendant::w:pPr[w:listPr/w:ilfo/@w:val = $currlistid][1]"/>
        <xsl:variable name="rootlistid" select="/w:wordDocument/w:lists/w:list[@w:ilfo=$currlistid]/w:ilst/@w:val"/>
        <xsl:variable name="rootlistname" select="/w:wordDocument/w:lists/w:listDef[@w:listDefId =$rootlistid ]/w:listStyleLink/@w:val"/>
        <xsl:element name="text:ordered-list">
            <xsl:attribute name="text:style-name"><xsl:choose><xsl:when test="string-length($rootlistname) &gt; 0"><xsl:value-of select="$rootlistname"/></xsl:when><xsl:otherwise>List<xsl:value-of select="count($firstoccur/preceding::w:listPr)"/></xsl:otherwise></xsl:choose></xsl:attribute>
            <xsl:choose>
                <xsl:when test="preceding::w:pPr/w:listPr/w:ilfo/@w:val = w:pPr/w:listPr/w:ilfo/@w:val">
                    <xsl:attribute name="text:continue-numbering">true</xsl:attribute>
                    <xsl:element name="text:list-item">
                        <xsl:call-template name="levels">
                            <xsl:with-param name="level" select="$currlistlvl"/>
                        </xsl:call-template>
                    </xsl:element>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:element name="text:list-item">
                        <xsl:call-template name="levels">
                            <xsl:with-param name="level" select="$currlistlvl"/>
                        </xsl:call-template>
                    </xsl:element>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:element>
    </xsl:template>
    <xsl:template name="levels">
        <xsl:param name="level"/>
        <xsl:choose>
            <xsl:when test="$level = '0'">
                <xsl:call-template name="process-common-paragraph"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:element name="text:ordered-list">
                    <xsl:element name="text:list-item">
                        <xsl:call-template name="levels">
                            <xsl:with-param name="level" select="$level -1"/>
                        </xsl:call-template>
                    </xsl:element>
                </xsl:element>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="w:style" mode="list">
        <xsl:variable name="listname" select="@w:styleId"/>
        <xsl:if test="/w:wordDocument/w:lists/w:listDef[w:styleLink/@w:val=$listname]">
            <text:list-style style:name="{$listname}">
                <xsl:apply-templates select="/w:wordDocument/w:lists/w:listDef[w:styleLink/@w:val=$listname]/w:lvl"/>
            </text:list-style>
        </xsl:if>
    </xsl:template>
    <!-- for create outline style in office:styles -->
    <xsl:template name="create-outline-style">
        <xsl:element name="text:outline-style">
            <xsl:call-template name="outline-level-style">
                <xsl:with-param name="level" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="outline-level-style">
                <xsl:with-param name="level" select="2"/>
            </xsl:call-template>
            <xsl:call-template name="outline-level-style">
                <xsl:with-param name="level" select="3"/>
            </xsl:call-template>
            <xsl:call-template name="outline-level-style">
                <xsl:with-param name="level" select="4"/>
            </xsl:call-template>
            <xsl:call-template name="outline-level-style">
                <xsl:with-param name="level" select="5"/>
            </xsl:call-template>
            <xsl:call-template name="outline-level-style">
                <xsl:with-param name="level" select="6"/>
            </xsl:call-template>
            <xsl:call-template name="outline-level-style">
                <xsl:with-param name="level" select="7"/>
            </xsl:call-template>
            <xsl:call-template name="outline-level-style">
                <xsl:with-param name="level" select="8"/>
            </xsl:call-template>
            <xsl:call-template name="outline-level-style">
                <xsl:with-param name="level" select="9"/>
            </xsl:call-template>
            <xsl:call-template name="outline-level-style">
                <xsl:with-param name="level" select="10"/>
            </xsl:call-template>
        </xsl:element>
    </xsl:template>
    <xsl:template name="outline-level-style">
        <xsl:param name="level"/>
        <xsl:element name="text:outline-level-style">
            <xsl:choose>
                <xsl:when test="w:style[@w:type = 'paragraph' and (w:pPr/w:outlineLvl/@w:val = $level -1) and w:pPr/w:listPr]">
                    <xsl:apply-templates select="(w:style[@w:type = 'paragraph' and w:pPr/w:outlineLvl/@w:val = $level -1 and w:pPr/w:listPr ]/w:pPr/w:listPr)[position()=1]" mode="outline">
                        <xsl:with-param name="outlinelevel" select="$level"/>
                    </xsl:apply-templates>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:attribute name="text:level"><xsl:value-of select="$level"/></xsl:attribute>
                    <xsl:attribute name="style:num-format"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:element>
    </xsl:template>
    <xsl:template match="w:listPr" mode="outline">
        <xsl:param name="outlinelevel"/>
        <xsl:variable name="currlistid" select="w:ilfo/@w:val"/>
        <xsl:variable name="currlistlevel">
            <xsl:choose>
                <xsl:when test="w:ilvl">
                    <xsl:value-of select="w:ilvl/@w:val"/>
                </xsl:when>
                <xsl:otherwise>0</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="rootlistid" select="/w:wordDocument/w:lists/w:list[@w:ilfo=$currlistid]/w:ilst/@w:val"/>
        <xsl:variable name="rootlist" select="/w:wordDocument/w:lists/w:listDef[@w:listDefId =$rootlistid ]"/>
        <xsl:for-each select="$rootlist/w:lvl[@w:ilvl=$currlistlevel]">
            <xsl:call-template name="list-styles-common">
                <xsl:with-param name="listtype">
                    <xsl:choose>
                        <xsl:when test="w:nfc/@w:val">
                            <xsl:value-of select="w:nfc/@w:val"/>
                        </xsl:when>
                        <xsl:otherwise>0</xsl:otherwise>
                    </xsl:choose>
                </xsl:with-param>
                <xsl:with-param name="currlevel" select="$outlinelevel"/>
            </xsl:call-template>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="nfc2numformat">
        <xsl:param name="nfcvalue"/>
        <xsl:param name="prefix"/>
        <xsl:param name="suffix"/>
        <xsl:choose>
            <xsl:when test="$nfcvalue=0">
                <xsl:attribute name="style:num-format">1</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=1">
                <xsl:attribute name="style:num-format">I</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=2">
                <xsl:attribute name="style:num-format">i</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=3">
                <xsl:attribute name="style:num-format">A</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=4">
                <xsl:attribute name="style:num-format">a</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=10 or $nfcvalue=11 or $nfcvalue=17 or $nfcvalue=29 or $nfcvalue=33 or $nfcvalue=35 or $nfcvalue=36 or $nfcvalue=37 or $nfcvalue=39 or $nfcvalue=44">
                <xsl:attribute name="style:num-format">一, 二, 三, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=12">
                <xsl:attribute name="style:num-format">ア, イ, ウ, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=13">
                <xsl:attribute name="style:num-format">イ, ロ, ハ, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=14 or $nfcvalue=19">
                <xsl:attribute name="style:num-format">１, ２, ３, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=16">
                <xsl:attribute name="style:num-format">壱, 弐, 参, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=18 or $nfcvalue=28">
                <xsl:attribute name="style:num-format">①, ②, ③, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=20">
                <xsl:attribute name="style:num-format">ｱ, ｲ, ｳ, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=21">
                <xsl:attribute name="style:num-format">ｲ, ﾛ, ﾊ, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=24">
                <xsl:attribute name="style:num-format">가, 나, 다, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=25">
                <xsl:attribute name="style:num-format">ㄱ, ㄴ, ㄷ, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=30">
                <xsl:attribute name="style:num-format">甲, 乙, 丙, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=31">
                <xsl:attribute name="style:num-format">子, 丑, 寅, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=34">
                <xsl:attribute name="style:num-format">壹, 貳, 參, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=38">
                <xsl:attribute name="style:num-format">壹, 贰, 叁, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=41 or $nfcvalue=42 or $nfcvalue=43">
                <xsl:attribute name="style:num-format">일, 이, 삼, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=45 or $nfcvalue=47">
                <xsl:attribute name="style:num-format">א, ב, ג, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=46 or $nfcvalue=48">
                <xsl:attribute name="style:num-format">أ, ب, ت, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=53">
                <xsl:attribute name="style:num-format">ก, ข, ฃ, ...</xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue!=57 and $nfcvalue &gt; 48 and $nfcvalue &lt; 60">
                <xsl:attribute name="style:num-format">Native Numbering</xsl:attribute>
            </xsl:when>
            <xsl:otherwise>
                <xsl:attribute name="style:num-format">1</xsl:attribute>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:choose>
            <xsl:when test="$nfcvalue=26">
                <xsl:attribute name="style:num-prefix"><xsl:value-of select="$prefix"/></xsl:attribute>
                <xsl:attribute name="style:num-suffix"><xsl:value-of select="concat( '.' , $suffix )"/></xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=27 or $nfcvalue=29">
                <xsl:attribute name="style:num-prefix"><xsl:value-of select="concat( $prefix, '(' )"/></xsl:attribute>
                <xsl:attribute name="style:num-suffix"><xsl:value-of select="concat( ')' , $suffix )"/></xsl:attribute>
            </xsl:when>
            <xsl:when test="$nfcvalue=57">
                <xsl:attribute name="style:num-prefix"><xsl:value-of select="concat( $prefix, '- ' )"/></xsl:attribute>
                <xsl:attribute name="style:num-suffix"><xsl:value-of select="concat( ' -' , $suffix )"/></xsl:attribute>
            </xsl:when>
            <xsl:otherwise>
                <xsl:attribute name="style:num-prefix"><xsl:value-of select="$prefix"/></xsl:attribute>
                <xsl:attribute name="style:num-suffix"><xsl:value-of select="$suffix"/></xsl:attribute>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
<!-- End of OOo2.0 import/wordml/wordml2ooo_list.xsl stylesheet  -->
<!-- Start of OOo2.0 import/wordml/wordml2ooo_page.xsl stylesheet  -->
    <xsl:template match="w:sectPr" mode="page-master">
        <style:page-master>
            <xsl:attribute name="style:name">pm<xsl:number from="/w:wordDocument/w:body" level="any" count="w:sectPr"/></xsl:attribute>
            <style:properties>
                <xsl:attribute name="fo:page-width"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgSz/@w:w,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                <xsl:attribute name="fo:page-height"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgSz/@w:h,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                <xsl:choose>
                    <xsl:when test="/w:wordDocument/w:docPr/w:gutterAtTop">
                        <xsl:attribute name="fo:margin-top"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgMar/@w:top + w:pgMar/@w:gutter,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                        <xsl:attribute name="fo:margin-left"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgMar/@w:left,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                        <xsl:attribute name="fo:margin-right"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgMar/@w:right,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                    </xsl:when>
                    <xsl:when test="w:rtlGutter">
                        <xsl:attribute name="fo:margin-top"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgMar/@w:top,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                        <xsl:attribute name="fo:margin-left"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgMar/@w:left,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                        <xsl:attribute name="fo:margin-right"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgMar/@w:right + w:pgMar/@w:gutter,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="fo:margin-top"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgMar/@w:top,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                        <xsl:attribute name="fo:margin-left"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgMar/@w:left + w:pgMar/@w:gutter,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                        <xsl:attribute name="fo:margin-right"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgMar/@w:right,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:attribute name="fo:margin-bottom"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgMar/@w:bottom,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                <xsl:attribute name="style:footnote-max-height"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgMar/@w:footer,'dxa')"/></xsl:call-template></xsl:attribute>
                <xsl:if test="w:pgSz/@w:orient">
                    <xsl:attribute name="style:print-orientation"><xsl:value-of select="w:pgSz/@w:orient"/></xsl:attribute>
                </xsl:if>
                <xsl:if test="w:cols/@w:num">
                    <!-- create sction property-->
                    <style:columns>
                        <xsl:attribute name="fo:column-count"><xsl:value-of select="w:cols/@w:num"/></xsl:attribute>
                        <xsl:attribute name="fo:column-gap"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:cols/@w:space,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                    </style:columns>
                </xsl:if>
            </style:properties>
        </style:page-master>
    </xsl:template>
    <xsl:template match="w:sectPr" mode="master-page">
        <!-- style:page-master style:style-->
        <style:master-page>
            <xsl:variable name="master-page-name">
                <xsl:number count="w:sectPr" from="/w:wordDocument/w:body" level="any"/>
            </xsl:variable>
            <xsl:attribute name="style:name">Standard<xsl:value-of select="$master-page-name"/></xsl:attribute>
            <xsl:attribute name="style:page-master-name"><xsl:value-of select="concat('pm', $master-page-name)"/></xsl:attribute>
            <!-- Headers and footers-->
            <style:header-style>
                <style:properties>
                    <xsl:attribute name="fo:min-height"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgMar/@w:header,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                    <xsl:attribute name="fo:margin-bottom">0.792cm</xsl:attribute>
                    <xsl:attribute name="style:dynamic-spacing">true</xsl:attribute>
                </style:properties>
            </style:header-style>
            <style:footer-style>
                <style:properties>
                    <xsl:attribute name="fo:min-height"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pgMar/@w:footer,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                    <xsl:attribute name="fo:margin-top">0.792cm</xsl:attribute>
                    <xsl:attribute name="style:dynamic-spacing">true</xsl:attribute>
                </style:properties>
            </style:footer-style>
            <xsl:if test="not(w:titlePg)">
                <xsl:apply-templates select="w:hdr[@w:type='odd']"/>
                <xsl:apply-templates select="w:hdr[@w:type='even']"/>
                <xsl:apply-templates select="w:ftr[@w:type='odd']"/>
                <xsl:apply-templates select="w:ftr[@w:type='even']"/>
            </xsl:if>
        </style:master-page>
    </xsl:template>
    <xsl:template match="w:hdr">
        <xsl:choose>
            <xsl:when test="@w:type = 'odd'">
                <style:header>
                    <xsl:apply-templates/>
                </style:header>
            </xsl:when>
            <xsl:when test="@w:type = 'even'">
                <style:header-left>
                    <xsl:apply-templates/>
                </style:header-left>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="w:ftr">
        <xsl:choose>
            <xsl:when test="@w:type = 'odd'">
                <style:footer>
                    <xsl:apply-templates/>
                </style:footer>
            </xsl:when>
            <xsl:when test="@w:type = 'even'">
                <style:footer-left>
                    <xsl:apply-templates/>
                </style:footer-left>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
<!-- End of OOo2.0 import/wordml/wordml2ooo_page.xsl stylesheet  -->
<!-- Start of OOo2.0 import/wordml/wordml2ooo_settings.xsl stylesheet  -->
    <xsl:template match="w:docPr">
        <office:settings>
            <config:config-item-set config:name="view-settings">
                <config:config-item config:name="InBrowseMode" config:type="boolean">
                    <xsl:choose>
                        <xsl:when test="w:view/@w:val = 'outline'">true</xsl:when>
                        <xsl:when test="w:view/@w:val = 'print'">false</xsl:when>
                        <!-- others: web, reading, normal, master-pages, none. glu -->
                        <xsl:otherwise>true</xsl:otherwise>
                    </xsl:choose>
                </config:config-item>
                <config:config-item-map-indexed config:name="Views">
                    <config:config-item-map-entry>
                        <xsl:if test="w:zoom">
                            <!-- VisibleRight and VisibleBottom are arbitrary positive numbers. ;) glu -->
                            <config:config-item config:name="VisibleRight" config:type="int">1</config:config-item>
                            <config:config-item config:name="VisibleBottom" config:type="int">1</config:config-item>
                            <xsl:choose>
                                <xsl:when test="w:zoom/@w:val = 'best-fit'">
                                    <config:config-item config:name="ZoomType" config:type="short">3</config:config-item>
                                </xsl:when>
                                <xsl:when test="w:zoom/@w:val = 'full-page'">
                                    <config:config-item config:name="ZoomType" config:type="short">2</config:config-item>
                                </xsl:when>
                                <xsl:when test="w:zoom/@w:val = 'text-fit'">
                                    <config:config-item config:name="ZoomType" config:type="short">1</config:config-item>
                                </xsl:when>
                                <xsl:otherwise>
                                    <config:config-item config:name="ZoomType" config:type="short">0</config:config-item>
                                </xsl:otherwise>
                            </xsl:choose>
                            <config:config-item config:name="ZoomFactor" config:type="short">
                                <xsl:value-of select="w:zoom/@w:percent"/>
                            </config:config-item>
                        </xsl:if>
                    </config:config-item-map-entry>
                </config:config-item-map-indexed>
            </config:config-item-set>
        </office:settings>
    </xsl:template>
<!-- End of OOo2.0 import/wordml/wordml2ooo_settings.xsl stylesheet  -->
<!-- Start of OOo2.0 import/wordml/wordml2ooo_table.xsl stylesheet  -->
    <xsl:template match="w:tblPr" mode="style">
        <xsl:element name="style:style">
            <xsl:attribute name="style:name">Table<xsl:number count="w:tbl" from="/w:wordDocument/w:body" level="any"/></xsl:attribute>
            <xsl:attribute name="style:family">table</xsl:attribute>
            <xsl:if test="w:tblStyle">
                <xsl:attribute name="style:parent-style-name"><xsl:value-of select="w:tblStyle/@w:val"/></xsl:attribute>
            </xsl:if>
            <xsl:element name="style:properties">
                <xsl:choose>
                    <xsl:when test="w:jc/@w:val = 'left' or w:jc/@w:val = 'center' or w:jc/@w:val = 'right'">
                        <xsl:attribute name="table:align"><xsl:value-of select="w:jc/@w:val"/></xsl:attribute>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="table:align">margins</xsl:attribute>
                    </xsl:otherwise>
                </xsl:choose>
                <!-- adopt the width of table and column corresponding the width of page and margins. . -->
                <xsl:variable name="sectPr" select="following::w:sectPr[1]"/>
                <xsl:variable name="total-page-size" select="$sectPr/w:pgSz/@w:w"/>
                <xsl:variable name="page-left-mar" select="$sectPr/w:pgMar/@w:left"/>
                <xsl:variable name="page-right-mar" select="$sectPr/w:pgMar/@w:right"/>
                <xsl:variable name="page-size-value" select="$total-page-size - $page-left-mar - $page-right-mar"/>
                <xsl:variable name="page-size-inch">
                    <xsl:call-template name="convert2in">
                        <xsl:with-param name="value" select="concat($page-size-value, 'dxa') "/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:variable name="gridcols" select="../w:tblGrid/w:gridCol"/>
                <xsl:variable name="tblsize" select="sum($gridcols/@w:w)"/>
                <xsl:variable name="table_indent">
                    <xsl:choose>
                        <xsl:when test="w:tblInd and  w:tblInd/@w:w &gt; 0 ">
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat(w:tblInd/@w:w, 'dxa') "/>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="number( '0') "/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:variable name="rel-tblsize">
                    <xsl:choose>
                        <xsl:when test="w:tblW/@w:type = 'pct'">
                            <xsl:value-of select="(number(w:tblW/@w:w  ) div 5000) * $page-size-inch"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat($tblsize, 'dxa')"/>
                            </xsl:call-template>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:attribute name="style:width"><xsl:value-of select="concat($rel-tblsize, 'inch' )"/></xsl:attribute>
                <xsl:variable name="tbl_margin_left">
                    <xsl:choose>
                        <xsl:when test="not(w:tblpPr ) ">
                            <xsl:choose>
                                <xsl:when test="w:bidiVisual">
                                    <xsl:choose>
                                        <xsl:when test=" number($page-size-inch - $table_indent - $rel-tblsize) &gt; 0">
                                            <xsl:value-of select="$page-size-inch - $table_indent - $rel-tblsize"/>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:text>0</xsl:text>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:value-of select="$table_indent"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:when test="w:tblpPr">
                            <!-- if the table is  put into a draw:text-box,  fo:margin-left and fo:margin-right should be 0 -->
                            <xsl:text>0</xsl:text>
                        </xsl:when>
                    </xsl:choose>
                </xsl:variable>
                <xsl:variable name="tbl_margin_right">
                    <xsl:choose>
                        <xsl:when test="not(w:tblpPr ) ">
                            <xsl:choose>
                                <xsl:when test="w:bidiVisual">
                                    <xsl:value-of select="$table_indent"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:choose>
                                        <xsl:when test=" number($page-size-inch - $table_indent - $rel-tblsize) &gt; 0">
                                            <xsl:value-of select="$page-size-inch - $table_indent - $rel-tblsize"/>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:text>0</xsl:text>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:when test="w:tblpPr">
                            <!-- if the table is  put into a draw:text-box,  fo:margin-left and fo:margin-right should be 0 -->
                            <xsl:text>0</xsl:text>
                        </xsl:when>
                    </xsl:choose>
                </xsl:variable>
                <xsl:attribute name="fo:margin-left"><xsl:value-of select="concat( $tbl_margin_left, 'inch')"/></xsl:attribute>
                <xsl:attribute name="fo:margin-right"><xsl:value-of select="concat($tbl_margin_right, 'inch')"/></xsl:attribute>
                <!-- If previous w:p has a page break, the table must have the page break attribute applied to it	 May need this for tables starting on new pages -->
                <!--	<xsl:if test="parent::w:tbl/preceding-sibling::w:p[1][descendant::w:br/@w:type='page']">
							<xsl:attribute name="fo:break-before">page</xsl:attribute></xsl:if>	-->
                <!-- initial values for tables-->
            </xsl:element>
        </xsl:element>
        <!-- the following style is for conveting Word table text wrapping to SO Writer. Since SO Writer has no table text wrapping feature, so we use the draw:text-box as a container and put the table in draw:text-box -->
        <xsl:if test="w:tblpPr">
            <xsl:element name="style:style">
                <xsl:attribute name="style:name">TableFrame<xsl:number count="w:tblpPr" from="/w:wordDocument/w:body" level="any"/></xsl:attribute>
                <xsl:attribute name="style:family">graphics</xsl:attribute>
                <xsl:attribute name="style:parent-style-name"><xsl:value-of select=" 'Frame' "/></xsl:attribute>
                <xsl:element name="style:properties">
                    <xsl:if test="w:tblpPr/@w:leftFromText">
                        <xsl:variable name="left_margin_from_text">
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat (w:tblpPr/@w:leftFromText, 'dxa') "/>
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:attribute name="fo:margin-left"><xsl:value-of select="concat( $left_margin_from_text, 'inch') "/></xsl:attribute>
                    </xsl:if>
                    <xsl:if test="w:tblpPr/@w:rightFromText">
                        <xsl:variable name="right_margin_from_text">
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat (w:tblpPr/@w:rightFromText, 'dxa') "/>
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:attribute name="fo:margin-right"><xsl:value-of select="concat( $right_margin_from_text, 'inch') "/></xsl:attribute>
                    </xsl:if>
                    <xsl:if test="w:tblpPr/@w:topFromText">
                        <xsl:variable name="top_margin_from_text">
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat (w:tblpPr/@w:topFromText, 'dxa') "/>
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:attribute name="fo:margin-top"><xsl:value-of select="concat( $top_margin_from_text, 'inch') "/></xsl:attribute>
                    </xsl:if>
                    <xsl:if test="w:tblpPr/@w:bottomFromText">
                        <xsl:variable name="bottom_margin_from_text">
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat (w:tblpPr/@w:bottomFromText, 'dxa') "/>
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:attribute name="fo:margin-bottom"><xsl:value-of select="concat( $bottom_margin_from_text, 'inch') "/></xsl:attribute>
                    </xsl:if>
                    <xsl:attribute name="style:number-wrapped-paragraphs"><xsl:text>no-limit</xsl:text></xsl:attribute>
                    <!--xsl:if test="w:tblpPr/@w:tblpYSpec" to get the vertical alignment-->
                    <xsl:variable name="vertical_alignment">
                        <xsl:choose>
                            <xsl:when test="w:tblpPr/@w:tblpYSpec = 'top' ">
                                <xsl:text>top</xsl:text>
                            </xsl:when>
                            <xsl:when test="w:tblpPr/@w:tblpYSpec = 'center' ">
                                <xsl:text>middle</xsl:text>
                            </xsl:when>
                            <xsl:when test="w:tblpPr/@w:tblpYSpec= 'bottom' ">
                                <xsl:text>bottom</xsl:text>
                            </xsl:when>
                            <xsl:when test="w:tblpPr/@w:tblpYSpec = 'inside' ">
                                <xsl:text>from-top</xsl:text>
                            </xsl:when>
                            <xsl:when test="w:tblpPr/@w:tblpYSpec= 'outside' ">
                                <xsl:text>top</xsl:text>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:text>from-top</xsl:text>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:attribute name="style:vertical-pos"><xsl:value-of select="$vertical_alignment"/></xsl:attribute>
                    <!--/xsl:if-->
                    <!--xsl:if test="w:tblpPr/@w:vertAnchor" to get the vertical anchor related area type -->
                    <xsl:variable name="frame_v_anchor">
                        <xsl:choose>
                            <xsl:when test="w:tblpPr/@w:vertAnchor = 'text' ">
                                <xsl:value-of select=" 'paragraph' "/>
                            </xsl:when>
                            <xsl:when test="w:tblpPr/@w:vertAnchor = 'margin' ">
                                <xsl:value-of select=" 'paragraph-content' "/>
                            </xsl:when>
                            <xsl:when test="w:tblpPr/@w:vertAnchor = 'page' ">
                                <xsl:value-of select="w:tblpPr/@w:vertAnchor"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select=" 'page-content' "/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:attribute name="style:vertical-rel"><xsl:value-of select="$frame_v_anchor"/></xsl:attribute>
                    <!--/xsl:if-->
                    <!--xsl:if test="w:tblpPr/@w:tblpXSpec" to get the horizntal alignment-->
                    <xsl:variable name="horizental_alignment">
                        <xsl:choose>
                            <xsl:when test="w:tblpPr/@w:tblpXSpec = 'left' ">
                                <xsl:text>left</xsl:text>
                            </xsl:when>
                            <xsl:when test="w:tblpPr/@w:tblpXSpec = 'center' ">
                                <xsl:text>center</xsl:text>
                            </xsl:when>
                            <xsl:when test="w:tblpPr/@w:tblpXSpec = 'right' ">
                                <xsl:text>right</xsl:text>
                            </xsl:when>
                            <xsl:when test="w:tblpPr/@w:tblpXSpec = 'inside' ">
                                <xsl:text>from-left</xsl:text>
                            </xsl:when>
                            <xsl:when test="w:tblpPr/@w:tblpXSpec = 'outside' ">
                                <xsl:text>outside</xsl:text>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:text>left</xsl:text>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:attribute name="style:horizontal-pos"><xsl:value-of select="$horizental_alignment"/></xsl:attribute>
                    <!--/xsl:if-->
                    <!--xsl:if test="w:tblpPr/@w:horzAnchor" to get the horizental anchor related area type-->
                    <xsl:variable name="frame_h_anchor">
                        <xsl:choose>
                            <xsl:when test="w:tblpPr/@w:horzAnchor = 'text' ">
                                <xsl:value-of select=" 'paragraph' "/>
                            </xsl:when>
                            <xsl:when test="w:tblpPr/@w:horzAnchor = 'margin' ">
                                <xsl:value-of select=" 'page-content' "/>
                            </xsl:when>
                            <xsl:when test="w:tblpPr/@w:horzAnchor = 'page' ">
                                <xsl:value-of select="w:tblpPr/@w:horzAnchor"/>
                            </xsl:when>
                            <xsl:when test="w:tblpPr/@w:horzAnchor= 'inside' ">
                                <xsl:value-of select=" 'paragraph-start-margin' "/>
                            </xsl:when>
                            <xsl:when test="w:tblpPr/@w:horzAnchor= 'outside' ">
                                <xsl:value-of select=" 'paragraph-end-margin' "/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select=" 'paragraph-content' "/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:attribute name="style:horizontal-rel"><xsl:value-of select="$frame_h_anchor"/></xsl:attribute>
                    <!--/xsl:if-->
                    <xsl:attribute name="fo:background-color"><xsl:text>#ffffff</xsl:text></xsl:attribute>
                    <xsl:attribute name="style:background-transparency"><xsl:text>100%</xsl:text></xsl:attribute>
                    <xsl:attribute name="style:wrap"><xsl:text>parallel</xsl:text></xsl:attribute>
                </xsl:element>
            </xsl:element>
        </xsl:if>
    </xsl:template>
    <xsl:template match="w:gridCol" mode="style">
        <xsl:element name="style:style">
            <xsl:attribute name="style:family">table-column</xsl:attribute>
            <xsl:attribute name="style:name">Table<xsl:number count="w:tbl" from="/w:wordDocument/w:body" level="any"/>.C<xsl:number count="w:gridCol" from="/w:wordDocument/w:body" level="single"/></xsl:attribute>
            <xsl:element name="style:properties">
                <xsl:variable name="column_width">
                    <xsl:call-template name="convert2in">
                        <xsl:with-param name="value" select="concat(@w:w, 'dxa') "/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:attribute name="style:column-width"><xsl:value-of select="concat($column_width,'inch') "/></xsl:attribute>
            </xsl:element>
        </xsl:element>
    </xsl:template>
    <xsl:template match="w:trPr" mode="style">
        <!-- to generate style:style of table-row height.  -->
        <xsl:element name="style:style">
            <xsl:attribute name="style:family">table-row</xsl:attribute>
            <xsl:attribute name="style:name">Table<xsl:number count="w:tbl" from="/w:wordDocument/w:body" level="any"/>.R<xsl:number count="w:tr" from="/w:wordDocument/w:body" level="single"/></xsl:attribute>
            <xsl:element name="style:properties">
                <xsl:choose>
                    <xsl:when test="w:trHeight/@w:val">
                        <xsl:variable name="tbl_row_height">
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat(w:trHeight/@w:val, 'dxa') "/>
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:attribute name="style:row-height"><xsl:value-of select="concat($tbl_row_height, 'inch' )"/></xsl:attribute>
                    </xsl:when>
                </xsl:choose>
            </xsl:element>
        </xsl:element>
    </xsl:template>
    <xsl:template match="w:tcPr" mode="style">
        <style:style>
            <xsl:attribute name="style:name">Table<xsl:number count="w:tbl" from="/w:wordDocument/w:body" level="any"/>.R<xsl:number count="w:tr" from="/w:wordDocument/w:body" level="single"/>C<xsl:number count="w:tc" from="/w:wordDocument/w:body" level="single"/></xsl:attribute>
            <xsl:attribute name="style:family">table-cell</xsl:attribute>
            <xsl:variable name="rootStyle" select="ancestor::w:tbl/w:tblPr/w:tblStyle/@w:val"/>
            <xsl:variable name="rootStyleNode" select="/w:wordDocument/w:styles/w:style[@w:styleId = $rootStyle]"/>
            <xsl:element name="style:properties">
                <!-- cell background color start -->
                <xsl:variable name="tbl_cell_background_color">
                    <xsl:choose>
                        <xsl:when test="w:shd/@w:fill">
                            <xsl:value-of select="w:shd/@w:fill"/>
                        </xsl:when>
                        <xsl:when test="$rootStyleNode/w:tblpr/w:shd/@w:fill">
                            <xsl:value-of select="$rootStyleNode/w:tblpr/w:shd/@w:fill"/>
                        </xsl:when>
                    </xsl:choose>
                </xsl:variable>
                <xsl:attribute name="fo:background-color"><xsl:value-of select="concat('#',$tbl_cell_background_color)"/></xsl:attribute>
                <!--cell background color end -->
                <!-- table cell vertical alignment start -->
                <xsl:if test="w:vAlign">
                    <xsl:variable name="tbl_cell_alignment">
                        <xsl:choose>
                            <xsl:when test="w:vAlign/@w:val = 'top' ">
                                <xsl:text>top</xsl:text>
                            </xsl:when>
                            <xsl:when test="w:vAlign/@w:val = 'center' ">
                                <xsl:text>middle</xsl:text>
                            </xsl:when>
                            <xsl:when test="w:vAlign/@w:val = 'bottom' ">
                                <xsl:text>bottom</xsl:text>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:text>automatic</xsl:text>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:attribute name="fo:vertical-align"><xsl:value-of select="$tbl_cell_alignment"/></xsl:attribute>
                </xsl:if>
                <!--table cell alignment end -->
                <!-- cell margin start -->
                <xsl:variable name="tblcell_leftmargin">
                    <xsl:choose>
                        <xsl:when test="w:tcMar/w:left">
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat(w:tcMar/w:left/@w:w , w:tcMar/w:left/@w:type) "/>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:when test="$rootStyleNode/w:tblPr/w:tblCellMar/w:left">
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat($rootStyleNode/w:tblPr/w:tblCellMar/w:left/@w:w , $rootStyleNode/w:tblPr/w:tblCellMar/w:left/@w:type)"/>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>0</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:variable name="tblcell_rightmargin">
                    <xsl:choose>
                        <xsl:when test="w:tcMar/w:right">
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat(w:tcMar/w:right/@w:w , w:tcMar/w:right/@w:type) "/>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:when test="$rootStyleNode/w:tblPr/w:tblCellMar/w:right">
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat($rootStyleNode/w:tblPr/w:tblCellMar/w:right/@w:w , $rootStyleNode/w:tblPr/w:tblCellMar/w:right/@w:type)"/>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>0</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:variable name="tblcell_topmargin">
                    <xsl:choose>
                        <xsl:when test="w:tcMar/w:top">
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat(w:tcMar/w:top/@w:w , w:tcMar/w:top/@w:type) "/>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:when test="$rootStyleNode/w:tblPr/w:tblCellMar/w:top">
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat($rootStyleNode/w:tblPr/w:tblCellMar/w:top/@w:w , $rootStyleNode/w:tblPr/w:tblCellMar/w:top/@w:type)"/>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>0</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:variable name="tblcell_bottommargin">
                    <xsl:choose>
                        <xsl:when test="w:tcMar/w:bottom">
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat(w:tcMar/w:bottom/@w:w , w:tcMar/w:bottom/@w:type) "/>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:when test="$rootStyleNode/w:tblPr/w:tblCellMar/w:bottom">
                            <xsl:call-template name="convert2in">
                                <xsl:with-param name="value" select="concat($rootStyleNode/w:tblPr/w:tblCellMar/w:bottom/@w:w , $rootStyleNode/w:tblPr/w:tblCellMar/w:bottom/@w:type)"/>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>0</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:attribute name="fo:padding-left"><xsl:value-of select="concat($tblcell_leftmargin, 'inch' )"/></xsl:attribute>
                <xsl:attribute name="fo:padding-right"><xsl:value-of select="concat($tblcell_rightmargin, 'inch' )"/></xsl:attribute>
                <xsl:attribute name="fo:padding-top"><xsl:value-of select="concat($tblcell_topmargin, 'inch' )"/></xsl:attribute>
                <xsl:attribute name="fo:padding-bottom"><xsl:value-of select="concat($tblcell_bottommargin, 'inch' )"/></xsl:attribute>
                <!-- cell margin end -->
                <xsl:variable name="row-position">
                    <xsl:number count="w:tr" from="/w:wordDocument/w:body" level="single"/>
                </xsl:variable>
                <!-- cell borders should be carefully converted. a little complex. glu :( -->
                <xsl:variable name="Borders" select="ancestor::w:tbl/w:tblPr/w:tblBorders"/>
                <xsl:choose>
                    <xsl:when test="$row-position &gt; 1">
                        <xsl:call-template name="get-table-border">
                            <xsl:with-param name="style-pos" select="'top'"/>
                            <xsl:with-param name="style-position-0" select="w:tcBorders/w:top"/>
                            <xsl:with-param name="style-position-1" select="$Borders/w:insideH"/>
                            <xsl:with-param name="style-position-2" select="$rootStyleNode/w:tblPr/w:tblBorders/w:insideH"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="get-table-border">
                            <xsl:with-param name="style-pos" select="'top'"/>
                            <xsl:with-param name="style-position-0" select="w:tcBorders/w:top"/>
                            <xsl:with-param name="style-position-1" select="$Borders/w:top"/>
                            <xsl:with-param name="style-position-2" select="$rootStyleNode/w:tblPr/w:tblBorders/w:top"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:choose>
                    <xsl:when test="count(ancestor::w:tr/following-sibling::w:tr) &gt; 0">
                        <xsl:call-template name="get-table-border">
                            <xsl:with-param name="style-pos" select="'bottom'"/>
                            <xsl:with-param name="style-position-0" select="w:tcBorders/w:bottom"/>
                            <xsl:with-param name="style-position-1" select="$Borders/w:insideH"/>
                            <xsl:with-param name="style-position-2" select="$rootStyleNode/w:tblPr/w:tblBorders/w:insideH"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="get-table-border">
                            <xsl:with-param name="style-pos" select="'bottom'"/>
                            <xsl:with-param name="style-position-0" select="w:tcBorders/w:bottom"/>
                            <xsl:with-param name="style-position-1" select="$Borders/w:bottom"/>
                            <xsl:with-param name="style-position-2" select="$rootStyleNode/w:tblPr/w:tblBorders/w:bottom"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:choose>
                    <xsl:when test="count(ancestor::w:tc/preceding-sibling::w:tc) &gt; 0">
                        <xsl:call-template name="get-table-border">
                            <xsl:with-param name="style-pos" select="'left'"/>
                            <xsl:with-param name="style-position-0" select="w:tcBorders/w:left"/>
                            <xsl:with-param name="style-position-1" select="$Borders/w:insideV"/>
                            <xsl:with-param name="style-position-2" select="$rootStyleNode/w:tblPr/w:tblBorders/w:insideV"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="get-table-border">
                            <xsl:with-param name="style-pos" select="'left'"/>
                            <xsl:with-param name="style-position-0" select="w:tcBorders/w:left"/>
                            <xsl:with-param name="style-position-1" select="$Borders/w:left"/>
                            <xsl:with-param name="style-position-2" select="$rootStyleNode/w:tblPr/w:tblBorders/w:left"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:choose>
                    <xsl:when test="count(ancestor::w:tc/following-sibling::w:tc) &gt; 0">
                        <xsl:call-template name="get-table-border">
                            <xsl:with-param name="style-pos" select="'right'"/>
                            <xsl:with-param name="style-position-0" select="w:tcBorders/w:right"/>
                            <xsl:with-param name="style-position-1" select="$Borders/w:insideV"/>
                            <xsl:with-param name="style-position-2" select="$rootStyleNode/w:tblPr/w:tblBorders/w:insideV"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="get-table-border">
                            <xsl:with-param name="style-pos" select="'right'"/>
                            <xsl:with-param name="style-position-0" select="w:tcBorders/w:right"/>
                            <xsl:with-param name="style-position-1" select="$Borders/w:right"/>
                            <xsl:with-param name="style-position-2" select="$rootStyleNode/w:tblPr/w:tblBorders/w:right"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:element>
        </style:style>
    </xsl:template>
    <xsl:template name="get-table-border">
        <xsl:param name="style-pos"/>
        <xsl:param name="style-position-0"/>
        <xsl:param name="style-position-1"/>
        <xsl:param name="style-position-2"/>
        <xsl:variable name="size-style">
            <xsl:choose>
                <xsl:when test="$style-position-0">
                    <xsl:value-of select="$style-position-0/@w:sz"/>
                </xsl:when>
                <xsl:when test="$style-position-1">
                    <xsl:value-of select="$style-position-1/@w:sz"/>
                </xsl:when>
                <xsl:when test="$style-position-2">
                    <xsl:value-of select="$style-position-2/@w:sz"/>
                </xsl:when>
                <xsl:otherwise>2</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="border-style">
            <xsl:choose>
                <xsl:when test="$style-position-0">
                    <xsl:value-of select="$style-position-0/@w:val"/>
                </xsl:when>
                <xsl:when test="$style-position-1">
                    <xsl:value-of select="$style-position-1/@w:val"/>
                </xsl:when>
                <xsl:when test="$style-position-2">
                    <xsl:value-of select="$style-position-2/@w:val"/>
                </xsl:when>
                <xsl:otherwise>single</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <!-- totally basic Word table border styles: nil, none, single, thick, double, dotted, dashed, dot-dash, dot-dot-dash, triple, thin-thick-small-gap, thick-thin-small-gap, thin-thick-thin-small-gap, thin-thick-medium-gap, thick-thin-medium-gap, thin-thick-thin-medium-gap, thin-thick-large-gap, thick-thin-large-gap, thin-thick-thin-large-gap, wave, double-wave, dash-small-gap, dash-dot-stroked, three-d-emboss, three-d-engrave, outset, inset. Others are advanced graphical table border styles. glu -->
        <xsl:variable name="style-border">
            <xsl:choose>
                <xsl:when test="$border-style = 'nil' or $border-style ='none'">hidden</xsl:when>
                <xsl:when test="$border-style = 'single' or $border-style = 'thick' or $border-style = 'dotted' or $border-style = 'dashed' or $border-style = 'dot-dash' or $border-style = 'dot-dot-dash' or $border-style = 'wave' or $border-style = 'dash-small-gap' or $border-style = 'dash-dot-stroked'">solid</xsl:when>
                <xsl:otherwise>double</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="color-border">
            <xsl:choose>
                <xsl:when test="$style-position-0 and string-length($style-position-0/@w:color) = 6">
                    <xsl:value-of select="$style-position-0/@w:color"/>
                </xsl:when>
                <xsl:when test="$style-position-0 and $style-position-0/@w:color = 'auto' and contains($border-style, 'set')">
                    <xsl:text>c0c0c0</xsl:text>
                </xsl:when>
                <xsl:when test="$style-position-1 and string-length($style-position-1/@w:color) = 6">
                    <xsl:value-of select="$style-position-1/@w:color"/>
                </xsl:when>
                <xsl:when test="$style-position-1 and $style-position-1/@w:color = 'auto' and contains($border-style, 'set')">
                    <xsl:text>c0c0c0</xsl:text>
                </xsl:when>
                <xsl:when test="$style-position-2 and string-length($style-position-2/@w:color) = 6">
                    <xsl:value-of select="$style-position-2/@w:color"/>
                </xsl:when>
                <xsl:when test="$style-position-2 and $style-position-2/@w:color = 'auto' and contains($border-style, 'set')">
                    <xsl:text>c0c0c0</xsl:text>
                </xsl:when>
                <xsl:otherwise>000000</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <!-- mapping border line widths. glu -->
        <xsl:choose>
            <xsl:when test="$border-style = 'single'">
                <xsl:choose>
                    <xsl:when test="$size-style &lt; 7">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.002cm solid #', $color-border)"/></xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 20">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.035cm solid #', $color-border)"/></xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 30">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.088cm solid #', $color-border)"/></xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 40">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.141cm solid #', $color-border)"/></xsl:attribute>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.176cm solid #', $color-border)"/></xsl:attribute>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="$border-style = 'double'">
                <xsl:choose>
                    <xsl:when test="$size-style &lt; 10">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.039cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.035cm 0.002cm</xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 15">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.092cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.002cm</xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 20">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.106cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.035cm 0.035cm 0.035cm</xsl:attribute>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.265cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.088cm 0.088cm</xsl:attribute>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="$border-style = 'triple'">
                <xsl:choose>
                    <xsl:when test="$size-style &lt; 5">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.039cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.035cm 0.002cm</xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 10">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.092cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">.002cm 0.088cm 0.002cm</xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 15">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.106cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.035cm 0.035cm 0.035cm</xsl:attribute>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.265cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.088cm 0.088cm</xsl:attribute>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="$border-style = 'thin-thick-small-gap' or $border-style = 'thick-thin-small-gap'">
                <xsl:choose>
                    <xsl:when test="($border-style = 'thin-thick-small-gap' and ($style-pos = 'left' or $style-pos = 'top')) or ($border-style = 'thick-thin-small-gap' and ($style-pos = 'right' or $style-pos = 'bottom'))">
                        <xsl:choose>
                            <xsl:when test="$size-style &lt; 20">
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.125cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.035cm</xsl:attribute>
                            </xsl:when>
                            <xsl:when test="$size-style &lt; 30">
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.178cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.088cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.231cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.141cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.159cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.035cm 0.035cm</xsl:attribute>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="$border-style = 'thin-thick-thin-small-gap'">
                <xsl:choose>
                    <xsl:when test="$size-style &lt; 20">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.178cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.088cm</xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 40">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.231cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.141cm</xsl:attribute>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.318cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.088cm 0.141cm</xsl:attribute>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="$border-style = 'thin-thick-medium-gap' or $border-style = 'thick-thin-medium-gap'">
                <xsl:choose>
                    <xsl:when test="$size-style &lt; 10">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.039cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.035cm 0.002cm</xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 15">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.106cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.035cm 0.035cm 0.035cm</xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 30">
                        <xsl:choose>
                            <xsl:when test="($border-style = 'thin-thick-medium-gap' and ($style-pos = 'left' or $style-pos = 'top')) or ($border-style = 'thick-thin-medium-gap' and ($style-pos = 'right' or $style-pos = 'bottom'))">
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.212cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.035cm 0.088cm 0.088cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.159cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.035cm 0.035cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.318cm double #', $color-border)"/></xsl:attribute>
                        <xsl:choose>
                            <xsl:when test="($border-style = 'thin-thick-medium-gap' and ($style-pos = 'left' or $style-pos = 'top')) or ($border-style = 'thick-thin-medium-gap' and ($style-pos = 'right' or $style-pos = 'bottom'))">
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.088cm 0.141cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.141cm 0.088cm 0.088cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="$border-style = 'thin-thick-thin-medium-gap'">
                <xsl:choose>
                    <xsl:when test="$size-style &lt; 10">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.039cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.035cm 0.002cm</xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 15">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.106cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.035cm 0.035cm 0.035cm</xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 30">
                        <xsl:choose>
                            <xsl:when test="$style-pos = 'left' or $style-pos = 'top'">
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.159cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.035cm 0.035cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.212cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.035cm 0.088cm 0.088cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.318cm double #', $color-border)"/></xsl:attribute>
                        <xsl:choose>
                            <xsl:when test="$style-pos = 'left' or $style-pos = 'top'">
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.141cm 0.088cm 0.088cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.088cm 0.141cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="$border-style = 'thin-thick-large-gap' or $border-style = 'thick-thin-large-gap'">
                <xsl:choose>
                    <xsl:when test="$size-style &lt; 7">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.092cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.002cm</xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 10">
                        <xsl:choose>
                            <xsl:when test="($border-style = 'thin-thick-large-gap' and ($style-pos = 'left' or $style-pos = 'top')) or ($border-style = 'thick-thin-large-gap' and ($style-pos = 'right' or $style-pos = 'bottom'))">
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.125cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.035cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.092cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.002cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 15">
                        <xsl:choose>
                            <xsl:when test="($border-style = 'thin-thick-large-gap' and ($style-pos = 'left' or $style-pos = 'top')) or ($border-style = 'thick-thin-large-gap' and ($style-pos = 'right' or $style-pos = 'bottom'))">
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.125cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.035cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.159cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.035cm 0.035cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 30">
                        <xsl:choose>
                            <xsl:when test="($border-style = 'thin-thick-large-gap' and ($style-pos = 'left' or $style-pos = 'top')) or ($border-style = 'thick-thin-large-gap' and ($style-pos = 'right' or $style-pos = 'bottom'))">
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.178cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.088cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.159cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.035cm 0.035cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 40">
                        <xsl:choose>
                            <xsl:when test="($border-style = 'thin-thick-large-gap' and ($style-pos = 'left' or $style-pos = 'top')) or ($border-style = 'thick-thin-large-gap' and ($style-pos = 'right' or $style-pos = 'bottom'))">
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.231cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.141cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.159cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.035cm 0.035cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.318cm double #', $color-border)"/></xsl:attribute>
                        <xsl:choose>
                            <xsl:when test="($border-style = 'thin-thick-large-gap' and ($style-pos = 'left' or $style-pos = 'top')) or ($border-style = 'thick-thin-large-gap' and ($style-pos = 'right' or $style-pos = 'bottom'))">
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.088cm 0.141cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.141cm 0.088cm 0.088cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="$border-style = 'thin-thick-thin-large-gap'">
                <xsl:choose>
                    <xsl:when test="$size-style &lt; 5">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.125cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.035cm</xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 10">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.178cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.088cm</xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 20">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.231cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.141cm</xsl:attribute>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.318cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.088cm 0.141cm</xsl:attribute>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="contains( $border-style, 'wave') or $border-style = 'dash-dot-stroked'">
                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.106cm double #', $color-border)"/></xsl:attribute>
                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.035cm 0.035cm 0.035cm</xsl:attribute>
            </xsl:when>
            <xsl:when test="contains( $border-style, 'three-d')">
                <xsl:choose>
                    <xsl:when test="$size-style &lt; 10">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.035cm solid #', $color-border)"/></xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 20">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.088cm solid #', $color-border)"/></xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 30">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.176cm solid #', $color-border)"/></xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 40">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.265cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.088cm 0.088cm</xsl:attribute>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.318cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.088cm 0.141cm</xsl:attribute>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="contains( $border-style, 'set')">
                <xsl:choose>
                    <xsl:when test="$size-style &lt; 7">
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.092cm double #', $color-border)"/></xsl:attribute>
                        <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.002cm</xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 10">
                        <xsl:choose>
                            <xsl:when test="($border-style = 'outset' and ($style-pos = 'left' or $style-pos = 'top')) or ($border-style = 'inset' and ($style-pos = 'right' or $style-pos = 'bottom'))">
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.092cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.002cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.125cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.035cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 15">
                        <xsl:choose>
                            <xsl:when test="($border-style = 'outset' and ($style-pos = 'left' or $style-pos = 'top')) or ($border-style = 'inset' and ($style-pos = 'right' or $style-pos = 'bottom'))">
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.159cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.035cm 0.035cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.125cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.035cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 30">
                        <xsl:choose>
                            <xsl:when test="($border-style = 'outset' and ($style-pos = 'left' or $style-pos = 'top')) or ($border-style = 'inset' and ($style-pos = 'right' or $style-pos = 'bottom'))">
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.159cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.035cm 0.035cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.178cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.088cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="$size-style &lt; 40">
                        <xsl:choose>
                            <xsl:when test="($border-style = 'outset' and ($style-pos = 'left' or $style-pos = 'top')) or ($border-style = 'inset' and ($style-pos = 'right' or $style-pos = 'bottom'))">
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.159cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.035cm 0.035cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.231cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.002cm 0.088cm 0.141cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.318cm double #', $color-border)"/></xsl:attribute>
                        <xsl:choose>
                            <xsl:when test="($border-style = 'outset' and ($style-pos = 'left' or $style-pos = 'top')) or ($border-style = 'inset' and ($style-pos = 'right' or $style-pos = 'bottom'))">
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.141cm 0.088cm 0.088cm</xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="{concat('fo:border-', $style-pos)}"><xsl:value-of select="concat('0.231cm double #', $color-border)"/></xsl:attribute>
                                <xsl:attribute name="{concat('style:border-line-width-',$style-pos)}">0.088cm 0.088cm 0.141cm</xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:attribute name="{concat('fo:border-', $style-pos)}">0.002cm solid #000000</xsl:attribute>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="w:tbl">
        <xsl:choose>
            <xsl:when test="w:tblPr/w:tblpPr">
                <!-- if the table is surrounded by text then put the table into a draw:text-box -->
                <xsl:element name="text:p">
                    <xsl:element name="draw:text-box">
                        <xsl:attribute name="draw:style-name"><xsl:text>TableFrame</xsl:text><xsl:number count="w:tblpPr" from="/w:wordDocument/w:body" level="any"/></xsl:attribute>
                        <xsl:attribute name="draw:name">TableFr<xsl:number count="w:tblpPr" from="/w:wordDocument/w:body" level="any"/></xsl:attribute>
                        <xsl:variable name="tbl_anchor_type">
                            <xsl:choose>
                                <xsl:when test="name(..) = 'w:tc' ">
                                    <xsl:text>as-char</xsl:text>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:text>paragraph</xsl:text>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:variable>
                        <xsl:attribute name="text:anchor-type"><xsl:value-of select="$tbl_anchor_type"/></xsl:attribute>
                        <xsl:variable name="tbl_draw_textbox_width">
                            <xsl:call-template name="convert2in">
                                <!--  adjust the width of draw:text-box containing a table with 20dxa + table-width -->
                                <xsl:with-param name="value" select="concat(string(number(sum(w:tblGrid/w:gridCol/@w:w) +20)), 'dxa' )"/>
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:attribute name="svg:width"><xsl:value-of select="concat ($tbl_draw_textbox_width, 'inch') "/></xsl:attribute>
                        <xsl:if test="w:tblPr/w:tblpPr/@w:tblpX">
                            <xsl:variable name="x_distance_from_anchor">
                                <xsl:call-template name="convert2in">
                                    <xsl:with-param name="value" select="concat(w:tblPr/w:tblpPr/@w:tblpX, 'dxa' ) "/>
                                </xsl:call-template>
                            </xsl:variable>
                            <xsl:attribute name="svg:x"><xsl:value-of select="concat ($x_distance_from_anchor, 'inch' )"/></xsl:attribute>
                        </xsl:if>
                        <xsl:if test="w:tblPr/w:tblpPr/@w:tblpY">
                            <xsl:variable name="y_distance_from_anchor">
                                <xsl:call-template name="convert2in">
                                    <xsl:with-param name="value" select="concat(w:tblPr/w:tblpPr/@w:tblpY, 'dxa' ) "/>
                                </xsl:call-template>
                            </xsl:variable>
                            <xsl:attribute name="svg:y"><xsl:value-of select="concat ($y_distance_from_anchor, 'inch' )"/></xsl:attribute>
                        </xsl:if>
                        <!--create table in draw:text-box to produce table wrapping text effect-->
                        <xsl:element name="table:table">
                            <xsl:if test="w:tblPr">
                                <xsl:attribute name="table:style-name">Table<xsl:number count="w:tbl" from="/w:wordDocument/w:body" level="any"/></xsl:attribute>
                            </xsl:if>
                            <xsl:apply-templates select="w:tblGrid | w:tr"/>
                        </xsl:element>
                    </xsl:element>
                    <!--draw:text-box end  -->
                </xsl:element>
                <!-- text:p end -->
            </xsl:when>
            <xsl:otherwise>
                <!-- if the table is not surrounded by text then put the table into a draw:text-box -->
                <xsl:element name="table:table">
                    <xsl:if test="w:tblPr">
                        <xsl:attribute name="table:style-name">Table<xsl:number count="w:tbl" from="/w:wordDocument/w:body" level="any"/></xsl:attribute>
                    </xsl:if>
                    <xsl:apply-templates select="w:tblGrid | w:tr"/>
                </xsl:element>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="w:tblGrid">
        <xsl:apply-templates select="w:gridCol"/>
    </xsl:template>
    <xsl:template match="w:gridCol">
        <xsl:element name="table:table-column">
            <xsl:attribute name="table:style-name">Table<xsl:number count="w:tbl" from="/w:wordDocument/w:body" level="any"/>.C<xsl:number count="w:gridCol" from="/w:wordDocument/w:body" level="single"/></xsl:attribute>
        </xsl:element>
    </xsl:template>
    <xsl:template match="w:tr">
        <xsl:element name="table:table-row">
            <!-- generate row in table and add attribute of table:style-name if the style:style exists. cp tom chen. -->
            <xsl:if test="w:trPr/w:trHeight">
                <xsl:attribute name="table:style-name">Table<xsl:number count="w:tbl" from="/w:wordDocument/w:body" level="any"/>.R<xsl:number count="w:tr" from="/w:wordDocument/w:body" level="single"/></xsl:attribute>
            </xsl:if>
            <xsl:apply-templates select="w:tc"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="w:tc">
        <xsl:element name="table:table-cell">
            <xsl:attribute name="table:style-name">Table<xsl:number count="w:tbl" from="/w:wordDocument/w:body" level="any"/>.R<xsl:number count="w:tr" from="/w:wordDocument/w:body" level="single"/>C<xsl:number count="w:tc" from="/w:wordDocument/w:body" level="single"/></xsl:attribute>
            <xsl:if test="w:tcPr/w:gridSpan">
                <xsl:attribute name="table:number-columns-spanned"><xsl:value-of select="w:tcPr/w:gridSpan/@w:val"/></xsl:attribute>
            </xsl:if>
            <xsl:apply-templates select="w:p | w:tbl"/>
        </xsl:element>
    </xsl:template>
<!-- End of OOo2.0 import/wordml/wordml2ooo_table.xsl stylesheet  -->
<!-- Start of OOo2.0 import/wordml/wordml2ooo_text.xsl stylesheet  -->
    <xsl:template name="create-default-paragraph-styles">
        <xsl:variable name="default-paragraph-style" select="w:style[@w:default = 'on' and @w:type = 'paragraph']"/>
        <xsl:if test="$default-paragraph-style">
            <style:default-style style:family="paragraph">
                <style:properties>
                    <xsl:choose>
                        <xsl:when test="/w:wordDocument/w:fonts/w:defaultFonts">
                            <xsl:attribute name="style:font-name"><xsl:value-of select="/w:wordDocument/w:fonts/w:defaultFonts/@w:ascii"/></xsl:attribute>
                            <xsl:attribute name="style:font-name-asian"><xsl:value-of select="/w:wordDocument/w:fonts/w:defaultFonts/@w:fareast"/></xsl:attribute>
                            <xsl:attribute name="style:font-name-complex"><xsl:value-of select="/w:wordDocument/w:fonts/w:defaultFonts/@w:cs"/></xsl:attribute>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:attribute name="style:font-name">Times New Roman</xsl:attribute>
                        </xsl:otherwise>
                    </xsl:choose>
                    <xsl:if test="$default-paragraph-style/w:rPr/w:sz">
                        <xsl:attribute name="fo:font-size"><xsl:value-of select="$default-paragraph-style/w:rPr/w:sz/@w:val div 2"/>pt</xsl:attribute>
                        <xsl:attribute name="fo:font-size-asian"><xsl:value-of select="$default-paragraph-style/w:rPr/w:sz/@w:val div 2"/>pt</xsl:attribute>
                    </xsl:if>
                    <xsl:if test="$default-paragraph-style/w:rPr/w:sz-cs">
                        <xsl:attribute name="fo:font-size-complex"><xsl:value-of select="$default-paragraph-style/w:rPr/w:sz-cs/@w:val div 2"/>pt</xsl:attribute>
                    </xsl:if>
                    <!-- if not defined default font size in Word, make it out as 10pt. glu -->
                    <xsl:if test="not($default-paragraph-style/w:rPr/w:sz or w:rPr/w:sz-cs)">
                        <xsl:attribute name="fo:font-size">10pt</xsl:attribute>
                        <xsl:attribute name="fo:font-size-asian">10pt</xsl:attribute>
                        <xsl:attribute name="fo:font-size-complex">10pt</xsl:attribute>
                    </xsl:if>
                    <xsl:if test="$default-paragraph-style/w:rPr/w:lang">
                        <xsl:if test="$default-paragraph-style/w:rPr/w:lang/@w:val">
                            <xsl:attribute name="fo:language"><xsl:value-of select="substring-before( $default-paragraph-style/w:rPr/w:lang/@w:val, '-')"/></xsl:attribute>
                            <xsl:attribute name="fo:country"><xsl:value-of select="substring-after( $default-paragraph-style/w:rPr/w:lang/@w:val, '-')"/></xsl:attribute>
                        </xsl:if>
                        <xsl:if test="$default-paragraph-style/w:rPr/w:lang/@w:fareast">
                            <xsl:attribute name="fo:language-asian"><xsl:value-of select="substring-before( $default-paragraph-style/w:rPr/w:lang/@w:fareast, '-')"/></xsl:attribute>
                            <xsl:attribute name="fo:country-asian"><xsl:value-of select="substring-after( $default-paragraph-style/w:rPr/w:lang/@w:fareast, '-')"/></xsl:attribute>
                        </xsl:if>
                        <xsl:if test="$default-paragraph-style/w:rPr/w:lang/@w:bidi">
                            <xsl:attribute name="fo:language-complex"><xsl:value-of select="substring-before( $default-paragraph-style/w:rPr/w:lang/@w:bidi, '-')"/></xsl:attribute>
                            <xsl:attribute name="fo:country-complex"><xsl:value-of select="substring-after( $default-paragraph-style/w:rPr/w:lang/@w:bidi, '-')"/></xsl:attribute>
                        </xsl:if>
                    </xsl:if>
                    <xsl:attribute name="style:tab-stop-distance"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(/w:wordDocument/w:docPr/w:defaultTabStop/@w:val,'dxa')"/></xsl:call-template>cm</xsl:attribute>
                </style:properties>
            </style:default-style>
        </xsl:if>
    </xsl:template>
    <xsl:template name="create-default-text-styles">
        <style:style style:name="Numbering Symbols" style:family="text"/>
        <style:style style:name="Bullet Symbols" style:family="text">
            <style:properties style:font-name="StarSymbol" fo:font-size="12pt" style:font-name-asian="StarSymbol" style:font-size-asian="12pt" style:font-name-complex="StarSymbol" style:font-size-complex="12pt"/>
        </style:style>
    </xsl:template>
    <xsl:template match="w:p" mode="style">
        <xsl:variable name="paragraph-number">
            <xsl:number from="/w:wordDocument/w:body" level="any" count="w:p"/>
        </xsl:variable>
        <xsl:variable name="section-property-number" select="count(preceding::w:sectPr)"/>
        <xsl:variable name="last-section-property" select="preceding::w:pPr/w:sectPr[1]"/>
        <style:style style:family="paragraph" style:name="P{$paragraph-number}">
            <xsl:if test="w:pPr/w:pStyle">
                <xsl:attribute name="style:parent-style-name"><xsl:value-of select="w:pPr/w:pStyle/@w:val"/></xsl:attribute>
            </xsl:if>
            <xsl:choose>
                <xsl:when test="generate-id($last-section-property[last()]/following::w:p[1]) = generate-id(.) and not(ancestor::w:sectPr)">
                    <xsl:attribute name="style:master-page-name">Standard<xsl:value-of select="$section-property-number + 1"/></xsl:attribute>
                </xsl:when>
                <xsl:when test="$paragraph-number = 1">
                    <xsl:attribute name="style:master-page-name">Standard1</xsl:attribute>
                </xsl:when>
            </xsl:choose>
            <style:properties>
                <xsl:apply-templates select="w:pPr"/>
            </style:properties>
        </style:style>
        <xsl:if test="w:r/w:br/@w:type='page'">
            <style:style style:family="paragraph" style:name="P{$paragraph-number}page-break">
                <xsl:if test="w:pPr/w:pStyle">
                    <xsl:attribute name="style:parent-style-name"><xsl:value-of select="w:pPr/w:pStyle/@w:val"/></xsl:attribute>
                </xsl:if>
                <xsl:choose>
                    <xsl:when test="generate-id($last-section-property[last()]/following::w:p[1]) = generate-id(.) and not(ancestor::w:sectPr)">
                        <xsl:attribute name="style:master-page-name">Standard<xsl:value-of select="$section-property-number + 1"/></xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$paragraph-number = 1">
                        <xsl:attribute name="style:master-page-name">Standard1</xsl:attribute>
                    </xsl:when>
                </xsl:choose>
                <style:properties fo:break-before="page">
                    <xsl:apply-templates select="w:pPr"/>
                </style:properties>
            </style:style>
        </xsl:if>
        <xsl:if test="w:r/w:br/@w:type='column'">
            <style:style style:family="paragraph" style:name="P{$paragraph-number}column-break">
                <xsl:if test="w:pPr/w:pStyle">
                    <xsl:attribute name="style:parent-style-name"><xsl:value-of select="w:pPr/w:pStyle/@w:val"/></xsl:attribute>
                </xsl:if>
                <xsl:choose>
                    <xsl:when test="generate-id($last-section-property[last()]/following::w:p[1]) = generate-id(.) and not(ancestor::w:sectPr)">
                        <xsl:attribute name="style:master-page-name">Standard<xsl:value-of select="$section-property-number + 1"/></xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$paragraph-number = 1">
                        <xsl:attribute name="style:master-page-name">Standard1</xsl:attribute>
                    </xsl:when>
                </xsl:choose>
                <style:properties fo:break-before="column">
                    <xsl:apply-templates select="w:pPr"/>
                </style:properties>
            </style:style>
        </xsl:if>
    </xsl:template>
    <xsl:template match="w:pPr">
        <xsl:if test="w:ind/@w:left">
            <xsl:attribute name="fo:margin-left"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:ind/@w:left, 'dxa')"/></xsl:call-template>cm</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:ind/@w:right">
            <xsl:attribute name="fo:margin-right"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:ind/@w:right, 'dxa')"/></xsl:call-template>cm</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:ind/@w:first-line">
            <xsl:attribute name="fo:text-indent"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:ind/@w:first-line, 'dxa')"/></xsl:call-template>cm</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:ind/@w:hanging">
            <xsl:attribute name="fo:text-indent"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat('-',w:ind/@w:hanging, 'dxa')"/></xsl:call-template>cm</xsl:attribute>
        </xsl:if>
        <!-- bi-directional support-->
        <xsl:if test="w:bidi">
            <xsl:attribute name="style:writing-mode">rl-tb</xsl:attribute>
            <xsl:attribute name="fo:text-align">end</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:jc">
            <xsl:choose>
                <xsl:when test="w:jc/@w:val = 'center'">
                    <xsl:attribute name="fo:text-align">center</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:jc/@w:val = 'left'">
                    <xsl:choose>
                        <xsl:when test="w:bidi">
                            <xsl:attribute name="fo:text-align">end</xsl:attribute>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:attribute name="fo:text-align">start</xsl:attribute>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="w:jc/@w:val = 'right'">
                    <xsl:choose>
                        <xsl:when test="w:bidi">
                            <xsl:attribute name="fo:text-align">start</xsl:attribute>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:attribute name="fo:text-align">end</xsl:attribute>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:attribute name="fo:text-align">justify</xsl:attribute>
                    <xsl:attribute name="style:justify-single-word">false</xsl:attribute>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
        <xsl:attribute name="style:auto-text-indent">false</xsl:attribute>
        <xsl:if test="w:spacing">
            <xsl:choose>
                <xsl:when test="w:spacing/@w:line-rule = 'at-least'">
                    <xsl:attribute name="style:line-height-at-least"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:spacing/@w:line, 'dxa')"/></xsl:call-template>cm</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:spacing/@w:line-rule = 'auto'">
                    <xsl:attribute name="fo:line-height"><xsl:value-of select="round(w:spacing/@w:line div 240 * 100)"/>%</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:spacing/@w:line-rule = 'exact'">
                    <xsl:attribute name="fo:line-height"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:spacing/@w:line, 'dxa')"/></xsl:call-template>cm</xsl:attribute>
                </xsl:when>
            </xsl:choose>
            <xsl:if test="w:spacing/@w:before">
                <xsl:attribute name="fo:margin-top"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:spacing/@w:before, 'dxa')"/></xsl:call-template>cm</xsl:attribute>
            </xsl:if>
            <xsl:if test="w:spacing/@w:after">
                <xsl:attribute name="fo:margin-bottom"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:spacing/@w:after, 'dxa')"/></xsl:call-template>cm</xsl:attribute>
            </xsl:if>
        </xsl:if>
        <xsl:if test="w:shd">
            <xsl:variable name="background-color">
                <xsl:choose>
                    <xsl:when test="string-length(w:shd/@w:fill) = 6">
                        <xsl:value-of select="concat('#', w:shd/@w:fill)"/>
                    </xsl:when>
                    <xsl:otherwise>#000000</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:choose>
                <xsl:when test="w:shd/@w:val = 'solid'">
                    <xsl:attribute name="fo:background-color"><xsl:value-of select="$background-color"/></xsl:attribute>
                </xsl:when>
                <!-- patterns are necessary in the future. glu -->
                <xsl:otherwise/>
            </xsl:choose>
        </xsl:if>
        <xsl:if test="w:pageBreakBefore">
            <xsl:attribute name="fo:break-before">page</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:tabs">
            <xsl:element name="style:tab-stops">
                <xsl:for-each select="w:tabs/w:tab">
                    <xsl:element name="style:tab-stop">
                        <xsl:attribute name="style:position"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(@w:pos, 'dxa')"/></xsl:call-template>cm</xsl:attribute>
                        <xsl:choose>
                            <xsl:when test="@w:val = 'decimal'">
                                <xsl:attribute name="style:type">char</xsl:attribute>
                                <xsl:attribute name="style:char"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="style:type"><xsl:value-of select="@w:val"/></xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                        <xsl:if test="@w:leader">
                            <xsl:attribute name="style:leader-char"><xsl:choose><xsl:when test="hyphen">-</xsl:when><xsl:when test="underscore">_</xsl:when><xsl:when test="dot">.</xsl:when></xsl:choose></xsl:attribute>
                        </xsl:if>
                        <xsl:if test="@style:leader-char">
                            <xsl:choose>
                                <xsl:when test="@style:leader-char='-'">
                                    <xsl:attribute name="w:leader">hyphen</xsl:attribute>
                                </xsl:when>
                                <xsl:when test="@style:leader-char='_'">
                                    <xsl:attribute name="w:leader">underscore</xsl:attribute>
                                </xsl:when>
                                <xsl:when test="@style:leader-char='.'">
                                    <xsl:attribute name="w:leader">dot</xsl:attribute>
                                </xsl:when>
                                <xsl:when test="@style:leader-char='·'">
                                    <xsl:attribute name="w:leader">middle-dot</xsl:attribute>
                                </xsl:when>
                            </xsl:choose>
                        </xsl:if>
                    </xsl:element>
                </xsl:for-each>
            </xsl:element>
        </xsl:if>
        <xsl:if test="w:keepNext">
            <xsl:attribute name="fo:keep-with-next">true</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:keepLines">
            <xsl:attribute name="style:break-inside">avoid</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:widowControl='on'">
            <xsl:attribute name="fo:widows">2</xsl:attribute>
            <xsl:attribute name="fo:orphans">2</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:suppressAutoHyphens">
            <xsl:attribute name="fo:hyphenate">false</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:kinsoku/@w:val='off'">
            <xsl:attribute name="style:line-break">normal</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:overflowPunct/@w:val='off'">
            <xsl:attribute name="style:punctuation-wrap">simple</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:autoSpaceDE/@w:val='off' or w:autoSpaceDN/@w:val='off'">
            <xsl:attribute name="style:text-autospace">none</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:textAlignment">
            <xsl:choose>
                <xsl:when test="w:textAlignment/@w:val='center'">
                    <xsl:attribute name="style:vertical-align">middle</xsl:attribute>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:attribute name="style:vertical-align"><xsl:value-of select="w:textAlignment/@w:val"/></xsl:attribute>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
        <xsl:if test="w:pBdr">
            <xsl:if test="w:pBdr/w:top">
                <xsl:call-template name="get-table-border">
                    <xsl:with-param name="style-pos" select="'top'"/>
                    <xsl:with-param name="style-position-0" select="w:pBdr/w:top"/>
                </xsl:call-template>
                <xsl:attribute name="fo:padding-top"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pBdr/w:top/@w:space,'pt')"/></xsl:call-template>cm</xsl:attribute>
            </xsl:if>
            <xsl:if test="w:pBdr/w:left">
                <xsl:call-template name="get-table-border">
                    <xsl:with-param name="style-pos" select="'left'"/>
                    <xsl:with-param name="style-position-0" select="w:pBdr/w:left"/>
                </xsl:call-template>
                <xsl:attribute name="fo:padding-left"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pBdr/w:left/@w:space,'pt')"/></xsl:call-template>cm</xsl:attribute>
            </xsl:if>
            <xsl:if test="w:pBdr/w:right">
                <xsl:call-template name="get-table-border">
                    <xsl:with-param name="style-pos" select="'right'"/>
                    <xsl:with-param name="style-position-0" select="w:pBdr/w:right"/>
                </xsl:call-template>
                <xsl:attribute name="fo:padding-right"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pBdr/w:right/@w:space,'pt')"/></xsl:call-template>cm</xsl:attribute>
            </xsl:if>
            <xsl:if test="w:pBdr/w:bottom">
                <xsl:call-template name="get-table-border">
                    <xsl:with-param name="style-pos" select="'bottom'"/>
                    <xsl:with-param name="style-position-0" select="w:pBdr/w:bottom"/>
                </xsl:call-template>
                <xsl:attribute name="fo:padding-bottom"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:pBdr/w:bottom/@w:space,'pt')"/></xsl:call-template>cm</xsl:attribute>
            </xsl:if>
            <xsl:if test="w:pBdr/*/@w:shadow='on'">
                <xsl:attribute name="style:shadow">#000000 0.15cm 0.15cm</xsl:attribute>
            </xsl:if>
        </xsl:if>
         <xsl:if test="w:snapToGrid/@w:val='off'">
            <xsl:attribute name="style:snap-to-layout-grid">false</xsl:attribute>
        </xsl:if>
        <xsl:apply-templates select="w:rPr"/>
    </xsl:template>
    <xsl:template match="w:rPr" mode="style">
        <xsl:element name="style:style">
            <xsl:attribute name="style:name">T<xsl:number from="/w:wordDocument/w:body" level="any" count="w:rPr"/></xsl:attribute>
            <xsl:attribute name="style:family">text</xsl:attribute>
            <xsl:if test="w:rStyle">
                <xsl:attribute name="style:parent-style-name"><xsl:value-of select="w:rStyle/@w:val"/></xsl:attribute>
            </xsl:if>
            <xsl:element name="style:properties">
                <xsl:apply-templates select="current()"/>
            </xsl:element>
        </xsl:element>
    </xsl:template>
    <xsl:template match="w:rPr">
        <xsl:if test="w:rFonts">
            <xsl:if test="w:rFonts/@w:ascii">
                <xsl:attribute name="style:font-name"><xsl:value-of select="w:rFonts/@w:ascii"/></xsl:attribute>
                <xsl:if test="ancestor::w:body">
                    <xsl:attribute name="style:font-name-asian"><xsl:value-of select="w:rFonts/@w:ascii"/></xsl:attribute>
                    <xsl:attribute name="style:font-name-complex"><xsl:value-of select="w:rFonts/@w:ascii"/></xsl:attribute>
                </xsl:if>
            </xsl:if>
            <xsl:if test="ancestor::w:styles">
                <xsl:if test="w:rFonts/@w:fareast">
                    <xsl:attribute name="style:font-name-asian"><xsl:value-of select="w:rFonts/@w:fareast"/></xsl:attribute>
                </xsl:if>
                <xsl:if test="w:rFonts/@w:cs">
                    <xsl:attribute name="style:font-name-complex"><xsl:value-of select="w:rFonts/@w:cs"/></xsl:attribute>
                </xsl:if>
            </xsl:if>
        </xsl:if>
        <xsl:if test="w:b">
            <xsl:attribute name="fo:font-weight">bold</xsl:attribute>
            <xsl:attribute name="fo:font-weight-asian">bold</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:b-cs">
            <xsl:attribute name="fo:font-weight-complex">bold</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:i">
            <xsl:attribute name="fo:font-style">italic</xsl:attribute>
            <xsl:attribute name="fo:font-style-asian">italic</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:i-cs">
            <xsl:attribute name="fo:font-style-complex">italic</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:caps">
            <xsl:attribute name="fo:text-transform">uppercase</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:smallCaps">
            <xsl:attribute name="fo:font-variant">small-caps</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:strike">
            <xsl:attribute name="style:text-crossing-out">single-line</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:dstrike">
            <xsl:attribute name="style:text-crossing-out">double-line</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:outline">
            <xsl:attribute name="style:text-outline">true</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:shadow">
            <xsl:attribute name="style:text-shadow">1pt 1pt</xsl:attribute>
            <xsl:attribute name="fo:text-shadow">1pt 1pt</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:imprint">
            <xsl:attribute name="style:font-relief">engraved</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:emboss">
            <xsl:attribute name="style:font-relief">embossed</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:vanish">
            <xsl:attribute name="text:display">true</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:color[not(@w:val = 'auto')]">
            <xsl:attribute name="fo:color">#<xsl:value-of select="w:color/@w:val"/></xsl:attribute>
        </xsl:if>
        <xsl:if test="w:spacing">
            <xsl:attribute name="fo:letter-spacing"><xsl:call-template name="convert2cm"><xsl:with-param name="value" select="concat(w:spacing/@w:val,'dxa')"/></xsl:call-template>cm</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:w/@w:val">
            <xsl:attribute name="style:text-scale"><xsl:value-of select="w:w/@w:val"/></xsl:attribute>
        </xsl:if>
        <xsl:if test="w:vertAlign or w:position">
            <xsl:variable name="height">
                <xsl:choose>
                    <xsl:when test="w:vertAlign[@w:val = 'superscript' or @w:val = 'subscript']">58%</xsl:when>
                    <xsl:otherwise>100%</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:variable name="position">
                <xsl:choose>
                    <xsl:when test="w:position">
                        <!-- con't get font height easily, so just set w:val as percentage. glu -->
                        <xsl:value-of select="concat( w:position/@w:val, '%')"/>
                    </xsl:when>
                    <xsl:when test="w:vertAlign[@w:val = 'superscript']">super</xsl:when>
                    <xsl:when test="w:vertAlign[@w:val = 'subscript']">sub</xsl:when>
                </xsl:choose>
            </xsl:variable>
            <xsl:attribute name="style:text-position"><xsl:value-of select="concat($position, ' ', $height)"/></xsl:attribute>
        </xsl:if>
        <xsl:if test="w:sz">
            <xsl:attribute name="fo:font-size"><xsl:value-of select="w:sz/@w:val div 2"/>pt</xsl:attribute>
            <xsl:attribute name="fo:font-size-asian"><xsl:value-of select="w:sz/@w:val div 2"/>pt</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:sz-cs">
            <xsl:attribute name="fo:font-size-complex"><xsl:value-of select="w:sz-cs/@w:val div 2"/>pt</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:highlight">
            <xsl:choose>
                <xsl:when test="w:highlight/@w:val='black'">
                    <xsl:attribute name="style:text-background-color">#000000</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:highlight/@w:val='yellow'">
                    <xsl:attribute name="style:text-background-color">#ffff00</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:highlight/@w:val='green'">
                    <xsl:attribute name="style:text-background-color">#00ff00</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:highlight/@w:val='cyan'">
                    <xsl:attribute name="style:text-background-color">#00ffff</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:highlight/@w:val='magenta'">
                    <xsl:attribute name="style:text-background-color">#ff00ff</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:highlight/@w:val='blue'">
                    <xsl:attribute name="style:text-background-color">#0000ff</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:highlight/@w:val='red'">
                    <xsl:attribute name="style:text-background-color">#ff0000</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:highlight/@w:val='dark-blue'">
                    <xsl:attribute name="style:text-background-color">#000080</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:highlight/@w:val='dark-cyan'">
                    <xsl:attribute name="style:text-background-color">#008080</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:highlight/@w:val='dark-green'">
                    <xsl:attribute name="style:text-background-color">#008000</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:highlight/@w:val='dark-magenta'">
                    <xsl:attribute name="style:text-background-color">#800080</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:highlight/@w:val='dark-red'">
                    <xsl:attribute name="style:text-background-color">#800000</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:highlight/@w:val='dark-yellow'">
                    <xsl:attribute name="style:text-background-color">#808000</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:highlight/@w:val='dark-gray'">
                    <xsl:attribute name="style:text-background-color">#808080</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:highlight/@w:val='light-gray'">
                    <xsl:attribute name="style:text-background-color">#c0c0c0</xsl:attribute>
                </xsl:when>
            </xsl:choose>
        </xsl:if>
        <xsl:if test="w:u">
            <xsl:choose>
                <xsl:when test="w:u/@w:val = 'words'">
                    <xsl:attribute name="style:text-underline">single</xsl:attribute>
                    <xsl:attribute name="fo:score-spaces">false</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:u/@w:val = 'thick'">
                    <xsl:attribute name="style:text-underline">bold</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:u/@w:val = 'dotted-heavy'">
                    <xsl:attribute name="style:text-underline">bold-dotted</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:u/@w:val = 'dashed-heavy'">
                    <xsl:attribute name="style:text-underline">bold-dash</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:u/@w:val = 'dash-long'">
                    <xsl:attribute name="style:text-underline">long-dash</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:u/@w:val = 'dash-long-heavy'">
                    <xsl:attribute name="style:text-underline">bold-long-dash</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:u/@w:val = 'dash-dot-heavy'">
                    <xsl:attribute name="style:text-underline">bold-dot-dash</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:u/@w:val = 'dash-dot-dot-heavy'">
                    <xsl:attribute name="style:text-underline">bold-dot-dot-dash</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:u/@w:val = 'wavy-heavy'">
                    <xsl:attribute name="style:text-underline">bold-wave</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:u/@w:val = 'wavy-double'">
                    <xsl:attribute name="style:text-underline">double-wave</xsl:attribute>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:attribute name="style:text-underline"><xsl:value-of select="w:u/@w:val"/></xsl:attribute>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:if test="w:u/@w:color and not(w:u/@w:color = 'auto')">
                <xsl:attribute name="style:text-underline-color">#<xsl:value-of select="w:u/@w:color"/></xsl:attribute>
            </xsl:if>
        </xsl:if>
        <xsl:if test="w:effect[@w:val = 'blink-background']">
            <xsl:attribute name="style:text-blinking">true</xsl:attribute>
            <xsl:attribute name="style:text-background-color">#000000</xsl:attribute>
        </xsl:if>
        <xsl:if test="w:shd and not(w:highlight)">
            <xsl:if test="string-length(w:shd/@w:fill) = 6">
                <xsl:attribute name="style:text-background-color">#<xsl:value-of select="w:shd/@w:fill"/></xsl:attribute>
            </xsl:if>
        </xsl:if>
        <xsl:if test="w:em">
            <xsl:choose>
                <xsl:when test="w:em/@w:val = 'comma'">
                    <xsl:attribute name="style:text-emphasize">accent below</xsl:attribute>
                </xsl:when>
                <xsl:when test="w:em/@w:val = 'under-dot'">
                    <xsl:attribute name="style:text-emphasize">disc below</xsl:attribute>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:attribute name="style:text-emphasize"><xsl:value-of select="concat( w:em/@w:val, ' below')"/></xsl:attribute>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
        <xsl:if test="w:lang">
            <xsl:if test="w:lang/@w:val">
                <xsl:attribute name="fo:language"><xsl:value-of select="substring-before( w:lang/@w:val, '-')"/></xsl:attribute>
                <xsl:attribute name="fo:country"><xsl:value-of select="substring-after( w:lang/@w:val, '-')"/></xsl:attribute>
            </xsl:if>
            <xsl:if test="w:lang/@w:fareast">
                <xsl:attribute name="fo:language-asian"><xsl:value-of select="substring-before( w:lang/@w:fareast, '-')"/></xsl:attribute>
                <xsl:attribute name="fo:country-asian"><xsl:value-of select="substring-after( w:lang/@w:fareast, '-')"/></xsl:attribute>
            </xsl:if>
            <xsl:if test="w:lang/@w:bidi">
                <xsl:attribute name="fo:language-complex"><xsl:value-of select="substring-before( w:lang/@w:bidi, '-')"/></xsl:attribute>
                <xsl:attribute name="fo:country-complex"><xsl:value-of select="substring-after( w:lang/@w:bidi, '-')"/></xsl:attribute>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    <xsl:template match="w:p">
        <xsl:choose>
            <!-- because word treats page breaks as separate tags, we must split some paragraphs up so that we can 
			give the sub para a fo:break-before ="page" or column attribute. -->
            <xsl:when test="w:r[w:br/@w:type='page' or w:br/@w:type='column']">
                <xsl:call-template name="process-breaks-in-paragraph"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="process-common-paragraph"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="process-breaks-in-paragraph">
        <xsl:variable name="textruns-with-break" select="w:r[w:br/@w:type='page' or w:br/@w:type='column']"/>
        <xsl:call-template name="create-sub-paragraph">
            <xsl:with-param name="textruns" select="$textruns-with-break[1]/preceding-sibling::w:r"/>
        </xsl:call-template>
        <xsl:for-each select="$textruns-with-break">
            <xsl:variable name="break-position" select="position()"/>
            <xsl:call-template name="create-sub-paragraph">
                <xsl:with-param name="textruns" select="following-sibling::w:r[not(w:br/@w:type='page' or w:br/@w:type='column') and (count(preceding::w:r[w:br/@w:type='page' or w:br/@w:type='column']) = $break-position)]"/>
                <xsl:with-param name="textruns-with-break" select="current()"/>
            </xsl:call-template>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="create-sub-paragraph">
        <xsl:param name="textruns"/>
        <xsl:param name="textruns-with-break"/>
        <xsl:if test="$textruns or $textruns-with-break">
            <xsl:variable name="curr-num">
                <xsl:number from="/w:wordDocument/w:body" level="any" count="w:p"/>
            </xsl:variable>
            <text:p>
                <xsl:choose>
                    <xsl:when test="$textruns-with-break">
                        <xsl:attribute name="text:style-name"><xsl:value-of select="concat('P',$curr-num,w:br/@w:type, '-break')"/></xsl:attribute>
                        <xsl:apply-templates select="$textruns-with-break"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="text:style-name"><xsl:value-of select="concat( 'P', $curr-num)"/></xsl:attribute>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:if test="$textruns">
                    <xsl:apply-templates select="$textruns"/>
                </xsl:if>
            </text:p>
        </xsl:if>
    </xsl:template>
    <xsl:template name="process-common-paragraph">
        <xsl:variable name="heading-or-paragraph">
            <xsl:choose>
                <xsl:when test="key('heading-style', w:pPr/w:pStyle/@w:val)">text:h</xsl:when>
                <xsl:otherwise>text:p</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:element name="{$heading-or-paragraph}">
            <xsl:if test="$heading-or-paragraph = 'text:h'">
                <xsl:attribute name="text:level"><xsl:value-of select="key('heading-style',w:pPr/w:pStyle/@w:val)/w:pPr/w:outlineLvl/@w:val + 1"/></xsl:attribute>
            </xsl:if>
            <xsl:variable name="curr-num">
                <xsl:number from="/w:wordDocument/w:body" level="any" count="w:p"/>
            </xsl:variable>
            <xsl:attribute name="text:style-name"><xsl:value-of select="concat( 'P', $curr-num)"/></xsl:attribute>
            <!-- call the template to generate bookmark-start matching nodes before current. cp tom chen. -->
            <xsl:variable name="bm-node" select="preceding::aml:annotation[@w:type = 'Word.Bookmark.Start']"/>
            <xsl:variable name="wp-node" select="preceding::w:p[1]"/>
            <xsl:call-template name="start-end-bookmark">
                <xsl:with-param name="type" select="'start'"/>
                <xsl:with-param name="bm-node" select="$bm-node"/>
                <xsl:with-param name="wp-node" select="$wp-node"/>
            </xsl:call-template>
            <xsl:apply-templates select=".//w:r | w:fldSimple | w:hlink"/>
            <xsl:variable name="bm-node2" select="following::aml:annotation[@w:type = 'Word.Bookmark.End']"/>
            <xsl:variable name="wp-node2" select="following::w:p[position() = 1]"/>
            <xsl:call-template name="start-end-bookmark">
                <xsl:with-param name="type" select="'end'"/>
                <xsl:with-param name="bm-node" select="$bm-node2"/>
                <xsl:with-param name="wp-node" select="$wp-node2"/>
            </xsl:call-template>
        </xsl:element>
    </xsl:template>
    <!-- WordML contains multiple w:t within one w:r, so in Star Writer text:span should correspond to w:t glu -->
    <xsl:template match="w:r">
        <!-- handling another type of Hyperlink address in w:body.cp tom chen. 
            Acutally they're from Field features, a complex one. glu 
            <xsl:when test="w:r/w:instrText and contains(w:r/w:instrText , 'HYPERLINK')">
                <xsl:variable name="hyper-str" select="normalize-space(w:r/w:instrText)"/>
                <xsl:variable name="hyper-dest" select="substring-before( substring($hyper-str, 12), '&quot;')"/>
                <xsl:variable name="hyper-bookmark">
                    <xsl:choose>
                        <xsl:when test="contains( $hyper-str, ' \l ')">
                            <xsl:value-of select="concat( '#', substring-before( substring-after( substring-after( $hyper-str, ' \l '), '&quot;'), '&quot;') )"/>
                        </xsl:when>
                        <xsl:otherwise/>
                    </xsl:choose>
                </xsl:variable>
                <text:p>
                    <text:a>
                        <xsl:attribute name="xlink:type">simple</xsl:attribute>
                        <xsl:attribute name="xlink:href"><xsl:value-of select="concat( $hyper-dest, $hyper-bookmark)"/></xsl:attribute>
                        <xsl:apply-templates/>
                    </text:a>
                </text:p>
            </xsl:when>
            -->
        <xsl:if test="w:br[@w:type='text-wrapping' or not(@w:type)]">
            <text:line-break/>
        </xsl:if>
        <xsl:choose>
            <xsl:when test="aml:annotation/@w:type = 'Word.Comment'">
                <office:annotation office:author="{aml:annotation/@aml:author}" office:create-date="{substring(aml:annotation/@aml:createdate,1,10)}" office:display="true">
                    <xsl:apply-templates/>
                </office:annotation>
            </xsl:when>
            <xsl:when test="(preceding-sibling::w:r) or (w:rPr)">
                <xsl:element name="text:span">
                    <xsl:choose>
                        <xsl:when test="w:rPr/w:rStyle">
                            <xsl:attribute name="text:style-name"><xsl:value-of select="w:rPr/w:rStyle/@w:val"/></xsl:attribute>
                        </xsl:when>
                        <xsl:when test="w:rPr">
                            <xsl:variable name="position">
                                <xsl:number from="/w:wordDocument/w:body" level="any" count="w:rPr"/>
                            </xsl:variable>
                            <xsl:attribute name="text:style-name">T<xsl:value-of select="$position + 1"/></xsl:attribute>
                        </xsl:when>
                    </xsl:choose>
                    <xsl:apply-templates/>
                </xsl:element>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <!-- strange enough, WordML allows bookmarks out of w:p, but this isn't supported by StarWriter. To be patched. :( glu -->
    <xsl:template match="aml:annotation[@w:type = 'Word.Bookmark.Start']">
        <xsl:variable name="id" select="@aml:id"/>
        <text:bookmark-start text:name="{@w:name}"/>
    </xsl:template>
    <xsl:template match="aml:annotation[@w:type = 'Word.Bookmark.End']">
        <xsl:variable name="id" select="@aml:id"/>
        <text:bookmark-end text:name="{preceding::aml:annotation[@aml:id = $id]/@w:name}"/>
    </xsl:template>
    <xsl:template match="w:hlink">
        <xsl:element name="text:a">
            <xsl:attribute name="xlink:type">simple</xsl:attribute>
            <xsl:choose>
                <xsl:when test="@w:dest and @w:bookmark">
                    <xsl:attribute name="xlink:href"><xsl:value-of select="concat( @w:dest, concat('#', @w:bookmark) )"/></xsl:attribute>
                </xsl:when>
                <xsl:when test="@w:dest">
                    <xsl:attribute name="xlink:href"><xsl:value-of select="@w:dest"/></xsl:attribute>
                </xsl:when>
                <xsl:when test="@w:bookmark">
                    <xsl:attribute name="xlink:href"><xsl:value-of select="concat('#', @w:bookmark)"/></xsl:attribute>
                </xsl:when>
            </xsl:choose>
            <xsl:if test="@w:target">
                <xsl:attribute name="office:target-frame-name"><xsl:value-of select="@w:target"/></xsl:attribute>
            </xsl:if>
            <xsl:apply-templates/>
        </xsl:element>
    </xsl:template>
    <xsl:template name="start-end-bookmark">
        <!--?? generate bookmark before/after the tag w:p by recursion untill another type of aml:annotation. type: start/end. cp tom chen. -->
        <xsl:param name="type"/>
        <xsl:param name="bm-node"/>
        <xsl:param name="wp-node"/>
        <xsl:for-each select="$bm-node">
            <xsl:variable name="curr" select="."/>
            <xsl:for-each select="$wp-node[1]">
                <xsl:if test="not(preceding::aml:annotation/@aml:id = $curr/@aml:id) and not(./aml:annotation[@aml:id = $curr/@aml:id]) and ($type = 'start')">
                    <text:bookmark-start text:name="{$bm-node[@aml:id = $curr/@aml:id]/@w:name}"/>
                </xsl:if>
                <xsl:if test="not(following::aml:annotation/@aml:id = $curr/@aml:id) and not(./aml:annotation[@aml:id = $curr/@aml:id]) and ($type = 'end')">
                    <text:bookmark-end text:name="{preceding::aml:annotation[@aml:id = $curr/@aml:id]/@w:name}"/>
                </xsl:if>
            </xsl:for-each>
        </xsl:for-each>
    </xsl:template>
    <xsl:template match="w:t">
        <xsl:choose>
            <xsl:when test="string(.) = ' ' ">
                <xsl:element name="text:s"/>
            </xsl:when>
            <xsl:when test="contains(.,'  ')">
                <xsl:call-template name="replace-spaces">
                    <xsl:with-param name="curr-string" select="."/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="replace-spaces">
        <xsl:param name="curr-string"/>
        <xsl:if test="contains($curr-string,'  ')">
            <xsl:value-of select="substring-before($curr-string,'  ')"/>
            <text:s text:c="2"/>
            <xsl:variable name="next-string" select="substring-after($curr-string,'  ')"/>
            <xsl:choose>
                <xsl:when test="contains($next-string, '  ')">
                    <xsl:call-template name="replace-spaces">
                        <xsl:with-param name="curr-string" select="$next-string"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$next-string"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
    </xsl:template>
    <xsl:template match="w:tab">
        <xsl:element name="text:tab-stop"/>
    </xsl:template>
    <xsl:template match="w:instrText"/>
    <xsl:template match="w:fldChar"/>
<!-- End of OOo2.0 import/wordml/wordml2ooo_text.xsl stylesheet  -->
<!-- Start of OOo2.0 import/common/ms2ooo_docpr.xsl stylesheet  -->
    <xsl:template match="o:DocumentProperties">
        <office:meta>
            <meta:generator>Microsoft Word 2003</meta:generator>
            <dc:title>
                <xsl:value-of select="o:Title"/>
            </dc:title>
            <dc:description>
                <xsl:value-of select="o:Description"/>
            </dc:description>
            <dc:subject>
                <xsl:value-of select="o:Subject"/>
            </dc:subject>
            <meta:initial-creator>
                <xsl:value-of select="o:Author"/>
            </meta:initial-creator>
            <meta:creation-date>
                <xsl:value-of select="substring-before( o:Created, 'Z')"/>
            </meta:creation-date>
            <dc:creator>
                <xsl:value-of select="o:LastAuthor"/>
            </dc:creator>
            <dc:date>
                <xsl:value-of select="substring-before( o:LastSaved, 'Z')"/>
            </dc:date>
            <meta:printed-by/>
            <meta:print-date>
                <xsl:value-of select="substring-before( o:LastPrinted, 'Z')"/>
            </meta:print-date>
            <meta:keywords>
                <meta:keyword>
                    <xsl:value-of select="o:Keywords"/>
                </meta:keyword>
            </meta:keywords>
            <dc:language/>
            <meta:editing-cycles>
                <xsl:value-of select="o:Revision"/>
            </meta:editing-cycles>
            <meta:editing-duration>
                <xsl:if test="o:TotalTime">
                    <xsl:value-of select="concat('PT', floor(o:TotalTime div 60), 'H', o:TotalTime mod 60, 'M0S')"/>
                </xsl:if>
            </meta:editing-duration>
            <meta:user-defined meta:name="Category">
                <xsl:value-of select="o:Category"/>
            </meta:user-defined>
            <meta:user-defined meta:name="Manager">
                <xsl:value-of select="o:Manager"/>
            </meta:user-defined>
            <meta:user-defined meta:name="Company">
                <xsl:value-of select="o:Company"/>
            </meta:user-defined>
            <meta:user-defined meta:name="Version">
                <xsl:value-of select="o:Version"/>
            </meta:user-defined>
            <meta:user-defined meta:name="HyperlinkBase">
                <xsl:value-of select="o:HyperlinkBase"/>
            </meta:user-defined>
            <xsl:apply-templates select="../o:CustomDocumentProperties"/>
            <meta:document-statistic meta:page-count="{o:Pages}" meta:paragraph-count="{o:Paragraphs}" meta:word-count="{o:Words}" meta:character-count="{o:Characters}"/>
        </office:meta>
    </xsl:template>
    <xsl:template match="o:CustomDocumentProperties">
        <xsl:for-each select="node()[@dt:dt]">
            <meta:user-defined meta:name="{local-name()}">
                <xsl:value-of select="."/>
            </meta:user-defined>
        </xsl:for-each>
    </xsl:template>
<!-- End of OOo2.0 import/common/ms2ooo_docpr.xsl stylesheet  -->
<!-- Start of OOo2.0 common/measure_conversion.xsl stylesheet  -->
    <!-- DPI (dots per inch) the standard resolution of given pictures (necessary for the conversion of 'cm' into 'pixel')
         Although many pictures have a 96 dpi resolution, a higher resoltion give better results for common browsers -->
    <xsl:param name="dpi" select="111"/>
    <xsl:param name="centimeter-in-mm" select="10"/>
    <xsl:param name="inch-in-mm" select="25.4"/>
    <xsl:param name="didot-point-in-mm" select="0.376065"/>
    <xsl:param name="pica-in-mm" select="4.2333333"/>
    <xsl:param name="point-in-mm" select="0.3527778"/>
    <xsl:param name="twip-in-mm" select="0.017636684"/>
    <xsl:param name="pixel-in-mm" select="$inch-in-mm div $dpi"/>
    <!-- ***** MEASUREMENT CONVERSIONS *****
      PARAM 'value'
        The measure to be converted.
        The current measure is judged by a substring (e.g. 'mm', 'cm', 'in', 'pica'...)
        directly added to the number.

      PARAM 'rounding-factor'
        Is used for the rounding of decimal places.
        The parameter number is the product of 1 and some '10', where
        every zero represents a decimal place.

        For example, providing as parameter:
            <xsl:param name="rounding-factor" select="10000" />
        Gives by default four decimal places.

        To round two decimal places, basically the following is done:
            <xsl:value-of select="round(100 * value) div 100"/>

      RETURN    The converted number, by default rounded to four decimal places.
                In case the input measure could not be matched the same value is
                returned and a warning message is written out.



     MEASURE LIST:
     * 1 milimeter (mm), the basic measure

     * 1 centimeter (cm) = 10 mm

     * 1 inch (in) = 25.4 mm
        While the English have already seen the light (read: the metric system), the US
        remains loyal to this medieval system.

     * 1 point (pt) = 0.35277777.. mm
        Sometimes called PostScript point (ppt), as when Adobe created PostScript, they added their own system of points.
        There are exactly 72 PostScript points in 1 inch.

     * 1 twip = twentieth of a (PostScript) point
        A twip (twentieth of a point) is a 1/20th of a PostScript point, a traditional measure in printing.

     * 1 didot point (dpt) = 0.376065 mm
        Didot point after the French typographer Firmin Didot (1764-1836).

        More details under
        http://www.unc.edu/~rowlett/units/dictP.html:
        "A unit of length used by typographers and printers. When printing was done
        from hand-set metal type, one point represented the smallest element of type
        that could be handled, roughly 1/64 inch. Eventually, the point was standardized
        in Britain and America as exactly 1/72.27 = 0.013 837 inch, which is
        about 0.35 mm (351.46 micrometers). In continental Europe, typographers
        traditionally used a slightly larger point of 0.014 83 inch (about
        1/72 pouce, 0.377 mm, or roughly 1/67 English inch), called a Didot point
        after the French typographer Firmin Didot (1764-1836). In the U.S.,
        Adobe software defines the point to be exactly 1/72 inch (0.013 888 9 inch
        or 0.352 777 8 millimeters) and TeX software uses a slightly smaller point
        of 0.351 459 8035 mm. The German standards agency DIN has proposed that
        all these units be replaced by multiples of 0.25 millimeters (1/101.6 inch).

     * 1 pica = 4.233333 mm
        1/6 inch or 12 points

     * 1 pixel (px) = 0.26458333.. mm   (relative to 'DPI', here: 96 dpi)
        Most pictures have the 96 dpi resolution, but the dpi variable may vary by stylesheet parameter


    -->
    <!-- changing measure to mm -->
    <xsl:template name="convert2mm">
        <xsl:param name="value"/>
        <xsl:param name="rounding-factor" select="10000"/>
        <xsl:choose>
            <xsl:when test="contains($value, 'mm')">
                <xsl:value-of select="substring-before($value, 'mm')"/>
            </xsl:when>
            <xsl:when test="contains($value, 'cm')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'cm' ) * $centimeter-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'in')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'in' ) * $inch-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pt')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'pt') * $point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'twip')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'twip') * $twip-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'dxa')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'dxa') * $twip-in-mm)) div $rounding-factor"/>
            </xsl:when>

            <xsl:when test="contains($value, 'dpt')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'dpt') * $didot-point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pica')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'pica') * $pica-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'px')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'px') * $pixel-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>measure_conversion.xsl: Find no conversion for <xsl:value-of select="$value"/> to 'mm'!</xsl:message>
                <xsl:value-of select="$value"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <!-- changing measure to cm -->
    <xsl:template name="convert2cm">
        <xsl:param name="value"/>
        <xsl:param name="rounding-factor" select="10000"/>
        <xsl:choose>
            <xsl:when test="contains($value, 'mm')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'mm') div $centimeter-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'cm')">
                <xsl:value-of select="substring-before($value, 'cm')"/>
            </xsl:when>
            <xsl:when test="contains($value, 'in')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'in') div $centimeter-in-mm * $inch-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pt')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'pt') div $centimeter-in-mm * $point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'dpt')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'dpt') div $centimeter-in-mm * $didot-point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pica')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'pica') div $centimeter-in-mm * $pica-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'twip')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'twip') div $centimeter-in-mm * $twip-in-mm)) div $rounding-factor"/>
            </xsl:when>
             <xsl:when test="contains($value, 'dxa')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'dxa') div $centimeter-in-mm * $twip-in-mm)) div $rounding-factor"/>
            </xsl:when>

            <xsl:when test="contains($value, 'px')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'px') div $centimeter-in-mm * $pixel-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>measure_conversion.xsl: Find no conversion for <xsl:value-of select="$value"/> to 'cm'!</xsl:message>
                <xsl:value-of select="$value"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <!-- changing measure to inch (cp. section comment) -->
    <xsl:template name="convert2in">
        <xsl:param name="value"/>
        <xsl:param name="rounding-factor" select="10000"/>
        <xsl:choose>
            <xsl:when test="contains($value, 'mm')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'mm') div $inch-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'cm')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'cm') div $inch-in-mm * $centimeter-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'in')">
                <xsl:value-of select="substring-before($value, 'in')"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pt')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'pt') div $inch-in-mm * $point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'dpt')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'dpt') div $inch-in-mm * $didot-point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pica')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'pica') div $inch-in-mm * $pica-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'twip')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'twip') div $inch-in-mm * $twip-in-mm)) div $rounding-factor"/>
            </xsl:when>
             <xsl:when test="contains($value, 'dxa')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'dxa') div $inch-in-mm * $twip-in-mm)) div $rounding-factor"/>
            </xsl:when>

            <xsl:when test="contains($value, 'px')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'px') div $inch-in-mm * $pixel-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>measure_conversion.xsl: Find no conversion for <xsl:value-of select="$value"/> to 'in'!</xsl:message>
                <xsl:value-of select="$value"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <!-- changing measure to dpt (cp. section comment) -->
    <xsl:template name="convert2dpt">
        <xsl:param name="value"/>
        <xsl:param name="rounding-factor" select="10000"/>
        <xsl:choose>
            <xsl:when test="contains($value, 'mm')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'mm') div $didot-point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'cm')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'cm') div $didot-point-in-mm * $centimeter-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'in')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'in') div $didot-point-in-mm * $inch-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pt')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'pt') div $didot-point-in-mm * $point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'dpt')">
                <xsl:value-of select="substring-before($value, 'dpt')"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pica')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'pica') div $didot-point-in-mm * $pica-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'twip')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'twip') div $didot-point-in-mm * $twip-in-mm)) div $rounding-factor"/>
            </xsl:when>
             <xsl:when test="contains($value, 'dxa')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'dxa') div $didot-point-in-mm * $twip-in-mm)) div $rounding-factor"/>
            </xsl:when>

            <xsl:when test="contains($value, 'px')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'px') div $didot-point-in-mm * $pixel-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>measure_conversion.xsl: Find no conversion for <xsl:value-of select="$value"/> to 'dpt'!</xsl:message>
                <xsl:value-of select="$value"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <!-- changing measure to pica (cp. section comment) -->
    <xsl:template name="convert2pica">
        <xsl:param name="value"/>
        <xsl:param name="rounding-factor" select="10000"/>
        <xsl:choose>
            <xsl:when test="contains($value, 'mm')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'mm') div $pica-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'cm')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'cm') div $pica-in-mm * $centimeter-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'in')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'in') div $pica-in-mm * $inch-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pt')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'pt') div $pica-in-mm * $point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'dpt')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'dpt') div $pica-in-mm * $didot-point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pica')">
                <xsl:value-of select="substring-before($value, 'pica')"/>
            </xsl:when>
            <xsl:when test="contains($value, 'twip')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'twip') div $pica-in-mm * $twip-in-mm)) div $rounding-factor"/>
            </xsl:when>
             <xsl:when test="contains($value, 'dxa')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'dxa') div $pica-in-mm * $twip-in-mm)) div $rounding-factor"/>
            </xsl:when>

            <xsl:when test="contains($value, 'px')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'px') div $pica-in-mm * $pixel-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>measure_conversion.xsl: Find no conversion for <xsl:value-of select="$value"/> to 'pica'!</xsl:message>
                <xsl:value-of select="$value"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <!-- changing measure to pt (cp. section comment) -->
    <xsl:template name="convert2pt">
        <xsl:param name="value"/>
        <xsl:param name="rounding-factor" select="10000"/>
        <xsl:choose>
            <xsl:when test="contains($value, 'mm')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'mm') div $point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'cm')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'cm') div $point-in-mm * $centimeter-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'in')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'in') div $point-in-mm * $inch-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pt')">
                <xsl:value-of select="substring-before($value, 'pt')"/>
            </xsl:when>
            <xsl:when test="contains($value, 'dpt')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'dpt') div $point-in-mm * $didot-point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pica')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'pica') div $point-in-mm * $pica-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'twip')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'twip') div $point-in-mm * $twip-in-mm)) div $rounding-factor"/>
            </xsl:when>
             <xsl:when test="contains($value, 'dxa')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'dxa') div $point-in-mm * $twip-in-mm)) div $rounding-factor"/>
            </xsl:when>

            <xsl:when test="contains($value, 'px')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'px') div $point-in-mm * $pixel-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>measure_conversion.xsl: Find no conversion for <xsl:value-of select="$value"/> to 'pt'!</xsl:message>
                <xsl:value-of select="$value"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <!-- changing measure to pt (cp. section comment) -->
    <xsl:template name="convert2twip">
        <xsl:param name="value"/>
        <xsl:param name="rounding-factor" select="10000"/>
        <xsl:choose>
            <xsl:when test="contains($value, 'mm')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'mm') div $twip-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'cm')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'cm') div $twip-in-mm * $centimeter-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'in')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'in') div $twip-in-mm * $inch-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pt')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'pt') div $twip-in-mm * $point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'dpt')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'dpt') div $twip-in-mm * $didot-point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pica')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'pica') div $twip-in-mm * $pica-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'twip')">
                <xsl:value-of select="substring-before($value, 'twip')"/>
            </xsl:when>
            <xsl:when test="contains($value, 'dxa')">
                <xsl:value-of select="substring-before($value, 'dxa')"/>
            </xsl:when>

            <xsl:when test="contains($value, 'px')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'px') div $twip-in-mm * $pixel-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>measure_conversion.xsl: Find no conversion for <xsl:value-of select="$value"/> to 'twip'!</xsl:message>
                <xsl:value-of select="$value"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <!-- changing measure to pixel by via parameter provided dpi (dots per inch) standard factor (cp. section comment) -->
    <xsl:template name="convert2px">
        <xsl:param name="value"/>
        <xsl:choose>
            <xsl:when test="contains($value, 'mm')">
                <xsl:value-of select="round(number(substring-before($value, 'mm')) div $pixel-in-mm)"/>
            </xsl:when>
            <xsl:when test="contains($value, 'cm')">
                <xsl:value-of select="round(number(substring-before($value, 'cm')) div $pixel-in-mm * $centimeter-in-mm)"/>
            </xsl:when>
            <xsl:when test="contains($value, 'in')">
                <xsl:value-of select="round(number(substring-before($value, 'in')) div $pixel-in-mm * $inch-in-mm)"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pt')">
                <xsl:value-of select="round(number(substring-before($value, 'pt')) div $pixel-in-mm * $point-in-mm)"/>
            </xsl:when>
            <xsl:when test="contains($value, 'dpt')">
                <xsl:value-of select="round(number(substring-before($value, 'dpt')) div $pixel-in-mm * $didot-point-in-mm)"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pica')">
                <xsl:value-of select="round(number(substring-before($value, 'pica')) div $pixel-in-mm * $pica-in-mm)"/>
            </xsl:when>
            <xsl:when test="contains($value, 'twip')">
                <xsl:value-of select="round(number(substring-before($value, 'twip')) div $pixel-in-mm * $twip-in-mm)"/>
            </xsl:when>
            <xsl:when test="contains($value, 'dxa')">
                <xsl:value-of select="round(number(substring-before($value, 'dxa')) div $pixel-in-mm * $twip-in-mm)"/>
            </xsl:when>

            <xsl:when test="contains($value, 'px')">
                <xsl:value-of select="$value"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>measure_conversion.xsl: Find no conversion for <xsl:value-of select="$value"/> to 'px'!</xsl:message>
                <xsl:value-of select="$value"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
        <xsl:template name="convert2dxa">
        <!-- this template is the same as the template of convert2twip because M$ word uses the dxa to represent twip-->
        <xsl:param name="value"/>
        <xsl:param name="rounding-factor" select="10000"/>
        <xsl:choose>
            <xsl:when test="contains($value, 'mm')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'mm') div $twip-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'cm')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'cm') div $twip-in-mm * $centimeter-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'in')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'in') div $twip-in-mm * $inch-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pt')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'pt') div $twip-in-mm * $point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'dpt')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'dpt') div $twip-in-mm * $didot-point-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'pica')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'pica') div $twip-in-mm * $pica-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:when test="contains($value, 'twip')">
                <xsl:value-of select="substring-before($value, 'twip')"/>
            </xsl:when>
            <xsl:when test="contains($value, 'dxa')">
                <xsl:value-of select="substring-before($value, 'dxa')"/>
            </xsl:when>

            <xsl:when test="contains($value, 'px')">
                <xsl:value-of select="round($rounding-factor * number(substring-before($value, 'px') div $twip-in-mm * $pixel-in-mm)) div $rounding-factor"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>measure_conversion.xsl: Find no conversion for <xsl:value-of select="$value"/> to 'twip'!</xsl:message>
                <xsl:value-of select="$value"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
<!-- End of OOo2.0 common/measure_conversion.xsl stylesheet  -->
</xsl:stylesheet>
