#
# Copyright (c) 1999, 2021, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

# Messages in this file which use "placeholders" for values (e.g. {0}, {1})
# are preceded by a stylized comment describing the type of the corresponding
# values.
# The simple types currently in use are:
#
# annotation        annotation compound
# boolean           true or false
# diagnostic        a sub-message; see compiler.misc.*
# fragment          similar to 'message segment', but with more specific type
# modifier          a Java modifier; e.g. public, private, protected
# file              a file URL
# file object       a file URL - similar to 'file' but typically used for source/class files, hence more specific
# flag              a Flags.Flag instance
# name              a name, typically a Java identifier
# number            an integer
# option name       the name of a command line option
# path              a path
# profile           a profile name
# source            a source version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.code.Source
# source version    a source version number, such as 1.5, 1.6, 1.7, taken from a javax.lang.model.SourceVersion
# string            a general string
# symbol            the name of a declared type
# symbol kind       the kind of a symbol (i.e. method, variable)
# kind name         an informative description of the kind of a declaration; see compiler.misc.kindname.*
# target            a target version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.jvm.Target
# token             the name of a non-terminal in source code; see compiler.misc.token.*
# tree tag          the name of a non-terminal in source code; see compiler.misc.token.*
# type              a Java type; e.g. int, X, X<T>
# url               a URL
# object            a Java object (unspecified)
# unused            the value is not used in this message
#
# The following compound types are also used:
#
# collection of X   a comma-separated collection of items; e.g. collection of type
# list of X         a comma-separated list of items; e.g. list of type
# set of X          a comma-separated set of items; e.g. set of modifier
#
# These may be composed:
#
# list of type or message segment
#
# The following type aliases are supported:
#
# message segment --> diagnostic or fragment
# file name --> file, path or file object
#
# Custom comments are supported in parenthesis i.e.
#
# number (classfile major version)
#
# These comments are used internally in order to generate an enum-like class declaration containing
# a method/field for each of the diagnostic keys listed here. Those methods/fields can then be used
# by javac code to build diagnostics in a type-safe fashion.
#
# In addition, these comments are verified by the jtreg test test/tools/javac/diags/MessageInfo,
# using info derived from the collected set of examples in test/tools/javac/diags/examples.
# MessageInfo can also be run as a standalone utility providing more facilities
# for manipulating this file. For more details, see MessageInfo.java.

##
## errors
##

# 0: symbol
compiler.err.abstract.cant.be.instantiated=\
    {0} is abstract; cannot be instantiated

compiler.err.abstract.meth.cant.have.body=\
    abstract methods cannot have a body

# 0: kind name, 1: symbol
compiler.err.already.annotated=\
    {0} {1} has already been annotated

# 0: kind name, 1: symbol, 2: kind name, 3: symbol
compiler.err.already.defined=\
    {0} {1} is already defined in {2} {3}

# 0: kind name, 1: symbol, 2: kind name, 3: kind name, 4: symbol
compiler.err.already.defined.in.clinit=\
    {0} {1} is already defined in {2} of {3} {4}

# 0: symbol
compiler.err.already.defined.single.import=\
    a type with the same simple name is already defined by the single-type-import of {0}

# 0: symbol
compiler.err.already.defined.static.single.import=\
    a type with the same simple name is already defined by the static single-type-import of {0}

# 0: symbol
compiler.err.already.defined.this.unit=\
    {0} is already defined in this compilation unit

# 0: type, 1: list of name
compiler.err.annotation.missing.default.value=\
    annotation @{0} is missing a default value for the element ''{1}''

# 0: type, 1: list of name
compiler.err.annotation.missing.default.value.1=\
    annotation @{0} is missing default values for elements {1}

# 0: type
compiler.err.annotation.not.valid.for.type=\
    annotation not valid for an element of type {0}

compiler.err.annotation.type.not.applicable=\
    annotation type not applicable to this kind of declaration

# 0: type
compiler.err.annotation.type.not.applicable.to.type=\
    annotation @{0} not applicable in this type context

compiler.err.annotation.value.must.be.annotation=\
    annotation value must be an annotation

compiler.err.annotation.value.must.be.class.literal=\
    annotation value must be a class literal

compiler.err.annotation.value.must.be.name.value=\
    annotation values must be of the form ''name=value''

compiler.err.annotation.value.not.allowable.type=\
    annotation value not of an allowable type

compiler.err.expression.not.allowable.as.annotation.value=\
    expression not allowed as annotation value

compiler.err.anon.class.impl.intf.no.args=\
    anonymous class implements interface; cannot have arguments

compiler.err.anon.class.impl.intf.no.typeargs=\
    anonymous class implements interface; cannot have type arguments

compiler.err.anon.class.impl.intf.no.qual.for.new=\
    anonymous class implements interface; cannot have qualifier for new

compiler.err.cant.inherit.from.anon=\
    cannot inherit from anonymous class

# 0: symbol, 1: symbol, 2: symbol
compiler.err.array.and.varargs=\
    cannot declare both {0} and {1} in {2}

compiler.err.array.dimension.missing=\
    array dimension missing

compiler.err.illegal.array.creation.both.dimension.and.initialization=\
    array creation with both dimension expression and initialization is illegal

# 0: type
compiler.err.array.req.but.found=\
    array required, but {0} found

compiler.err.attribute.value.must.be.constant=\
    element value must be a constant expression

# 0: string (statement type)
compiler.err.bad.initializer=\
    bad initializer for {0}

compiler.err.break.outside.switch.loop=\
    break outside switch or loop

compiler.err.break.outside.switch.expression=\
    attempt to break out of a switch expression

compiler.err.continue.outside.switch.expression=\
    attempt to continue out of a switch expression

compiler.err.return.outside.switch.expression=\
    attempt to return out of a switch expression

compiler.err.rule.completes.normally=\
    switch rule completes without providing a value\n\
    (switch rules in switch expressions must either provide a value or throw)

compiler.err.switch.expression.completes.normally=\
    switch expression completes without providing a value\n\
    (switch expressions must either provide a value or throw for all possible input values)

compiler.err.no.switch.expression =\
    yield outside of switch expression

compiler.err.no.switch.expression.qualify=\
    yield outside of switch expression\n\
    (to invoke a method called yield, qualify the yield with a receiver or type name)

compiler.err.invalid.yield=\
    invalid use of a restricted identifier ''yield''\n\
    (to invoke a method called yield, qualify the yield with a receiver or type name)

compiler.warn.invalid.yield=\
    ''yield'' may become a restricted identifier in a future release\n\
    (to invoke a method called yield, qualify the yield with a receiver or type name)

compiler.err.switch.expression.empty=\
    switch expression does not have any case clauses

compiler.err.switch.expression.no.result.expressions=\
    switch expression does not have any result expressions

# 0: name
compiler.err.call.must.be.first.stmt.in.ctor=\
    call to {0} must be first statement in constructor

# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
compiler.err.cant.apply.symbol=\
    {0} {1} in {4} {5} cannot be applied to given types;\n\
    required: {2}\n\
    found:    {3}\n\
    reason: {6}

# 0: symbol kind, 1: name, 2: list of type
compiler.err.cant.apply.symbols=\
    no suitable {0} found for {1}({2})

# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
compiler.misc.cant.apply.symbol=\
    {0} {1} in {4} {5} cannot be applied to given types\n\
    required: {2}\n\
    found:    {3}\n\
    reason: {6}

# 0: symbol kind, 1: name, 2: list of type
compiler.misc.cant.apply.symbols=\
    no suitable {0} found for {1}({2})

# 0: kind name, 1: symbol
compiler.misc.no.abstracts=\
    no abstract method found in {0} {1}

# 0: kind name, 1: symbol
compiler.misc.incompatible.abstracts=\
    multiple non-overriding abstract methods found in {0} {1}

compiler.err.bad.functional.intf.anno=\
    Unexpected @FunctionalInterface annotation

# 0: message segment
compiler.err.bad.functional.intf.anno.1=\
    Unexpected @FunctionalInterface annotation\n\
    {0}

# 0: message segment
compiler.err.anonymous.diamond.method.does.not.override.superclass=\
    method does not override or implement a method from a supertype\n\
    {0}

# 0: symbol
compiler.misc.not.a.functional.intf=\
    {0} is not a functional interface

# 0: symbol, 1: message segment
compiler.misc.not.a.functional.intf.1=\
    {0} is not a functional interface\n\
    {1}

# 0: type, 1: kind name, 2: symbol
compiler.misc.invalid.generic.lambda.target=\
    invalid functional descriptor for lambda expression\n\
    method {0} in {1} {2} is generic

# 0: kind name, 1: symbol
compiler.misc.incompatible.descs.in.functional.intf=\
    incompatible function descriptors found in {0} {1}

# 0: name, 1: list of type, 2: type, 3: list of type
compiler.misc.descriptor=\
    descriptor: {2} {0}({1})

# 0: name, 1: list of type, 2: type, 3: list of type
compiler.misc.descriptor.throws=\
    descriptor: {2} {0}({1}) throws {3}

# 0: type
compiler.misc.no.suitable.functional.intf.inst=\
    cannot infer functional interface descriptor for {0}

# 0: message segment
compiler.misc.bad.intersection.target.for.functional.expr=\
    bad intersection type target for lambda or method reference\n\
    {0}

# 0: symbol or type
compiler.misc.not.an.intf.component=\
    component type {0} is not an interface

# 0: kind name, 1: message segment
compiler.err.invalid.mref=\
    invalid {0} reference\n\
    {1}

# 0: kind name, 1: message segment
compiler.misc.invalid.mref=\
    invalid {0} reference\n\
    {1}

compiler.misc.static.mref.with.targs=\
    parameterized qualifier on static method reference

# 0: symbol
compiler.err.cant.assign.val.to.final.var=\
    cannot assign a value to final variable {0}

compiler.err.cant.assign.val.to.this=\
    cannot assign to ''this''

# 0: symbol, 1: message segment
compiler.err.cant.ref.non.effectively.final.var=\
    local variables referenced from {1} must be final or effectively final

compiler.err.try.with.resources.expr.needs.var=\
    the try-with-resources resource must either be a variable declaration or an expression denoting \
a reference to a final or effectively final variable

# 0: symbol
compiler.err.try.with.resources.expr.effectively.final.var=\
    variable {0} used as a try-with-resources resource neither final nor effectively final


compiler.misc.lambda=\
    a lambda expression

compiler.misc.inner.cls=\
    an inner class

compiler.misc.guard=\
    a guard

# 0: type
compiler.err.cant.deref=\
    {0} cannot be dereferenced

compiler.err.cant.extend.intf.annotation=\
    ''extends'' not allowed for @interfaces

compiler.err.annotation.decl.not.allowed.here=\
    annotation type declaration not allowed here

# 0: symbol
compiler.err.cant.inherit.from.final=\
    cannot inherit from final {0}

# 0: symbol or string
compiler.err.cant.ref.before.ctor.called=\
    cannot reference {0} before supertype constructor has been called

compiler.err.cant.select.static.class.from.param.type=\
    cannot select a static class from a parameterized type

# 0: symbol, 1: string, 2: string
compiler.err.cant.inherit.diff.arg=\
    {0} cannot be inherited with different arguments: <{1}> and <{2}>

compiler.err.catch.without.try=\
    ''catch'' without ''try''

# 0: kind name, 1: symbol
compiler.err.clash.with.pkg.of.same.name=\
    {0} {1} clashes with package of same name

compiler.err.class.not.allowed=\
    class, interface or enum declaration not allowed here

compiler.err.const.expr.req=\
    constant expression required

compiler.err.cont.outside.loop=\
    continue outside of loop

# 0: symbol or type
compiler.err.cyclic.inheritance=\
    cyclic inheritance involving {0}

# 0: symbol
compiler.err.cyclic.annotation.element=\
    type of element {0} is cyclic

# 0: symbol
compiler.err.call.to.super.not.allowed.in.enum.ctor=\
    call to super not allowed in enum constructor

# 0: type
compiler.err.no.superclass=\
    {0} has no superclass.

# 0: symbol, 1: type, 2: symbol, 3: type, 4: type
compiler.err.concrete.inheritance.conflict=\
    methods {0} from {1} and {2} from {3} are inherited with the same signature

compiler.err.default.allowed.in.intf.annotation.member=\
    default value only allowed in an annotation type declaration

# 0: symbol
compiler.err.doesnt.exist=\
    package {0} does not exist

# 0: type
compiler.err.duplicate.annotation.invalid.repeated=\
    annotation {0} is not a valid repeatable annotation

# 0: name, 1: type
compiler.err.duplicate.annotation.member.value=\
    duplicate element ''{0}'' in annotation @{1}.

# 0: type
compiler.err.duplicate.annotation.missing.container=\
    {0} is not a repeatable annotation type

# 0: symbol
compiler.err.invalid.repeatable.annotation=\
    duplicate annotation: {0} is annotated with an invalid @Repeatable annotation

# 0: symbol or type
compiler.err.invalid.repeatable.annotation.no.value=\
    {0} is not a valid @Repeatable, no value element method declared

# 0: type, 1: number
compiler.err.invalid.repeatable.annotation.multiple.values=\
    {0} is not a valid @Repeatable, {1} element methods named ''value'' declared

# 0: type
compiler.err.invalid.repeatable.annotation.invalid.value=\
    {0} is not a valid @Repeatable: invalid value element

# 0: symbol or type, 1: type, 2: type
compiler.err.invalid.repeatable.annotation.value.return=\
    containing annotation type ({0}) must declare an element named ''value'' of type {2}

# 0: symbol or type, 1: symbol
compiler.err.invalid.repeatable.annotation.elem.nondefault=\
    containing annotation type ({0}) does not have a default value for element {1}

# 0: symbol, 1: string, 2: symbol, 3: string
compiler.err.invalid.repeatable.annotation.retention=\
    retention of containing annotation type ({0}) is shorter than the retention of repeatable annotation type ({2})

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.not.documented=\
    repeatable annotation type ({1}) is @Documented while containing annotation type ({0}) is not

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.not.inherited=\
    repeatable annotation type ({1}) is @Inherited while containing annotation type ({0}) is not

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.incompatible.target=\
    containing annotation type ({0}) is applicable to more targets than repeatable annotation type ({1})

# 0: symbol
compiler.err.invalid.repeatable.annotation.repeated.and.container.present=\
    container {0} must not be present at the same time as the element it contains

# 0: type, 1: symbol
compiler.err.invalid.repeatable.annotation.not.applicable=\
    container {0} is not applicable to element {1}

# 0: type
compiler.err.invalid.repeatable.annotation.not.applicable.in.context=\
    container {0} is not applicable in this type context

# 0: name
compiler.err.duplicate.class=\
    duplicate class: {0}

# 0: name, 1: name
compiler.err.same.binary.name=\
    classes: {0} and {1} have the same binary name

compiler.err.duplicate.case.label=\
    duplicate case label

compiler.err.pattern.dominated=\
    this case label is dominated by a preceding case label

compiler.err.duplicate.default.label=\
    duplicate default label

compiler.err.duplicate.total.pattern=\
    duplicate total pattern

compiler.err.total.pattern.and.default=\
    switch has both a total pattern and a default label

# 0: type, 1: type
compiler.err.constant.label.not.compatible=\
    constant label of type {0} is not compatible with switch selector type {1}

compiler.err.flows.through.to.pattern=\
    illegal fall-through to a pattern

compiler.err.flows.through.from.pattern=\
    illegal fall-through from a pattern

compiler.err.else.without.if=\
    ''else'' without ''if''

compiler.err.empty.char.lit=\
    empty character literal

# 0: symbol
compiler.err.encl.class.required=\
    an enclosing instance that contains {0} is required

compiler.err.enum.annotation.must.be.enum.constant=\
    an enum annotation value must be an enum constant

compiler.err.enum.cant.be.instantiated=\
    enum types may not be instantiated

compiler.err.enum.label.must.be.unqualified.enum=\
    an enum switch case label must be the unqualified name of an enumeration constant

compiler.err.enum.no.subclassing=\
    classes cannot directly extend java.lang.Enum

compiler.err.enum.types.not.extensible=\
    enum types are not extensible

compiler.err.enum.no.finalize=\
    enums cannot have finalize methods

# 0: file name, 1: string
compiler.err.error.reading.file=\
    error reading {0}; {1}

# 0: type
compiler.err.except.already.caught=\
    exception {0} has already been caught

# 0: type
compiler.err.except.never.thrown.in.try=\
    exception {0} is never thrown in body of corresponding try statement

# 0: symbol
compiler.err.final.parameter.may.not.be.assigned=\
    final parameter {0} may not be assigned

# 0: symbol
compiler.err.try.resource.may.not.be.assigned=\
    auto-closeable resource {0} may not be assigned

# 0: symbol
compiler.err.multicatch.parameter.may.not.be.assigned=\
    multi-catch parameter {0} may not be assigned

# 0: type, 1: type
compiler.err.multicatch.types.must.be.disjoint=\
    Alternatives in a multi-catch statement cannot be related by subclassing\n\
    Alternative {0} is a subclass of alternative {1}

compiler.err.finally.without.try=\
    ''finally'' without ''try''

# 0: type, 1: message segment
compiler.err.foreach.not.applicable.to.type=\
    for-each not applicable to expression type\n\
    required: {1}\n\
    found:    {0}

compiler.err.fp.number.too.large=\
    floating-point number too large

compiler.err.fp.number.too.small=\
    floating-point number too small

compiler.err.generic.array.creation=\
    generic array creation

compiler.err.generic.throwable=\
    a generic class may not extend java.lang.Throwable

# 0: symbol
compiler.err.icls.cant.have.static.decl=\
    Illegal static declaration in inner class {0}\n\
    modifier \''static\'' is only allowed in constant variable declarations

# 0: string
compiler.err.illegal.char=\
    illegal character: ''{0}''

# 0: string, 1: string
compiler.err.illegal.char.for.encoding=\
    unmappable character (0x{0}) for encoding {1}

# 0: set of flag, 1: set of flag
compiler.err.illegal.combination.of.modifiers=\
    illegal combination of modifiers: {0} and {1}

compiler.err.illegal.enum.static.ref=\
    illegal reference to static field from initializer

compiler.err.illegal.esc.char=\
    illegal escape character

compiler.err.illegal.forward.ref=\
    illegal forward reference

# 0: symbol, 1: object
compiler.err.not.in.profile=\
    {0} is not available in profile ''{1}''

# 0: symbol
compiler.warn.forward.ref=\
    reference to variable ''{0}'' before it has been initialized

compiler.err.illegal.self.ref=\
    self-reference in initializer

# 0: symbol
compiler.warn.self.ref=\
    self-reference in initializer of variable ''{0}''

# 0: type
compiler.err.illegal.initializer.for.type=\
    illegal initializer for {0}

compiler.err.illegal.line.end.in.char.lit=\
    illegal line end in character literal

compiler.err.illegal.text.block.open=\
    illegal text block open delimiter sequence, missing line terminator

compiler.warn.inconsistent.white.space.indentation=\
    inconsistent white space indentation

compiler.warn.trailing.white.space.will.be.removed=\
    trailing white space will be removed

compiler.err.illegal.nonascii.digit=\
    illegal non-ASCII digit

compiler.err.illegal.underscore=\
    illegal underscore

compiler.err.illegal.dot=\
    illegal ''.''

# 0: symbol
compiler.err.illegal.qual.not.icls=\
    illegal qualifier; {0} is not an inner class

compiler.err.illegal.start.of.expr=\
    illegal start of expression

compiler.err.illegal.start.of.stmt=\
    illegal start of statement

compiler.err.illegal.start.of.type=\
    illegal start of type

compiler.err.illegal.parenthesized.expression=\
    illegal parenthesized expression

compiler.err.illegal.unicode.esc=\
    illegal unicode escape

# 0: symbol
compiler.err.import.requires.canonical=\
    import requires canonical name for {0}

compiler.err.improperly.formed.type.param.missing=\
    improperly formed type, some parameters are missing

compiler.err.improperly.formed.type.inner.raw.param=\
    improperly formed type, type arguments given on a raw type

# 0: type, 1: type
compiler.err.incomparable.types=\
    incomparable types: {0} and {1}

# 0: string
compiler.err.int.number.too.large=\
    integer number too large

compiler.err.intf.annotation.members.cant.have.params=\
    elements in annotation type declarations cannot declare formal parameters

# 0: symbol
compiler.err.intf.annotation.cant.have.type.params=\
    annotation type {0} cannot be generic

compiler.err.intf.annotation.members.cant.have.type.params=\
    elements in annotation type declarations cannot be generic methods

# 0: symbol, 1: type
compiler.err.intf.annotation.member.clash=\
    annotation type {1} declares an element with the same name as method {0}

compiler.err.intf.expected.here=\
    interface expected here

compiler.err.intf.meth.cant.have.body=\
    interface abstract methods cannot have body

compiler.err.invalid.annotation.member.type=\
    invalid type for annotation type element

compiler.err.invalid.binary.number=\
    binary numbers must contain at least one binary digit

compiler.err.invalid.hex.number=\
    hexadecimal numbers must contain at least one hexadecimal digit

compiler.err.invalid.meth.decl.ret.type.req=\
    invalid method declaration; return type required

compiler.err.varargs.and.old.array.syntax=\
    legacy array notation not allowed on variable-arity parameter

compiler.err.varargs.and.receiver =\
    varargs notation not allowed on receiver parameter

compiler.err.varargs.must.be.last =\
    varargs parameter must be the last parameter

compiler.err.array.and.receiver =\
    legacy array notation not allowed on receiver parameter

compiler.err.wrong.receiver =\
    wrong receiver parameter name

compiler.err.variable.not.allowed=\
    variable declaration not allowed here

# 0: name
compiler.err.label.already.in.use=\
    label {0} already in use

# 0: symbol
compiler.err.local.var.accessed.from.icls.needs.final=\
    local variable {0} is accessed from within inner class; needs to be declared final

compiler.err.local.enum=\
    enum types must not be local

compiler.err.cannot.create.array.with.type.arguments=\
    cannot create array with type arguments

compiler.err.cannot.create.array.with.diamond=\
    cannot create array with ''<>''

compiler.err.invalid.module.directive=\
  module directive keyword or ''}'' expected

#
# limits.  We don't give the limits in the diagnostic because we expect
# them to change, yet we want to use the same diagnostic.  These are all
# detected during code generation.
#
compiler.err.limit.code=\
    code too large

compiler.err.limit.code.too.large.for.try.stmt=\
    code too large for try statement

compiler.err.limit.dimensions=\
    array type has too many dimensions

compiler.err.limit.locals=\
    too many local variables

compiler.err.limit.parameters=\
    too many parameters

compiler.err.limit.pool=\
    too many constants

compiler.err.limit.pool.in.class=\
    too many constants in class {0}

compiler.err.limit.stack=\
    code requires too much stack

compiler.err.limit.string=\
    constant string too long

# 0: string
compiler.err.limit.string.overflow=\
    UTF8 representation for string \"{0}...\" is too long for the constant pool

compiler.err.malformed.fp.lit=\
    malformed floating-point literal

compiler.err.method.does.not.override.superclass=\
    method does not override or implement a method from a supertype

compiler.err.static.methods.cannot.be.annotated.with.override=\
    static methods cannot be annotated with @Override

compiler.err.missing.meth.body.or.decl.abstract=\
    missing method body, or declare abstract

compiler.err.missing.ret.stmt=\
    missing return statement

# 0: type
compiler.misc.missing.ret.val=\
    missing return value

compiler.misc.unexpected.ret.val=\
    unexpected return value

# 0: set of flag
compiler.err.mod.not.allowed.here=\
    modifier {0} not allowed here

# 0: name
compiler.err.modifier.not.allowed.here=\
    modifier {0} not allowed here

compiler.err.intf.not.allowed.here=\
    interface not allowed here

# 0: symbol, 1: symbol
compiler.err.name.clash.same.erasure=\
    name clash: {0} and {1} have the same erasure

# 0: name, 1: list of type, 2: symbol, 3: name, 4: list of type, 5: symbol
compiler.err.name.clash.same.erasure.no.override=\
    name clash: {0}({1}) in {2} and {3}({4}) in {5} have the same erasure, yet neither overrides the other

# 0: string, 1: name, 2: name, 3: list of type, 4: symbol, 5: name, 6: list of type, 7: symbol
compiler.err.name.clash.same.erasure.no.override.1=\
    name clash: {0} {1} has two methods with the same erasure, yet neither overrides the other\n\
    first method:  {2}({3}) in {4}\n\
    second method: {5}({6}) in {7}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.err.name.clash.same.erasure.no.hide=\
    name clash: {0} in {1} and {2} in {3} have the same erasure, yet neither hides the other

compiler.err.name.reserved.for.internal.use=\
    {0} is reserved for internal use

compiler.err.native.meth.cant.have.body=\
    native methods cannot have a body


# 0: message segment
compiler.misc.incompatible.type.in.conditional=\
    bad type in conditional expression\n\
    {0}

compiler.misc.conditional.target.cant.be.void=\
    target-type for conditional expression cannot be void

compiler.misc.switch.expression.target.cant.be.void=\
    target-type for switch expression cannot be void

# 0: message segment
compiler.misc.incompatible.type.in.switch.expression=\
    bad type in switch expression\n\
    {0}

# 0: message segment
compiler.misc.incompatible.ret.type.in.lambda=\
    bad return type in lambda expression\n\
    {0}

compiler.misc.stat.expr.expected=\
    lambda body is not compatible with a void functional interface\n\
    (consider using a block lambda body, or use a statement expression instead)

# 0: message segment
compiler.misc.incompatible.ret.type.in.mref=\
    bad return type in method reference\n\
    {0}

compiler.err.lambda.body.neither.value.nor.void.compatible=\
    lambda body is neither value nor void compatible

# 0: list of type
compiler.err.incompatible.thrown.types.in.mref=\
    incompatible thrown types {0} in functional expression

compiler.misc.incompatible.arg.types.in.lambda=\
    incompatible parameter types in lambda expression

compiler.misc.incompatible.arg.types.in.mref=\
    incompatible parameter types in method reference

compiler.err.new.not.allowed.in.annotation=\
    ''new'' not allowed in an annotation

# 0: name, 1: type
compiler.err.no.annotation.member=\
    no annotation member {0} in {1}

# 0: symbol
compiler.err.no.encl.instance.of.type.in.scope=\
    no enclosing instance of type {0} is in scope

compiler.err.no.intf.expected.here=\
    no interface expected here

compiler.err.no.match.entry=\
    {0} has no match in entry in {1}; required {2}

# 0: type
compiler.err.not.annotation.type=\
    {0} is not an annotation type

# 0: symbol, 1: symbol, 2: message segment
compiler.err.not.def.access.package.cant.access=\
    {0} is not visible\n\
    ({2})

# 0: symbol, 1: symbol, 2: message segment
compiler.misc.not.def.access.package.cant.access=\
    {0} is not visible\n\
    ({2})

# 0: symbol, 1: message segment
compiler.err.package.not.visible=\
    package {0} is not visible\n\
    ({1})

# 0: symbol, 1: message segment
compiler.misc.package.not.visible=\
    package {0} is not visible\n\
    ({1})

# {0} - current module
# {1} - package in which the invisible class is declared
# {2} - module in which {1} is declared
# 0: symbol, 1: symbol, 2: symbol
compiler.misc.not.def.access.does.not.read=\
    package {1} is declared in module {2}, but module {0} does not read it

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.does.not.read.from.unnamed=\
    package {0} is declared in module {1}, which is not in the module graph

# {0} - package in which the invisible class is declared
# {1} - current module
# 0: symbol, 1: symbol
compiler.misc.not.def.access.does.not.read.unnamed=\
    package {0} is declared in the unnamed module, but module {1} does not read it

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported=\
    package {0} is declared in module {1}, which does not export it

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported.from.unnamed=\
    package {0} is declared in module {1}, which does not export it

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# {2} - current module
# 0: symbol, 1: symbol, 2: symbol
compiler.misc.not.def.access.not.exported.to.module=\
    package {0} is declared in module {1}, which does not export it to module {2}

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported.to.module.from.unnamed=\
    package {0} is declared in module {1}, which does not export it to the unnamed module

# 0: symbol, 1: symbol
compiler.err.not.def.access.class.intf.cant.access=\
    {1}.{0} is defined in an inaccessible class or interface

# 0: symbol, 1: symbol
compiler.misc.not.def.access.class.intf.cant.access=\
    {1}.{0} is defined in an inaccessible class or interface

# 0: symbol, 1: symbol, 2: symbol, 3: message segment
compiler.err.not.def.access.class.intf.cant.access.reason=\
    {1}.{0} in package {2} is not accessible\n\
    ({3})

# 0: symbol, 1: symbol, 2: symbol, 3: message segment
compiler.misc.not.def.access.class.intf.cant.access.reason=\
    {1}.{0} in package {2} is not accessible\n\
    ({3})

# 0: symbol, 1: list of type, 2: type
compiler.misc.cant.access.inner.cls.constr=\
    cannot access constructor {0}({1})\n\
    an enclosing instance of type {2} is not in scope

# 0: symbol, 1: symbol
compiler.err.not.def.public.cant.access=\
    {0} is not public in {1}; cannot be accessed from outside package

# 0: symbol, 1: symbol
compiler.err.not.def.public=\
    {0} is not public in {1}

# 0: symbol, 1: symbol
compiler.misc.not.def.public.cant.access=\
    {0} is not public in {1}; cannot be accessed from outside package

# 0: name
compiler.err.not.loop.label=\
    not a loop label: {0}

compiler.err.not.stmt=\
    not a statement

# 0: symbol
compiler.err.not.encl.class=\
    not an enclosing class: {0}

# 0: name, 1: type
compiler.err.operator.cant.be.applied=\
    bad operand type {1} for unary operator ''{0}''

# 0: name, 1: type, 2: type
compiler.err.operator.cant.be.applied.1=\
    bad operand types for binary operator ''{0}''\n\
    first type:  {1}\n\
    second type: {2}

compiler.err.pkg.annotations.sb.in.package-info.java=\
    package annotations should be in file package-info.java

compiler.err.no.pkg.in.module-info.java=\
    package declarations not allowed in file module-info.java

# 0: symbol
compiler.err.pkg.clashes.with.class.of.same.name=\
    package {0} clashes with class of same name

compiler.err.warnings.and.werror=\
    warnings found and -Werror specified

# Errors related to annotation processing

# 0: symbol, 1: message segment, 2: string (stack-trace)
compiler.err.proc.cant.access=\
    cannot access {0}\n\
    {1}\n\
    Consult the following stack trace for details.\n\
    {2}

# 0: symbol, 1: message segment
compiler.err.proc.cant.access.1=\
    cannot access {0}\n\
    {1}

# 0: string
compiler.err.proc.cant.find.class=\
    Could not find class file for ''{0}''.

# 0: string
compiler.err.proc.cant.load.class=\
    Could not load processor class file due to ''{0}''.

# Print a client-generated error message; assumed to be localized, no translation required
# 0: string
compiler.err.proc.messager=\
    {0}

# 0: string
compiler.misc.exception.message=\
    {0}

compiler.misc.user.selected.completion.failure=\
    user-selected completion failure by class name

# 0: collection of string
compiler.err.proc.no.explicit.annotation.processing.requested=\
    Class names, ''{0}'', are only accepted if annotation processing is explicitly requested

compiler.err.proc.no.service=\
    A ServiceLoader was not usable and is required for annotation processing.

# 0: string, 1: string
compiler.err.proc.processor.bad.option.name=\
    Bad option name ''{0}'' provided by processor ''{1}''

# 0: string
compiler.err.proc.processor.cant.instantiate=\
    Could not instantiate an instance of processor ''{0}''

# 0: string
compiler.err.proc.processor.not.found=\
    Annotation processor ''{0}'' not found

# 0: string
compiler.err.proc.processor.wrong.type=\
    Annotation processor ''{0}'' does not implement javax.annotation.processing.Processor

compiler.err.proc.service.problem=\
    Error creating a service loader to load Processors.

# 0: string
compiler.err.proc.bad.config.file=\
    Bad service configuration file, or exception thrown while constructing Processor object: {0}

compiler.err.proc.cant.create.loader=\
    Could not create class loader for annotation processors: {0}

# 0: symbol
compiler.err.qualified.new.of.static.class=\
    qualified new of static class

compiler.err.recursive.ctor.invocation=\
    recursive constructor invocation

# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
compiler.err.ref.ambiguous=\
    reference to {0} is ambiguous\n\
    both {1} {2} in {3} and {4} {5} in {6} match

# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
compiler.misc.ref.ambiguous=\
    reference to {0} is ambiguous\n\
    both {1} {2} in {3} and {4} {5} in {6} match

compiler.err.repeated.annotation.target=\
    repeated annotation target

compiler.err.repeated.interface=\
    repeated interface

compiler.err.repeated.modifier=\
    repeated modifier

# 0: symbol, 1: set of modifier, 2: symbol
compiler.err.report.access=\
    {0} has {1} access in {2}

# 0: symbol, 1: set of modifier, 2: symbol
compiler.misc.report.access=\
    {0} has {1} access in {2}

compiler.err.ret.outside.meth=\
    return outside method

compiler.err.signature.doesnt.match.supertype=\
    signature does not match {0}; incompatible supertype

compiler.err.signature.doesnt.match.intf=\
    signature does not match {0}; incompatible interfaces

# 0: symbol, 1: symbol, 2: symbol
compiler.err.does.not.override.abstract=\
    {0} is not abstract and does not override abstract method {1} in {2}

# 0: file object
compiler.err.source.cant.overwrite.input.file=\
    error writing source; cannot overwrite input file {0}

# 0: symbol
compiler.err.stack.sim.error=\
    Internal error: stack sim error on {0}

compiler.err.static.imp.only.classes.and.interfaces=\
    static import only from classes and interfaces

compiler.err.string.const.req=\
    constant string expression required

compiler.err.pattern.expected=\
    type pattern expected

# 0: symbol, 1: fragment
compiler.err.cannot.generate.class=\
    error while generating class {0}\n\
    ({1})

# 0: symbol, 1: symbol
compiler.misc.synthetic.name.conflict=\
    the symbol {0} conflicts with a compiler-synthesized symbol in {1}

# 0: symbol, 1: type
compiler.misc.illegal.signature=\
    illegal signature attribute for type {1}

compiler.err.throws.not.allowed.in.intf.annotation=\
    throws clause not allowed in @interface members

compiler.err.try.without.catch.finally.or.resource.decls=\
    ''try'' without ''catch'', ''finally'' or resource declarations

# 0: symbol
compiler.err.type.doesnt.take.params=\
    type {0} does not take parameters

compiler.err.type.var.cant.be.deref=\
    cannot select from a type variable

compiler.err.type.var.may.not.be.followed.by.other.bounds=\
    a type variable may not be followed by other bounds

compiler.err.type.var.more.than.once=\
    type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated

compiler.err.type.var.more.than.once.in.result=\
    type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated

# 0: type, 1: type, 2: fragment
compiler.err.types.incompatible=\
    types {0} and {1} are incompatible;\n\
    {2}

# 0: name, 1: list of type
compiler.misc.incompatible.diff.ret=\
    both define {0}({1}), but with unrelated return types

# 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
compiler.misc.incompatible.unrelated.defaults=\
    {0} {1} inherits unrelated defaults for {2}({3}) from types {4} and {5}

# 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
compiler.misc.incompatible.abstract.default=\
    {0} {1} inherits abstract and default for {2}({3}) from types {4} and {5}

# 0: name, 1: kind name, 2: symbol
compiler.err.default.overrides.object.member=\
    default method {0} in {1} {2} overrides a member of java.lang.Object

# 0: type
compiler.err.illegal.static.intf.meth.call=\
    illegal static interface method call\n\
    the receiver expression should be replaced with the type qualifier ''{0}''

# 0: symbol or type, 1: message segment
compiler.err.illegal.default.super.call=\
    bad type qualifier {0} in default super call\n\
    {1}

# 0: symbol, 1: type
compiler.misc.overridden.default=\
    method {0} is overridden in {1}

# 0: symbol, 1: type or symbol
compiler.misc.redundant.supertype=\
    redundant interface {0} is extended by {1}

compiler.err.unclosed.char.lit=\
    unclosed character literal

compiler.err.unclosed.comment=\
    unclosed comment

compiler.err.unclosed.str.lit=\
    unclosed string literal

compiler.err.unclosed.text.block=\
    unclosed text block

# 0: string
compiler.err.unsupported.encoding=\
    unsupported encoding: {0}

compiler.err.io.exception=\
    error reading source file: {0}

# 0: name
compiler.err.undef.label=\
    undefined label: {0}

# 0: name
compiler.err.illegal.ref.to.restricted.type=\
    illegal reference to restricted type ''{0}''

# 0: name
compiler.warn.illegal.ref.to.restricted.type=\
    illegal reference to restricted type ''{0}''

# 0: name, 1: source
compiler.err.restricted.type.not.allowed=\
    ''{0}'' not allowed here\n\
    as of release {1}, ''{0}'' is a restricted type name and cannot be used for type declarations

# 0: name, 1: source
compiler.warn.restricted.type.not.allowed=\
    as of release {1}, ''{0}'' is a restricted type name and cannot be used for type declarations or as the element type of an array

# 0: name, 1: source
compiler.warn.restricted.type.not.allowed.preview=\
    ''{0}'' may become a restricted type name in a future release and may be unusable for type declarations or as the element type of an array

# 0: name (variable), 1: message segment
compiler.err.cant.infer.local.var.type=\
    cannot infer type for local variable {0}\n\
    ({1})

# 0: name
compiler.err.restricted.type.not.allowed.here=\
    ''{0}'' is not allowed here

# 0: name
compiler.err.restricted.type.not.allowed.array=\
    ''{0}'' is not allowed as an element type of an array

# 0: name
compiler.err.restricted.type.not.allowed.compound=\
    ''{0}'' is not allowed in a compound declaration

# 0: fragment
compiler.err.invalid.lambda.parameter.declaration=\
    invalid lambda parameter declaration\n\
    ({0})

compiler.misc.implicit.and.explicit.not.allowed=\
    cannot mix implicitly-typed and explicitly-typed parameters

compiler.misc.var.and.explicit.not.allowed=\
    cannot mix ''var'' and explicitly-typed parameters

compiler.misc.var.and.implicit.not.allowed=\
    cannot mix ''var'' and implicitly-typed parameters

compiler.misc.local.cant.infer.null=\
    variable initializer is ''null''

compiler.misc.local.cant.infer.void=\
    variable initializer is ''void''

compiler.misc.local.missing.init=\
    cannot use ''var'' on variable without initializer

compiler.misc.local.lambda.missing.target=\
    lambda expression needs an explicit target-type

compiler.misc.local.mref.missing.target=\
    method reference needs an explicit target-type

compiler.misc.local.array.missing.target=\
    array initializer needs an explicit target-type

compiler.misc.local.self.ref=\
    cannot use ''var'' on self-referencing variable

# 0: message segment, 1: unused
compiler.err.cant.apply.diamond=\
    cannot infer type arguments for {0}

# 0: message segment or type, 1: message segment
compiler.err.cant.apply.diamond.1=\
    cannot infer type arguments for {0}\n\
    reason: {1}

# 0: message segment or type, 1: message segment
compiler.misc.cant.apply.diamond.1=\
    cannot infer type arguments for {0}\n\
    reason: {1}

compiler.err.unreachable.stmt=\
    unreachable statement

compiler.err.not.exhaustive=\
    the switch expression does not cover all possible input values

compiler.err.not.exhaustive.statement=\
    the switch statement does not cover all possible input values

compiler.err.initializer.must.be.able.to.complete.normally=\
    initializer must be able to complete normally

compiler.err.initializer.not.allowed=\
    initializers not allowed in interfaces

# 0: type
compiler.err.unreported.exception.need.to.catch.or.throw=\
    unreported exception {0}; must be caught or declared to be thrown

# 0: type
compiler.err.unreported.exception.default.constructor=\
    unreported exception {0} in default constructor

# 0: type, 1: name
compiler.err.unreported.exception.implicit.close=\
    unreported exception {0}; must be caught or declared to be thrown\n\
    exception thrown from implicit call to close() on resource variable ''{1}''

compiler.err.void.not.allowed.here=\
    ''void'' type not allowed here

# 0: string
compiler.err.wrong.number.type.args=\
    wrong number of type arguments; required {0}

# 0: symbol
compiler.err.var.might.already.be.assigned=\
    variable {0} might already have been assigned

# 0: symbol
compiler.err.var.might.not.have.been.initialized=\
    variable {0} might not have been initialized

# 0: symbol
compiler.err.var.not.initialized.in.default.constructor=\
    variable {0} not initialized in the default constructor

# 0: symbol
compiler.err.var.might.be.assigned.in.loop=\
    variable {0} might be assigned in loop

# 0: symbol, 1: message segment
compiler.err.varargs.invalid.trustme.anno=\
    Invalid {0} annotation. {1}

# 0: type
compiler.misc.varargs.trustme.on.reifiable.varargs=\
    Varargs element type {0} is reifiable.

# 0: type, 1: type
compiler.err.instanceof.reifiable.not.safe=\
    {0} cannot be safely cast to {1}

# 0: type, 1: type
compiler.err.instanceof.pattern.no.subtype=\
    expression type {0} is a subtype of pattern type {1}

# 0: symbol
compiler.misc.varargs.trustme.on.non.varargs.meth=\
    Method {0} is not a varargs method.

# 0: symbol
compiler.misc.varargs.trustme.on.non.varargs.accessor=\
    Accessor {0} is not a varargs method.

# 0: symbol
compiler.misc.varargs.trustme.on.virtual.varargs=\
    Instance method {0} is neither final nor private.

# 0: symbol
compiler.misc.varargs.trustme.on.virtual.varargs.final.only=\
    Instance method {0} is not final.

# 0: type, 1: symbol kind, 2: symbol
compiler.misc.inaccessible.varargs.type=\
    formal varargs element type {0} is not accessible from {1} {2}

# In the following string, {1} will always be the detail message from
# java.io.IOException.
# 0: symbol, 1: string
compiler.err.class.cant.write=\
    error while writing {0}: {1}

# In the following string, {0} is the name of the class in the Java source.
# It really should be used two times..
# 0: kind name, 1: name
compiler.err.class.public.should.be.in.file=\
    {0} {1} is public, should be declared in a file named {1}.java

## All errors which do not refer to a particular line in the source code are
## preceded by this string.
compiler.err.error=\
    error:\u0020

# The following error messages do not refer to a line in the source code.
compiler.err.cant.read.file=\
    cannot read: {0}

# 0: string
compiler.err.plugin.not.found=\
    plug-in not found: {0}

# 0: path
compiler.warn.locn.unknown.file.on.module.path=\
    unknown file on module path: {0}


# 0: path
compiler.err.locn.bad.module-info=\
    problem reading module-info.class in {0}

# 0: path
compiler.err.locn.cant.read.directory=\
    cannot read directory {0}

# 0: path
compiler.err.locn.cant.read.file=\
    cannot read file {0}

# 0: path
compiler.err.locn.cant.get.module.name.for.jar=\
    cannot determine module name for {0}

# 0: path
compiler.err.multi-module.outdir.cannot.be.exploded.module=\
    in multi-module mode, the output directory cannot be an exploded module: {0}

# 0: path
compiler.warn.outdir.is.in.exploded.module=\
    the output directory is within an exploded module: {0}

# 0: file object
compiler.err.locn.module-info.not.allowed.on.patch.path=\
    module-info.class not allowed on patch path: {0}

# 0: string
compiler.err.locn.invalid.arg.for.xpatch=\
    invalid argument for --patch-module option: {0}

compiler.err.file.sb.on.source.or.patch.path.for.module=\
    file should be on source path, or on patch path for module

#####

# Fatal Errors

compiler.misc.fatal.err.no.java.lang=\
    Fatal Error: Unable to find package java.lang in classpath or bootclasspath

# 0: name
compiler.misc.fatal.err.cant.locate.meth=\
    Fatal Error: Unable to find method {0}

# 0: name
compiler.misc.fatal.err.cant.locate.field=\
    Fatal Error: Unable to find field {0}

# 0: type
compiler.misc.fatal.err.cant.locate.ctor=\
    Fatal Error: Unable to find constructor for {0}

compiler.misc.fatal.err.cant.close=\
    Fatal Error: Cannot close compiler resources

#####

##
## miscellaneous strings
##

compiler.misc.diamond.anonymous.methods.implicitly.override=\
    (due to <>, every non-private method declared in this anonymous class must override or implement a method from a supertype)

compiler.misc.source.unavailable=\
    (source unavailable)

compiler.misc.base.membership=\
    all your base class are belong to us

# 0: string, 1: string, 2: boolean
compiler.misc.x.print.processor.info=\
    Processor {0} matches {1} and returns {2}.

# 0: number, 1: string, 2: set of symbol, 3: boolean
compiler.misc.x.print.rounds=\
    Round {0}:\n\tinput files: {1}\n\tannotations: {2}\n\tlast round: {3}

# 0: file name
compiler.warn.file.from.future=\
    Modification date is in the future for file {0}

#####

## The following string will appear before all messages keyed as:
## "compiler.note".

compiler.note.compressed.diags=\
    Some messages have been simplified; recompile with -Xdiags:verbose to get full output

# 0: boolean, 1: symbol
compiler.note.lambda.stat=\
    Translating lambda expression\n\
    alternate metafactory = {0}\n\
    synthetic method = {1}

# 0: boolean, 1: unused
compiler.note.mref.stat=\
    Translating method reference\n\
    alternate metafactory = {0}\n\

# 0: boolean, 1: symbol
compiler.note.mref.stat.1=\
    Translating method reference\n\
    alternate metafactory = {0}\n\
    bridge method = {1}

compiler.note.note=\
    Note:\u0020

# 0: file name
compiler.note.deprecated.filename=\
    {0} uses or overrides a deprecated API.

compiler.note.deprecated.plural=\
    Some input files use or override a deprecated API.

# The following string may appear after one of the above deprecation
# messages.
compiler.note.deprecated.recompile=\
    Recompile with -Xlint:deprecation for details.

# 0: file name
compiler.note.deprecated.filename.additional=\
    {0} has additional uses or overrides of a deprecated API.

compiler.note.deprecated.plural.additional=\
    Some input files additionally use or override a deprecated API.

# 0: file name
compiler.note.removal.filename=\
    {0} uses or overrides a deprecated API that is marked for removal.

compiler.note.removal.plural=\
    Some input files use or override a deprecated API that is marked for removal.

# The following string may appear after one of the above removal messages.
compiler.note.removal.recompile=\
    Recompile with -Xlint:removal for details.

# 0: file name
compiler.note.removal.filename.additional=\
    {0} has additional uses or overrides of a deprecated API that is marked for removal.

compiler.note.removal.plural.additional=\
    Some input files additionally use or override a deprecated API that is marked for removal.

# 0: file name
compiler.note.unchecked.filename=\
    {0} uses unchecked or unsafe operations.

compiler.note.unchecked.plural=\
    Some input files use unchecked or unsafe operations.

# The following string may appear after one of the above unchecked messages.
compiler.note.unchecked.recompile=\
    Recompile with -Xlint:unchecked for details.

# 0: file name
compiler.note.unchecked.filename.additional=\
    {0} has additional unchecked or unsafe operations.

compiler.note.unchecked.plural.additional=\
    Some input files additionally use unchecked or unsafe operations.

# 0: file name, 1: source
compiler.note.preview.filename=\
    {0} uses preview features of Java SE {1}.

# 0: source
compiler.note.preview.plural=\
    Some input files use preview features of Java SE {0}.

# The following string may appear after one of the above deprecation
# messages.
compiler.note.preview.recompile=\
    Recompile with -Xlint:preview for details.

# 0: file name, 1: source
compiler.note.preview.filename.additional=\
    {0} has additional uses of preview features of Java SE {1}.

# 0: source
compiler.note.preview.plural.additional=\
    Some input files additionally use preview features of Java SE {0}.

# Notes related to annotation processing

# Print a client-generated note; assumed to be localized, no translation required
# 0: string
compiler.note.proc.messager=\
    {0}

# 0: string, 1: string, 2: string
compiler.note.multiple.elements=\
    Multiple elements named ''{1}'' in modules ''{2}'' were found by javax.lang.model.util.Elements.{0}.

#####

# 0: number
compiler.misc.count.error=\
    {0} error

# 0: number
compiler.misc.count.error.plural=\
    {0} errors

# 0: number, 1: number
compiler.misc.count.error.recompile=\
    only showing the first {0} errors, of {1} total; use -Xmaxerrs if you would like to see more

# 0: number, 1: number
compiler.misc.count.warn.recompile=\
    only showing the first {0} warnings, of {1} total; use -Xmaxwarns if you would like to see more

# 0: number
compiler.misc.count.warn=\
    {0} warning

# 0: number
compiler.misc.count.warn.plural=\
    {0} warnings

compiler.misc.version.not.available=\
    (version info not available)

## extra output when using -verbose (JavaCompiler)

# 0: symbol
compiler.misc.verbose.checking.attribution=\
    [checking {0}]

# 0: string
compiler.misc.verbose.parsing.done=\
    [parsing completed {0}ms]

# 0: file name
compiler.misc.verbose.parsing.started=\
    [parsing started {0}]

# 0: string
compiler.misc.verbose.total=\
    [total {0}ms]

# 0: file name
compiler.misc.verbose.wrote.file=\
    [wrote {0}]

## extra output when using -verbose (code/ClassReader)
# 0: string
compiler.misc.verbose.loading=\
    [loading {0}]

# 0: string
compiler.misc.verbose.sourcepath=\
    [search path for source files: {0}]

# 0: string
compiler.misc.verbose.classpath=\
    [search path for class files: {0}]

## extra output when using -prompt (util/Log)
compiler.misc.resume.abort=\
    R)esume, A)bort>

#####

##
## warnings
##

## All warning messages are preceded by the following string.
compiler.warn.warning=\
    warning:\u0020

## Warning messages may also include the following prefix to identify a
## lint option
# 0: option name
compiler.warn.lintOption=\
    [{0}]\u0020

# 0: symbol
compiler.warn.constant.SVUID=\
    serialVersionUID must be constant in class {0}

# 0: path
compiler.warn.dir.path.element.not.found=\
    bad path element "{0}": no such directory

# 0: file name
compiler.warn.dir.path.element.not.directory=\
    bad path element "{0}": not a directory

# 0: symbol, 1: symbol, 2: symbol
compiler.warn.missing-explicit-ctor=\
    class {0} in exported package {1} declares no explicit constructors, thereby exposing a default constructor to clients of module {2}

compiler.warn.strictfp=\
    as of release 17, all floating-point expressions are evaluated strictly and ''strictfp'' is not required

compiler.warn.finally.cannot.complete=\
    finally clause cannot complete normally

# 0: name
compiler.warn.poor.choice.for.module.name=\
    module name component {0} should avoid terminal digits

# 0: string
compiler.warn.incubating.modules=\
    using incubating module(s): {0}

# 0: symbol, 1: symbol
compiler.warn.has.been.deprecated=\
    {0} in {1} has been deprecated

# 0: symbol, 1: symbol
compiler.warn.has.been.deprecated.for.removal=\
    {0} in {1} has been deprecated and marked for removal

# 0: symbol
compiler.warn.is.preview=\
    {0} is a preview API and may be removed in a future release.

# 0: symbol
compiler.err.is.preview=\
    {0} is a preview API and is disabled by default.\n\
    (use --enable-preview to enable preview APIs)

# 0: symbol
compiler.warn.is.preview.reflective=\
    {0} is a reflective preview API and may be removed in a future release.

# 0: symbol
compiler.warn.has.been.deprecated.module=\
    module {0} has been deprecated

# 0: symbol
compiler.warn.has.been.deprecated.for.removal.module=\
    module {0} has been deprecated and marked for removal

# 0: symbol
compiler.warn.sun.proprietary=\
    {0} is internal proprietary API and may be removed in a future release

compiler.warn.illegal.char.for.encoding=\
    unmappable character for encoding {0}

# 0: symbol
compiler.warn.improper.SVUID=\
    serialVersionUID must be declared static final in class {0}

# 0: type, 1: type
compiler.warn.inexact.non-varargs.call=\
    non-varargs call of varargs method with inexact argument type for last parameter;\n\
    cast to {0} for a varargs call\n\
    cast to {1} for a non-varargs call and to suppress this warning

# 0: list of type
compiler.warn.unreachable.catch=\
    unreachable catch clause\n\
    thrown type {0} has already been caught

# 0: list of type
compiler.warn.unreachable.catch.1=\
    unreachable catch clause\n\
    thrown types {0} have already been caught

# 0: symbol
compiler.warn.long.SVUID=\
    serialVersionUID must be of type long in class {0}

# 0: symbol
compiler.warn.missing.SVUID=\
    serializable class {0} has no definition of serialVersionUID

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.warn.potentially.ambiguous.overload=\
    {0} in {1} is potentially ambiguous with {2} in {3}

# 0: message segment
compiler.warn.override.varargs.missing=\
    {0}; overridden method has no ''...''

# 0: message segment
compiler.warn.override.varargs.extra=\
    {0}; overriding method is missing ''...''

# 0: message segment
compiler.warn.override.bridge=\
    {0}; overridden method is a bridge method

# 0: symbol
compiler.warn.pkg-info.already.seen=\
    a package-info.java file has already been seen for package {0}

# 0: path
compiler.warn.path.element.not.found=\
    bad path element "{0}": no such file or directory

compiler.warn.possible.fall-through.into.case=\
    possible fall-through into case

# 0: type
compiler.warn.redundant.cast=\
    redundant cast to {0}

# 0: number
compiler.warn.position.overflow=\
    Position encoding overflows at line {0}

# 0: file name, 1: number, 2: number
compiler.warn.big.major.version=\
    {0}: major version {1} is newer than {2}, the highest major version supported by this compiler.\n\
    It is recommended that the compiler be upgraded.

# 0: kind name, 1: symbol
compiler.warn.static.not.qualified.by.type=\
    static {0} should be qualified by type name, {1}, instead of by an expression

# 0: string
compiler.warn.source.no.bootclasspath=\
    bootstrap class path not set in conjunction with -source {0}

# 0: string
compiler.warn.source.no.system.modules.path=\
    system modules path not set in conjunction with -source {0}

# 0: string
compiler.warn.option.obsolete.source=\
    source value {0} is obsolete and will be removed in a future release

# 0: target
compiler.warn.option.obsolete.target=\
    target value {0} is obsolete and will be removed in a future release

# 0: string, 1: string
compiler.err.option.removed.source=\
    Source option {0} is no longer supported. Use {1} or later.

# 0: target, 1: target
compiler.err.option.removed.target=\
    Target option {0} is no longer supported. Use {1} or later.


# 0: target, 1: target
compiler.warn.option.parameters.unsupported=\
    -parameters is not supported for target value {0}. Use {1} or later.

compiler.warn.option.obsolete.suppression=\
    To suppress warnings about obsolete options, use -Xlint:-options.

# 0: name, 1: number, 2: number, 3: number, 4: number
compiler.warn.future.attr=\
    {0} attribute introduced in version {1}.{2} class files is ignored in version {3}.{4} class files

compiler.warn.requires.automatic=\
    requires directive for an automatic module

compiler.warn.requires.transitive.automatic=\
    requires transitive directive for an automatic module

# Warnings related to annotation processing
# 0: string
compiler.warn.proc.package.does.not.exist=\
    package {0} does not exist

# 0: string
compiler.warn.proc.file.reopening=\
    Attempt to create a file for ''{0}'' multiple times

# 0: string
compiler.warn.proc.type.already.exists=\
    A file for type ''{0}'' already exists on the sourcepath or classpath

# 0: string
compiler.warn.proc.type.recreate=\
    Attempt to create a file for type ''{0}'' multiple times

# 0: string
compiler.warn.proc.illegal.file.name=\
    Cannot create file for illegal name ''{0}''.

# 0: string, 1: string
compiler.warn.proc.suspicious.class.name=\
    Creating file for a type whose name ends in {1}: ''{0}''

# 0: string
compiler.warn.proc.file.create.last.round=\
    File for type ''{0}'' created in the last round will not be subject to annotation processing.

# 0: string, 1: string
compiler.warn.proc.malformed.supported.string=\
    Malformed string ''{0}'' for a supported annotation type returned by processor ''{1}''

# 0: set of string
compiler.warn.proc.annotations.without.processors=\
    No processor claimed any of these annotations: {0}

# 0: source version, 1: string, 2: string
compiler.warn.proc.processor.incompatible.source.version=\
    Supported source version ''{0}'' from annotation processor ''{1}'' less than -source ''{2}''

# 0: string, 1: string
compiler.warn.proc.duplicate.option.name=\
    Duplicate supported option ''{0}'' returned by annotation processor ''{1}''

# 0: string, 1: string
compiler.warn.proc.duplicate.supported.annotation=\
    Duplicate supported annotation type ''{0}'' returned by annotation processor ''{1}''

# 0: string
compiler.warn.proc.redundant.types.with.wildcard=\
    Annotation processor ''{0}'' redundantly supports both ''*'' and other annotation types

compiler.warn.proc.proc-only.requested.no.procs=\
    Annotation processing without compilation requested but no processors were found.

compiler.warn.proc.use.implicit=\
    Implicitly compiled files were not subject to annotation processing.\n\
    Use -implicit to specify a policy for implicit compilation.

compiler.warn.proc.use.proc.or.implicit=\
    Implicitly compiled files were not subject to annotation processing.\n\
    Use -proc:none to disable annotation processing or -implicit to specify a policy for implicit compilation.

# Print a client-generated warning; assumed to be localized, no translation required
# 0: string
compiler.warn.proc.messager=\
    {0}

# 0: set of string
compiler.warn.proc.unclosed.type.files=\
    Unclosed files for the types ''{0}''; these types will not undergo annotation processing

# 0: string
compiler.warn.proc.unmatched.processor.options=\
    The following options were not recognized by any processor: ''{0}''

compiler.warn.try.explicit.close.call=\
    explicit call to close() on an auto-closeable resource

# 0: symbol
compiler.warn.try.resource.not.referenced=\
    auto-closeable resource {0} is never referenced in body of corresponding try statement

# 0: type
compiler.warn.try.resource.throws.interrupted.exc=\
    auto-closeable resource {0} has a member method close() that could throw InterruptedException

compiler.warn.unchecked.assign=\
    unchecked assignment: {0} to {1}

# 0: symbol, 1: type
compiler.warn.unchecked.assign.to.var=\
    unchecked assignment to variable {0} as member of raw type {1}

# 0: symbol, 1: type
compiler.warn.unchecked.call.mbr.of.raw.type=\
    unchecked call to {0} as a member of the raw type {1}

compiler.warn.unchecked.cast.to.type=\
    unchecked cast to type {0}

# 0: kind name, 1: name, 2: object, 3: object, 4: kind name, 5: symbol
compiler.warn.unchecked.meth.invocation.applied=\
    unchecked method invocation: {0} {1} in {4} {5} is applied to given types\n\
    required: {2}\n\
    found:    {3}

# 0: type
compiler.warn.unchecked.generic.array.creation=\
    unchecked generic array creation for varargs parameter of type {0}

# 0: type
compiler.warn.unchecked.varargs.non.reifiable.type=\
    Possible heap pollution from parameterized vararg type {0}

# 0: symbol
compiler.warn.varargs.unsafe.use.varargs.param=\
    Varargs method could cause heap pollution from non-reifiable varargs parameter {0}

compiler.warn.missing.deprecated.annotation=\
    deprecated item is not annotated with @Deprecated

# 0: kind name
compiler.warn.deprecated.annotation.has.no.effect=\
    @Deprecated annotation has no effect on this {0} declaration

# 0: string
compiler.warn.invalid.path=\
    Invalid filename: {0}

compiler.warn.doclint.not.available=\
    No service provider for doclint is available

# 0: string
compiler.err.invalid.path=\
    Invalid filename: {0}


# 0: path
compiler.warn.invalid.archive.file=\
    Unexpected file on path: {0}

# 0: path
compiler.warn.unexpected.archive.file=\
    Unexpected extension for archive file: {0}

# 0: path
compiler.err.no.zipfs.for.archive=\
    No file system provider is available to handle this file: {0}

compiler.warn.div.zero=\
    division by zero

compiler.warn.empty.if=\
    empty statement after if

# 0: type, 1: name
compiler.warn.annotation.method.not.found=\
    Cannot find annotation method ''{1}()'' in type ''{0}''

# 0: type, 1: name, 2: message segment
compiler.warn.annotation.method.not.found.reason=\
    Cannot find annotation method ''{1}()'' in type ''{0}'': {2}

# 0: file object, 1: symbol, 2: name
compiler.warn.unknown.enum.constant=\
    unknown enum constant {1}.{2}

# 0: file object, 1: symbol, 2: name, 3: message segment
compiler.warn.unknown.enum.constant.reason=\
    unknown enum constant {1}.{2}\n\
    reason: {3}

# 0: type, 1: type
compiler.warn.raw.class.use=\
    found raw type: {0}\n\
    missing type arguments for generic class {1}

compiler.warn.diamond.redundant.args=\
    Redundant type arguments in new expression (use diamond operator instead).

compiler.warn.local.redundant.type=\
    Redundant type for local variable (replace explicit type with ''var'').

compiler.warn.potential.lambda.found=\
    This anonymous inner class creation can be turned into a lambda expression.

compiler.warn.method.redundant.typeargs=\
    Redundant type arguments in method call.

# 0: symbol, 1: message segment
compiler.warn.varargs.redundant.trustme.anno=\
    Redundant {0} annotation. {1}

# 0: symbol
compiler.warn.access.to.member.from.serializable.element=\
    access to member {0} from serializable element can be publicly accessible to untrusted code

# 0: symbol
compiler.warn.access.to.member.from.serializable.lambda=\
    access to member {0} from serializable lambda can be publicly accessible to untrusted code

#####

## The following are tokens which are non-terminals in the language. They should
## be named as JLS3 calls them when translated to the appropriate language.
compiler.misc.token.identifier=\
    <identifier>

compiler.misc.token.character=\
    <character>

compiler.misc.token.string=\
    <string>

compiler.misc.token.integer=\
    <integer>

compiler.misc.token.long-integer=\
    <long integer>

compiler.misc.token.float=\
    <float>

compiler.misc.token.double=\
    <double>

compiler.misc.token.bad-symbol=\
    <bad symbol>

compiler.misc.token.end-of-input=\
    <end of input>

## The argument to the following string will always be one of the following:
## 1. one of the above non-terminals
## 2. a keyword (JLS1.8)
## 3. a boolean literal (JLS3.10.3)
## 4. the null literal (JLS3.10.7)
## 5. a Java separator (JLS3.11)
## 6. an operator (JLS3.12)
##
## This is the only place these tokens will be used.
# 0: token
compiler.err.expected=\
    {0} expected

# 0: string
compiler.err.expected.str=\
    {0} expected

# 0: token, 1: token
compiler.err.expected2=\
    {0} or {1} expected

# 0: token, 1: token, 2: token
compiler.err.expected3=\
    {0}, {1}, or {2} expected

# 0: token, 1: token, 2: token, 3: string
compiler.err.expected4=\
    {0}, {1}, {2}, or {3} expected

compiler.err.premature.eof=\
    reached end of file while parsing

compiler.err.enum.constant.expected=\
    enum constant expected here

compiler.err.enum.constant.not.expected=\
    enum constant not expected here

## The following are related in form, but do not easily fit the above paradigm.
compiler.err.expected.module.or.open=\
    ''module'' or ''open'' expected

compiler.err.dot.class.expected=\
    ''.class'' expected

## The argument to this string will always be either 'case' or 'default'.
# 0: token
compiler.err.orphaned=\
    orphaned {0}

# 0: name
compiler.misc.anonymous.class=\
    <anonymous {0}>

# 0: name, 1: type
compiler.misc.type.captureof=\
    capture#{0} of {1}

compiler.misc.type.captureof.1=\
    capture#{0}

compiler.misc.type.none=\
    <none>

compiler.misc.unnamed.package=\
    unnamed package

compiler.misc.unnamed.module=\
    unnamed module

#####

# 0: symbol, 1: message segment
compiler.err.cant.access=\
    cannot access {0}\n\
    {1}

# 0: name
compiler.misc.bad.class.file=\
    class file is invalid for class {0}

# 0: file name, 1: string (expected constant pool entry type), 2: number (constant pool index)
compiler.misc.bad.const.pool.entry=\
    bad constant pool entry in {0}\n\
    expected {1} at index {2}

# 0: file name, 1: number (constant pool index), 2: number (constant pool size)
compiler.misc.bad.const.pool.index=\
    bad constant pool index in {0}\n\
    index {1} is not within pool size {2}.

# 0: file name, 1: message segment
compiler.misc.bad.class.file.header=\
    bad class file: {0}\n\
    {1}\n\
    Please remove or make sure it appears in the correct subdirectory of the classpath.

# 0: file name, 1: message segment
compiler.misc.bad.source.file.header=\
    bad source file: {0}\n\
    {1}\n\
    Please remove or make sure it appears in the correct subdirectory of the sourcepath.

## The following are all possible strings for the second argument ({1}) of the
## above strings.
compiler.misc.bad.class.signature=\
    bad class signature: {0}

#0: symbol, 1: symbol
compiler.misc.bad.enclosing.class=\
    bad enclosing class for {0}: {1}

# 0: symbol
compiler.misc.bad.enclosing.method=\
    bad enclosing method attribute for class {0}

compiler.misc.bad.runtime.invisible.param.annotations=\
    bad RuntimeInvisibleParameterAnnotations attribute: {0}

compiler.misc.bad.const.pool.tag=\
    bad constant pool tag: {0}

compiler.misc.bad.const.pool.tag.at=\
    bad constant pool tag: {0} at {1}

compiler.misc.unexpected.const.pool.tag.at=\
    unexpected constant pool tag: {0} at {1}

compiler.misc.bad.signature=\
    bad signature: {0}

compiler.misc.bad.type.annotation.value=\
    bad type annotation target type value: {0}

compiler.misc.bad.module-info.name=\
    bad class name

compiler.misc.class.file.wrong.class=\
    class file contains wrong class: {0}

compiler.misc.module.info.invalid.super.class=\
    module-info with invalid super class

# 0: name
compiler.misc.class.file.not.found=\
    class file for {0} not found

# 0: string (constant value), 1: symbol (constant field), 2: type (field type)
compiler.misc.bad.constant.range=\
    constant value ''{0}'' for {1} is outside the expected range for {2}

# 0: string (constant value), 1: symbol (constant field), 2: string (expected class)
compiler.misc.bad.constant.value=\
    bad constant value ''{0}'' for {1}, expected {2}

# 0: type (field type)
compiler.misc.bad.constant.value.type=\
    variable of type ''{0}'' cannot have a constant value, but has one specified

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.invalid.default.interface=\
    default method found in version {0}.{1} classfile

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.invalid.static.interface=\
    static method found in version {0}.{1} classfile

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.anachronistic.module.info=\
    module declaration found in version {0}.{1} classfile

compiler.misc.module.info.definition.expected=\
    module-info definition expected

# 0: name
compiler.misc.file.doesnt.contain.class=\
    file does not contain class {0}

# 0: symbol
compiler.misc.file.does.not.contain.package=\
    file does not contain package {0}

compiler.misc.file.does.not.contain.module=\
    file does not contain module declaration

compiler.misc.illegal.start.of.class.file=\
    illegal start of class file

# 0: name
compiler.misc.method.descriptor.invalid=\
    method descriptor invalid for {0}

compiler.misc.unable.to.access.file=\
    unable to access file: {0}

compiler.misc.unicode.str.not.supported=\
    unicode string in class file not supported

compiler.misc.undecl.type.var=\
    undeclared type variable: {0}

compiler.misc.malformed.vararg.method=\
    class file contains malformed variable arity method: {0}

compiler.misc.wrong.version=\
    class file has wrong version {0}.{1}, should be {2}.{3}

#####

# 0: type, 1: type or symbol
compiler.err.not.within.bounds=\
    type argument {0} is not within bounds of type-variable {1}

## The following are all possible strings for the second argument ({1}) of the
## above string.

## none yet...

#####

# 0: message segment
compiler.err.prob.found.req=\
    incompatible types: {0}

# 0: message segment
compiler.misc.prob.found.req=\
    incompatible types: {0}

# 0: message segment, 1: type, 2: type
compiler.warn.prob.found.req=\
    {0}\n\
    required: {2}\n\
    found:    {1}

# 0: type, 1: type
compiler.misc.inconvertible.types=\
    {0} cannot be converted to {1}

# 0: type, 1: type
compiler.misc.possible.loss.of.precision=\
    possible lossy conversion from {0} to {1}

compiler.misc.unchecked.assign=\
    unchecked conversion

# compiler.misc.storecheck=\
#     assignment might cause later store checks to fail
# compiler.misc.unchecked=\
#     assigned array cannot dynamically check its stores
compiler.misc.unchecked.cast.to.type=\
    unchecked cast

# compiler.err.star.expected=\
#     ''*'' expected
# compiler.err.no.elem.type=\
#     \[\*\] cannot have a type

# 0: message segment
compiler.misc.try.not.applicable.to.type=\
    try-with-resources not applicable to variable type\n\
    ({0})

#####

# 0: object, 1: message segment
compiler.err.type.found.req=\
    unexpected type\n\
    required: {1}\n\
    found:    {0}

## The following are all possible strings for the first argument ({0}) of the
## above string.
compiler.misc.type.req.class=\
    class

compiler.misc.type.req.class.array=\
    class or array

compiler.misc.type.req.array.or.iterable=\
    array or java.lang.Iterable

compiler.misc.type.req.ref=\
    reference

compiler.misc.type.req.exact=\
    class or interface without bounds

# 0: type
compiler.misc.type.parameter=\
    type parameter {0}

#####

## The following are all possible strings for the last argument of all those
## diagnostics whose key ends in ".1"

# 0: type, 1: list of type
compiler.misc.no.unique.maximal.instance.exists=\
    no unique maximal instance exists for type variable {0} with upper bounds {1}

# 0: type, 1: list of type
compiler.misc.no.unique.minimal.instance.exists=\
    no unique minimal instance exists for type variable {0} with lower bounds {1}

# 0: type, 1: list of type
compiler.misc.incompatible.upper.bounds=\
    inference variable {0} has incompatible upper bounds {1}

# 0: type, 1: list of type
compiler.misc.incompatible.eq.bounds=\
    inference variable {0} has incompatible equality constraints {1}

# 0: type, 1: fragment, 2: fragment
compiler.misc.incompatible.bounds=\
    inference variable {0} has incompatible bounds\n\
    {1}\n\
    {2}

# 0: list of type
compiler.misc.lower.bounds=\
        lower bounds: {0}

# 0: list of type
compiler.misc.eq.bounds=\
        equality constraints: {0}

# 0: list of type
compiler.misc.upper.bounds=\
        lower bounds: {0}

# 0: list of type, 1: type, 2: type
compiler.misc.infer.no.conforming.instance.exists=\
    no instance(s) of type variable(s) {0} exist so that {1} conforms to {2}

# 0: list of type, 1: message segment
compiler.misc.infer.no.conforming.assignment.exists=\
    cannot infer type-variable(s) {0}\n\
    (argument mismatch; {1})

# 0: list of type
compiler.misc.infer.arg.length.mismatch=\
    cannot infer type-variable(s) {0}\n\
    (actual and formal argument lists differ in length)

# 0: list of type, 1: message segment
compiler.misc.infer.varargs.argument.mismatch=\
    cannot infer type-variable(s) {0}\n\
    (varargs mismatch; {1})

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.upper.bounds=\
    inferred type does not conform to upper bound(s)\n\
    inferred: {0}\n\
    upper bound(s): {1}

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.lower.bounds=\
    inferred type does not conform to lower bound(s)\n\
    inferred: {0}\n\
    lower bound(s): {1}

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.eq.bounds=\
    inferred type does not conform to equality constraint(s)\n\
    inferred: {0}\n\
    equality constraints(s): {1}

# 0: symbol
compiler.misc.diamond=\
    {0}<>

# 0: type
compiler.misc.diamond.non.generic=\
    cannot use ''<>'' with non-generic class {0}

# 0: list of type, 1: message segment
compiler.misc.diamond.invalid.arg=\
    type argument {0} inferred for {1} is not allowed in this context\n\
    inferred argument is not expressible in the Signature attribute

# 0: list of type, 1: message segment
compiler.misc.diamond.invalid.args=\
    type arguments {0} inferred for {1} are not allowed in this context\n\
    inferred arguments are not expressible in the Signature attribute

# 0: type
compiler.misc.diamond.and.explicit.params=\
    cannot use ''<>'' with explicit type parameters for constructor

compiler.misc.mref.infer.and.explicit.params=\
    cannot use raw constructor reference with explicit type parameters for constructor

# 0: type, 1: list of type
compiler.misc.explicit.param.do.not.conform.to.bounds=\
    explicit type argument {0} does not conform to declared bound(s) {1}

compiler.misc.arg.length.mismatch=\
    actual and formal argument lists differ in length

# 0: string
compiler.misc.wrong.number.type.args=\
    wrong number of type arguments; required {0}

# 0: message segment
compiler.misc.no.conforming.assignment.exists=\
    argument mismatch; {0}

# 0: message segment
compiler.misc.varargs.argument.mismatch=\
    varargs mismatch; {0}

#####

# 0: symbol or type, 1: file name
compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file=\
    auxiliary class {0} in {1} should not be accessed from outside its own source file

## The first argument ({0}) is a "kindname".
# 0: kind name, 1: symbol, 2: symbol
compiler.err.abstract.cant.be.accessed.directly=\
    abstract {0} {1} in {2} cannot be accessed directly

## The first argument ({0}) is a "kindname".
# 0: symbol kind, 1: symbol
compiler.err.non-static.cant.be.ref=\
    non-static {0} {1} cannot be referenced from a static context

# 0: symbol kind, 1: symbol
compiler.misc.bad.static.method.in.unbound.lookup=\
    unexpected static {0} {1} found in unbound lookup

# 0: symbol kind, 1: symbol
compiler.misc.bad.instance.method.in.unbound.lookup=\
    unexpected instance {0} {1} found in unbound lookup

# 0: symbol kind, 1: symbol
compiler.misc.bad.static.method.in.bound.lookup=\
    unexpected static {0} {1} found in bound lookup

## Both arguments ({0}, {1}) are "kindname"s.  {0} is a comma-separated list
## of kindnames (the list should be identical to that provided in source.
# 0: set of kind name, 1: set of kind name
compiler.err.unexpected.type=\
    unexpected type\n\
    required: {0}\n\
    found:    {1}

compiler.err.unexpected.lambda=\
   lambda expression not expected here

compiler.err.unexpected.mref=\
   method reference not expected here

## The first argument {0} is a "kindname" (e.g. 'constructor', 'field', etc.)
## The second argument {1} is the non-resolved symbol
## The third argument {2} is a list of type parameters (non-empty if {1} is a method)
## The fourth argument {3} is a list of argument types (non-empty if {1} is a method)
# 0: kind name, 1: name, 2: unused, 3: unused
compiler.err.cant.resolve=\
    cannot find symbol\n\
    symbol: {0} {1}

# 0: kind name, 1: name, 2: unused, 3: list of type
compiler.err.cant.resolve.args=\
    cannot find symbol\n\
    symbol: {0} {1}({3})

# 0: kind name, 1: name, 2: unused, 3: list of type
compiler.misc.cant.resolve.args=\
    cannot find symbol\n\
    symbol: {0} {1}({3})

# 0: kind name, 1: name, 2: list of type, 3: list of type
compiler.err.cant.resolve.args.params=\
    cannot find symbol\n\
    symbol: {0} <{2}>{1}({3})

## arguments from {0} to {3} have the same meaning as above
## The fifth argument {4} is a location subdiagnostic (see below)
# 0: kind name, 1: name, 2: unused, 3: unused, 4: message segment
compiler.err.cant.resolve.location=\
    cannot find symbol\n\
    symbol:   {0} {1}\n\
    location: {4}

# 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
compiler.err.cant.resolve.location.args=\
    cannot find symbol\n\
    symbol:   {0} {1}({3})\n\
    location: {4}

# 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
compiler.err.cant.resolve.location.args.params=\
    cannot find symbol\n\
    symbol:   {0} <{2}>{1}({3})\n\
    location: {4}

### Following are replicated/used for method reference diagnostics

# 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
compiler.misc.cant.resolve.location.args=\
    cannot find symbol\n\
    symbol:   {0} {1}({3})\n\
    location: {4}

# 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
compiler.misc.cant.resolve.location.args.params=\
    cannot find symbol\n\
    symbol:   {0} <{2}>{1}({3})\n\
    location: {4}

##a location subdiagnostic is composed as follows:
## The first argument {0} is the location "kindname" (e.g. 'constructor', 'field', etc.)
## The second argument {1} is the location name
## The third argument {2} is the location type (only when {1} is a variable name)

# 0: kind name, 1: type or symbol, 2: unused
compiler.misc.location=\
    {0} {1}

# 0: kind name, 1: symbol, 2: type
compiler.misc.location.1=\
    {0} {1} of type {2}

## The following are all possible string for "kindname".
## They should be called whatever the JLS calls them after it been translated
## to the appropriate language.
# compiler.misc.kindname.constructor=\
#     static member
compiler.misc.kindname.annotation=\
    @interface

compiler.misc.kindname.constructor=\
    constructor

compiler.misc.kindname.enum=\
    enum

compiler.misc.kindname.interface=\
    interface

compiler.misc.kindname.static=\
    static

compiler.misc.kindname.type.variable=\
    type variable

compiler.misc.kindname.type.variable.bound=\
    bound of type variable

compiler.misc.kindname.variable=\
    variable

compiler.misc.kindname.value=\
    value

compiler.misc.kindname.method=\
    method

compiler.misc.kindname.class=\
    class

compiler.misc.kindname.package=\
    package

compiler.misc.kindname.module=\
    module

compiler.misc.kindname.static.init=\
    static initializer

compiler.misc.kindname.instance.init=\
    instance initializer

compiler.misc.kindname.record.component=\
    record component

compiler.misc.kindname.record=\
    record

#####

compiler.misc.no.args=\
    no arguments

# 0: message segment
compiler.err.override.static=\
    {0}\n\
    overriding method is static

# 0: message segment, 1: set of flag
compiler.err.override.meth=\
    {0}\n\
    overridden method is {1}

# 0: message segment, 1: type
compiler.err.override.meth.doesnt.throw=\
    {0}\n\
    overridden method does not throw {1}

# In the following string {1} is a space separated list of Java Keywords, as
# they would have been declared in the source code
# 0: message segment, 1: set of flag or string
compiler.err.override.weaker.access=\
    {0}\n\
    attempting to assign weaker access privileges; was {1}

# 0: message segment, 1: type, 2: type
compiler.err.override.incompatible.ret=\
    {0}\n\
    return type {1} is not compatible with {2}

# 0: message segment, 1: type, 2: type
compiler.warn.override.unchecked.ret=\
    {0}\n\
    return type requires unchecked conversion from {1} to {2}

# 0: message segment, 1: type
compiler.warn.override.unchecked.thrown=\
    {0}\n\
    overridden method does not throw {1}

# 0: symbol
compiler.warn.override.equals.but.not.hashcode=\
    Class {0} overrides equals, but neither it nor any superclass overrides hashCode method

## The following are all possible strings for the first argument ({0}) of the
## above strings.
# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.override=\
    {0} in {1} cannot override {2} in {3}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.hide=\
    {0} in {1} cannot hide {2} in {3}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.implement=\
    {0} in {1} cannot implement {2} in {3}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.clashes.with=\
    {0} in {1} clashes with {2} in {3}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.override=\
    {0} in {1} overrides {2} in {3}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.implement=\
    {0} in {1} implements {2} in {3}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.clash.with=\
    {0} in {1} overrides {2} in {3}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.override=\
    {0} in {1} overrides {2} in {3}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.implement=\
    {0} in {1} implements {2} in {3}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.clash.with=\
    {0} in {1} overrides {2} in {3}

# 0: kind name, 1: symbol, 2: symbol, 3: message segment
compiler.misc.inapplicable.method=\
    {0} {1}.{2} is not applicable\n\
    ({3})

########################################
# Diagnostics for language feature changes.
# Such diagnostics have a common template which can be customized by using a feature
# diagnostic fragment (one of those given below).
########################################

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.err.feature.not.supported.in.source=\
   {0} is not supported in -source {1}\n\
    (use -source {2} or higher to enable {0})

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.err.feature.not.supported.in.source.plural=\
   {0} are not supported in -source {1}\n\
    (use -source {2} or higher to enable {0})

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.misc.feature.not.supported.in.source=\
   {0} is not supported in -source {1}\n\
    (use -source {2} or higher to enable {0})

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.misc.feature.not.supported.in.source.plural=\
   {0} are not supported in -source {1}\n\
    (use -source {2} or higher to enable {0})

# 0: message segment (feature)
compiler.err.preview.feature.disabled=\
   {0} is a preview feature and is disabled by default.\n\
   (use --enable-preview to enable {0})

# 0: message segment (feature)
compiler.err.preview.feature.disabled.plural=\
   {0} are a preview feature and are disabled by default.\n\
   (use --enable-preview to enable {0})

# 0: file object (classfile), 1: string (expected version)
compiler.err.preview.feature.disabled.classfile=\
   class file for {0} uses preview features of Java SE {1}.\n\
   (use --enable-preview to allow loading of class files which contain preview features)

# 0: message segment (feature)
compiler.warn.preview.feature.use=\
   {0} is a preview feature and may be removed in a future release.

# 0: message segment (feature)
compiler.warn.preview.feature.use.plural=\
   {0} are a preview feature and may be removed in a future release.

# 0: file object (classfile), 1: string (expected version)
compiler.warn.preview.feature.use.classfile=\
   class file for {0} uses preview features of Java SE {1}.


compiler.misc.feature.modules=\
    modules

compiler.misc.feature.diamond.and.anon.class=\
    ''<>'' with anonymous inner classes

compiler.misc.feature.var.in.try.with.resources=\
    variables in try-with-resources

compiler.misc.feature.type.annotations=\
    type annotations

compiler.misc.feature.annotations.after.type.params=\
    annotations after method type parameters

compiler.misc.feature.repeatable.annotations=\
    repeated annotations

compiler.misc.feature.diamond=\
    diamond operator

compiler.misc.feature.lambda=\
    lambda expressions

compiler.misc.feature.method.references=\
    method references

compiler.misc.feature.default.methods=\
    default methods

compiler.misc.feature.intersection.types.in.cast=\
    intersection types

compiler.misc.feature.static.intf.methods=\
    static interface methods

compiler.misc.feature.static.intf.method.invoke=\
    static interface method invocations

compiler.misc.feature.private.intf.methods=\
    private interface methods

compiler.misc.feature.text.blocks=\
    text blocks

compiler.misc.feature.multiple.case.labels=\
    multiple case labels

compiler.misc.feature.switch.rules=\
    switch rules

compiler.misc.feature.switch.expressions=\
    switch expressions

compiler.misc.feature.var.syntax.in.implicit.lambda=\
    var syntax in implicit lambdas

compiler.misc.feature.pattern.matching.instanceof=\
    pattern matching in instanceof

compiler.misc.feature.reifiable.types.instanceof=\
    reifiable types in instanceof

compiler.misc.feature.records=\
    records

compiler.misc.feature.sealed.classes=\
    sealed classes

compiler.misc.feature.case.null=\
    null in switch cases

compiler.misc.feature.pattern.switch=\
    patterns in switch statements

compiler.warn.underscore.as.identifier=\
    as of release 9, ''_'' is a keyword, and may not be used as an identifier

compiler.err.underscore.as.identifier=\
    as of release 9, ''_'' is a keyword, and may not be used as an identifier

compiler.err.underscore.as.identifier.in.lambda=\
    ''_'' used as an identifier\n\
    (use of ''_'' as an identifier is forbidden for lambda parameters)

compiler.err.enum.as.identifier=\
    as of release 5, ''enum'' is a keyword, and may not be used as an identifier

compiler.err.assert.as.identifier=\
    as of release 1.4, ''assert'' is a keyword, and may not be used as an identifier

# TODO 308: make a better error message
compiler.err.this.as.identifier=\
    as of release 8, ''this'' is allowed as the parameter name for the receiver type only\n\
    which has to be the first parameter, and cannot be a lambda parameter

compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class=\
    receiver parameter not applicable for constructor of top-level class

# TODO 308: make a better error message
# 0: annotation
compiler.err.cant.type.annotate.scoping.1=\
    scoping construct cannot be annotated with type-use annotation: {0}

# TODO 308: make a better error message
# 0: list of annotation
compiler.err.cant.type.annotate.scoping=\
    scoping construct cannot be annotated with type-use annotations: {0}

# 0: type, 1: type
compiler.err.incorrect.receiver.name=\
    the receiver name does not match the enclosing class type\n\
    required: {0}\n\
    found:    {1}

# 0: type, 1: type
compiler.err.incorrect.receiver.type=\
    the receiver type does not match the enclosing class type\n\
    required: {0}\n\
    found:    {1}

# 0: type, 1: type
compiler.err.incorrect.constructor.receiver.type=\
    the receiver type does not match the enclosing outer class type\n\
    required: {0}\n\
    found:    {1}

# 0: type, 1: type
compiler.err.incorrect.constructor.receiver.name=\
    the receiver name does not match the enclosing outer class type\n\
    required: {0}\n\
    found:    {1}

compiler.err.no.annotations.on.dot.class=\
    no annotations are allowed in the type of a class literal

########################################
# Diagnostics for verbose resolution
# used by Resolve (debug only)
########################################

# 0: number, 1: symbol, 2: unused
compiler.misc.applicable.method.found=\
    #{0} applicable method found: {1}

# 0: number, 1: symbol, 2: message segment
compiler.misc.applicable.method.found.1=\
    #{0} applicable method found: {1}\n\
    ({2})

# 0: number, 1: symbol, 2: message segment
compiler.misc.not.applicable.method.found=\
    #{0} not applicable method found: {1}\n\
    ({2})

# 0: type
compiler.misc.partial.inst.sig=\
    partially instantiated to: {0}

# 0: name, 1: symbol, 2: number, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
compiler.note.verbose.resolve.multi=\
    resolving method {0} in type {1} to candidate {2}\n\
    phase: {3}\n\
    with actuals: {4}\n\
    with type-args: {5}\n\
    candidates:

# 0: name, 1: symbol, 2: unused, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
compiler.note.verbose.resolve.multi.1=\
    erroneous resolution for method {0} in type {1}\n\
    phase: {3}\n\
    with actuals: {4}\n\
    with type-args: {5}\n\
    candidates:

# 0: symbol, 1: type, 2: type
compiler.note.deferred.method.inst=\
    Deferred instantiation of method {0}\n\
    instantiated signature: {1}\n\
    target-type: {2}

########################################
# Diagnostics for lambda deduplication
# used by LambdaToMethod (debug only)
########################################

# 0: symbol
compiler.note.verbose.l2m.deduplicate=\
    deduplicating lambda implementation method {0}

########################################
# Diagnostics for method reference search
# results used by Resolve (debug only)
########################################

# 0: fragment, 1: string, 2: number
compiler.note.method.ref.search.results.multi=\
    {0} search results for {1}, with most specific {2}\n\
    applicable candidates:

# 0: number, 1: fragment, 2: symbol
compiler.misc.applicable.method.found.2=\
    #{0} applicable method found: {1} {2}

# 0: number, 1: fragment, 2: symbol, 3: message segment
compiler.misc.applicable.method.found.3=\
    #{0} applicable method found: {1} {2}\n\
    ({3})

compiler.misc.static=\
    static

compiler.misc.non.static=\
    non-static

compiler.misc.bound=\
    bound

compiler.misc.unbound=\
    unbound

########################################
# Diagnostics for where clause implementation
# used by the RichDiagnosticFormatter.
########################################

compiler.misc.type.null=\
    <null>

# X#n (where n is an int id) is disambiguated tvar name
# 0: name, 1: number
compiler.misc.type.var=\
    {0}#{1}

# CAP#n (where n is an int id) is an abbreviation for 'captured type'
# 0: number
compiler.misc.captured.type=\
    CAP#{0}

# <INT#n> (where n is an int id) is an abbreviation for 'intersection type'
# 0: number
compiler.misc.intersection.type=\
    INT#{0}

# where clause for captured type: contains upper ('extends {1}') and lower
# ('super {2}') bound along with the wildcard that generated this captured type ({3})
# 0: type, 1: type, 2: type, 3: type
compiler.misc.where.captured=\
    {0} extends {1} super: {2} from capture of {3}

# compact where clause for captured type: contains upper ('extends {1}') along
# with the wildcard that generated this captured type ({3})
# 0: type, 1: type, 2: unused, 3: type
compiler.misc.where.captured.1=\
    {0} extends {1} from capture of {3}

# where clause for type variable: contains upper bound(s) ('extends {1}') along with
# the kindname ({2}) and location ({3}) in which the typevar has been declared
# 0: type, 1: list of type, 2: symbol kind, 3: symbol
compiler.misc.where.typevar=\
    {0} extends {1} declared in {2} {3}

# compact where clause for type variable: contains the kindname ({2}) and location ({3})
# in which the typevar has been declared
# 0: type, 1: list of type, 2: symbol kind, 3: symbol
compiler.misc.where.typevar.1=\
    {0} declared in {2} {3}

# where clause for fresh type variable: contains upper bound(s) ('extends {1}').
# Since a fresh type-variable is synthetic - there's no location/kindname here.
# 0: type, 1: list of type
compiler.misc.where.fresh.typevar=\
    {0} extends {1}

# where clause for type variable: contains all the upper bound(s) ('extends {1}')
# of this intersection type
# 0: type, 1: list of type
compiler.misc.where.intersection=\
    {0} extends {1}

### Where clause headers ###
compiler.misc.where.description.captured=\
    where {0} is a fresh type-variable:

# 0: set of type
compiler.misc.where.description.typevar=\
    where {0} is a type-variable:

# 0: set of type
compiler.misc.where.description.intersection=\
    where {0} is an intersection type:

# 0: set of type
compiler.misc.where.description.captured.1=\
    where {0} are fresh type-variables:

# 0: set of type
compiler.misc.where.description.typevar.1=\
    where {0} are type-variables:

# 0: set of type
compiler.misc.where.description.intersection.1=\
    where {0} are intersection types:

###
# errors related to doc comments

compiler.err.dc.bad.entity=\
    bad HTML entity

compiler.err.dc.bad.inline.tag=\
    incorrect use of inline tag

compiler.err.dc.identifier.expected=\
    identifier expected

compiler.err.dc.malformed.html=\
    malformed HTML

compiler.err.dc.missing.semicolon=\
    semicolon missing

compiler.err.dc.no.content=\
    no content

compiler.err.dc.no.tag.name=\
    no tag name after '@'

compiler.err.dc.gt.expected=\
    ''>'' expected

compiler.err.dc.ref.bad.parens=\
    unexpected text after parenthesis

compiler.err.dc.ref.syntax.error=\
    syntax error in reference

compiler.err.dc.ref.unexpected.input=\
    unexpected text

compiler.err.dc.unexpected.content=\
    unexpected content

compiler.err.dc.unterminated.inline.tag=\
    unterminated inline tag

compiler.err.dc.unterminated.signature=\
    unterminated signature

compiler.err.dc.unterminated.string=\
    unterminated string

compiler.err.dc.ref.annotations.not.allowed=\
    annotations not allowed

###
# errors related to modules

compiler.err.expected.module=\
    expected ''module''

# 0: symbol
compiler.err.module.not.found=\
    module not found: {0}

# 0: symbol
compiler.warn.module.not.found=\
    module not found: {0}

compiler.err.too.many.modules=\
    too many module declarations found

compiler.err.module.not.found.on.module.source.path=\
    module not found on module source path

compiler.err.not.in.module.on.module.source.path=\
    not in a module on the module source path

# 0: symbol
compiler.err.duplicate.module=\
    duplicate module: {0}

# 0: symbol
compiler.err.duplicate.requires=\
    duplicate requires: {0}

# 0: symbol
compiler.err.conflicting.exports=\
    duplicate or conflicting exports: {0}

# 0: symbol
compiler.err.conflicting.opens=\
    duplicate or conflicting opens: {0}

# 0: symbol
compiler.err.conflicting.exports.to.module=\
    duplicate or conflicting exports to module: {0}

# 0: symbol
compiler.err.conflicting.opens.to.module=\
    duplicate or conflicting opens to module: {0}

compiler.err.no.opens.unless.strong=\
    ''opens'' only allowed in strong modules

# 0: symbol
compiler.err.repeated.provides.for.service=\
    multiple ''provides'' for service {0}

# 0: symbol, 1: symbol
compiler.err.duplicate.provides=\
    duplicate provides: service {0}, implementation {1}

# 0: symbol
compiler.err.duplicate.uses=\
    duplicate uses: {0}

# 0: symbol
compiler.err.service.implementation.is.abstract=\
    the service implementation is an abstract class: {0}

compiler.err.service.implementation.must.be.subtype.of.service.interface=\
    the service implementation type must be a subtype of the service interface type, or \
    have a public static no-args method named "provider" returning the service implementation

compiler.err.service.implementation.provider.return.must.be.subtype.of.service.interface=\
    the "provider" method return type must be a subtype of the service interface type

# 0: symbol
compiler.err.service.implementation.is.inner=\
    the service implementation is an inner class: {0}

# 0: symbol
compiler.err.service.definition.is.enum=\
    the service definition is an enum: {0}

# 0: symbol
compiler.err.service.implementation.doesnt.have.a.no.args.constructor=\
    the service implementation does not have a default constructor: {0}

# 0: symbol
compiler.err.service.implementation.no.args.constructor.not.public=\
    the no arguments constructor of the service implementation is not public: {0}

# 0: symbol
compiler.err.package.empty.or.not.found=\
    package is empty or does not exist: {0}

# 0: symbol
compiler.warn.package.empty.or.not.found=\
    package is empty or does not exist: {0}

compiler.err.no.output.dir=\
    no class output directory specified

compiler.err.unnamed.pkg.not.allowed.named.modules=\
    unnamed package is not allowed in named modules

# 0: name, 1: name
compiler.err.module.name.mismatch=\
    module name {0} does not match expected name {1}

# 0: name, 1: name
compiler.misc.module.name.mismatch=\
    module name {0} does not match expected name {1}

# 0: name
compiler.err.module.non.zero.opens=\
    open module {0} has non-zero opens_count

# 0: name
compiler.misc.module.non.zero.opens=\
    open module {0} has non-zero opens_count

compiler.err.module.decl.sb.in.module-info.java=\
    module declarations should be in a file named module-info.java

# 0: set of string
compiler.err.too.many.patched.modules=\
    too many patched modules ({0}), use --module-source-path

# 0: name, 1: name
compiler.err.file.patched.and.msp=\
    file accessible from both --patch-module and --module-source-path, \
    but belongs to a different module on each path: {0}, {1}

compiler.err.processorpath.no.processormodulepath=\
    illegal combination of -processorpath and --processor-module-path

# 0: symbol
compiler.err.package.in.other.module=\
    package exists in another module: {0}

# 0: symbol, 1: name, 2: symbol, 3: symbol
compiler.err.package.clash.from.requires=\
    module {0} reads package {1} from both {2} and {3}

# 0: name, 1: symbol, 2: symbol
compiler.err.package.clash.from.requires.in.unnamed=\
    the unnamed module reads package {0} from both {1} and {2}

# 0: string
compiler.err.module.not.found.in.module.source.path=\
    module {0} not found in module source path

compiler.err.output.dir.must.be.specified.with.dash.m.option=\
    class output directory must be specified if -m option is used

compiler.err.modulesourcepath.must.be.specified.with.dash.m.option=\
    module source path must be specified if -m option is used

# 0: symbol
compiler.err.service.implementation.not.in.right.module=\
    service implementation must be defined in the same module as the provides directive

# 0: symbol
compiler.err.cyclic.requires=\
    cyclic dependence involving {0}

# 0: fragment, 1: name
compiler.err.duplicate.module.on.path=\
    duplicate module on {0}\nmodule in {1}

# 0: option name, 1: string
compiler.warn.bad.name.for.option=\
    bad name in value for {0} option: ''{1}''

# 0: option name, 1: string
compiler.err.bad.name.for.option=\
    bad name in value for {0} option: ''{1}''

# 0: option name, 1: symbol
compiler.warn.module.for.option.not.found=\
    module name in {0} option not found: {1}

compiler.err.addmods.all.module.path.invalid=\
    --add-modules ALL-MODULE-PATH can only be used when compiling the unnamed module or \
    when compiling in the context of an automatic module

# 0: symbol
compiler.err.add.exports.with.release=\
    exporting a package from system module {0} is not allowed with --release

# 0: symbol
compiler.err.add.reads.with.release=\
    adding read edges for system module {0} is not allowed with --release

compiler.warn.addopens.ignored=\
    --add-opens has no effect at compile time

compiler.misc.locn.module_source_path=\
    module source path

compiler.misc.locn.upgrade_module_path=\
    upgrade module path

compiler.misc.locn.system_modules=\
    system modules

compiler.misc.locn.module_path=\
    application module path

compiler.misc.cant.resolve.modules=\
    cannot resolve modules

compiler.misc.bad.requires.flag=\
    bad requires flag: {0}

# 0: string
compiler.err.invalid.module.specifier=\
    module specifier not allowed: {0}

# 0: symbol
compiler.warn.service.provided.but.not.exported.or.used=\
    service interface provided but not exported or used

# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible=\
    {0} {1} in module {2} is not accessible to clients that require this module
# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible.unexported=\
    {0} {1} in module {2} is not exported
# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible.not.required.transitive=\
    {0} {1} in module {2} is not indirectly exported using 'requires transitive'
# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible.unexported.qualified=\
    {0} {1} in module {2} may not be visible to all clients that require this module

###
# errors related to options

# 0: string, 1: string
compiler.err.illegal.argument.for.option=\
    illegal argument for {0}: {1}

compiler.err.match.binding.exists=\
    illegal attempt to redefine an existing match binding

compiler.err.switch.case.unexpected.statement=\
    unexpected statement in case, expected is an expression, a block or a throw statement

compiler.err.switch.mixing.case.types=\
    different case kinds used in the switch

###
# errors related to sealed classes

# permits clause
# 0: fragment
compiler.err.invalid.permits.clause=\
    invalid permits clause\n\
    ({0})

# 0: string
compiler.misc.class.is.not.sealed=\
    {0} must be sealed

# 0: type
compiler.misc.is.a.type.variable=\
    must not include type variables: {0}

# 0: type
compiler.misc.is.duplicated=\
    must not contain duplicates: {0}

# 0: type
compiler.misc.doesnt.extend.sealed=\
    subclass {0} must extend sealed class

compiler.misc.must.not.be.same.class=\
    illegal self-reference in permits clause

# 0: type
compiler.misc.must.not.be.supertype=\
    illegal reference to supertype {0}

# other sealed types related errors

compiler.err.sealed.class.must.have.subclasses=\
    sealed class must have subclasses

# errors in subclasses of sealed classes
# 0: symbol
compiler.err.cant.inherit.from.sealed=\
    class is not allowed to extend sealed class: {0} \
    (as it is not listed in its 'permits' clause)

# 0: symbol
compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package=\
    class {0} in unnamed module cannot extend a sealed class in a different package

# 0: symbol, 1: symbol
compiler.err.class.in.module.cant.extend.sealed.in.diff.module=\
    class {0} in module {1} cannot extend a sealed class in a different module

# 0: symbol
compiler.err.non.sealed.with.no.sealed.supertype=\
    non-sealed modifier not allowed here\n\
    (class {0} does not have any sealed supertypes)

compiler.err.non.sealed.sealed.or.final.expected=\
    sealed, non-sealed or final modifiers expected

compiler.err.non.sealed.or.sealed.expected=\
    sealed or non-sealed modifiers expected

compiler.err.sealed.or.non.sealed.local.classes.not.allowed=\
    sealed or non-sealed local classes are not allowed

# 0: fragment
compiler.err.local.classes.cant.extend.sealed=\
    {0} classes must not extend sealed classes\

compiler.misc.anonymous=\
    anonymous

compiler.misc.local=\
    local

###
# errors related to records

# record components
compiler.err.record.cant.declare.field.modifiers=\
    record components cannot have modifiers

# 0: symbol
compiler.err.illegal.record.component.name=\
    illegal record component name {0}

compiler.err.record.component.and.old.array.syntax=\
    legacy array notation not allowed on record components

# accessor methods
# 0: symbol, 1: fragment
compiler.err.invalid.accessor.method.in.record=\
    invalid accessor method in record {0}\n\
    ({1})

compiler.misc.method.must.be.public=\
    accessor method must be public

# 0: symbol, 1: symbol
compiler.misc.accessor.return.type.doesnt.match=\
    return type of accessor method {0} must match the type of record component {1}

compiler.misc.accessor.method.cant.throw.exception=\
    throws clause not allowed for accessor method

compiler.misc.accessor.method.must.not.be.generic=\
    accessor method must not be generic

compiler.misc.accessor.method.must.not.be.static=\
    accessor method must not be static

# canonical constructors
# 0: fragment, 1: name, 2: fragment
compiler.err.invalid.canonical.constructor.in.record=\
    invalid {0} constructor in record {1}\n\
    ({2})

compiler.misc.canonical=\
    canonical

compiler.misc.compact=\
    compact

# 0: fragment
compiler.misc.throws.clause.not.allowed.for.canonical.constructor=\
    throws clause not allowed for {0} constructor

compiler.misc.canonical.with.name.mismatch=\
    invalid parameter names in canonical constructor

compiler.misc.canonical.cant.have.return.statement=\
    compact constructor must not have return statements

compiler.misc.canonical.must.not.declare.type.variables=\
    canonical constructor must not declare type variables

compiler.misc.type.must.be.identical.to.corresponding.record.component.type=\
    type and arity must match that of the corresponding record component\

compiler.misc.canonical.must.not.contain.explicit.constructor.invocation=\
    canonical constructor must not contain explicit constructor invocation

# 0: set of flag or string
compiler.misc.canonical.must.not.have.stronger.access=\
    attempting to assign stronger access privileges; was {0}

# other
compiler.err.record.cannot.declare.instance.fields=\
    field declaration must be static\n\
    (consider replacing field with record component)

# 0: symbol
compiler.err.invalid.supertype.record=\
    classes cannot directly extend {0}

# 0: symbol
compiler.err.first.statement.must.be.call.to.another.constructor=\
    constructor is not canonical, so its first statement must invoke another constructor of class {0}

compiler.err.instance.initializer.not.allowed.in.records=\
    instance initializers not allowed in records

compiler.err.static.declaration.not.allowed.in.inner.classes=\
    static declarations not allowed in inner classes

compiler.err.record.header.expected=\
    record header expected

############################################
# messages previously at javac.properties

compiler.err.empty.A.argument=\
    -A requires an argument; use ''-Akey'' or ''-Akey=value''

# 0: string
compiler.err.invalid.A.key=\
    key in annotation processor option ''{0}'' is not a dot-separated sequence of identifiers

# 0: string
compiler.err.invalid.flag=\
    invalid flag: {0}

compiler.err.profile.bootclasspath.conflict=\
    profile and bootclasspath options cannot be used together

# 0: string
compiler.err.invalid.profile=\
    invalid profile: {0}

# 0: string
compiler.err.invalid.target=\
    invalid target release: {0}

# 0: option name, 1: target
compiler.err.option.not.allowed.with.target=\
    option {0} not allowed with target {1}

# 0: string
compiler.err.option.too.many=\
    option {0} can only be specified once

compiler.err.no.source.files=\
    no source files

compiler.err.no.source.files.classes=\
    no source files or class names

# 0: string
compiler.err.req.arg=\
    {0} requires an argument

# 0: string
compiler.err.invalid.source=\
    invalid source release: {0}

# 0: string, 1: string
compiler.err.error.writing.file=\
    error writing {0}; {1}

compiler.err.sourcepath.modulesourcepath.conflict=\
    cannot specify both --source-path and --module-source-path

# 0: string, 1: target
compiler.warn.source.target.conflict=\
    source release {0} requires target release {1}

# 0: string, 1: target
compiler.warn.target.default.source.conflict=\
    target release {0} conflicts with default source release {1}

# 0: profile, 1: target
compiler.warn.profile.target.conflict=\
    profile {0} is not valid for target release {1}

# 0: string
compiler.err.file.not.directory=\
    not a directory: {0}

# 0: object
compiler.err.file.not.file=\
    not a file: {0}

compiler.err.two.class.loaders.1=\
    javac is split between multiple class loaders: check your configuration

# 0: url, 1: url
compiler.err.two.class.loaders.2=\
    javac is split between multiple class loaders:\n\
    one class comes from file: {0}\n\
    while javac comes from {1}

# 0: string, 1: string
compiler.err.bad.value.for.option=\
    bad value for {0} option: ''{1}''

# 0: string
compiler.err.no.value.for.option=\
    no value for {0} option

# 0: string
compiler.err.repeated.value.for.patch.module=\
    --patch-module specified more than once for module {0}

# 0: string
compiler.err.repeated.value.for.module.source.path=\
    --module-source-path specified more than once for module {0}

compiler.err.multiple.values.for.module.source.path=\
    --module-source-path specified more than once with a pattern argument

# 0: string
compiler.err.unmatched.quote=\
    unmatched quote in environment variable {0}

# 0: option name
compiler.err.release.bootclasspath.conflict=\
    option {0} cannot be used together with --release

# 0: string
compiler.err.unsupported.release.version=\
    release version {0} not supported

# 0: string
compiler.err.file.not.found=\
    file not found: {0}

# 0: string, 1: source
compiler.err.preview.not.latest=\
    invalid source release {0} with --enable-preview\n\
    (preview language features are only supported for release {1})

compiler.err.preview.without.source.or.release=\
    --enable-preview must be used with either -source or --release

# 0: kind name, 1: symbol
compiler.warn.declared.using.preview=\
    {0} {1} is declared using a preview feature, which may be removed in a future release.

compiler.warn.attempt.to.synchronize.on.instance.of.value.based.class=\
    attempt to synchronize on an instance of a value-based class
