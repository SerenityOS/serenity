#
# Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

jshell.msg.welcome =\
Welcome to JShell -- Version {0}\n\
For an introduction type: /help intro
jshell.err.opt.arg = Argument to {0} missing.
jshell.err.opt.invalid = Invalid options: {0}.
jshell.err.opt.one = Only one {0} option may be used.
jshell.err.opt.startup.conflict = Conflicting options: both --startup and --no-startup were used.
jshell.err.opt.feedback.one = Only one feedback option (--feedback, -q, -s, or -v) may be used.
jshell.err.opt.unknown = Unknown option: {0}

jshell.msg.terminated = State engine terminated.
jshell.msg.terminated.restore = Restore definitions with: /reload -restore

jshell.msg.use.one.of = Use one of: {0}
jshell.msg.see.classes.etc = See /types, /methods, /vars, or /list
jshell.err.arg = Invalid ''{0}'' argument: {1}
jshell.msg.see = See {0} for help.

jshell.err.file.not.accessible = File ''{1}'' for ''{0}'' is not accessible: {2}
jshell.err.file.not.found = File ''{1}'' for ''{0}'' is not found.
jshell.err.file.exception = File ''{1}'' for ''{0}'' threw exception: {2}
jshell.err.file.filename = ''{0}'' requires a filename argument.

jshell.err.startup.unexpected.exception = Unexpected exception reading startup: {0}
jshell.err.unexpected.exception = Unexpected exception: {0}

jshell.err.invalid.command = Invalid command: {0}
jshell.err.command.ambiguous = Command: ''{0}'' is ambiguous: {1}
jshell.msg.set.restore = Setting new options and restoring state.
jshell.msg.set.editor.set = Editor set to: {0}
jshell.msg.set.editor.retain = Editor setting retained: {0}
jshell.msg.set.indent.set = Indent level set to: {0}
jshell.err.invalid.indent = Invalid indent level: {0}
jshell.err.no.builtin.editor = Built-in editor not available.
jshell.err.cant.launch.editor = Cannot launch built-in editor -- unexpected exception: {0}
jshell.msg.try.set.editor = See ''/help /set editor'' to use external editor.
jshell.msg.press.return.to.leave.edit.mode = Press return to leave edit mode.
jshell.err.wait.applies.to.external.editor = -wait applies to external editors
jshell.label.editpad = JShell Edit Pad

jshell.err.setting.to.retain.must.be.specified = The setting to retain must be specified -- {0}
jshell.msg.set.show.mode.settings = \nTo show mode settings use ''/set prompt'', ''/set truncation'', ...\n\
or use ''/set mode'' followed by the feedback mode name.
jshell.err.continuation.prompt.required = Continuation prompt required -- {0}

jshell.msg.try.command.without.args = Try ''{0}'' without arguments.
jshell.msg.no.active = There are no active definitions.

jshell.msg.resetting = Resetting...
jshell.msg.resetting.state = Resetting state.

jshell.err.reload.no.previous = No previous history to restore
jshell.err.reload.restarting.previous.state = Restarting and restoring from previous state.
jshell.err.reload.restarting.state = Restarting and restoring state.

jshell.err.restart.failed = Restart failed: {0}\n\n\
Reverting to previous settings and restarting...

jshell.msg.vars.not.active = (not-active)

jshell.err.out.of.range = Out of range

jshell.msg.error = Error:
jshell.msg.warning = Warning:

jshell.err.sub.arg = The ''{0}'' command requires a sub-command. See: ''/help {0}''
jshell.err.sub.ambiguous = Ambiguous sub-command argument to ''{0}'': {1}

jshell.err.classpath.arg = The /classpath command requires a path argument.
jshell.msg.classpath = Path ''{0}'' added to classpath

jshell.err.help.arg = No commands or subjects start with the provided argument: {0}
jshell.msg.help.begin =\
Type a Java language expression, statement, or declaration.\n\
Or type one of the following commands:\n
jshell.msg.help.subject =\n\
For more information type ''/help'' followed by the name of a\n\
command or a subject.\n\
For example ''/help /list'' or ''/help intro''.\n\
\n\
Subjects:\n\
\n

jshell.err.no.snippet.with.id = No snippet with ID: {0}
jshell.err.end.snippet.range.less.than.start = End of snippet range less than start: {0} - {1}
jshell.err.range.requires.id = Snippet ranges require snippet IDs: {0}

jshell.err.exit.not.expression = The argument to /exit must be a valid integer expression, it is not an expression: {0}
jshell.err.exit.bad.type = The argument to /exit must be a valid integer expression. The type is {1} : {0}
jshell.err.exit.bad.value = The argument to /exit has bad value is {1} : {0}

jshell.err.drop.arg =\
In the /drop argument, please specify an import, variable, method, or class to drop.\n\
Specify by ID or name. Use /list to see IDs. Use /reset to reset all state.
jshell.err.failed = Failed.
jshell.msg.native.method = Native Method
jshell.msg.unknown.source = Unknown Source
jshell.msg.goodbye = Goodbye
jshell.msg.goodbye.value = Goodbye ({0})

jshell.msg.help.for.help = Type /help for help.

jshell.err.mode.name = Expected a feedback mode name: {0}
jshell.err.missing.mode = Missing the feedback mode -- {0}
jshell.err.field.name = Expected a field name: {0} -- {1}
jshell.err.mode.unknown = No feedback mode named: {0} -- {1}

jshell.err.feedback.does.not.match.mode = Does not match any current feedback mode: {0} -- {1}
jshell.err.feedback.ambiguous.mode = Matches more then one current feedback mode: {0} -- {1}
jshell.err.feedback.must.be.quoted = Format ''{0}'' must be quoted -- {1}
jshell.err.feedback.not.a.valid.selector = Not a valid selector ''{0}'' in ''{1}'' -- {2}
jshell.err.feedback.multiple.sections = Selector kind in multiple sections of selector list ''{0}'' in ''{1}'' -- {2}
jshell.err.feedback.different.selector.kinds = Different selector kinds in same sections of selector list ''{0}'' in ''{1}'' -- {2}

jshell.msg.feedback.new.mode = Created new feedback mode: {0}
jshell.msg.feedback.mode = Feedback mode: {0}
jshell.msg.feedback.mode.following = Available feedback modes:
jshell.msg.feedback.retained.mode.following = Retained feedback modes:
jshell.err.mode.creation = To create a new mode either the -command or the -quiet option must be used -- {0}
jshell.err.mode.exists = Mode to be created already exists: {0} -- {1}

jshell.err.truncation.expected.length = Expected truncation length -- {0}
jshell.err.truncation.length.not.integer = Truncation length must be an integer: {0} -- {1}

jshell.err.not.valid.with.predefined.mode = Not valid with a predefined mode: {0} -- {1}
jshell.err.retained.feedback.mode.must.be.retained.or.predefined = \
''/set feedback -retain <mode>'' requires that <mode> is predefined or has been retained with ''/set mode -retain'' -- {0}

jshell.err.unknown.option = Unknown option: {0} -- {1}
jshell.err.default.option.or.program = Specify -default option, -delete option, or program -- {0}
jshell.err.option.or.filename = Specify no more than one of -default, -none, or a startup file name -- {0}
jshell.err.unexpected.at.end = Unexpected arguments at end of command: {0} -- {1}
jshell.err.conflicting.options = Conflicting options -- {0}
jshell.err.cannot.delete.current.mode = The current feedback mode ''{0}'' cannot be deleted, use ''/set feedback'' first -- {1}
jshell.err.cannot.delete.retained.mode = The retained feedback mode ''{0}'' cannot be deleted, use ''/set feedback -retain'' first -- {1}
jshell.err.may.not.specify.options.and.snippets = Options and snippets must not both be used: {0}
jshell.err.no.such.snippets = No such snippet: {0}
jshell.err.the.snippet.cannot.be.used.with.this.command = This command does not accept the snippet ''{0}'' : {1}
jshell.err.retained.mode.failure = Failure in retained modes (modes cleared) -- {0} {1}

jshell.err.corrupted.stored.startup = Corrupted stored startup, using default -- {0}

jshell.err.exception.thrown = Exception {0}
jshell.err.exception.thrown.message = Exception {0}: {1}
jshell.err.exception.cause = Caused by: {0}
jshell.err.exception.cause.message = Caused by: {0}: {1}

jshell.console.see.synopsis = <press tab again to see synopsis>
jshell.console.see.full.documentation = <press tab again to see full documentation>
jshell.console.see.documentation = <press tab again to see documentation>
jshell.console.see.next.page = <press tab again to see next page>
jshell.console.see.next.javadoc = <press tab to see next documentation>
jshell.console.see.next.command.doc = <press tab to see next command>
jshell.console.no.such.command = No such command
jshell.console.completion.current.signatures = Signatures:
jshell.console.completion.all.completions.number = <press tab again to see all possible completions; total possible completions: {0}>
jshell.console.completion.all.completions = <press tab again to see all possible completions>
jshell.console.no.javadoc = <no documentation found>
jshell.console.do.nothing = Do nothing
jshell.console.choice = Choice: \

jshell.console.create.variable = Create variable
jshell.console.create.method = Create method
jshell.console.resolvable = \nThe identifier is resolvable in this context.
jshell.console.no.candidate = \nNo candidate fully qualified names found to import.
jshell.console.incomplete = \nResults may be incomplete; try again later for complete results.
jshell.console.erroneous = \nIncomplete or erroneous. A single valid expression or statement must precede Shift+Tab m.
jshell.console.exprstmt = \nA single valid expression or statement must precede Shift+Tab m.
jshell.console.empty = \nEmpty entry. A single valid expression or statement must precede Shift+Tab m.

jshell.fix.wrong.shortcut =\
Unexpected character after Shift+Tab.\n\
Use "i" for auto-import, "v" for variable creation, or "m" for method creation.\n\
For more information see:\n\
   /help shortcuts

help.usage = \
Usage:   jshell <option>... <load-file>...\n\
where possible options include:\n\
\    --class-path <path>   Specify where to find user class files\n\
\    --module-path <path>  Specify where to find application modules\n\
\    --add-modules <module>(,<module>)*\n\
\                          Specify modules to resolve, or all modules on the\n\
\                            module path if <module> is ALL-MODULE-PATHs\n\
\    --enable-preview      Allow code to depend on preview features of this release\n\
\    --startup <file>      One run replacement for the startup definitions\n\
\    --no-startup          Do not run the startup definitions\n\
\    --feedback <mode>     Specify the initial feedback mode. The mode may be\n\
\                            predefined (silent, concise, normal, or verbose) or\n\
\                            previously user-defined\n\
\    -q                    Quiet feedback.  Same as: --feedback concise\n\
\    -s                    Really quiet feedback.  Same as: --feedback silent\n\
\    -v                    Verbose feedback.  Same as: --feedback verbose\n\
\    -J<flag>              Pass <flag> directly to the runtime system.\n\
\                            Use one -J for each runtime flag or flag argument\n\
\    -R<flag>              Pass <flag> to the remote runtime system.\n\
\                            Use one -R for each remote flag or flag argument\n\
\    -C<flag>              Pass <flag> to the compiler.\n\
\                            Use one -C for each compiler flag or flag argument\n\
\    --version             Print version information and exit\n\
\    --show-version        Print version information and continue\n\
\    --help, -?, -h        Print this synopsis of standard options and exit\n\
\    --help-extra, -X      Print help on non-standard options and exit\n\
\n\
A file argument may be a file name, or one of the predefined file names: DEFAULT,\n\
PRINTING, or JAVASE.\n\
A load-file may also be "-" to indicate standard input, without interactive I/O.\n\
\n\
For more information on the evaluation context options (--class-path,\n\
--module-path, and --add-modules) see:\n\t\
     /help context\n\
\n\
A path lists the directories and archives to search. For Windows, use a\n\
semicolon (;) to separate items in the path. On other platforms, use a\n\
colon (:) to separate items.\n\

help.usage.x = \
\    --add-exports <module>/<package>   Specify a package to be considered as\n\
\                                         exported from its defining module \n\
\    --execution <spec>                 Specify an alternate execution engine.\n\
\                                         Where <spec> is an ExecutionControl spec.\n\
\                                         See the documentation of the package\n\
\                                         jdk.jshell.spi for the syntax of the spec\n\
\    \n\
\These options are non-standard and subject to change without notice.\n

help.list.summary = list the source you have typed
help.list.args = [<name or id>|-all|-start]
help.list =\
Show the snippets, prefaced with their snippet IDs.\n\
\n\
/list\n\t\
    List the currently active snippets of code that you typed or read with /open\n\n\
/list -start\n\t\
    List the evaluated startup snippets\n\n\
/list -all\n\t\
    List all snippets including failed, overwritten, dropped, and startup\n\n\
/list <name>\n\t\
    List snippets with the specified name (preference for active snippets)\n\n\
/list <id>\n\t\
    List the snippet with the specified snippet ID.\n\t\
    One or more IDs or ID ranges may used, see '/help id'

help.edit.summary = edit a source entry
help.edit.args = <name or id>
help.edit =\
Edit a snippet or snippets of source in an external editor.\n\
The editor to use is set with /set editor. If no editor is set, then the\n\
following environment variables are checked in order: JSHELLEDITOR, VISUAL,\n\
and EDITOR. If no editor has been set and none of the editor environment\n\
variables is set, a simple editor will be launched.\n\
\n\
/edit <name>\n\t\
    Edit the snippet or snippets with the specified name (preference for active snippets)\n\n\
/edit <id>\n\t\
    Edit the snippet with the specified snippet ID.\n\t\
    One or more IDs or ID ranges may used, see '/help id'\n\n\
/edit -start\n\t\
    Edit the startup snippets. Any changes are in this session, and do not\n\t\
    affect the startup setting\n\n\
/edit -all\n\t\
    Edit all snippets including failed, overwritten, dropped, and startup\n\n\
/edit\n\t\
    Edit the currently active snippets of code that you typed or read with /open

help.drop.summary = delete a source entry
help.drop.args = <name or id>
help.drop =\
Drop a snippet -- making it inactive.\n\
\n\
/drop <name>\n\t\
    Drop the snippet with the specified name\n\n\
/drop <id>\n\t\
    Drop the snippet with the specified snippet ID.\n\t\
    One or more IDs or ID ranges may used, see '/help id'

help.save.summary = Save snippet source to a file
help.save.args = [-all|-history|-start] <file>
help.save =\
Save the specified snippets and/or commands to the specified file.\n\
\n\
/save <file>\n\t\
    Save the source of current active snippets to the file.\n\n\
/save -all <file>\n\t\
    Save the source of all snippets to the file.\n\t\
    Includes source of overwritten, failed, and startup code\n\n\
/save -history <file>\n\t\
    Save the sequential history of all commands and snippets entered since the\n\t\
    jshell tool was launched.\n\n\
/save -start <file>\n\t\
    Save the current startup definitions to the file\n\n\
/save <id> <file>\n\t\
    Save the snippet with the specified snippet ID.\n\t\
    One or more IDs or ID ranges may used, see '/help id'

help.open.summary = open a file as source input
help.open.args = <file>
help.open =\
Open a file and read its contents as snippets and commands.\n\
\n\
/open <file>\n\t\
    Read the specified file as the jshell tool input.\n\
\n\
The <file> may be an operating system file name, or one of the predefined\n\
file names: DEFAULT, PRINTING, or JAVASE.\n\
These are respectively: the default import snippets (as used by -default),\n\
definitions of print(), println(), and printf() method snippets, or\n\
imports of all Java SE packages.\n

help.vars.summary = list the declared variables and their values
help.vars.args = [<name or id>|-all|-start]
help.vars =\
List the type, name, and value of variables that were entered.\n\
\n\
/vars\n\t\
    List the type, name, and value of the current active variables\n\n\
/vars <name>\n\t\
    List variables with the specified name (preference for active variables)\n\n\
/vars <id>\n\t\
    List the variable with the specified snippet ID.\n\t\
    One or more IDs or ID ranges may used, see '/help id'\n\n\
/vars -start\n\t\
    List the variables in the evaluated startup snippets\n\n\
/vars -all\n\t\
    List all variables including failed, overwritten, dropped, and startup

help.methods.summary = list the declared methods and their signatures
help.methods.args = [<name or id>|-all|-start]
help.methods =\
List the name, parameter types, and return type of methods that were entered.\n\
\n\
/methods\n\t\
    List the name, parameter types, and return type of the current active methods\n\n\
/methods <name>\n\t\
    List methods with the specified name (preference for active methods)\n\n\
/methods <id>\n\t\
    List the method with the specified snippet ID.\n\t\
    One or more IDs or ID ranges may used, see '/help id'\n\n\
/methods -start\n\t\
    List the methods in the evaluated startup snippets\n\n\
/methods -all\n\t\
    List all snippets including failed, overwritten, dropped, and startup

help.types.summary = list the type declarations
help.types.args =[<name or id>|-all|-start]
help.types =\
List classes and interfaces that were entered.\n\
\n\
/types\n\t\
    List the current active type declarations\n\n\
/types <name>\n\t\
    List type declarations with the specified name (preference for active snippets)\n\n\
/types <id>\n\t\
    List the type declaration with the specified snippet ID.\n\t\
    One or more IDs or ID ranges may used, see '/help id'\n\n\
/types -start\n\t\
    List the type declarations in the evaluated startup snippets\n\n\
/types -all\n\t\
    List all type declarations including failed, overwritten, dropped, and startup

help.imports.summary = list the imported items
help.imports.args =
help.imports =\
List the current active imports.  This will include imports from\n\
startup snippets.

help.exit.summary = exit the jshell tool
help.exit.args =[<integer-expression-snippet>]
help.exit =\
Leave the jshell tool.  No work is saved.\n\
Save any work before using this command\n\
\n\
/exit\n\t\
    Leave the jshell tool.  The exit status is zero\n\n\
/exit <integer-expression-snippet>\n\t\
    Evaluate the snippet.  If the snippet fails or is not an integer expression,\n\t\
    display the error.  Otherwise leave the jshell tool with the\n\t\
    value of the expression as the exit status

help.reset.summary = reset the jshell tool
help.reset.args = \
[-class-path <path>] [-module-path <path>] [-add-modules <modules>]...
help.reset =\
Reset the jshell tool code and execution state:\n\t\
   * All entered code is lost\n\t\
   * The execution state is restarted\n\t\
   * Startup code is re-executed\n\
Save any work before using this command.\n\
The /reset command accepts evaluation context options, see:\n\n\t\
     /help context\n\


help.reload.summary = reset and replay relevant history -- current or previous (-restore)
help.reload.args = \
[-restore] [-quiet] [-class-path <path>] [-module-path <path>]...
help.reload =\
Reset the jshell tool code and execution state then replay each valid snippet\n\
and any /drop commands in the order they were entered.\n\
\n\
/reload\n\t\
     Reset and replay the valid history since the jshell tool was entered, or\n\t\
     a /reset or /reload command was executed -- whichever is most\n\t\
     recent\n\n\
/reload -restore\n\t\
     Reset and replay the valid history between the previous and most\n\t\
     recent time that the jshell tool was entered, or a /reset, /reload, or /env\n\t\
     command was executed. This can thus be used to restore a previous\n\t\
     jshell tool session\n\n\
/reload [-restore] -quiet\n\t\
     With the '-quiet' argument the replay is not shown, however any errors\n\t\
     will be displayed\n\
\n\
Each of the above accepts evaluation context options, see:\n\n\t\
     /help context\n\
\n\
For example:\n\n\t\
     /reload -add-modules com.greetings -restore

help.env.summary = view or change the evaluation context
help.env.args = \
[-class-path <path>] [-module-path <path>] [-add-modules <modules>] ...
help.env =\
View or change the evaluation context.  The evaluation context is the class path,\n\
module path, etc.\n\n\
/env\n\t\
     Show the evaluation context displayed as context options\n\n\
/env [-class-path <path>] [-module-path <path>] [-add-modules <modules>] ...\n\t\
     With at least one option set, sets the evaluation context.  If snippets\n\t\
     have been defined, the execution state is reset with the new\n\t\
     evaluation context and the snippets will be replayed -- the replay is not\n\t\
     shown, however any errors will be displayed.  This is equivalent to:\n\n\t\t\
             /reload -quiet ...\n\
\n\
For details of evaluation context options, see:\n\n\t\
     /help context\n\n\
For example:\n\n\t\
     /env -add-modules com.greetings

help.history.summary = history of what you have typed
help.history.args = [-all]
help.history =\
Display the history of snippet and command input.\n\
\n\
/history\n\t\
    List the history of snippet and command input since this jshell tool was launched\n\n\
/history -all\n\t\
    List all the history of snippet and command input from this and previous sessions

help.debug.summary = toggle debugging of the jshell tool
help.debug.args = [0][r][g][f][c][d][e]
help.debug =\
Display debugging information for the jshell tool implementation.\n\
0: Debugging off\n\
r: Tool level debugging on\n\
g: General debugging on\n\
f: File manager debugging on\n\
c: Completion analysis debugging on\n\
d: Dependency debugging on\n\
e: Event debugging on

help.help.summary = get information about using the jshell tool
help.help.args = [<command>|<subject>]
help.help =\
Display information about using the jshell tool.\n\
/help\n\t\
     List the jshell tool commands and help subjects\n\n\
/help <command>\n\t\
     Display information about the specified command.\n\t\
     Only the first few letters of the command are needed -- if there is more than\n\t\
     one match, each will be displayed.  Example:  /help /li\n\n\
/help <subject>\n\t\
     Display information about the specified help subject. Example: /help intro

help.set.summary = set configuration information
help.set.args = editor|start|feedback|mode|prompt|truncation|format ...
help.set =\
Set the jshell tool configuration information, including:\n\
the external editor to use, the startup definitions to use, a new feedback mode,\n\
the command prompt, the feedback mode to use, or the format of output.\n\
\n\
/set editor [-wait] <command> <optional-arg>...\n\t\
     Specify the command to launch for the /edit command.\n\t\
     The <command> is an operating system dependent string\n\n\
/set start <file>\n\t\
     The contents of the specified <file> become the default startup snippets and commands\n\n\
/set feedback <mode>\n\t\
     Set the feedback mode describing displayed feedback for entered snippets and commands\n\n\
/set mode <mode> [<old-mode>] -command|-quiet|-delete\n\t\
     Create or update a user-defined feedback mode, optionally copying from an existing mode\n\n\
/set prompt <mode> "<prompt>" "<continuation-prompt>"\n\t\
     Set the displayed prompts for a given feedback mode\n\n\
/set truncation <mode> <length> <selector>...\n\t\
     Set the maximum length of a displayed value\n\n\
/set format <mode> <field> "<format>" <selector>...\n\t\
     Configure a feedback mode by setting the format of a field when the selector matches\n\n\
/set indent <number>\n\t\
     Set the number of spaces that should be used to automatically indent snippets\n\n\
/set\n\t\
     Show editor, start, and feedback settings as /set commands.\n\t\
     To show the settings of any of the above, omit the set value\n\n\
To get more information about one of these forms, use /help with the form specified.\n\
For example:   /help /set format

help.quest.summary = get information about using the jshell tool
help.quest.args = [<command>|<subject>]
help.quest =\
Display information about using the jshell tool (abbreviation for /help).\n\
/?\n\t\
     Display list of commands and help subjects\n\
/? <command>\n\t\
     Display information about the specified command.\n\t\
     Only the first few letters of the command are needed -- if there is more than\n\t\
     one match, each will be displayed.  Example:  /? /li\n\n\
/? <subject>\n\t\
     Display information about the specified help subject. Example: /? intro

help.bang.summary = rerun last snippet -- see /help rerun
help.bang.args =
help.bang =\
Reevaluate the most recently entered snippet.

help.slashID.summary = rerun snippets by ID or ID range -- see /help rerun
help.slashID.args =
help.slashID =\
/<id> <id> <id>\n\
\n\
/<id>-<id>\n\
\n\
Reevaluate the snippets specified by the ID or ID range.\n\
An ID range is represented as a two IDs separated by a hyphen, e.g.:  3-17\n\
Startup and error snippets maybe used, e.g.:  s3-s9    or   e1-e4\n\
Any number of IDs or ID ranges may be used, e.g.:  /3-7 s4 14-16 e2\n\
See '/help id'.

help.previous.summary = rerun n-th previous snippet -- see /help rerun
help.previous.args =
help.previous =\
Reevaluate the n-th most recently entered snippet.

help.intro.summary = an introduction to the jshell tool
help.intro =\
The jshell tool allows you to execute Java code, getting immediate results.\n\
You can enter a Java definition (variable, method, class, etc), like:  int x = 8\n\
or a Java expression, like:  x + x\n\
or a Java statement or import.\n\
These little chunks of Java code are called 'snippets'.\n\
\n\
There are also the jshell tool commands that allow you to understand and\n\
control what you are doing, like:  /list\n\
\n\
For a list of commands: /help

help.keys.summary = a description of readline-like input editing
help.keys =\
The jshell tool provides line editing support to allow you to navigate within\n\
and edit snippets and commands. The current command/snippet can be edited,\n\
or prior commands/snippets can be retrieved from history, edited, and executed.\n\
This support is similar to readline/editline with simple emacs-like bindings.\n\
There are also jshell tool specific key sequences.\n\
\n\
Line and history navigation:\n\
\n\t\
Return\n\t\t\
  Enters the current snippet\n\t\
Left-arrow or Ctrl+B\n\t\t\
  Moves backward one character\n\t\
Right-arrow or Ctrl+F\n\t\t\
  Moves forward one character\n\t\
Up-arrow or Ctrl+P\n\t\t\
  Moves up one line, backward through history\n\t\
Down arrow or Ctrl+N\n\t\t\
  Moves down one line, forward through history\n\t\
Ctrl+A\n\t\t\
  Moves to the beginning of the line\n\t\
Ctrl+E\n\t\t\
  Moves to the end of the line\n\t\
Meta+B\n\t\t\
  Moves backward one word\n\t\
Meta+F\n\t\t\
  Moves forward one word\n\t\
Ctrl+R\n\t\t\
  Search backward through history\n\
\n\
\n\
Line and history basic editing:\n\
\n\t\
Meta+Return or Ctrl+Return (depending on platform)\n\t\t\
  Insert a new line in snippet\n\t\
Ctrl+_ (underscore may require the Shift key) or Ctrl+X then Ctrl+U\n\t\t\
  Undo edit - repeat to undo more edits\n\t\
Delete\n\t\t\
  Deletes the character at or after the cursor, depending on the operating system\n\t\
Backspace\n\t\t\
  Deletes the character before the cursor\n\t\
Ctrl+K\n\t\t\
  Deletes the text from the cursor to the end of the line\n\t\
Meta+D\n\t\t\
  Deletes the text from the cursor to the end of the word\n\t\
Ctrl+W\n\t\t\
  Deletes the text from the cursor to the previous white space\n\t\
Ctrl+Y\n\t\t\
  Pastes the most recently deleted text into the line\n\t\
Meta+Y\n\t\t\
  After Ctrl+Y, Meta+Y cycles through previously deleted text\n\t\
Ctrl+X then Ctrl+K\n\t\t\
  Delete whole snippet\n\
\n\
\n\
Shortcuts for jshell tool:\n\
\n\t\
For details, see: /help shortcuts\n\
\n\t\
Tab\n\t\t\
  Complete Java identifier or jshell command\n\t\
Shift+Tab then v\n\t\t\
  Convert expression to variable declaration\n\t\
Shift+Tab then m\n\t\t\
  Convert statement to method declaration\n\t\
Shift+Tab then i\n\t\t\
  Add imports for this identifier\n\t\
\n\
\n\
More line and history editing:\n\
\n\t\
Ctrl+L\n\t\t\
  Clear screen and reprint snippet\n\t\
Ctrl+U\n\t\t\
  Kill whole line\n\t\
Ctrl+T\n\t\t\
  Transpose characters\n\t\
Ctrl+X then Ctrl+B\n\t\t\
  Navigate to matching bracket, parenthesis, ...\n\t\
Ctrl+X then =\n\t\t\
  Enter show current character position mode\n\t\
Ctrl+X then Ctrl+O\n\t\t\
  Toggle overwrite characters vs insert characters\n\t\
Meta+C\n\t\t\
  Capitalize word\n\t\
Meta+U\n\t\t\
  Convert word to uppercase\n\t\
Meta+L\n\t\t\
  Convert word to lowercase\n\t\
Meta+0 through Meta+9 then key\n\t\t\
  Repeat the specified number of times\n\
\n\
Where, for example, "Ctrl+A" means hold down the Control key and press A.\n\
Where "Meta" is "Alt" on many keyboards.\n\
Line editing support is derived from JLine 3.

help.shortcuts.summary = a description of keystrokes for snippet and command completion,\n\
information access, and automatic code generation
help.shortcuts =\
Supported shortcuts include:\n\
\n\t\
Tab\n\t\t\
        After entering the first few letters of a Java identifier,\n\t\t\
        a jshell tool command, or, in some cases, a jshell tool\n\t\t\
        command argument, press the Tab key to complete the input.\n\t\t\
        If there is more than one completion, then possible completions\n\t\t\
        will be shown.\n\t\t\
        Another Tab will show documentation if available and appropriate.\n\n\t\
Shift+Tab then v\n\t\t\
        After a complete expression, hold down the Shift key while\n\t\t\
        pressing the Tab key, then release and press the "v" key,\n\t\t\
        the expression will be converted to a variable declaration \n\t\t\
        whose type is based on the type of the expression.\n\n\t\
Shift+Tab then m\n\t\t\
        After a complete expression or statement, hold down the\n\t\t\
        Shift key while pressing the Tab key, then release and press\n\t\t\
        the "m" key, the expression or statement will be converted\n\t\t\
        to a method declaration. If it is an expression, the method\n\t\t\
        return type will be based on the type of the expression.\n\n\t\
Shift+Tab then i\n\t\t\
        After an unresolvable identifier, hold down the Shift key\n\t\t\
        while pressing the Tab key, then release and press the "i" key,\n\t\t\
        and the jshell tool will propose possible imports which will\n\t\t\
        resolve the identifier based on the content of the specified\n\t\t\
        classpath. Enter the digit corresponding to the desired import,\n\t\t\
        or press the "0" key to add no imports.\n\
\n\
For information onother special keys see: /help keys

help.context.summary = a description of the evaluation context options for /env /reload and /reset
help.context =\
These options configure the evaluation context.  They can be specified on the\n\
command-line when the jshell tool is started or as command options when the jshell tool is\n\
restarted with the commands /env, /reload, or /reset.\n\
\n\
They are:\n\t\
    --class-path <path>\n\t\t\
                  The <path> is a list of directories, JAR archives,\n\t\t\
                  and ZIP archives to search for class files.\n\t\t\
                  For Windows, use a semicolon (;) to separate items in the\n\t\t\
                  path. On other platforms, use a  colon (:) to separate items.\n\t\
    --module-path <path>...\n\t\t\
                  The <path> is a list of directories, JAR archives,\n\t\t\
                  and ZIP archives to search for modules.\n\t\t\
                  For Windows, use a semicolon (;) to separate items in the\n\t\t\
                  path. On other platforms, use a  colon (:) to separate items.\n\t\
    --add-modules <modulename>[,<modulename>...]\n\t\t\
                  root modules to resolve in addition to the initial module.\n\t\t\
                  <modulename> can also be ALL-DEFAULT, ALL-SYSTEM,\n\t\t\
                  ALL-MODULE-PATH.\n\t\
    --add-exports <module>/<package>=<target-module>(,<target-module>)*\n\t\t\
                  updates <module> to export <package> to <target-module>,\n\t\t\
                  regardless of module declaration.\n\t\t\
                  <target-module> can be ALL-UNNAMED to export to all\n\t\t\
                  unnamed modules. In jshell, if the <target-module> is not\n\t\t\
                  specified (no =) then ALL-UNNAMED is used.\n\
\n\
Evaluation context options entered on the command line or provided with a\n\
previous /reset, /env, or /reload command are maintained unless an option is\n\
entered that overwrites the setting.\n\
\n\
On the command-line these options must have two dashes, e.g.: --module-path\n\
On the jshell tool commands they can have one or two dashes, e.g.: -module-path

help.id.summary = a description of snippet IDs and how use them
help.id =\
Every snippet of code you enter has its own unique snippet ID.  Even if you\n\
enter the same snippet again, it will have a new ID.  For normal snippets the ID\n\
is an increasing number.  Snippets which fail with an error have a snippet ID\n\
which begins with 'e'.  Snippets in the startup have an ID which begins with 's'.\n\
\n\
A snippet ID is one way to refer to a snippet in a command.  For example, this\n\
command drops the snippet with ID '14':\n\
\n\t\
        /drop 14\n\
\n\
To see the ID of a snippet or snippets use the '/list' command.  To see the ID\n\
of all snippets. including failed, startup, and overwritten snippets, use the\n\
'/list -all' command.\n\
\n\
You can also refer to a range of IDs by separating the beginning ID and ending\n\
ID with a hypen.  For example, '1-4' is the same as '1 2 3 4'.  All commands\n\
which refer to snippets will take a list of IDs, ID ranges, and snippet names\n\
as arguments.  These commands are: /list, /edit, /drop, /save, /vars, /methods,\n\
/types, and /<id>.  Some examples:\n\
\n\t\
        /edit 7-23\n\
\n\t\
        /save s1-s4 3-8 foo 12 myfile\n\
\n\t\
        /9-12 33\n\
\n\
See '/help /edit', '/help /save', and '/help rerun' respectively.

help.rerun.summary = a description of ways to re-evaluate previously entered snippets
help.rerun =\
There are four ways to re-evaluate previously entered snippets.\n\
The last snippet can be re-evaluated using: /!\n\
The n-th previous snippet can be re-evaluated by slash-minus and the digits of n, e.g.:  /-4\n\
For example:\n\
\n\
    \tjshell> 2 + 2\n\
    \t$1 ==> 4\n\
\n\
    \tjshell> /!\n\
    \t2 + 2\n\
    \t$2 ==> 4\n\
\n\
    \tjshell> int z\n\
    \tz ==> 0\n\
\n\
    \tjshell> /-1\n\
    \tint z;\n\
    \tz ==> 0\n\
\n\
    \tjshell> /-4\n\
    \t2 + 2\n\
    \t$5 ==> 4\n\
\n\
The snippets to re-evaluate may be specified by snippet ID or ID range.\n\
An ID range is represented as a two IDs separated by a hyphen, e.g.:  3-17\n\
Startup and error snippets maybe used, e.g.:  s3-s9    or   e1-e4\n\
Any number of IDs or ID ranges may be used, e.g.:  /3-7 s4 14-16 e2\n\
See also '/help id'.\n\
\n\
Finally, you can search backwards through history by entering Ctrl+R followed by the string to search for.

help.set._retain = \
The '-retain' option saves a setting so that it is used in future sessions.\n\
The -retain option can be used on the following forms of /set:\n\n\t\
/set editor -retain\n\t\
/set start -retain\n\t\
/set feedback -retain\n\t\
/set mode -retain\n\n\
See these commands for more detail -- for example /help /set editor

help.set.format.summary = \
Set the format for reporting a snippet event

help.set.format = \
Set the format for reporting a snippet event:\n\
\n\t\
/set format <mode> <field> "<format>" <selector>...\n\
\n\
Show the format settings:\n\
\n\t\
/set format [<mode> [<field>]]\n\
\n\
Where <mode> is the name of a previously defined feedback mode -- see '/help /set mode'.\n\
Where <field> is the name of context-specific format to define.\n\
Where <format> is a quoted string which will be the value of the field if one of\n\
the selectors matches (or there are no selectors). When the format is used,\n\
field names enclosed in braces are replaced with the value of the field at that\n\
time. These fields may have been previously defined with this command or may be\n\
one of these predefined fields specific to the context:\n\t\
{name}       == The name, e.g.: the variable name, ...\n\t\
{type}       == The type name. The type of a variable or expression, the\n\t\t\t\
                 parameter types of a method\n\t\
{value}      == The result value of an expression or variable initialization\n\t\
{unresolved} == The list of unresolved references\n\t\
{errors}     == The list of recoverable errors (during the processing of the\n\t\t\t\
                "display" field only)\n\t\
{err}        == An unformatted error line (during the processing of the\n\t\t\t\
                "errorline" field only)\n\
The following fields are accessed by the tool to determine the displayed feedback:\n\t\
{display}    == The displayed message for a snippet event\n\t\
{errorline}  == The format of one error line within the "errors" field\n\t\
{pre}        == The feedback prefix (begins command feedback)\n\t\
{post}       == The feedback postfix (ends command feedback)\n\t\
{errorpre}   == The error prefix (begins error feedback)\n\t\
{errorpost}  == The error postfix (ends error feedback)\n\
These fields have default settings (which may be overwritten).\n\
Where <selector> is the context in which the format is applied.\n\
The structure of selector is a hyphen separated list of selector kind lists.\n\
A selector kind list is a comma separated list of values of one selector kind.\n\
A selector matches if each selector kind list matches; A selector kind list\n\
matches if one of the values matches.\n\n\
The case selector kind describes the kind of snippet.  The values are:\n\t\
   import     -- import declaration\n\t\
   class      -- class declaration\n\t\
   interface  -- interface declaration\n\t\
   enum       -- enum declaration\n\t\
   annotation -- annotation interface declaration\n\t\
   record     -- record declaration\n\t\
   method     -- method declaration -- note: {type}==parameter-types\n\t\
   vardecl    -- variable declaration without init\n\t\
   varinit    -- variable declaration with init\n\t\
   expression -- expression -- note: {name}==scratch-variable-name\n\t\
   varvalue   -- variable value expression\n\t\
   assignment -- assign variable\n\t\
   statement  -- statement\n\
The action selector kind describes what happened to the snippet.  The values are:\n\t\
   added     -- snippet has been added\n\t\
   modified  -- an existing snippet has been modified\n\t\
   replaced  -- an existing snippet has been replaced with a new snippet\n\t\
   overwrote -- an existing snippet has been overwritten\n\t\
   dropped   -- snippet has been dropped\n\t\
   used      -- snippet was used when it cannot be\n\
The when-did-it-occur selector kind describes if this is a direct or indirect action.  The values are:\n\t\
   primary -- the entered snippet\n\t\
   update  -- an update to a dependent snippet\n\
The resolution-state selector kind describes the state of resolution/definition of the snippet.  The values are:\n\t\
   ok         -- resolved correctly\n\t\
   defined    -- defined despite recoverably unresolved references\n\t\
   notdefined -- not defined because of recoverably unresolved references\n\
The unresolved-count selector kind describes the number of unresolved references.  The values are:\n\t\
   unresolved0 -- no names are unresolved\n\t\
   unresolved1 -- one name is unresolved\n\t\
   unresolved2 -- two or more names are unresolved\n\
The errors-count selector kind describes the number of errors.  The values are:\n\t\
   error0 -- no errors\n\t\
   error1 -- one error\n\t\
   error2 -- two or more errors\n\n\
Examples:\n\t\
/set format mymode action 'Created' added-primary\n\t\
/set format mymode action 'Update replaced' replaced-update\n\t\
/set format mymode display '{pre}{action} class {name}{post}' class-ok\n\t\
/set format mymode display '{pre}{action} variable {name}, reset to null{post}' replaced-vardecl,varinit-ok-update\n\n\
Note that subsequent selectors for a field may overwrite some or all of previous used selectors -- last one wins\n\
\n\
The form without <format> shows the current format settings.\n\
When the <mode> is specified only the format settings for that mode are shown.\n\
When both the <mode> and <field> are specified only the format settings for that\n\
mode and field are shown.  Example:\n\t\
/set format mymode\n\
shows the format settings for the mode mymode\n

help.set.truncation.summary = \
Set the max length of a displayed value

help.set.truncation = \
Set the max length of a displayed value:\n\
\n\t\
/set truncation <mode> <length> <selector>...\n\
\n\
Show the current truncation settings:\n\
\n\t\
/set truncation [<mode>]\n\
\n\
Where <mode> is the name of a previously defined feedback mode -- see '/help /set mode'.\n\
Where <length> is an unsigned integer representing a maximum length.\n\
Where <selector> is only needed if you wish to fine-tune value truncation length\n\
by context, <selector> is the context in which the truncation is applied.\n\
The structure of selector is a hyphen separated list of selector kind lists.\n\
A selector kind list is a comma separated list of values of one selector kind.\n\
A selector matches if each selector kind list matches; A selector kind list\n\
matches if one of the values matches.\n\n\
Below are the relevant selector kinds for truncation.\n\n\
The case selector kind describes the kind of snippet.  The values are:\n\t\
   vardecl    -- variable declaration without init\n\t\
   varinit    -- variable declaration with init\n\t\
   expression -- expression -- note: {name}==scratch-variable-name\n\t\
   varvalue   -- variable value expression\n\t\
   assignment -- assign variable\n\
The action selector kind describes what happened to the snippet.  The values are:\n\t\
   added     -- snippet has been added\n\t\
   modified  -- an existing snippet has been modified\n\t\
   replaced  -- an existing snippet has been replaced with a new snippet\n\
Examples:\n\t\
/set trunc mymode 80\n\t\
/set truncation mymode 45 expression\n\t\
/set truncation mymode 0 vardecl-modified,replaced\n\n\
Note that subsequent selectors for a field may overwrite some or all of previous used selectors -- last one wins\n\
\n\
The form without <length> shows the truncation settings.\n\
When the <mode> is specified only the truncation settings for that mode are shown.\n\
Example:\n\t\
/set truncation mymode\n\
shows the truncation settings for the mode mymode\n

help.set.feedback.summary = \
Set the feedback mode describing displayed feedback for entered snippets and commands

help.set.feedback = \
Set the feedback mode describing displayed feedback for entered snippets and commands:\n\
\n\t\
/set feedback [-retain] <mode>\n\
\n\
Retain the current feedback mode for future sessions:\n\
\n\t\
/set feedback -retain\n\
\n\
Show the feedback mode and list available modes:\n\
\n\t\
/set feedback\n\
\n\
Where <mode> is the name of a previously defined feedback mode.\n\
You may use just enough letters to make it unique.\n\
User-defined modes can be added, see '/help /set mode'\n\
\n\
When the -retain option is used, the setting will be used in this and future\n\
runs of the jshell tool.\n\
\n\
The form without <mode> or -retain displays the current feedback mode and available modes.\n

help.set.mode.summary = \
Create a user-defined feedback mode, optionally copying from an existing mode

help.set.mode = \
Create a user-defined feedback mode, optionally copying from an existing mode:\n\
\n\t\
/set mode <new-mode> [<old-mode>] (-command|-quiet)\n\
\n\
Retain a user-defined feedback mode for future sessions:\n\
\n\t\
/set mode -retain <mode>\n\
\n\
Delete a user-defined feedback mode:\n\
\n\t\
/set mode -delete [-retain] <mode>\n\
\n\
Show feedback mode settings:\n\
\n\t\
/set mode [<mode>]\n\
\n\
Where <new-mode> is the name of a mode you wish to create.\n\
Where <old-mode> is the name of a existing feedback mode.\n\
Where <mode> is the name of a existing feedback mode.\n\
\n\
If <old-mode> is present, its settings are copied to the new mode.\n\
\n\
The feedback that a mode provides for entered snippets is determined by the\n\
'/set format' settings. However, for entered commands, feedback is either on or off,\n\
as determined by the option used when creating the mode; Either the option '-command'\n\
or the option '-quiet' must be specified. If '-command' is used, informative and\n\
verifying command feedback is displayed when in the new mode.  If '-quiet' is used,\n\
commands give only essential feedback (e.g., errors).\n\
\n\
Once the new mode is created, use '/set format', '/set prompt' and '/set truncation'\n\
to configure it.  Use '/set feedback' to use the new mode.\n\
\n\
When the '-retain' option is used (without the '-delete' option), the mode (including\n\
its current prompt, format, and truncation settings) will be stored for use in\n\
future runs of the jshell tool.  If retain is not used, the mode is only defined in\n\
the current session. After updating the mode's settings, retain the mode again to\n\
preserve the updates across sessions.\n\
\n\
When only the '-delete' option is used, the mode is deleted from the current session.\n\
When both '-retain' and '-delete' are used, the mode is deleted from the current and\n\
future sessions.\n\
\n\
When the form without options is used, the mode settings are displayed.\n\
When the <mode> is specified, only the mode settings for that mode are shown.\n\
Note: the settings for the mode include the settings for prompt, format, and\n\
truncation.\n\
Example:\n\t\
/set mode mymode\n\
\n\
shows the mode, prompt, format, and truncation settings for the mode mymode

help.set.prompt.summary = \
Set the prompts

help.set.prompt = \
Set the prompts.  Both the normal prompt and the continuation-prompt must be set:\n\
\n\t\
/set prompt <mode> \"<prompt>\" \"<continuation-prompt>\"\n\
\n\
Show the normal prompt and the continuation-prompts:\n\
\n\t\
/set prompt [<mode>]\n\
\n\
Where <mode> is the name of a previously defined feedback mode.\n\
Where <prompt> and <continuation-prompt> are quoted strings to be printed as input prompts.\n\
Both may optionally contain '%%s' which will be substituted with the next snippet ID --\n\
note that what is entered may not be assigned that ID, for example it may be an error or command.\n\
The continuation-prompt is used on the second and subsequent lines of a multi-line snippet.\n\
\n\
The form without <prompt> shows the currently set prompts.\n\
When the <mode> is specified only the prompts for that mode are shown.\n\
Example:\n\t\
/set prompt mymode\n\
shows the prompts set for the mode mymode\n

help.set.editor.summary =\
Specify the command to launch for the /edit command

help.set.editor =\
Specify the command to launch for the /edit command:\n\
\n\t\
/set editor [-retain] [-wait] <command>\n\
\n\t\
/set editor [-retain] -default\n\
\n\t\
/set editor [-retain] -delete\n\
\n\
Retain the current editor setting for future sessions:\n\
\n\t\
/set editor -retain\n\
\n\
Show the command to launch for the /edit command:\n\
\n\t\
/set editor\n\
\n\
The <command> is an operating system dependent string.\n\
The <command> may include space-separated arguments (such as flags)\n\n\
If the -default option is specified, the built-in default editor will be used.\n\n\
If the -delete option is specified, previous settings are ignored -- the editor\n\
settings are initialized as when starting the jshell tool.  Specifically, if there\n\
is a retained setting it is used (unless both -retain and -delete are specified --\n\
which deletes the retained setting), if one of these environment variables is set\n\
it will be used: JSHELLEDITOR, VISUAL, or EDITOR (in that order).  Otherwise the\n\
built-in default editor will be used.\n\n\
If <command> is specified, it will be used as the external editor. The <command>\n\
consists of the program and zero or more program arguments.  When <command>\n\
is used, the temporary file to edit will be appended as the last argument.\n\
Normally, edit mode will last until the external editor exits. Some external editors\n\
will exit immediately (for example, if the edit window exists) either external editor\n\
flags should be used to prevent immediate exit, or the -wait option should be used to\n\
prompt the user to indicate when edit mode should end.\n\n\
Note: while in edit mode no command inputs are seen.  After leaving edit mode changes\n\
to the edited snippets are not seen.\n\
\n\
When the -retain option is used, the setting will be used in this and future\n\
runs of the jshell tool.\n\
\n\
The form without <command> or options shows the editor setting.\n

help.set.start.summary =\
Set the startup configuration

help.set.start =\
Set the startup configuration -- a sequence of snippets and commands read at startup:\n\
\n\t\
/set start [-retain] <file>...\n\
\n\t\
/set start [-retain] -default\n\
\n\t\
/set start [-retain] -none\n\
\n\
Retain the startup configuration for future sessions:\n\
\n\t\
/set start -retain\n\
\n\
Show the startup setting:\n\
\n\t\
/set start\n\
\n\
The contents of the specified <file> become the startup snippets and commands used\n\
when the /reset, /reload, or /env commands are used in this session.\n\
If instead the -default option is specified, the predefined startup import\n\
snippets will be used.\n\
If the -none option is used, the startup will be empty -- no startup snippets\n\
or commands will be used.\n\
This command is good for testing the startup settings.  To retain them for future\n\
runs of the jshell tool use the command:\n\t\
/set start -retain\n\
\n\
When the -retain option is used, the setting will be used in this and future\n\
runs of the jshell tool.\n\
\n\
The form without <file> or options shows the startup setting.\n\
Note: if the startup was last set from a file, this is shown with the\n\
'set start' command followed by the contents of the file.\n\
\n\
The <file> may be an operating system file name, or one of the predefined\n\
startup file names: DEFAULT, PRINTING, or JAVASE.\n\
These are respectively: the default import snippets (as used by -default),\n\
definitions of print(), println(), and printf() method snippets, or\n\
imports of all Java SE packages.\n\
More than one <file> may be specified, for example:\n\
\n\t\
/set start -retain DEFAULT PRINTING

help.set.indent.summary =\
Specify the number of spaces that should be used to indent snippets

help.set.indent =\
Specify the number of spaces that should be used to indent snippets:\n\
\n\t\
/set indent <number>\n\
\n\
Show the indent setting:\n\
\n\t\
/set indent\n\

startup.feedback = \
/set mode verbose -command    \n\
\n\
/set prompt verbose '\\njshell> '   '   ...> '    \n\
\n\
/set format verbose pre '|  '    \n\
/set format verbose post '%n'    \n\
/set format verbose errorpre '|  '    \n\
/set format verbose errorpost '%n'    \n\
\n\
/set format verbose errorline '{post}{pre}    {err}'    \n\
\n\
/set format verbose action 'created' added-primary    \n\
/set format verbose action 'modified' modified-primary    \n\
/set format verbose action 'replaced' replaced-primary    \n\
/set format verbose action 'overwrote' overwrote-primary    \n\
/set format verbose action 'dropped' dropped-primary    \n\
/set format verbose action '  update created' added-update    \n\
/set format verbose action '  update modified' modified-update    \n\
/set format verbose action '  update replaced' replaced-update    \n\
/set format verbose action '  update overwrote' overwrote-update    \n\
/set format verbose action '  update dropped' dropped-update    \n\
\n\
/set format verbose until ', however, it cannot be instantiated or its methods invoked until'   defined-class,record-primary    \n\
/set format verbose until ', however, its methods cannot be invoked until'                      defined-interface-primary    \n\
/set format verbose until ', however, it cannot be used until'                                  defined-enum,annotation-primary    \n\
/set format verbose until ', however, it cannot be invoked until'                               defined-method-primary    \n\
/set format verbose until ', however, it cannot be referenced until'                            notdefined-primary    \n\
/set format verbose until ' which cannot be instantiated or its methods invoked until'          defined-class,record-update    \n\
/set format verbose until ' whose methods cannot be invoked until'                              defined-interface-update    \n\
/set format verbose until ' which cannot be invoked until'                                      defined-method-update    \n\
/set format verbose until ' which cannot be referenced until'                                   notdefined-update    \n\
\n\
/set format verbose unrerr '{unresolved} is declared'                                           unresolved1-error0    \n\
/set format verbose unrerr '{unresolved} are declared'                                          unresolved2-error0    \n\
/set format verbose unrerr ' this error is corrected: {errors}'                                 unresolved0-error1    \n\
/set format verbose unrerr '{unresolved} is declared and this error is corrected: {errors}'     unresolved1-error1    \n\
/set format verbose unrerr '{unresolved} are declared and this error is corrected: {errors}'    unresolved2-error1    \n\
/set format verbose unrerr ' these errors are corrected: {errors}'                              unresolved0-error2    \n\
/set format verbose unrerr '{unresolved} is declared and these errors are corrected: {errors}'  unresolved1-error2    \n\
/set format verbose unrerr '{unresolved} are declared and these errors are corrected: {errors}' unresolved2-error2    \n\
\n\
/set format verbose resolve '{until}{unrerr}'                                                   defined,notdefined-added,modified,replaced,used    \n\
\n\
/set format verbose typeKind 'class'                  class    \n\
/set format verbose typeKind 'interface'              interface    \n\
/set format verbose typeKind 'enum'                   enum    \n\
/set format verbose typeKind 'annotation interface'   annotation    \n\
/set format verbose typeKind 'record'                 record    \n\
\n\
/set format verbose result '{name} ==> {value}{post}'                                        added,modified,replaced-ok-primary    \n\
\n\
/set format verbose display '{result}{pre}created scratch variable {name} : {type}{post}'    expression-added,modified,replaced-primary    \n\
/set format verbose display '{result}{pre}value of {name} : {type}{post}'                    varvalue-added,modified,replaced-primary    \n\
/set format verbose display '{result}{pre}assigned to {name} : {type}{post}'                 assignment-primary    \n\
/set format verbose display '{result}{pre}{action} variable {name} : {type}{resolve}{post}'  varinit,vardecl    \n\
/set format verbose display '{pre}{action} variable {name}{resolve}{post}'                   vardecl,varinit-notdefined    \n\
/set format verbose display '{pre}{action} variable {name}{post}'                            dropped-vardecl,varinit,expression    \n\
/set format verbose display '{pre}{action} variable {name}, reset to null{post}'             replaced-vardecl,varinit-ok-update    \n\
\n\
/set format verbose display '{pre}{action} {typeKind} {name}{resolve}{post}'                 class,interface,enum,annotation,record    \n\
/set format verbose display '{pre}{action} method {name}({type}){resolve}{post}'             method    \n\
\n\
/set format verbose display '{pre}attempted to use {typeKind} {name}{resolve}{post}'         used-class,interface,enum,annotation,record    \n\
/set format verbose display '{pre}attempted to call method {name}({type}){resolve}{post}'    used-method    \n\
\n\
/set truncation verbose 80\n\
/set truncation verbose 1000                                                                  varvalue,expression\n\
\n\
/set mode normal -command verbose    \n\
/set format normal display ''                                                               added,modified,replaced,overwrote,dropped-update    \n\
/set format normal display '{pre}{action} variable {name}, reset to null{post}'             replaced-vardecl,varinit-ok-update    \n\
/set format normal display '{pre}{action} variable {name}{resolve}{post}'                   replaced-vardecl,varinit-notdefined    \n\
/set format normal display '{result}'                                                       added,modified,replaced-expression,varvalue,assignment,varinit,vardecl-ok-primary    \n\
/set mode concise -quiet normal    \n\
\n\
/set prompt concise 'jshell> '   '   ...> '    \n\
\n\
/set format concise display ''                                                              class,interface,enum,annotation,record,method,assignment,varinit,vardecl-ok    \n\
\n\
/set feedback normal    \n\
\n\
/set mode silent -quiet    \n\
/set prompt silent '-> ' '>> '    \n\
/set truncation silent 80\n\
/set truncation silent 1000                                                                  varvalue,expression\n\
/set format silent pre '|  '    \n\
/set format silent post '%n'    \n\
/set format silent errorpre '|  '    \n\
/set format silent errorpost '%n'    \n\
/set format silent display ''    \n
