/*
 * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.org.apache.xalan.internal.xsltc.compiler;

import com.sun.java_cup.internal.runtime.*;
import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
import com.sun.org.apache.xalan.internal.xsltc.runtime.Operators;
import com.sun.org.apache.xml.internal.dtm.Axis;
import com.sun.org.apache.xml.internal.dtm.DTM;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * CUP v0.11b generated parser.
 * This class was generated by CUP v0.11b on Nov 12, 2019.
 *
 * @LastModified: Nov 2019
 */
public class XPathParser extends lr_parser {

    /**
     * Default constructor.
     */
    public XPathParser() {
        super();
    }

    /**
     * Constructor which sets the default scanner.
     */
    public XPathParser(Scanner s) {
        super(s);
    }

    /**
     * Production table.
     */
    protected static final short _production_table[][]
            = unpackFromStrings(new String[]{
        "\000\215\000\002\002\004\000\002\003\004\000\002\003"
        + "\004\000\002\036\003\000\002\036\005\000\002\037\003"
        + "\000\002\037\004\000\002\037\003\000\002\037\005\000"
        + "\002\037\005\000\002\037\004\000\002\037\003\000\002"
        + "\035\006\000\002\035\010\000\002\040\006\000\002\041"
        + "\003\000\002\041\005\000\002\041\005\000\002\042\003"
        + "\000\002\042\004\000\002\042\003\000\002\042\004\000"
        + "\002\042\004\000\002\042\005\000\002\042\004\000\002"
        + "\042\005\000\002\043\003\000\002\043\003\000\002\043"
        + "\003\000\002\043\003\000\002\043\003\000\002\044\003"
        + "\000\002\044\003\000\002\054\003\000\002\054\004\000"
        + "\002\054\004\000\002\045\003\000\002\045\004\000\002"
        + "\007\005\000\002\004\003\000\002\012\003\000\002\012"
        + "\005\000\002\013\003\000\002\013\005\000\002\014\003"
        + "\000\002\014\005\000\002\014\005\000\002\015\003\000"
        + "\002\015\005\000\002\015\005\000\002\015\005\000\002"
        + "\015\005\000\002\016\003\000\002\016\005\000\002\016"
        + "\005\000\002\017\003\000\002\017\005\000\002\017\005"
        + "\000\002\017\005\000\002\020\003\000\002\020\004\000"
        + "\002\024\003\000\002\024\005\000\002\025\003\000\002"
        + "\025\003\000\002\025\005\000\002\025\005\000\002\006"
        + "\003\000\002\006\003\000\002\027\003\000\002\027\005"
        + "\000\002\027\003\000\002\031\003\000\002\031\004\000"
        + "\002\031\003\000\002\030\005\000\002\032\004\000\002"
        + "\011\003\000\002\011\004\000\002\011\005\000\002\011"
        + "\004\000\002\011\003\000\002\053\004\000\002\053\003"
        + "\000\002\052\003\000\002\052\003\000\002\052\003\000"
        + "\002\052\003\000\002\052\003\000\002\052\003\000\002"
        + "\052\003\000\002\052\003\000\002\052\003\000\002\052"
        + "\003\000\002\052\003\000\002\052\003\000\002\052\003"
        + "\000\002\026\003\000\002\026\003\000\002\010\003\000"
        + "\002\010\004\000\002\023\003\000\002\023\005\000\002"
        + "\023\003\000\002\023\003\000\002\023\003\000\002\023"
        + "\003\000\002\021\004\000\002\022\005\000\002\022\006"
        + "\000\002\046\003\000\002\046\005\000\002\050\003\000"
        + "\002\051\003\000\002\005\003\000\002\033\003\000\002"
        + "\033\003\000\002\033\003\000\002\033\003\000\002\033"
        + "\006\000\002\033\003\000\002\034\003\000\002\034\003"
        + "\000\002\047\003\000\002\047\003\000\002\047\003\000"
        + "\002\047\003\000\002\047\003\000\002\047\003\000\002"
        + "\047\003\000\002\047\003\000\002\047\003\000\002\047"
        + "\003\000\002\047\003\000\002\047\003\000\002\047\003"
        + "\000\002\047\003\000\002\047\003\000\002\047\003\000"
        + "\002\047\003\000\002\047\003"});

    /**
     * Access to production table.
     */
    public short[][] production_table() {
        return _production_table;
    }

    /**
     * Parse-action table.
     */
    protected static final short[][] _action_table
            = unpackFromStrings(new String[]{
        "\000\307\000\006\066\006\067\005\001\002\000\004\002"
        + "\311\001\002\000\110\004\061\005\111\011\071\013\103"
        + "\015\134\016\066\017\106\021\070\031\075\032\031\033"
        + "\040\034\057\035\034\036\113\037\141\040\142\041\145"
        + "\044\063\045\062\046\065\047\115\050\123\051\136\052"
        + "\077\053\143\054\131\055\125\056\116\057\104\060\140"
        + "\061\067\062\060\063\127\064\132\065\072\001\002\000"
        + "\070\004\013\013\027\016\020\021\023\032\031\033\040"
        + "\035\034\036\033\037\046\040\047\041\051\044\015\045"
        + "\014\046\016\047\036\050\037\051\044\052\025\053\050"
        + "\054\043\055\041\056\035\057\030\060\045\061\021\062"
        + "\012\063\042\001\002\000\006\002\ufffe\010\306\001\002"
        + "\000\004\002\000\001\002\000\014\002\uffe7\004\uffe7\006"
        + "\uffe7\010\uffe7\021\uffe7\001\002\000\054\002\uff7a\004\uff7a"
        + "\006\uff7a\007\uff7a\010\uff7a\012\uff7a\013\uff7a\014\uff7a\021"
        + "\uff7a\022\uff7a\023\uff7a\024\uff7a\025\uff7a\026\uff7a\027\uff7a"
        + "\030\uff7a\031\uff7a\032\uff7a\033\uff7a\042\uff7a\043\uff7a\001"
        + "\002\000\070\002\ufffc\010\ufffc\013\027\016\020\032\031"
        + "\033\040\035\034\036\113\037\141\040\047\041\051\044"
        + "\015\045\014\046\016\047\036\050\037\051\044\052\025"
        + "\053\050\054\043\055\041\056\035\057\030\060\045\061"
        + "\021\062\012\063\042\001\002\000\014\002\uffe3\004\uffe3"
        + "\006\uffe3\010\uffe3\021\uffe3\001\002\000\014\002\uffe4\004"
        + "\uffe4\006\uffe4\010\uffe4\021\uffe4\001\002\000\004\011\302"
        + "\001\002\000\012\002\ufffa\004\277\010\ufffa\021\276\001"
        + "\002\000\062\013\uffe0\032\uffe0\033\uffe0\035\uffe0\036\uffe0"
        + "\037\uffe0\040\uffe0\041\uffe0\044\uffe0\045\uffe0\046\uffe0\047"
        + "\uffe0\050\uffe0\051\uffe0\052\uffe0\053\uffe0\054\uffe0\055\uffe0"
        + "\056\uffe0\057\uffe0\060\uffe0\061\uffe0\062\uffe0\063\uffe0\001"
        + "\002\000\054\002\uff7b\004\uff7b\006\uff7b\007\uff7b\010\uff7b"
        + "\012\uff7b\013\uff7b\014\uff7b\021\uff7b\022\uff7b\023\uff7b\024"
        + "\uff7b\025\uff7b\026\uff7b\027\uff7b\030\uff7b\031\uff7b\032\uff7b"
        + "\033\uff7b\042\uff7b\043\uff7b\001\002\000\062\013\027\032"
        + "\031\033\040\035\034\036\113\037\141\040\047\041\051"
        + "\044\015\045\014\046\016\047\036\050\037\051\044\052"
        + "\170\053\166\054\043\055\041\056\035\057\030\060\045"
        + "\061\021\062\012\063\042\001\002\000\064\013\027\016"
        + "\020\032\031\033\040\035\034\036\113\037\141\040\047"
        + "\041\051\044\015\045\014\046\016\047\036\050\037\051"
        + "\044\052\025\053\050\054\043\055\041\056\035\057\030"
        + "\060\045\061\021\062\012\063\042\001\002\000\012\002"
        + "\ufff2\004\266\010\ufff2\021\265\001\002\000\016\002\uff7f"
        + "\004\uff7f\006\uff7f\010\uff7f\020\264\021\uff7f\001\002\000"
        + "\006\002\ufff6\010\ufff6\001\002\000\014\002\uffe2\004\uffe2"
        + "\006\uffe2\010\uffe2\021\uffe2\001\002\000\054\002\uff7d\004"
        + "\uff7d\006\uff7d\007\uff7d\010\uff7d\012\uff7d\013\uff7d\014\uff7d"
        + "\021\uff7d\022\uff7d\023\uff7d\024\uff7d\025\uff7d\026\uff7d\027"
        + "\uff7d\030\uff7d\031\uff7d\032\uff7d\033\uff7d\042\uff7d\043\uff7d"
        + "\001\002\000\056\002\uff85\004\uff85\006\uff85\007\uff85\010"
        + "\uff85\011\uff85\012\uff85\013\uff85\014\uff85\021\uff85\022\uff85"
        + "\023\uff85\024\uff85\025\uff85\026\uff85\027\uff85\030\uff85\031"
        + "\uff85\032\uff85\033\uff85\042\uff85\043\uff85\001\002\000\014"
        + "\002\uffed\004\uffed\006\055\010\uffed\021\uffed\001\002\000"
        + "\016\002\uff75\004\uff75\006\uff75\010\uff75\011\260\021\uff75"
        + "\001\002\000\056\002\uff86\004\uff86\006\uff86\007\uff86\010"
        + "\uff86\011\uff86\012\uff86\013\uff86\014\uff86\021\uff86\022\uff86"
        + "\023\uff86\024\uff86\025\uff86\026\uff86\027\uff86\030\uff86\031"
        + "\uff86\032\uff86\033\uff86\042\uff86\043\uff86\001\002\000\054"
        + "\002\uff7e\004\uff7e\006\uff7e\007\uff7e\010\uff7e\012\uff7e\013"
        + "\uff7e\014\uff7e\021\uff7e\022\uff7e\023\uff7e\024\uff7e\025\uff7e"
        + "\026\uff7e\027\uff7e\030\uff7e\031\uff7e\032\uff7e\033\uff7e\042"
        + "\uff7e\043\uff7e\001\002\000\054\002\uff77\004\uff77\006\uff77"
        + "\007\uff77\010\uff77\012\uff77\013\uff77\014\uff77\021\uff77\022"
        + "\uff77\023\uff77\024\uff77\025\uff77\026\uff77\027\uff77\030\uff77"
        + "\031\uff77\032\uff77\033\uff77\042\uff77\043\uff77\001\002\000"
        + "\054\002\uff76\004\uff76\006\uff76\007\uff76\010\uff76\012\uff76"
        + "\013\uff76\014\uff76\021\uff76\022\uff76\023\uff76\024\uff76\025"
        + "\uff76\026\uff76\027\uff76\030\uff76\031\uff76\032\uff76\033\uff76"
        + "\042\uff76\043\uff76\001\002\000\056\002\uff84\004\uff84\006"
        + "\uff84\007\uff84\010\uff84\011\uff84\012\uff84\013\uff84\014\uff84"
        + "\021\uff84\022\uff84\023\uff84\024\uff84\025\uff84\026\uff84\027"
        + "\uff84\030\uff84\031\uff84\032\uff84\033\uff84\042\uff84\043\uff84"
        + "\001\002\000\054\002\uff81\004\uff81\006\uff81\007\uff81\010"
        + "\uff81\012\uff81\013\uff81\014\uff81\021\uff81\022\uff81\023\uff81"
        + "\024\uff81\025\uff81\026\uff81\027\uff81\030\uff81\031\uff81\032"
        + "\uff81\033\uff81\042\uff81\043\uff81\001\002\000\054\002\uff78"
        + "\004\uff78\006\uff78\007\uff78\010\uff78\012\uff78\013\uff78\014"
        + "\uff78\021\uff78\022\uff78\023\uff78\024\uff78\025\uff78\026\uff78"
        + "\027\uff78\030\uff78\031\uff78\032\uff78\033\uff78\042\uff78\043"
        + "\uff78\001\002\000\054\002\uff82\004\uff82\006\uff82\007\uff82"
        + "\010\uff82\012\uff82\013\uff82\014\uff82\021\uff82\022\uff82\023"
        + "\uff82\024\uff82\025\uff82\026\uff82\027\uff82\030\uff82\031\uff82"
        + "\032\uff82\033\uff82\042\uff82\043\uff82\001\002\000\054\002"
        + "\uff79\004\uff79\006\uff79\007\uff79\010\uff79\012\uff79\013\uff79"
        + "\014\uff79\021\uff79\022\uff79\023\uff79\024\uff79\025\uff79\026"
        + "\uff79\027\uff79\030\uff79\031\uff79\032\uff79\033\uff79\042\uff79"
        + "\043\uff79\001\002\000\054\002\uff7c\004\uff7c\006\uff7c\007"
        + "\uff7c\010\uff7c\012\uff7c\013\uff7c\014\uff7c\021\uff7c\022\uff7c"
        + "\023\uff7c\024\uff7c\025\uff7c\026\uff7c\027\uff7c\030\uff7c\031"
        + "\uff7c\032\uff7c\033\uff7c\042\uff7c\043\uff7c\001\002\000\016"
        + "\002\uff83\004\uff83\006\uff83\010\uff83\011\253\021\uff83\001"
        + "\002\000\014\002\uffe5\004\uffe5\006\uffe5\010\uffe5\021\uffe5"
        + "\001\002\000\016\002\uff80\004\uff80\006\uff80\010\uff80\020"
        + "\252\021\uff80\001\002\000\014\002\uffe6\004\uffe6\006\uffe6"
        + "\010\uffe6\021\uffe6\001\002\000\014\002\uffe1\004\uffe1\006"
        + "\uffe1\010\uffe1\021\uffe1\001\002\000\014\002\uffef\004\uffef"
        + "\006\055\010\uffef\021\uffef\001\002\000\054\002\uffdd\004"
        + "\uffdd\006\055\007\uffdd\010\uffdd\012\uffdd\013\uffdd\014\uffdd"
        + "\021\uffdd\022\uffdd\023\uffdd\024\uffdd\025\uffdd\026\uffdd\027"
        + "\uffdd\030\uffdd\031\uffdd\032\uffdd\033\uffdd\042\uffdd\043\uffdd"
        + "\001\002\000\110\004\061\005\111\011\071\013\103\015"
        + "\134\016\066\017\106\021\070\031\075\032\031\033\040"
        + "\034\057\035\034\036\113\037\141\040\142\041\145\044"
        + "\063\045\062\046\065\047\115\050\123\051\136\052\077"
        + "\053\143\054\131\055\125\056\116\057\104\060\140\061"
        + "\067\062\060\063\127\064\132\065\072\001\002\000\012"
        + "\002\uffee\004\uffee\010\uffee\021\uffee\001\002\000\054\002"
        + "\uff9a\004\uff9a\006\uff9a\007\uff9a\010\uff9a\012\uff9a\013\uff9a"
        + "\014\uff9a\021\uff9a\022\uff9a\023\uff9a\024\uff9a\025\uff9a\026"
        + "\uff9a\027\uff9a\030\uff9a\031\uff9a\032\uff9a\033\uff9a\042\uff9a"
        + "\043\uff9a\001\002\000\060\002\uff7a\004\uff7a\006\uff7a\007"
        + "\uff7a\010\uff7a\011\uff7a\012\uff7a\013\uff7a\014\uff7a\020\uffa5"
        + "\021\uff7a\022\uff7a\023\uff7a\024\uff7a\025\uff7a\026\uff7a\027"
        + "\uff7a\030\uff7a\031\uff7a\032\uff7a\033\uff7a\042\uff7a\043\uff7a"
        + "\001\002\000\126\002\uffb9\005\111\007\uffb9\010\uffb9\012"
        + "\uffb9\013\103\014\uffb9\016\066\017\106\022\uffb9\023\uffb9"
        + "\024\uffb9\025\uffb9\026\uffb9\027\uffb9\030\uffb9\031\uffb9\032"
        + "\031\033\040\035\034\036\113\037\141\040\142\041\145"
        + "\042\uffb9\043\uffb9\044\063\045\062\046\065\047\115\050"
        + "\123\051\136\052\077\053\143\054\131\055\125\056\116"
        + "\057\104\060\140\061\067\062\060\063\127\001\002\000"
        + "\054\002\uff89\004\uff89\006\uff89\007\uff89\010\uff89\012\uff89"
        + "\013\uff89\014\uff89\021\uff89\022\uff89\023\uff89\024\uff89\025"
        + "\uff89\026\uff89\027\uff89\030\uff89\031\uff89\032\uff89\033\uff89"
        + "\042\uff89\043\uff89\001\002\000\054\002\uff8b\004\uff8b\006"
        + "\uff8b\007\uff8b\010\uff8b\012\uff8b\013\uff8b\014\uff8b\021\uff8b"
        + "\022\uff8b\023\uff8b\024\uff8b\025\uff8b\026\uff8b\027\uff8b\030"
        + "\uff8b\031\uff8b\032\uff8b\033\uff8b\042\uff8b\043\uff8b\001\002"
        + "\000\032\002\uffd5\007\uffd5\012\uffd5\014\uffd5\022\uffd5\023"
        + "\uffd5\024\221\025\222\026\223\027\224\042\uffd5\043\uffd5"
        + "\001\002\000\004\011\245\001\002\000\062\013\uffae\032"
        + "\uffae\033\uffae\035\uffae\036\uffae\037\uffae\040\uffae\041\uffae"
        + "\044\uffae\045\uffae\046\uffae\047\uffae\050\uffae\051\uffae\052"
        + "\uffae\053\uffae\054\uffae\055\uffae\056\uffae\057\uffae\060\uffae"
        + "\061\uffae\062\uffae\063\uffae\001\002\000\060\002\uff7b\004"
        + "\uff7b\006\uff7b\007\uff7b\010\uff7b\011\uff7b\012\uff7b\013\uff7b"
        + "\014\uff7b\020\uffa6\021\uff7b\022\uff7b\023\uff7b\024\uff7b\025"
        + "\uff7b\026\uff7b\027\uff7b\030\uff7b\031\uff7b\032\uff7b\033\uff7b"
        + "\042\uff7b\043\uff7b\001\002\000\070\005\111\013\103\016"
        + "\066\017\106\032\031\033\040\035\034\036\113\037\141"
        + "\040\142\041\145\044\063\045\062\046\065\047\115\050"
        + "\123\051\136\052\077\053\143\054\131\055\125\056\116"
        + "\057\104\060\140\061\067\062\060\063\127\001\002\000"
        + "\110\004\061\005\111\011\071\013\103\015\134\016\066"
        + "\017\106\021\070\031\075\032\031\033\040\034\057\035"
        + "\034\036\113\037\141\040\142\041\145\044\063\045\062"
        + "\046\065\047\115\050\123\051\136\052\077\053\143\054"
        + "\131\055\125\056\116\057\104\060\140\061\067\062\060"
        + "\063\127\064\132\065\072\001\002\000\054\002\uff99\004"
        + "\uff99\006\uff99\007\uff99\010\uff99\012\uff99\013\uff99\014\uff99"
        + "\021\uff99\022\uff99\023\uff99\024\uff99\025\uff99\026\uff99\027"
        + "\uff99\030\uff99\031\uff99\032\uff99\033\uff99\042\uff99\043\uff99"
        + "\001\002\000\046\002\uffb7\007\uffb7\010\uffb7\012\uffb7\013"
        + "\uffb7\014\uffb7\022\uffb7\023\uffb7\024\uffb7\025\uffb7\026\uffb7"
        + "\027\uffb7\030\uffb7\031\uffb7\032\uffb7\033\uffb7\042\uffb7\043"
        + "\uffb7\001\002\000\054\002\uff97\004\uff97\006\uff97\007\uff97"
        + "\010\uff97\012\uff97\013\uff97\014\uff97\021\uff97\022\uff97\023"
        + "\uff97\024\uff97\025\uff97\026\uff97\027\uff97\030\uff97\031\uff97"
        + "\032\uff97\033\uff97\042\uff97\043\uff97\001\002\000\110\004"
        + "\061\005\111\011\071\013\103\015\134\016\066\017\106"
        + "\021\070\031\075\032\031\033\040\034\057\035\034\036"
        + "\113\037\141\040\142\041\145\044\063\045\062\046\065"
        + "\047\115\050\123\051\136\052\077\053\143\054\131\055"
        + "\125\056\116\057\104\060\140\061\067\062\060\063\127"
        + "\064\132\065\072\001\002\000\016\002\uffd9\007\uffd9\012"
        + "\uffd9\014\uffd9\042\uffd9\043\234\001\002\000\060\002\uff7f"
        + "\004\uff7f\006\uff7f\007\uff7f\010\uff7f\011\uff7f\012\uff7f\013"
        + "\uff7f\014\uff7f\020\uffaa\021\uff7f\022\uff7f\023\uff7f\024\uff7f"
        + "\025\uff7f\026\uff7f\027\uff7f\030\uff7f\031\uff7f\032\uff7f\033"
        + "\uff7f\042\uff7f\043\uff7f\001\002\000\062\013\103\032\031"
        + "\033\040\035\034\036\113\037\141\040\142\041\145\044"
        + "\063\045\062\046\065\047\036\050\037\051\044\052\170"
        + "\053\166\054\043\055\041\056\035\057\030\060\045\061"
        + "\021\062\012\063\042\001\002\000\004\020\236\001\002"
        + "\000\014\002\uffda\007\uffda\012\uffda\014\uffda\042\232\001"
        + "\002\000\054\002\uff88\004\uff88\006\uff88\007\uff88\010\uff88"
        + "\012\uff88\013\uff88\014\uff88\021\uff88\022\uff88\023\uff88\024"
        + "\uff88\025\uff88\026\uff88\027\uff88\030\uff88\031\uff88\032\uff88"
        + "\033\uff88\042\uff88\043\uff88\001\002\000\060\002\uff7d\004"
        + "\uff7d\006\uff7d\007\uff7d\010\uff7d\011\uff7d\012\uff7d\013\uff7d"
        + "\014\uff7d\020\uffa8\021\uff7d\022\uff7d\023\uff7d\024\uff7d\025"
        + "\uff7d\026\uff7d\027\uff7d\030\uff7d\031\uff7d\032\uff7d\033\uff7d"
        + "\042\uff7d\043\uff7d\001\002\000\022\002\uffd7\007\uffd7\012"
        + "\uffd7\014\uffd7\022\216\023\217\042\uffd7\043\uffd7\001\002"
        + "\000\052\002\uff9f\004\uff9f\007\uff9f\010\uff9f\012\uff9f\013"
        + "\uff9f\014\uff9f\021\uff9f\022\uff9f\023\uff9f\024\uff9f\025\uff9f"
        + "\026\uff9f\027\uff9f\030\uff9f\031\uff9f\032\uff9f\033\uff9f\042"
        + "\uff9f\043\uff9f\001\002\000\054\002\uffb4\004\uffb4\006\055"
        + "\007\uffb4\010\uffb4\012\uffb4\013\uffb4\014\uffb4\021\uffb4\022"
        + "\uffb4\023\uffb4\024\uffb4\025\uffb4\026\uffb4\027\uffb4\030\uffb4"
        + "\031\uffb4\032\uffb4\033\uffb4\042\uffb4\043\uffb4\001\002\000"
        + "\046\002\uffbd\007\uffbd\010\uffbd\012\uffbd\013\uffbd\014\uffbd"
        + "\022\uffbd\023\uffbd\024\uffbd\025\uffbd\026\uffbd\027\uffbd\030"
        + "\uffbd\031\uffbd\032\uffbd\033\uffbd\042\uffbd\043\uffbd\001\002"
        + "\000\052\002\uffa0\004\uffa0\007\uffa0\010\uffa0\012\uffa0\013"
        + "\uffa0\014\uffa0\021\uffa0\022\uffa0\023\uffa0\024\uffa0\025\uffa0"
        + "\026\uffa0\027\uffa0\030\uffa0\031\uffa0\032\uffa0\033\uffa0\042"
        + "\uffa0\043\uffa0\001\002\000\036\002\uffd2\007\uffd2\012\uffd2"
        + "\014\uffd2\022\uffd2\023\uffd2\024\uffd2\025\uffd2\026\uffd2\027"
        + "\uffd2\030\211\031\212\042\uffd2\043\uffd2\001\002\000\056"
        + "\002\uff75\004\uff75\006\uff75\007\uff75\010\uff75\011\uff75\012"
        + "\uff75\013\uff75\014\uff75\021\uff75\022\uff75\023\uff75\024\uff75"
        + "\025\uff75\026\uff75\027\uff75\030\uff75\031\uff75\032\uff75\033"
        + "\uff75\042\uff75\043\uff75\001\002\000\044\002\uffca\007\uffca"
        + "\012\uffca\013\uffca\014\uffca\022\uffca\023\uffca\024\uffca\025"
        + "\uffca\026\uffca\027\uffca\030\uffca\031\uffca\032\uffca\033\uffca"
        + "\042\uffca\043\uffca\001\002\000\060\002\uff77\004\uff77\006"
        + "\uff77\007\uff77\010\uff77\011\uff77\012\uff77\013\uff77\014\uff77"
        + "\020\uffa2\021\uff77\022\uff77\023\uff77\024\uff77\025\uff77\026"
        + "\uff77\027\uff77\030\uff77\031\uff77\032\uff77\033\uff77\042\uff77"
        + "\043\uff77\001\002\000\060\002\uff7e\004\uff7e\006\uff7e\007"
        + "\uff7e\010\uff7e\011\uff7e\012\uff7e\013\uff7e\014\uff7e\020\uffa9"
        + "\021\uff7e\022\uff7e\023\uff7e\024\uff7e\025\uff7e\026\uff7e\027"
        + "\uff7e\030\uff7e\031\uff7e\032\uff7e\033\uff7e\042\uff7e\043\uff7e"
        + "\001\002\000\004\011\201\001\002\000\052\002\uffbc\004"
        + "\uffbc\007\uffbc\010\uffbc\012\uffbc\013\uffbc\014\uffbc\021\uffbc"
        + "\022\uffbc\023\uffbc\024\uffbc\025\uffbc\026\uffbc\027\uffbc\030"
        + "\uffbc\031\uffbc\032\uffbc\033\uffbc\042\uffbc\043\uffbc\001\002"
        + "\000\046\002\uffc2\007\uffc2\010\uffc2\012\uffc2\013\uffc2\014"
        + "\uffc2\022\uffc2\023\uffc2\024\uffc2\025\uffc2\026\uffc2\027\uffc2"
        + "\030\uffc2\031\uffc2\032\uffc2\033\uffc2\042\uffc2\043\uffc2\001"
        + "\002\000\054\002\uff9e\004\uff9e\006\055\007\uff9e\010\uff9e"
        + "\012\uff9e\013\uff9e\014\uff9e\021\uff9e\022\uff9e\023\uff9e\024"
        + "\uff9e\025\uff9e\026\uff9e\027\uff9e\030\uff9e\031\uff9e\032\uff9e"
        + "\033\uff9e\042\uff9e\043\uff9e\001\002\000\060\002\uff76\004"
        + "\uff76\006\uff76\007\uff76\010\uff76\011\uff76\012\uff76\013\uff76"
        + "\014\uff76\020\uffa1\021\uff76\022\uff76\023\uff76\024\uff76\025"
        + "\uff76\026\uff76\027\uff76\030\uff76\031\uff76\032\uff76\033\uff76"
        + "\042\uff76\043\uff76\001\002\000\046\002\uffc4\007\uffc4\010"
        + "\176\012\uffc4\013\uffc4\014\uffc4\022\uffc4\023\uffc4\024\uffc4"
        + "\025\uffc4\026\uffc4\027\uffc4\030\uffc4\031\uffc4\032\uffc4\033"
        + "\uffc4\042\uffc4\043\uffc4\001\002\000\060\002\uff81\004\uff81"
        + "\006\uff81\007\uff81\010\uff81\011\uff81\012\uff81\013\uff81\014"
        + "\uff81\020\uffac\021\uff81\022\uff81\023\uff81\024\uff81\025\uff81"
        + "\026\uff81\027\uff81\030\uff81\031\uff81\032\uff81\033\uff81\042"
        + "\uff81\043\uff81\001\002\000\054\002\uff9c\004\uff9c\006\uff9c"
        + "\007\uff9c\010\uff9c\012\uff9c\013\uff9c\014\uff9c\021\uff9c\022"
        + "\uff9c\023\uff9c\024\uff9c\025\uff9c\026\uff9c\027\uff9c\030\uff9c"
        + "\031\uff9c\032\uff9c\033\uff9c\042\uff9c\043\uff9c\001\002\000"
        + "\060\002\uff78\004\uff78\006\uff78\007\uff78\010\uff78\011\uff78"
        + "\012\uff78\013\uff78\014\uff78\020\uffa3\021\uff78\022\uff78\023"
        + "\uff78\024\uff78\025\uff78\026\uff78\027\uff78\030\uff78\031\uff78"
        + "\032\uff78\033\uff78\042\uff78\043\uff78\001\002\000\052\002"
        + "\uffc1\004\173\007\uffc1\010\uffc1\012\uffc1\013\uffc1\014\uffc1"
        + "\021\172\022\uffc1\023\uffc1\024\uffc1\025\uffc1\026\uffc1\027"
        + "\uffc1\030\uffc1\031\uffc1\032\uffc1\033\uffc1\042\uffc1\043\uffc1"
        + "\001\002\000\060\002\uff82\004\uff82\006\uff82\007\uff82\010"
        + "\uff82\011\uff82\012\uff82\013\uff82\014\uff82\020\uffad\021\uff82"
        + "\022\uff82\023\uff82\024\uff82\025\uff82\026\uff82\027\uff82\030"
        + "\uff82\031\uff82\032\uff82\033\uff82\042\uff82\043\uff82\001\002"
        + "\000\054\002\uff98\004\uff98\006\uff98\007\uff98\010\uff98\012"
        + "\uff98\013\uff98\014\uff98\021\uff98\022\uff98\023\uff98\024\uff98"
        + "\025\uff98\026\uff98\027\uff98\030\uff98\031\uff98\032\uff98\033"
        + "\uff98\042\uff98\043\uff98\001\002\000\004\007\171\001\002"
        + "\000\046\032\031\033\040\035\034\036\113\037\141\047"
        + "\036\050\037\051\044\052\170\053\166\054\043\055\041"
        + "\056\035\057\030\060\045\061\021\062\012\063\042\001"
        + "\002\000\052\002\uffba\004\uffba\007\uffba\010\uffba\012\uffba"
        + "\013\uffba\014\uffba\021\uffba\022\uffba\023\uffba\024\uffba\025"
        + "\uffba\026\uffba\027\uffba\030\uffba\031\uffba\032\uffba\033\uffba"
        + "\042\uffba\043\uffba\001\002\000\060\002\uff79\004\uff79\006"
        + "\uff79\007\uff79\010\uff79\011\uff79\012\uff79\013\uff79\014\uff79"
        + "\020\uffa4\021\uff79\022\uff79\023\uff79\024\uff79\025\uff79\026"
        + "\uff79\027\uff79\030\uff79\031\uff79\032\uff79\033\uff79\042\uff79"
        + "\043\uff79\001\002\000\052\002\uffb0\004\uffb0\007\uffb0\010"
        + "\uffb0\012\uffb0\013\uffb0\014\uffb0\021\uffb0\022\uffb0\023\uffb0"
        + "\024\uffb0\025\uffb0\026\uffb0\027\uffb0\030\uffb0\031\uffb0\032"
        + "\uffb0\033\uffb0\042\uffb0\043\uffb0\001\002\000\060\002\uff7c"
        + "\004\uff7c\006\uff7c\007\uff7c\010\uff7c\011\uff7c\012\uff7c\013"
        + "\uff7c\014\uff7c\020\uffa7\021\uff7c\022\uff7c\023\uff7c\024\uff7c"
        + "\025\uff7c\026\uff7c\027\uff7c\030\uff7c\031\uff7c\032\uff7c\033"
        + "\uff7c\042\uff7c\043\uff7c\001\002\000\056\002\uff83\004\uff83"
        + "\006\uff83\007\uff83\010\uff83\011\uff83\012\uff83\013\uff83\014"
        + "\uff83\021\uff83\022\uff83\023\uff83\024\uff83\025\uff83\026\uff83"
        + "\027\uff83\030\uff83\031\uff83\032\uff83\033\uff83\042\uff83\043"
        + "\uff83\001\002\000\054\002\uff8c\004\uff8c\006\uff8c\007\uff8c"
        + "\010\uff8c\012\uff8c\013\uff8c\014\uff8c\021\uff8c\022\uff8c\023"
        + "\uff8c\024\uff8c\025\uff8c\026\uff8c\027\uff8c\030\uff8c\031\uff8c"
        + "\032\uff8c\033\uff8c\042\uff8c\043\uff8c\001\002\000\060\002"
        + "\uff80\004\uff80\006\uff80\007\uff80\010\uff80\011\uff80\012\uff80"
        + "\013\uff80\014\uff80\020\uffab\021\uff80\022\uff80\023\uff80\024"
        + "\uff80\025\uff80\026\uff80\027\uff80\030\uff80\031\uff80\032\uff80"
        + "\033\uff80\042\uff80\043\uff80\001\002\000\044\002\uffc6\007"
        + "\uffc6\012\uffc6\013\uffc6\014\uffc6\022\uffc6\023\uffc6\024\uffc6"
        + "\025\uffc6\026\uffc6\027\uffc6\030\uffc6\031\uffc6\032\uffc6\033"
        + "\uffc6\042\uffc6\043\uffc6\001\002\000\054\002\uff8d\004\uff8d"
        + "\006\uff8d\007\uff8d\010\uff8d\012\uff8d\013\uff8d\014\uff8d\021"
        + "\uff8d\022\uff8d\023\uff8d\024\uff8d\025\uff8d\026\uff8d\027\uff8d"
        + "\030\uff8d\031\uff8d\032\uff8d\033\uff8d\042\uff8d\043\uff8d\001"
        + "\002\000\044\002\uffcd\007\uffcd\012\uffcd\013\160\014\uffcd"
        + "\022\uffcd\023\uffcd\024\uffcd\025\uffcd\026\uffcd\027\uffcd\030"
        + "\uffcd\031\uffcd\032\161\033\157\042\uffcd\043\uffcd\001\002"
        + "\000\052\002\uffbe\004\153\007\uffbe\010\uffbe\012\uffbe\013"
        + "\uffbe\014\uffbe\021\152\022\uffbe\023\uffbe\024\uffbe\025\uffbe"
        + "\026\uffbe\027\uffbe\030\uffbe\031\uffbe\032\uffbe\033\uffbe\042"
        + "\uffbe\043\uffbe\001\002\000\054\002\uff8e\004\uff8e\006\uff8e"
        + "\007\uff8e\010\uff8e\012\uff8e\013\uff8e\014\uff8e\021\uff8e\022"
        + "\uff8e\023\uff8e\024\uff8e\025\uff8e\026\uff8e\027\uff8e\030\uff8e"
        + "\031\uff8e\032\uff8e\033\uff8e\042\uff8e\043\uff8e\001\002\000"
        + "\056\002\uff87\004\uff87\006\uff87\007\uff87\010\uff87\011\uff91"
        + "\012\uff87\013\uff87\014\uff87\021\uff87\022\uff87\023\uff87\024"
        + "\uff87\025\uff87\026\uff87\027\uff87\030\uff87\031\uff87\032\uff87"
        + "\033\uff87\042\uff87\043\uff87\001\002\000\070\005\111\013"
        + "\103\016\066\017\106\032\031\033\040\035\034\036\113"
        + "\037\141\040\142\041\145\044\063\045\062\046\065\047"
        + "\115\050\123\051\136\052\077\053\143\054\131\055\125"
        + "\056\116\057\104\060\140\061\067\062\060\063\127\001"
        + "\002\000\070\005\111\013\103\016\066\017\106\032\031"
        + "\033\040\035\034\036\113\037\141\040\142\041\145\044"
        + "\063\045\062\046\065\047\115\050\123\051\136\052\077"
        + "\053\143\054\131\055\125\056\116\057\104\060\140\061"
        + "\067\062\060\063\127\001\002\000\054\002\uff87\004\uff87"
        + "\006\uff87\007\uff87\010\uff87\012\uff87\013\uff87\014\uff87\021"
        + "\uff87\022\uff87\023\uff87\024\uff87\025\uff87\026\uff87\027\uff87"
        + "\030\uff87\031\uff87\032\uff87\033\uff87\042\uff87\043\uff87\001"
        + "\002\000\052\002\uffbb\004\uffbb\007\uffbb\010\uffbb\012\uffbb"
        + "\013\uffbb\014\uffbb\021\uffbb\022\uffbb\023\uffbb\024\uffbb\025"
        + "\uffbb\026\uffbb\027\uffbb\030\uffbb\031\uffbb\032\uffbb\033\uffbb"
        + "\042\uffbb\043\uffbb\001\002\000\052\002\uffb6\004\uffb6\007"
        + "\uffb6\010\uffb6\012\uffb6\013\uffb6\014\uffb6\021\uffb6\022\uffb6"
        + "\023\uffb6\024\uffb6\025\uffb6\026\uffb6\027\uffb6\030\uffb6\031"
        + "\uffb6\032\uffb6\033\uffb6\042\uffb6\043\uffb6\001\002\000\110"
        + "\004\061\005\111\011\071\013\103\015\134\016\066\017"
        + "\106\021\070\031\075\032\031\033\040\034\057\035\034"
        + "\036\113\037\141\040\142\041\145\044\063\045\062\046"
        + "\065\047\115\050\123\051\136\052\077\053\143\054\131"
        + "\055\125\056\116\057\104\060\140\061\067\062\060\063"
        + "\127\064\132\065\072\001\002\000\110\004\061\005\111"
        + "\011\071\013\103\015\134\016\066\017\106\021\070\031"
        + "\075\032\031\033\040\034\057\035\034\036\113\037\141"
        + "\040\142\041\145\044\063\045\062\046\065\047\115\050"
        + "\123\051\136\052\077\053\143\054\131\055\125\056\116"
        + "\057\104\060\140\061\067\062\060\063\127\064\132\065"
        + "\072\001\002\000\110\004\061\005\111\011\071\013\103"
        + "\015\134\016\066\017\106\021\070\031\075\032\031\033"
        + "\040\034\057\035\034\036\113\037\141\040\142\041\145"
        + "\044\063\045\062\046\065\047\115\050\123\051\136\052"
        + "\077\053\143\054\131\055\125\056\116\057\104\060\140"
        + "\061\067\062\060\063\127\064\132\065\072\001\002\000"
        + "\044\002\uffc8\007\uffc8\012\uffc8\013\uffc8\014\uffc8\022\uffc8"
        + "\023\uffc8\024\uffc8\025\uffc8\026\uffc8\027\uffc8\030\uffc8\031"
        + "\uffc8\032\uffc8\033\uffc8\042\uffc8\043\uffc8\001\002\000\044"
        + "\002\uffc9\007\uffc9\012\uffc9\013\uffc9\014\uffc9\022\uffc9\023"
        + "\uffc9\024\uffc9\025\uffc9\026\uffc9\027\uffc9\030\uffc9\031\uffc9"
        + "\032\uffc9\033\uffc9\042\uffc9\043\uffc9\001\002\000\044\002"
        + "\uffc7\007\uffc7\012\uffc7\013\uffc7\014\uffc7\022\uffc7\023\uffc7"
        + "\024\uffc7\025\uffc7\026\uffc7\027\uffc7\030\uffc7\031\uffc7\032"
        + "\uffc7\033\uffc7\042\uffc7\043\uffc7\001\002\000\054\002\uff90"
        + "\004\uff90\006\uff90\007\uff90\010\uff90\012\uff90\013\uff90\014"
        + "\uff90\021\uff90\022\uff90\023\uff90\024\uff90\025\uff90\026\uff90"
        + "\027\uff90\030\uff90\031\uff90\032\uff90\033\uff90\042\uff90\043"
        + "\uff90\001\002\000\054\002\uff80\004\uff80\006\uff80\007\uff80"
        + "\010\uff80\012\uff80\013\uff80\014\uff80\021\uff80\022\uff80\023"
        + "\uff80\024\uff80\025\uff80\026\uff80\027\uff80\030\uff80\031\uff80"
        + "\032\uff80\033\uff80\042\uff80\043\uff80\001\002\000\054\002"
        + "\uff96\004\uff96\006\uff96\007\uff96\010\uff96\012\uff96\013\uff96"
        + "\014\uff96\021\uff96\022\uff96\023\uff96\024\uff96\025\uff96\026"
        + "\uff96\027\uff96\030\uff96\031\uff96\032\uff96\033\uff96\042\uff96"
        + "\043\uff96\001\002\000\054\002\uff7f\004\uff7f\006\uff7f\007"
        + "\uff7f\010\uff7f\012\uff7f\013\uff7f\014\uff7f\021\uff7f\022\uff7f"
        + "\023\uff7f\024\uff7f\025\uff7f\026\uff7f\027\uff7f\030\uff7f\031"
        + "\uff7f\032\uff7f\033\uff7f\042\uff7f\043\uff7f\001\002\000\054"
        + "\002\uffdb\004\uffdb\006\uffdb\007\uffdb\010\uffdb\012\uffdb\013"
        + "\uffdb\014\uffdb\021\uffdb\022\uffdb\023\uffdb\024\uffdb\025\uffdb"
        + "\026\uffdb\027\uffdb\030\uffdb\031\uffdb\032\uffdb\033\uffdb\042"
        + "\uffdb\043\uffdb\001\002\000\070\005\111\013\103\016\066"
        + "\017\106\032\031\033\040\035\034\036\113\037\141\040"
        + "\142\041\145\044\063\045\062\046\065\047\115\050\123"
        + "\051\136\052\077\053\143\054\131\055\125\056\116\057"
        + "\104\060\140\061\067\062\060\063\127\001\002\000\070"
        + "\005\111\013\103\016\066\017\106\032\031\033\040\035"
        + "\034\036\113\037\141\040\142\041\145\044\063\045\062"
        + "\046\065\047\115\050\123\051\136\052\077\053\143\054"
        + "\131\055\125\056\116\057\104\060\140\061\067\062\060"
        + "\063\127\001\002\000\052\002\uffc0\004\153\007\uffc0\010"
        + "\uffc0\012\uffc0\013\uffc0\014\uffc0\021\152\022\uffc0\023\uffc0"
        + "\024\uffc0\025\uffc0\026\uffc0\027\uffc0\030\uffc0\031\uffc0\032"
        + "\uffc0\033\uffc0\042\uffc0\043\uffc0\001\002\000\052\002\uffbf"
        + "\004\153\007\uffbf\010\uffbf\012\uffbf\013\uffbf\014\uffbf\021"
        + "\152\022\uffbf\023\uffbf\024\uffbf\025\uffbf\026\uffbf\027\uffbf"
        + "\030\uffbf\031\uffbf\032\uffbf\033\uffbf\042\uffbf\043\uffbf\001"
        + "\002\000\106\004\061\005\111\011\071\013\103\015\134"
        + "\016\066\017\106\021\070\032\031\033\040\034\057\035"
        + "\034\036\113\037\141\040\142\041\145\044\063\045\062"
        + "\046\065\047\115\050\123\051\136\052\077\053\143\054"
        + "\131\055\125\056\116\057\104\060\140\061\067\062\060"
        + "\063\127\064\132\065\072\001\002\000\044\002\uffc3\007"
        + "\uffc3\012\uffc3\013\uffc3\014\uffc3\022\uffc3\023\uffc3\024\uffc3"
        + "\025\uffc3\026\uffc3\027\uffc3\030\uffc3\031\uffc3\032\uffc3\033"
        + "\uffc3\042\uffc3\043\uffc3\001\002\000\052\002\uff9d\004\uff9d"
        + "\007\uff9d\010\uff9d\012\uff9d\013\uff9d\014\uff9d\021\uff9d\022"
        + "\uff9d\023\uff9d\024\uff9d\025\uff9d\026\uff9d\027\uff9d\030\uff9d"
        + "\031\uff9d\032\uff9d\033\uff9d\042\uff9d\043\uff9d\001\002\000"
        + "\112\004\061\005\111\011\071\012\202\013\103\015\134"
        + "\016\066\017\106\021\070\031\075\032\031\033\040\034"
        + "\057\035\034\036\113\037\141\040\142\041\145\044\063"
        + "\045\062\046\065\047\115\050\123\051\136\052\077\053"
        + "\143\054\131\055\125\056\116\057\104\060\140\061\067"
        + "\062\060\063\127\064\132\065\072\001\002\000\054\002"
        + "\uff95\004\uff95\006\uff95\007\uff95\010\uff95\012\uff95\013\uff95"
        + "\014\uff95\021\uff95\022\uff95\023\uff95\024\uff95\025\uff95\026"
        + "\uff95\027\uff95\030\uff95\031\uff95\032\uff95\033\uff95\042\uff95"
        + "\043\uff95\001\002\000\006\012\uff93\014\207\001\002\000"
        + "\006\012\uff8f\014\uff8f\001\002\000\004\012\206\001\002"
        + "\000\054\002\uff94\004\uff94\006\uff94\007\uff94\010\uff94\012"
        + "\uff94\013\uff94\014\uff94\021\uff94\022\uff94\023\uff94\024\uff94"
        + "\025\uff94\026\uff94\027\uff94\030\uff94\031\uff94\032\uff94\033"
        + "\uff94\042\uff94\043\uff94\001\002\000\110\004\061\005\111"
        + "\011\071\013\103\015\134\016\066\017\106\021\070\031"
        + "\075\032\031\033\040\034\057\035\034\036\113\037\141"
        + "\040\142\041\145\044\063\045\062\046\065\047\115\050"
        + "\123\051\136\052\077\053\143\054\131\055\125\056\116"
        + "\057\104\060\140\061\067\062\060\063\127\064\132\065"
        + "\072\001\002\000\004\012\uff92\001\002\000\110\004\061"
        + "\005\111\011\071\013\103\015\134\016\066\017\106\021"
        + "\070\031\075\032\031\033\040\034\057\035\034\036\113"
        + "\037\141\040\142\041\145\044\063\045\062\046\065\047"
        + "\115\050\123\051\136\052\077\053\143\054\131\055\125"
        + "\056\116\057\104\060\140\061\067\062\060\063\127\064"
        + "\132\065\072\001\002\000\110\004\061\005\111\011\071"
        + "\013\103\015\134\016\066\017\106\021\070\031\075\032"
        + "\031\033\040\034\057\035\034\036\113\037\141\040\142"
        + "\041\145\044\063\045\062\046\065\047\115\050\123\051"
        + "\136\052\077\053\143\054\131\055\125\056\116\057\104"
        + "\060\140\061\067\062\060\063\127\064\132\065\072\001"
        + "\002\000\044\002\uffcb\007\uffcb\012\uffcb\013\160\014\uffcb"
        + "\022\uffcb\023\uffcb\024\uffcb\025\uffcb\026\uffcb\027\uffcb\030"
        + "\uffcb\031\uffcb\032\161\033\157\042\uffcb\043\uffcb\001\002"
        + "\000\044\002\uffcc\007\uffcc\012\uffcc\013\160\014\uffcc\022"
        + "\uffcc\023\uffcc\024\uffcc\025\uffcc\026\uffcc\027\uffcc\030\uffcc"
        + "\031\uffcc\032\161\033\157\042\uffcc\043\uffcc\001\002\000"
        + "\052\002\uffb3\004\uffb3\007\uffb3\010\uffb3\012\uffb3\013\uffb3"
        + "\014\uffb3\021\uffb3\022\uffb3\023\uffb3\024\uffb3\025\uffb3\026"
        + "\uffb3\027\uffb3\030\uffb3\031\uffb3\032\uffb3\033\uffb3\042\uffb3"
        + "\043\uffb3\001\002\000\110\004\061\005\111\011\071\013"
        + "\103\015\134\016\066\017\106\021\070\031\075\032\031"
        + "\033\040\034\057\035\034\036\113\037\141\040\142\041"
        + "\145\044\063\045\062\046\065\047\115\050\123\051\136"
        + "\052\077\053\143\054\131\055\125\056\116\057\104\060"
        + "\140\061\067\062\060\063\127\064\132\065\072\001\002"
        + "\000\110\004\061\005\111\011\071\013\103\015\134\016"
        + "\066\017\106\021\070\031\075\032\031\033\040\034\057"
        + "\035\034\036\113\037\141\040\142\041\145\044\063\045"
        + "\062\046\065\047\115\050\123\051\136\052\077\053\143"
        + "\054\131\055\125\056\116\057\104\060\140\061\067\062"
        + "\060\063\127\064\132\065\072\001\002\000\032\002\uffd3"
        + "\007\uffd3\012\uffd3\014\uffd3\022\uffd3\023\uffd3\024\221\025"
        + "\222\026\223\027\224\042\uffd3\043\uffd3\001\002\000\110"
        + "\004\061\005\111\011\071\013\103\015\134\016\066\017"
        + "\106\021\070\031\075\032\031\033\040\034\057\035\034"
        + "\036\113\037\141\040\142\041\145\044\063\045\062\046"
        + "\065\047\115\050\123\051\136\052\077\053\143\054\131"
        + "\055\125\056\116\057\104\060\140\061\067\062\060\063"
        + "\127\064\132\065\072\001\002\000\110\004\061\005\111"
        + "\011\071\013\103\015\134\016\066\017\106\021\070\031"
        + "\075\032\031\033\040\034\057\035\034\036\113\037\141"
        + "\040\142\041\145\044\063\045\062\046\065\047\115\050"
        + "\123\051\136\052\077\053\143\054\131\055\125\056\116"
        + "\057\104\060\140\061\067\062\060\063\127\064\132\065"
        + "\072\001\002\000\110\004\061\005\111\011\071\013\103"
        + "\015\134\016\066\017\106\021\070\031\075\032\031\033"
        + "\040\034\057\035\034\036\113\037\141\040\142\041\145"
        + "\044\063\045\062\046\065\047\115\050\123\051\136\052"
        + "\077\053\143\054\131\055\125\056\116\057\104\060\140"
        + "\061\067\062\060\063\127\064\132\065\072\001\002\000"
        + "\110\004\061\005\111\011\071\013\103\015\134\016\066"
        + "\017\106\021\070\031\075\032\031\033\040\034\057\035"
        + "\034\036\113\037\141\040\142\041\145\044\063\045\062"
        + "\046\065\047\115\050\123\051\136\052\077\053\143\054"
        + "\131\055\125\056\116\057\104\060\140\061\067\062\060"
        + "\063\127\064\132\065\072\001\002\000\036\002\uffce\007"
        + "\uffce\012\uffce\014\uffce\022\uffce\023\uffce\024\uffce\025\uffce"
        + "\026\uffce\027\uffce\030\211\031\212\042\uffce\043\uffce\001"
        + "\002\000\036\002\uffcf\007\uffcf\012\uffcf\014\uffcf\022\uffcf"
        + "\023\uffcf\024\uffcf\025\uffcf\026\uffcf\027\uffcf\030\211\031"
        + "\212\042\uffcf\043\uffcf\001\002\000\036\002\uffd0\007\uffd0"
        + "\012\uffd0\014\uffd0\022\uffd0\023\uffd0\024\uffd0\025\uffd0\026"
        + "\uffd0\027\uffd0\030\211\031\212\042\uffd0\043\uffd0\001\002"
        + "\000\036\002\uffd1\007\uffd1\012\uffd1\014\uffd1\022\uffd1\023"
        + "\uffd1\024\uffd1\025\uffd1\026\uffd1\027\uffd1\030\211\031\212"
        + "\042\uffd1\043\uffd1\001\002\000\032\002\uffd4\007\uffd4\012"
        + "\uffd4\014\uffd4\022\uffd4\023\uffd4\024\221\025\222\026\223"
        + "\027\224\042\uffd4\043\uffd4\001\002\000\110\004\061\005"
        + "\111\011\071\013\103\015\134\016\066\017\106\021\070"
        + "\031\075\032\031\033\040\034\057\035\034\036\113\037"
        + "\141\040\142\041\145\044\063\045\062\046\065\047\115"
        + "\050\123\051\136\052\077\053\143\054\131\055\125\056"
        + "\116\057\104\060\140\061\067\062\060\063\127\064\132"
        + "\065\072\001\002\000\016\002\uffd8\007\uffd8\012\uffd8\014"
        + "\uffd8\042\uffd8\043\234\001\002\000\110\004\061\005\111"
        + "\011\071\013\103\015\134\016\066\017\106\021\070\031"
        + "\075\032\031\033\040\034\057\035\034\036\113\037\141"
        + "\040\142\041\145\044\063\045\062\046\065\047\115\050"
        + "\123\051\136\052\077\053\143\054\131\055\125\056\116"
        + "\057\104\060\140\061\067\062\060\063\127\064\132\065"
        + "\072\001\002\000\022\002\uffd6\007\uffd6\012\uffd6\014\uffd6"
        + "\022\216\023\217\042\uffd6\043\uffd6\001\002\000\062\013"
        + "\uffaf\032\uffaf\033\uffaf\035\uffaf\036\uffaf\037\uffaf\040\uffaf"
        + "\041\uffaf\044\uffaf\045\uffaf\046\uffaf\047\uffaf\050\uffaf\051"
        + "\uffaf\052\uffaf\053\uffaf\054\uffaf\055\uffaf\056\uffaf\057\uffaf"
        + "\060\uffaf\061\uffaf\062\uffaf\063\uffaf\001\002\000\054\002"
        + "\uffb1\004\uffb1\006\055\007\uffb1\010\uffb1\012\uffb1\013\uffb1"
        + "\014\uffb1\021\uffb1\022\uffb1\023\uffb1\024\uffb1\025\uffb1\026"
        + "\uffb1\027\uffb1\030\uffb1\031\uffb1\032\uffb1\033\uffb1\042\uffb1"
        + "\043\uffb1\001\002\000\052\002\uffb2\004\uffb2\007\uffb2\010"
        + "\uffb2\012\uffb2\013\uffb2\014\uffb2\021\uffb2\022\uffb2\023\uffb2"
        + "\024\uffb2\025\uffb2\026\uffb2\027\uffb2\030\uffb2\031\uffb2\032"
        + "\uffb2\033\uffb2\042\uffb2\043\uffb2\001\002\000\044\002\uffc5"
        + "\007\uffc5\012\uffc5\013\uffc5\014\uffc5\022\uffc5\023\uffc5\024"
        + "\uffc5\025\uffc5\026\uffc5\027\uffc5\030\uffc5\031\uffc5\032\uffc5"
        + "\033\uffc5\042\uffc5\043\uffc5\001\002\000\004\012\243\001"
        + "\002\000\054\002\uff9b\004\uff9b\006\uff9b\007\uff9b\010\uff9b"
        + "\012\uff9b\013\uff9b\014\uff9b\021\uff9b\022\uff9b\023\uff9b\024"
        + "\uff9b\025\uff9b\026\uff9b\027\uff9b\030\uff9b\031\uff9b\032\uff9b"
        + "\033\uff9b\042\uff9b\043\uff9b\001\002\000\052\002\uffb5\004"
        + "\153\007\uffb5\010\uffb5\012\uffb5\013\uffb5\014\uffb5\021\152"
        + "\022\uffb5\023\uffb5\024\uffb5\025\uffb5\026\uffb5\027\uffb5\030"
        + "\uffb5\031\uffb5\032\uffb5\033\uffb5\042\uffb5\043\uffb5\001\002"
        + "\000\004\034\246\001\002\000\004\012\247\001\002\000"
        + "\054\002\uff8a\004\uff8a\006\uff8a\007\uff8a\010\uff8a\012\uff8a"
        + "\013\uff8a\014\uff8a\021\uff8a\022\uff8a\023\uff8a\024\uff8a\025"
        + "\uff8a\026\uff8a\027\uff8a\030\uff8a\031\uff8a\032\uff8a\033\uff8a"
        + "\042\uff8a\043\uff8a\001\002\000\052\002\uffb8\004\153\007"
        + "\uffb8\010\uffb8\012\uffb8\013\uffb8\014\uffb8\021\152\022\uffb8"
        + "\023\uffb8\024\uffb8\025\uffb8\026\uffb8\027\uffb8\030\uffb8\031"
        + "\uffb8\032\uffb8\033\uffb8\042\uffb8\043\uffb8\001\002\000\052"
        + "\002\uffdc\004\uffdc\007\uffdc\010\uffdc\012\uffdc\013\uffdc\014"
        + "\uffdc\021\uffdc\022\uffdc\023\uffdc\024\uffdc\025\uffdc\026\uffdc"
        + "\027\uffdc\030\uffdc\031\uffdc\032\uffdc\033\uffdc\042\uffdc\043"
        + "\uffdc\001\002\000\062\013\uffde\032\uffde\033\uffde\035\uffde"
        + "\036\uffde\037\uffde\040\uffde\041\uffde\044\uffde\045\uffde\046"
        + "\uffde\047\uffde\050\uffde\051\uffde\052\uffde\053\uffde\054\uffde"
        + "\055\uffde\056\uffde\057\uffde\060\uffde\061\uffde\062\uffde\063"
        + "\uffde\001\002\000\004\034\254\001\002\000\004\014\255"
        + "\001\002\000\004\034\256\001\002\000\004\012\257\001"
        + "\002\000\012\002\ufff4\004\ufff4\010\ufff4\021\ufff4\001\002"
        + "\000\004\034\261\001\002\000\004\012\262\001\002\000"
        + "\012\002\ufff5\004\ufff5\010\ufff5\021\ufff5\001\002\000\012"
        + "\002\uffec\004\uffec\010\uffec\021\uffec\001\002\000\062\013"
        + "\uffdf\032\uffdf\033\uffdf\035\uffdf\036\uffdf\037\uffdf\040\uffdf"
        + "\041\uffdf\044\uffdf\045\uffdf\046\uffdf\047\uffdf\050\uffdf\051"
        + "\uffdf\052\uffdf\053\uffdf\054\uffdf\055\uffdf\056\uffdf\057\uffdf"
        + "\060\uffdf\061\uffdf\062\uffdf\063\uffdf\001\002\000\064\013"
        + "\027\016\020\032\031\033\040\035\034\036\113\037\141"
        + "\040\047\041\051\044\015\045\014\046\016\047\036\050"
        + "\037\051\044\052\025\053\050\054\043\055\041\056\035"
        + "\057\030\060\045\061\021\062\012\063\042\001\002\000"
        + "\064\013\027\016\020\032\031\033\040\035\034\036\113"
        + "\037\141\040\047\041\051\044\015\045\014\046\016\047"
        + "\036\050\037\051\044\052\025\053\050\054\043\055\041"
        + "\056\035\057\030\060\045\061\021\062\012\063\042\001"
        + "\002\000\006\002\ufff1\010\ufff1\001\002\000\006\002\ufff0"
        + "\010\ufff0\001\002\000\006\002\ufff7\010\ufff7\001\002\000"
        + "\014\002\uffe9\004\uffe9\006\055\010\uffe9\021\uffe9\001\002"
        + "\000\014\002\uffeb\004\uffeb\006\055\010\uffeb\021\uffeb\001"
        + "\002\000\012\002\uffea\004\uffea\010\uffea\021\uffea\001\002"
        + "\000\012\002\uffe8\004\uffe8\010\uffe8\021\uffe8\001\002\000"
        + "\064\013\027\016\020\032\031\033\040\035\034\036\113"
        + "\037\141\040\047\041\051\044\015\045\014\046\016\047"
        + "\036\050\037\051\044\052\025\053\050\054\043\055\041"
        + "\056\035\057\030\060\045\061\021\062\012\063\042\001"
        + "\002\000\064\013\027\016\020\032\031\033\040\035\034"
        + "\036\113\037\141\040\047\041\051\044\015\045\014\046"
        + "\016\047\036\050\037\051\044\052\025\053\050\054\043"
        + "\055\041\056\035\057\030\060\045\061\021\062\012\063"
        + "\042\001\002\000\006\002\ufff9\010\ufff9\001\002\000\006"
        + "\002\ufff8\010\ufff8\001\002\000\004\034\303\001\002\000"
        + "\004\012\304\001\002\000\014\002\ufff3\004\ufff3\006\ufff3"
        + "\010\ufff3\021\ufff3\001\002\000\006\002\ufffb\010\ufffb\001"
        + "\002\000\070\004\013\013\027\016\020\021\023\032\031"
        + "\033\040\035\034\036\033\037\046\040\047\041\051\044"
        + "\015\045\014\046\016\047\036\050\037\051\044\052\025"
        + "\053\050\054\043\055\041\056\035\057\030\060\045\061"
        + "\021\062\012\063\042\001\002\000\004\002\ufffd\001\002"
        + "\000\004\002\uffff\001\002\000\004\002\001\001\002"});

    /**
     * Access to parse-action table.
     */
    public short[][] action_table() {
        return _action_table;
    }

    /**
     * <code>reduce_goto</code> table.
     */
    protected static final short[][] _reduce_table
            = unpackFromStrings(new String[]{
        "\000\307\000\004\003\003\001\001\000\002\001\001\000"
        + "\070\004\307\006\120\010\127\011\117\012\101\013\075"
        + "\014\104\015\063\016\111\017\145\020\113\021\125\022"
        + "\073\023\121\024\143\025\123\026\136\027\146\030\134"
        + "\031\107\032\072\033\106\034\147\047\150\050\116\052"
        + "\100\053\077\001\001\000\026\035\016\036\007\037\006"
        + "\040\031\041\025\042\023\043\052\044\010\047\051\054"
        + "\021\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\020\040\031\041\304\042"
        + "\023\043\052\044\010\047\051\054\021\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\012\040\271"
        + "\043\272\044\010\047\051\001\001\000\020\040\031\041"
        + "\270\042\023\043\052\044\010\047\051\054\021\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\006"
        + "\007\053\045\262\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\006\007\053\045\055\001\001"
        + "\000\006\007\053\045\250\001\001\000\070\004\132\006"
        + "\120\010\127\011\117\012\101\013\075\014\104\015\063"
        + "\016\111\017\145\020\113\021\125\022\073\023\121\024"
        + "\143\025\123\026\136\027\146\030\134\031\107\032\072"
        + "\033\106\034\147\047\150\050\116\052\100\053\077\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\024\011\117\026\136\027\247\030\134\033\106\034"
        + "\147\047\153\052\100\053\077\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\024\011\117\026\136"
        + "\027\243\030\134\033\106\034\147\047\153\052\100\053"
        + "\077\001\001\000\070\004\241\006\120\010\127\011\117"
        + "\012\101\013\075\014\104\015\063\016\111\017\145\020"
        + "\113\021\125\022\073\023\121\024\143\025\123\026\136"
        + "\027\146\030\134\031\107\032\072\033\106\034\147\047"
        + "\150\050\116\052\100\053\077\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\052\006\120\010"
        + "\127\011\117\020\240\021\125\022\073\023\121\024\143"
        + "\025\123\026\136\027\146\030\134\031\107\032\072\033"
        + "\106\034\147\047\150\050\116\052\100\053\077\001\001"
        + "\000\002\001\001\000\002\001\001\000\010\033\236\034"
        + "\147\047\153\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\006\007\053\045\214\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\006\007\053\045\177\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\006\047\164\051\166\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\020\011\155\026\136\033\106\034\147\047\153\052\100"
        + "\053\077\001\001\000\020\011\154\026\136\033\106\034"
        + "\147\047\153\052\100\053\077\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\052\006\120\010"
        + "\127\011\117\020\163\021\125\022\073\023\121\024\143"
        + "\025\123\026\136\027\146\030\134\031\107\032\072\033"
        + "\106\034\147\047\150\050\116\052\100\053\077\001\001"
        + "\000\052\006\120\010\127\011\117\020\162\021\125\022"
        + "\073\023\121\024\143\025\123\026\136\027\146\030\134"
        + "\031\107\032\072\033\106\034\147\047\150\050\116\052"
        + "\100\053\077\001\001\000\052\006\120\010\127\011\117"
        + "\020\161\021\125\022\073\023\121\024\143\025\123\026"
        + "\136\027\146\030\134\031\107\032\072\033\106\034\147"
        + "\047\150\050\116\052\100\053\077\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\024\011\117\026\136\027\174\030\134"
        + "\033\106\034\147\047\153\052\100\053\077\001\001\000"
        + "\024\011\117\026\136\027\173\030\134\033\106\034\147"
        + "\047\153\052\100\053\077\001\001\000\002\001\001\000"
        + "\002\001\001\000\050\006\120\010\127\011\117\021\125"
        + "\022\073\023\121\024\176\025\123\026\136\027\146\030"
        + "\134\031\107\032\072\033\106\034\147\047\150\050\116"
        + "\052\100\053\077\001\001\000\002\001\001\000\002\001"
        + "\001\000\074\004\203\005\202\006\120\010\127\011\117"
        + "\012\101\013\075\014\104\015\063\016\111\017\145\020"
        + "\113\021\125\022\073\023\121\024\143\025\123\026\136"
        + "\027\146\030\134\031\107\032\072\033\106\034\147\046"
        + "\204\047\150\050\116\052\100\053\077\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\074\004\203\005\202\006\120"
        + "\010\127\011\117\012\101\013\075\014\104\015\063\016"
        + "\111\017\145\020\113\021\125\022\073\023\121\024\143"
        + "\025\123\026\136\027\146\030\134\031\107\032\072\033"
        + "\106\034\147\046\207\047\150\050\116\052\100\053\077"
        + "\001\001\000\002\001\001\000\054\006\120\010\127\011"
        + "\117\017\213\020\113\021\125\022\073\023\121\024\143"
        + "\025\123\026\136\027\146\030\134\031\107\032\072\033"
        + "\106\034\147\047\150\050\116\052\100\053\077\001\001"
        + "\000\054\006\120\010\127\011\117\017\212\020\113\021"
        + "\125\022\073\023\121\024\143\025\123\026\136\027\146"
        + "\030\134\031\107\032\072\033\106\034\147\047\150\050"
        + "\116\052\100\053\077\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\060\006\120\010\127\011"
        + "\117\015\230\016\111\017\145\020\113\021\125\022\073"
        + "\023\121\024\143\025\123\026\136\027\146\030\134\031"
        + "\107\032\072\033\106\034\147\047\150\050\116\052\100"
        + "\053\077\001\001\000\060\006\120\010\127\011\117\015"
        + "\217\016\111\017\145\020\113\021\125\022\073\023\121"
        + "\024\143\025\123\026\136\027\146\030\134\031\107\032"
        + "\072\033\106\034\147\047\150\050\116\052\100\053\077"
        + "\001\001\000\002\001\001\000\056\006\120\010\127\011"
        + "\117\016\227\017\145\020\113\021\125\022\073\023\121"
        + "\024\143\025\123\026\136\027\146\030\134\031\107\032"
        + "\072\033\106\034\147\047\150\050\116\052\100\053\077"
        + "\001\001\000\056\006\120\010\127\011\117\016\226\017"
        + "\145\020\113\021\125\022\073\023\121\024\143\025\123"
        + "\026\136\027\146\030\134\031\107\032\072\033\106\034"
        + "\147\047\150\050\116\052\100\053\077\001\001\000\056"
        + "\006\120\010\127\011\117\016\225\017\145\020\113\021"
        + "\125\022\073\023\121\024\143\025\123\026\136\027\146"
        + "\030\134\031\107\032\072\033\106\034\147\047\150\050"
        + "\116\052\100\053\077\001\001\000\056\006\120\010\127"
        + "\011\117\016\224\017\145\020\113\021\125\022\073\023"
        + "\121\024\143\025\123\026\136\027\146\030\134\031\107"
        + "\032\072\033\106\034\147\047\150\050\116\052\100\053"
        + "\077\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\064\006"
        + "\120\010\127\011\117\013\232\014\104\015\063\016\111"
        + "\017\145\020\113\021\125\022\073\023\121\024\143\025"
        + "\123\026\136\027\146\030\134\031\107\032\072\033\106"
        + "\034\147\047\150\050\116\052\100\053\077\001\001\000"
        + "\002\001\001\000\062\006\120\010\127\011\117\014\234"
        + "\015\063\016\111\017\145\020\113\021\125\022\073\023"
        + "\121\024\143\025\123\026\136\027\146\030\134\031\107"
        + "\032\072\033\106\034\147\047\150\050\116\052\100\053"
        + "\077\001\001\000\002\001\001\000\002\001\001\000\006"
        + "\007\053\045\237\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\020\040\031\041\267\042\023\043\052\044\010\047\051"
        + "\054\021\001\001\000\020\040\031\041\266\042\023\043"
        + "\052\044\010\047\051\054\021\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\006\007\053\045"
        + "\274\001\001\000\006\007\053\045\273\001\001\000\002"
        + "\001\001\000\002\001\001\000\020\040\031\041\300\042"
        + "\023\043\052\044\010\047\051\054\021\001\001\000\020"
        + "\040\031\041\277\042\023\043\052\044\010\047\051\054"
        + "\021\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\026\035\016\036\306\037\006\040\031\041\025"
        + "\042\023\043\052\044\010\047\051\054\021\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001"});

    /**
     * Access to <code>reduce_goto</code> table.
     */
    public short[][] reduce_table() {
        return _reduce_table;
    }

    /**
     * Instance of action encapsulation class.
     */
    protected parser_actions action_obj;

    /**
     * Action encapsulation object initializer.
     */
    protected void init_actions() {
        action_obj = new parser_actions(this);
    }

    /**
     * Invoke a user supplied parse action.
     */
    public Symbol do_action(
            int act_num,
            lr_parser parser,
            Stack<Symbol> stack,
            int top)
            throws java.lang.Exception {
        /* call code in generated class */
        return action_obj.parser_do_action(act_num, parser, stack, top);
    }

    /**
     * Indicates start state.
     */
    public int start_state() {
        return 0;
    }

    /**
     * Indicates start production.
     */
    public int start_production() {
        return 0;
    }

    /**
     * <code>EOF</code> Symbol index.
     */
    public int EOF_sym() {
        return 0;
    }

    /**
     * <code>error</code> Symbol index.
     */
    public int error_sym() {
        return 1;
    }

    /**
     * Used by function calls with no args.
     */
    static public final List<Expression> EmptyArgs = new ArrayList<>(0);

    /**
     * Reference to non-existing variable.
     */
    static public final VariableRef DummyVarRef = null;

    /**
     * Reference to the Parser class.
     */
    private Parser _parser;
    private XSLTC _xsltc;

    /**
     * String representation of the expression being parsed.
     */
    private String _expression;

    /**
     * Line number where this expression/pattern was declared.
     */
    private int _lineNumber = 0;

    /**
     * Reference to the symbol table.
     */
    public SymbolTable _symbolTable;

    public XPathParser(Parser parser) {
        _parser = parser;
        _xsltc = parser.getXSLTC();
        _symbolTable = parser.getSymbolTable();
    }

    public int getLineNumber() {
        return _lineNumber;
    }

    public QName getQNameIgnoreDefaultNs(String name) {
        return _parser.getQNameIgnoreDefaultNs(name);
    }

    public QName getQName(String namespace, String prefix, String localname) {
        return _parser.getQName(namespace, prefix, localname);
    }

    public void setMultiDocument(boolean flag) {
        _xsltc.setMultiDocument(flag);
    }

    public void setCallsNodeset(boolean flag) {
        _xsltc.setCallsNodeset(flag);
    }

    public void setHasIdCall(boolean flag) {
        _xsltc.setHasIdCall(flag);
    }

    /**
     * This method is similar to findNodeType(int, Object) except that it
     * creates a StepPattern instead of just returning a node type. It also
     * differs in the way it handles "{uri}:*" and "{uri}:@*". The last two
     * patterns are expanded as "*[namespace-uri() = 'uri']" and
     * "@*[namespace-uri() = 'uri']", respectively. This expansion considerably
     * simplifies the grouping of patterns in the Mode class. For this expansion
     * to be correct, the priority of the pattern/template must be set to -0.25
     * (when no other predicates are present).
     */
    public StepPattern createStepPattern(int axis, Object test, List<Predicate> predicates) {
        int nodeType;

        if (test == null) {  // "*"
            nodeType = (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE
                    : (axis == Axis.NAMESPACE) ? -1 : NodeTest.ELEMENT;

            return new StepPattern(axis, nodeType, predicates);
        } else if (test instanceof Integer) {
            nodeType = ((Integer) test);

            return new StepPattern(axis, nodeType, predicates);
        } else {
            QName name = (QName) test;
            boolean setPriority = false;

            if (axis == Axis.NAMESPACE) {
                nodeType = (name.toString().equals("*")) ? -1
                        : _xsltc.registerNamespacePrefix(name);;
            } else {
                final String uri = name.getNamespace();
                final String local = name.getLocalPart();
                final QName namespace_uri
                        = _parser.getQNameIgnoreDefaultNs("namespace-uri");

                // Expand {uri}:* to *[namespace-uri() = 'uri'] - same for @*
                if (uri != null && (local.equals("*") || local.equals("@*"))) {
                    if (predicates == null) {
                        predicates = new ArrayList<>(2);
                    }

                    // Priority is set by hand if no other predicates exist
                    setPriority = (predicates.size() == 0);

                    predicates.add(
                            new Predicate(
                                    new EqualityExpr(Operators.EQ,
                                            new NamespaceUriCall(namespace_uri),
                                            new LiteralExpr(uri))));
                }

                if (local.equals("*")) {
                    nodeType = (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE
                            : NodeTest.ELEMENT;
                } else if (local.equals("@*")) {
                    nodeType = NodeTest.ATTRIBUTE;
                } else {
                    nodeType = (axis == Axis.ATTRIBUTE) ? _xsltc.registerAttribute(name)
                            : _xsltc.registerElement(name);
                }
            }

            final StepPattern result = new StepPattern(axis, nodeType, predicates);

            // Set priority for case prefix:* and prefix:@* (no predicates)
            if (setPriority) {
                result.setPriority(-0.25);
            }

            return result;
        }
    }

    public int findNodeType(int axis, Object test) {
        if (test == null) {  // *
            return (axis == Axis.ATTRIBUTE)
                    ? NodeTest.ATTRIBUTE
                    : (axis == Axis.NAMESPACE) ? -1 : NodeTest.ELEMENT;
        } else if (test instanceof Integer) {
            return ((Integer) test);
        } else {
            QName name = (QName) test;

            if (axis == Axis.NAMESPACE) {
                return (name.toString().equals("*")) ? -1
                        : _xsltc.registerNamespacePrefix(name);
            }

            if (name.getNamespace() == null) {
                final String local = name.getLocalPart();

                if (local.equals("*")) {
                    return (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE
                            : NodeTest.ELEMENT;
                } else if (local.equals("@*")) {
                    return NodeTest.ATTRIBUTE;
                }
            }

            return (axis == Axis.ATTRIBUTE) ? _xsltc.registerAttribute(name)
                    : _xsltc.registerElement(name);
        }
    }

    /**
     * Parse the expression passed to the current scanner. If this expression
     * contains references to local variables and it will be compiled in an
     * external module (not in the main class) request the current template to
     * create a new variable stack frame.
     *
     * @param expression the expression to be parsed
     * @param lineNumber Line where the current expression is defined.
     *
     */
    public Symbol parse(String expression, int lineNumber) throws Exception {
        try {
            _expression = expression;
            _lineNumber = lineNumber;
            return super.parse();
        } catch (IllegalCharException e) {
            ErrorMsg err = new ErrorMsg(ErrorMsg.ILLEGAL_CHAR_ERR,
                    lineNumber, e.getMessage());
            _parser.reportError(Constants.FATAL, err);
        }
        return null;
    }

    /**
     * Lookup a variable or parameter in the symbol table given its name.
     *
     * @param name Name of the symbol being looked up.
     */
    final SyntaxTreeNode lookupName(QName name) {
        // Is it a local var or param ?
        final SyntaxTreeNode result = _parser.lookupVariable(name);
        if (result != null) {
            return (result);
        } else {
            return (_symbolTable.lookupName(name));
        }
    }

    public final void addError(ErrorMsg error) {
        _parser.reportError(Constants.ERROR, error);
    }

    public void report_error(String message, Object info) {
        final ErrorMsg err = new ErrorMsg(ErrorMsg.SYNTAX_ERR, _lineNumber,
                _expression);
        _parser.reportError(Constants.FATAL, err);
    }

    public void report_fatal_error(String message, Object info) {
        // empty
    }

    public RelativeLocationPath insertStep(Step step, RelativeLocationPath rlp) {
        if (rlp instanceof Step) {
            return new ParentLocationPath(step, (Step) rlp);
        } else if (rlp instanceof ParentLocationPath) {
            final ParentLocationPath plp = (ParentLocationPath) rlp;
            final RelativeLocationPath newrlp = insertStep(step, plp.getPath());
            return new ParentLocationPath(newrlp, plp.getStep());
        } else {
            addError(new ErrorMsg(ErrorMsg.INTERNAL_ERR, "XPathParser.insertStep"));
            return rlp;
        }
    }

    /**
     * Returns true if the axis applies to elements only. The axes child,
     * attribute, namespace, descendant result in non-empty nodesets only if the
     * context node is of type element.
     */
    public boolean isElementAxis(int axis) {
        return (axis == Axis.CHILD || axis == Axis.ATTRIBUTE
                || axis == Axis.NAMESPACE || axis == Axis.DESCENDANT);
    }

}

/**
 * Cup generated class to encapsulate user supplied action code.
 */
class parser_actions {

    private final XPathParser parser;

    /**
     * Constructor
     */
    parser_actions(XPathParser parser) {
        this.parser = parser;
    }

    /**
     * Method with the actual generated action code.
     */
    public final Symbol parser_do_action(
            int parser_act_num,
            lr_parser parser_parser,
            Stack<Symbol> parser_stack,
            int parser_top)
            throws java.lang.Exception {
        /* Symbol object for return from actions */
        Symbol parser_result;

        /* select the action based on the action number */
        switch (parser_act_num) {
            /*. . . . . . . . . . . . . . . . . . . .*/
            case 0: // $START ::= TopLevel EOF
            {
                SyntaxTreeNode start_val = (SyntaxTreeNode) (parser_stack.get(parser_top - 1)).value;
                parser_result = new Symbol(0, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, start_val);
            }
            /* ACCEPT */
            parser_parser.done_parsing();
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 1: // TopLevel ::= PATTERN Pattern
            {
                Pattern pattern = (Pattern) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(1, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, pattern);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 2: // TopLevel ::= EXPRESSION Expr
            {
                Expression expr = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(1, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, expr);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 3: // Pattern ::= LocationPathPattern
            {
                Pattern lpp = (Pattern) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(28, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, lpp);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 4: // Pattern ::= LocationPathPattern VBAR Pattern
            {
                Pattern lpp = (Pattern) (parser_stack.get(parser_top - 2)).value;
                Pattern p = (Pattern) (parser_stack.get(parser_top - 0)).value;
                Pattern result = new AlternativePattern(lpp, p);
                parser_result = new Symbol(28, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 5: // LocationPathPattern ::= SLASH
            {
                Pattern result = new AbsolutePathPattern(null);
                parser_result = new Symbol(29, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 6: // LocationPathPattern ::= SLASH RelativePathPattern
            {
                RelativePathPattern rpp = (RelativePathPattern) (parser_stack.get(parser_top - 0)).value;
                Pattern result = new AbsolutePathPattern(rpp);
                parser_result = new Symbol(29, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 7: // LocationPathPattern ::= IdKeyPattern
            {
                IdKeyPattern ikp = (IdKeyPattern) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(29, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, ikp);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 8: // LocationPathPattern ::= IdKeyPattern SLASH RelativePathPattern
            {
                IdKeyPattern ikp = (IdKeyPattern) (parser_stack.get(parser_top - 2)).value;
                RelativePathPattern rpp = (RelativePathPattern) (parser_stack.get(parser_top - 0)).value;
                Pattern result = new ParentPattern(ikp, rpp);
                parser_result = new Symbol(29, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 9: // LocationPathPattern ::= IdKeyPattern DSLASH RelativePathPattern
            {
                IdKeyPattern ikp = (IdKeyPattern) (parser_stack.get(parser_top - 2)).value;
                RelativePathPattern rpp = (RelativePathPattern) (parser_stack.get(parser_top - 0)).value;
                Pattern result = new AncestorPattern(ikp, rpp);
                parser_result = new Symbol(29, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 10: // LocationPathPattern ::= DSLASH RelativePathPattern
            {
                RelativePathPattern rpp = (RelativePathPattern) (parser_stack.get(parser_top - 0)).value;
                Pattern result = new AncestorPattern(rpp);
                parser_result = new Symbol(29, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 11: // LocationPathPattern ::= RelativePathPattern
            {
                RelativePathPattern rpp = (RelativePathPattern) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(29, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, rpp);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 12: // IdKeyPattern ::= ID LPAREN Literal RPAREN
            {
                String l = (String) (parser_stack.get(parser_top - 1)).value;
                IdKeyPattern result = new IdPattern(l);
                parser.setHasIdCall(true);
                parser_result = new Symbol(27, (parser_stack.get(parser_top - 3)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 13: // IdKeyPattern ::= KEY LPAREN Literal COMMA Literal RPAREN
            {
                String l1 = (String) (parser_stack.get(parser_top - 3)).value;
                String l2 = (String) (parser_stack.get(parser_top - 1)).value;
                IdKeyPattern result = new KeyPattern(l1, l2);
                parser_result = new Symbol(27, (parser_stack.get(parser_top - 5)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 14: // ProcessingInstructionPattern ::= PIPARAM LPAREN Literal RPAREN
            {
                String l = (String) (parser_stack.get(parser_top - 1)).value;
                StepPattern result = new ProcessingInstructionPattern(l);
                parser_result = new Symbol(30, (parser_stack.get(parser_top - 3)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 15: // RelativePathPattern ::= StepPattern
            {
                StepPattern sp = (StepPattern) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(31, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, sp);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 16: // RelativePathPattern ::= StepPattern SLASH RelativePathPattern
            {
                StepPattern sp = (StepPattern) (parser_stack.get(parser_top - 2)).value;
                RelativePathPattern rpp = (RelativePathPattern) (parser_stack.get(parser_top - 0)).value;
                RelativePathPattern result = new ParentPattern(sp, rpp);
                parser_result = new Symbol(31, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 17: // RelativePathPattern ::= StepPattern DSLASH RelativePathPattern
            {
                StepPattern sp = (StepPattern) (parser_stack.get(parser_top - 2)).value;
                RelativePathPattern rpp = (RelativePathPattern) (parser_stack.get(parser_top - 0)).value;
                RelativePathPattern result = new AncestorPattern(sp, rpp);
                parser_result = new Symbol(31, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 18: // StepPattern ::= NodeTestPattern
            {
                Object nt = parser_stack.get(parser_top - 0).value;
                StepPattern result = parser.createStepPattern(Axis.CHILD, nt, null);
                parser_result = new Symbol(32, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 19: // StepPattern ::= NodeTestPattern Predicates
            {
                Object nt = parser_stack.get(parser_top - 1).value;
                @SuppressWarnings("unchecked")
                List<Predicate> pp = (ArrayList<Predicate>) (parser_stack.get(parser_top - 0)).value;
                StepPattern result = parser.createStepPattern(Axis.CHILD, nt, pp);
                parser_result = new Symbol(32, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 20: // StepPattern ::= ProcessingInstructionPattern
            {
                StepPattern pip = (StepPattern) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(32, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, pip);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 21: // StepPattern ::= ProcessingInstructionPattern Predicates
            {
                StepPattern pip = (StepPattern) (parser_stack.get(parser_top - 1)).value;
                @SuppressWarnings("unchecked")
                List<Predicate> pp = (ArrayList<Predicate>) (parser_stack.get(parser_top - 0)).value;
                StepPattern result = (ProcessingInstructionPattern) pip.setPredicates(pp);
                parser_result = new Symbol(32, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 22: // StepPattern ::= ChildOrAttributeAxisSpecifier NodeTestPattern
            {
                Integer axis = (Integer) (parser_stack.get(parser_top - 1)).value;
                Object nt = parser_stack.get(parser_top - 0).value;
                StepPattern result = parser.createStepPattern(axis, nt, null);
                parser_result = new Symbol(32, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 23: // StepPattern ::= ChildOrAttributeAxisSpecifier NodeTestPattern Predicates
            {
                Integer axis = (Integer) (parser_stack.get(parser_top - 2)).value;
                Object nt = parser_stack.get(parser_top - 1).value;
                @SuppressWarnings("unchecked")
                List<Predicate> pp = (ArrayList<Predicate>) (parser_stack.get(parser_top - 0)).value;
                StepPattern result = parser.createStepPattern(axis, nt, pp);
                parser_result = new Symbol(32, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 24: // StepPattern ::= ChildOrAttributeAxisSpecifier ProcessingInstructionPattern
            {
                StepPattern pip = (StepPattern) (parser_stack.get(parser_top - 0)).value;
                StepPattern result = pip;    // TODO: report error if axis is attribute
                parser_result = new Symbol(32, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 25: // StepPattern ::= ChildOrAttributeAxisSpecifier ProcessingInstructionPattern Predicates
            {
                StepPattern pip = (StepPattern) (parser_stack.get(parser_top - 1)).value;
                @SuppressWarnings("unchecked")
                List<Predicate> pp = (ArrayList<Predicate>) (parser_stack.get(parser_top - 0)).value;
                // TODO: report error if axis is attribute
                StepPattern result = (ProcessingInstructionPattern) pip.setPredicates(pp);
                parser_result = new Symbol(32, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 26: // NodeTestPattern ::= NameTestPattern
            {
                Object nt = parser_stack.get(parser_top - 0).value;
                parser_result = new Symbol(33, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, nt);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 27: // NodeTestPattern ::= NODE
            {
                Object result = NodeTest.ANODE;
                parser_result = new Symbol(33, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 28: // NodeTestPattern ::= TEXT
            {
                Object result = NodeTest.TEXT;
                parser_result = new Symbol(33, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 29: // NodeTestPattern ::= COMMENT
            {
                Object result = NodeTest.COMMENT;
                parser_result = new Symbol(33, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 30: // NodeTestPattern ::= PI
            {
                Object result = NodeTest.PI;
                parser_result = new Symbol(33, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 31: // NameTestPattern ::= STAR
            {
                Object result = null;
                parser_result = new Symbol(34, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 32: // NameTestPattern ::= QName
            {
                QName qn = (QName) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(34, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, qn);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 33: // ChildOrAttributeAxisSpecifier ::= ATSIGN
            {
                Integer result = Axis.ATTRIBUTE;
                parser_result = new Symbol(42, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 34: // ChildOrAttributeAxisSpecifier ::= CHILD DCOLON
            {
                Integer result = Axis.CHILD;
                parser_result = new Symbol(42, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 35: // ChildOrAttributeAxisSpecifier ::= ATTRIBUTE DCOLON
            {
                Integer result = Axis.ATTRIBUTE;
                parser_result = new Symbol(42, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 36: // Predicates ::= Predicate
            {
                Expression p = (Expression) (parser_stack.get(parser_top - 0)).value;
                List<Expression> temp = new ArrayList<>();
                temp.add(p);
                parser_result = new Symbol(35, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, temp);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 37: // Predicates ::= Predicate Predicates
            {
                Expression p = (Expression) (parser_stack.get(parser_top - 1)).value;
                @SuppressWarnings("unchecked")
                List<Expression> pp = (ArrayList<Expression>) (parser_stack.get(parser_top - 0)).value;
                pp.add(0, p);
                parser_result = new Symbol(35, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, pp);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 38: // Predicate ::= LBRACK Expr RBRACK
            {
                Expression e = (Expression) (parser_stack.get(parser_top - 1)).value;
                Expression result = new Predicate(e);
                parser_result = new Symbol(5, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 39: // Expr ::= OrExpr
            {
                Expression ex = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(2, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, ex);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 40: // OrExpr ::= AndExpr
            {
                Expression ae = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(8, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, ae);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 41: // OrExpr ::= OrExpr OR AndExpr
            {
                Expression oe = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression ae = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new LogicalExpr(LogicalExpr.OR, oe, ae);
                parser_result = new Symbol(8, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 42: // AndExpr ::= EqualityExpr
            {
                Expression e = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(9, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, e);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 43: // AndExpr ::= AndExpr AND EqualityExpr
            {
                Expression ae = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression ee = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new LogicalExpr(LogicalExpr.AND, ae, ee);
                parser_result = new Symbol(9, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 44: // EqualityExpr ::= RelationalExpr
            {
                Expression re = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(10, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, re);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 45: // EqualityExpr ::= EqualityExpr EQ RelationalExpr
            {
                Expression ee = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression re = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new EqualityExpr(Operators.EQ, ee, re);
                parser_result = new Symbol(10, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 46: // EqualityExpr ::= EqualityExpr NE RelationalExpr
            {
                Expression ee = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression re = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new EqualityExpr(Operators.NE, ee, re);
                parser_result = new Symbol(10, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 47: // RelationalExpr ::= AdditiveExpr
            {
                Expression ae = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(11, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, ae);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 48: // RelationalExpr ::= RelationalExpr LT AdditiveExpr
            {
                Expression re = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression ae = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new RelationalExpr(Operators.LT, re, ae);
                parser_result = new Symbol(11, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 49: // RelationalExpr ::= RelationalExpr GT AdditiveExpr
            {
                Expression re = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression ae = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new RelationalExpr(Operators.GT, re, ae);
                parser_result = new Symbol(11, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 50: // RelationalExpr ::= RelationalExpr LE AdditiveExpr
            {
                Expression re = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression ae = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new RelationalExpr(Operators.LE, re, ae);
                parser_result = new Symbol(11, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 51: // RelationalExpr ::= RelationalExpr GE AdditiveExpr
            {
                Expression re = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression ae = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new RelationalExpr(Operators.GE, re, ae);
                parser_result = new Symbol(11, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 52: // AdditiveExpr ::= MultiplicativeExpr
            {
                Expression me = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(12, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, me);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 53: // AdditiveExpr ::= AdditiveExpr PLUS MultiplicativeExpr
            {
                Expression ae = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression me = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new BinOpExpr(BinOpExpr.PLUS, ae, me);
                parser_result = new Symbol(12, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 54: // AdditiveExpr ::= AdditiveExpr MINUS MultiplicativeExpr
            {
                Expression ae = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression me = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new BinOpExpr(BinOpExpr.MINUS, ae, me);
                parser_result = new Symbol(12, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 55: // MultiplicativeExpr ::= UnaryExpr
            {
                Expression ue = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(13, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, ue);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 56: // MultiplicativeExpr ::= MultiplicativeExpr STAR UnaryExpr
            {
                Expression me = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression ue = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new BinOpExpr(BinOpExpr.TIMES, me, ue);
                parser_result = new Symbol(13, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 57: // MultiplicativeExpr ::= MultiplicativeExpr DIV UnaryExpr
            {
                Expression me = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression ue = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new BinOpExpr(BinOpExpr.DIV, me, ue);
                parser_result = new Symbol(13, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 58: // MultiplicativeExpr ::= MultiplicativeExpr MOD UnaryExpr
            {
                Expression me = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression ue = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new BinOpExpr(BinOpExpr.MOD, me, ue);
                parser_result = new Symbol(13, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 59: // UnaryExpr ::= UnionExpr
            {
                Expression ue = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(14, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, ue);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 60: // UnaryExpr ::= MINUS UnaryExpr
            {
                Expression ue = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new UnaryOpExpr(ue);
                parser_result = new Symbol(14, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 61: // UnionExpr ::= PathExpr
            {
                Expression pe = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(18, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, pe);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 62: // UnionExpr ::= PathExpr VBAR UnionExpr
            {
                Expression pe = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression rest = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new UnionPathExpr(pe, rest);
                parser_result = new Symbol(18, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 63: // PathExpr ::= LocationPath
            {
                Expression lp = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(19, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, lp);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 64: // PathExpr ::= FilterExpr
            {
                Expression fexp = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(19, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, fexp);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 65: // PathExpr ::= FilterExpr SLASH RelativeLocationPath
            {
                Expression fexp = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression rlp = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new FilterParentPath(fexp, rlp);
                parser_result = new Symbol(19, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 66: // PathExpr ::= FilterExpr DSLASH RelativeLocationPath
            {
                Expression fexp = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression rlp = (Expression) (parser_stack.get(parser_top - 0)).value;
                //
                // Expand '//' into '/descendant-or-self::node()/' or
                // into /descendant-or-self::*/
                //
                int nodeType = DOM.NO_TYPE;
                if (rlp instanceof Step
                        && parser.isElementAxis(((Step) rlp).getAxis())) {
                    nodeType = DTM.ELEMENT_NODE;
                }
                final Step step = new Step(Axis.DESCENDANTORSELF, nodeType, null);
                FilterParentPath fpp = new FilterParentPath(fexp, step);
                fpp = new FilterParentPath(fpp, rlp);
                if (fexp instanceof KeyCall == false) {
                    fpp.setDescendantAxis();
                }
                parser_result = new Symbol(19, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, fpp);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 67: // LocationPath ::= RelativeLocationPath
            {
                Expression rlp = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(4, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, rlp);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 68: // LocationPath ::= AbsoluteLocationPath
            {
                Expression alp = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(4, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, alp);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 69: // RelativeLocationPath ::= Step
            {
                Expression step = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(21, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, step);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 70: // RelativeLocationPath ::= RelativeLocationPath SLASH Step
            {
                Expression result = null;
                Expression rlp = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression step = (Expression) (parser_stack.get(parser_top - 0)).value;
                if (rlp instanceof Step && ((Step) rlp).isAbbreviatedDot()) {
                    result = step;       // Remove './' from the middle
                } else if (((Step) step).isAbbreviatedDot()) {
                    result = rlp;        // Remove '/.' from the end
                } else {
                    result
                            = new ParentLocationPath((RelativeLocationPath) rlp, step);
                }
                parser_result = new Symbol(21, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 71: // RelativeLocationPath ::= AbbreviatedRelativeLocationPath
            {
                Expression arlp = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(21, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, arlp);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 72: // AbsoluteLocationPath ::= SLASH
            {
                Expression result = new AbsoluteLocationPath();
                parser_result = new Symbol(23, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 73: // AbsoluteLocationPath ::= SLASH RelativeLocationPath
            {
                Expression rlp = (Expression) (parser_stack.get(parser_top - 0)).value;
                Expression result = new AbsoluteLocationPath(rlp);
                parser_result = new Symbol(23, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 74: // AbsoluteLocationPath ::= AbbreviatedAbsoluteLocationPath
            {
                Expression aalp = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(23, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, aalp);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 75: // AbbreviatedRelativeLocationPath ::= RelativeLocationPath DSLASH Step
            {
                Expression result = null;
                Expression rlp = (Expression) (parser_stack.get(parser_top - 2)).value;
                Expression step = (Expression) (parser_stack.get(parser_top - 0)).value;
                final Step right = (Step) step;
                final int axis = right.getAxis();
                final int type = right.getNodeType();
                final List<Predicate> predicates = right.getPredicates();
                if ((axis == Axis.CHILD) && (type != NodeTest.ATTRIBUTE)) {
                    // Compress './/child:E' into 'descendant::E' - if possible
                    if (predicates == null) {
                        right.setAxis(Axis.DESCENDANT);
                        if (rlp instanceof Step && ((Step) rlp).isAbbreviatedDot()) {
                            result = right;
                        } else {
                            // Expand 'rlp//child::E' into 'rlp/descendant::E'
                            RelativeLocationPath left = (RelativeLocationPath) rlp;
                            result = new ParentLocationPath(left, right);
                        }
                    } else // Expand './/step' -> 'descendant-or-self::*/step'
                    if (rlp instanceof Step && ((Step) rlp).isAbbreviatedDot()) {
                        Step left = new Step(Axis.DESCENDANTORSELF,
                                DTM.ELEMENT_NODE, null);
                        result = new ParentLocationPath(left, right);
                    } else {
                        // Expand 'rlp//step' -> 'rlp/descendant-or-self::*/step'
                        RelativeLocationPath left = (RelativeLocationPath) rlp;
                        Step mid = new Step(Axis.DESCENDANTORSELF,
                                DTM.ELEMENT_NODE, null);
                        ParentLocationPath ppl = new ParentLocationPath(mid, right);
                        result = new ParentLocationPath(left, ppl);
                    }
                } else if ((axis == Axis.ATTRIBUTE) || (type == NodeTest.ATTRIBUTE)) {
                    // Expand 'rlp//step' -> 'rlp/descendant-or-self::*/step'
                    RelativeLocationPath left = (RelativeLocationPath) rlp;
                    Step middle = new Step(Axis.DESCENDANTORSELF,
                            DTM.ELEMENT_NODE, null);
                    ParentLocationPath ppl = new ParentLocationPath(middle, right);
                    result = new ParentLocationPath(left, ppl);
                } else {
                    // Expand 'rlp//step' -> 'rlp/descendant-or-self::node()/step'
                    RelativeLocationPath left = (RelativeLocationPath) rlp;
                    Step middle = new Step(Axis.DESCENDANTORSELF,
                            DOM.NO_TYPE, null);
                    ParentLocationPath ppl = new ParentLocationPath(middle, right);
                    result = new ParentLocationPath(left, ppl);
                }
                parser_result = new Symbol(22, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 76: // AbbreviatedAbsoluteLocationPath ::= DSLASH RelativeLocationPath
            {
                Expression rlp = (Expression) (parser_stack.get(parser_top - 0)).value;
                //
                // Expand '//' into '/descendant-or-self::node()/' or
                // into /descendant-or-self::*/
                //
                int nodeType = DOM.NO_TYPE;
                if (rlp instanceof Step
                        && parser.isElementAxis(((Step) rlp).getAxis())) {
                    nodeType = DTM.ELEMENT_NODE;
                }
                final Step step = new Step(Axis.DESCENDANTORSELF, nodeType, null);
                Expression result = new AbsoluteLocationPath(parser.insertStep(step,
                        (RelativeLocationPath) rlp));
                parser_result = new Symbol(24, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 77: // Step ::= NodeTest
            {
                Expression result = null;
                Object ntest = parser_stack.get(parser_top - 0).value;
                if (ntest instanceof Step) {
                    result = (Step) ntest;
                } else {
                    result = new Step(Axis.CHILD,
                            parser.findNodeType(Axis.CHILD, ntest),
                            null);
                }
                parser_result = new Symbol(7, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 78: // Step ::= NodeTest Predicates
            {
                Expression result = null;
                Object ntest = parser_stack.get(parser_top - 1).value;
                @SuppressWarnings("unchecked")
                List<Predicate> pp = (ArrayList<Predicate>) (parser_stack.get(parser_top - 0)).value;
                if (ntest instanceof Step) {
                    Step step = (Step) ntest;
                    step.addPredicates(pp);
                    result = (Step) ntest;
                } else {
                    result = new Step(Axis.CHILD,
                            parser.findNodeType(Axis.CHILD, ntest), pp);
                }
                parser_result = new Symbol(7, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 79: // Step ::= AxisSpecifier NodeTest Predicates
            {
                Integer axis = (Integer) (parser_stack.get(parser_top - 2)).value;
                Object ntest = parser_stack.get(parser_top - 1).value;
                @SuppressWarnings("unchecked")
                List<Predicate> pp = (ArrayList<Predicate>) (parser_stack.get(parser_top - 0)).value;
                Expression result = new Step(axis, parser.findNodeType(axis, ntest), pp);
                parser_result = new Symbol(7, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 80: // Step ::= AxisSpecifier NodeTest
            {
                Integer axis = (Integer) (parser_stack.get(parser_top - 1)).value;
                Object ntest = parser_stack.get(parser_top - 0).value;
                Expression result = new Step(axis, parser.findNodeType(axis, ntest), null);
                parser_result = new Symbol(7, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 81: // Step ::= AbbreviatedStep
            {
                Expression abbrev = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(7, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, abbrev);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 82: // AxisSpecifier ::= AxisName DCOLON
            {
                Integer an = (Integer) (parser_stack.get(parser_top - 1)).value;
                parser_result = new Symbol(41, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, an);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 83: // AxisSpecifier ::= ATSIGN
            {
                Integer result = Axis.ATTRIBUTE;
                parser_result = new Symbol(41, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 84: // AxisName ::= ANCESTOR
            {
                Integer result = Axis.ANCESTOR;
                parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 85: // AxisName ::= ANCESTORORSELF
            {
                Integer result = Axis.ANCESTORORSELF;
                parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 86: // AxisName ::= ATTRIBUTE
            {
                Integer result = Axis.ATTRIBUTE;
                parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 87: // AxisName ::= CHILD
            {
                Integer result = Axis.CHILD;
                parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 88: // AxisName ::= DESCENDANT
            {
                Integer result = Axis.DESCENDANT;
                parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 89: // AxisName ::= DESCENDANTORSELF
            {
                Integer result = Axis.DESCENDANTORSELF;
                parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 90: // AxisName ::= FOLLOWING
            {
                Integer result = Axis.FOLLOWING;
                parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 91: // AxisName ::= FOLLOWINGSIBLING
            {
                Integer result = Axis.FOLLOWINGSIBLING;
                parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 92: // AxisName ::= NAMESPACE
            {
                Integer result = Axis.NAMESPACE;
                parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 93: // AxisName ::= PARENT
            {
                Integer result = Axis.PARENT;
                parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 94: // AxisName ::= PRECEDING
            {
                Integer result = Axis.PRECEDING;
                parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 95: // AxisName ::= PRECEDINGSIBLING
            {
                Integer result = Axis.PRECEDINGSIBLING;
                parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 96: // AxisName ::= SELF
            {
                Integer result = Axis.SELF;
                parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 97: // AbbreviatedStep ::= DOT
            {
                Expression result = new Step(Axis.SELF, NodeTest.ANODE, null);
                parser_result = new Symbol(20, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 98: // AbbreviatedStep ::= DDOT
            {
                Expression result = new Step(Axis.PARENT, NodeTest.ANODE, null);
                parser_result = new Symbol(20, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 99: // FilterExpr ::= PrimaryExpr
            {
                Expression primary = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(6, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, primary);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 100: // FilterExpr ::= PrimaryExpr Predicates
            {
                Expression primary = (Expression) (parser_stack.get(parser_top - 1)).value;
                @SuppressWarnings("unchecked")
                List<Expression> pp = (ArrayList<Expression>) (parser_stack.get(parser_top - 0)).value;
                Expression result = new FilterExpr(primary, pp);
                parser_result = new Symbol(6, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 101: // PrimaryExpr ::= VariableReference
            {
                Expression vr = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(17, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, vr);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 102: // PrimaryExpr ::= LPAREN Expr RPAREN
            {
                Expression ex = (Expression) (parser_stack.get(parser_top - 1)).value;
                parser_result = new Symbol(17, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, ex);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 103: // PrimaryExpr ::= Literal
            {
                String string = (String) (parser_stack.get(parser_top - 0)).value;
                /*
        * If the string appears to have the syntax of a QName, store
        * namespace info in the literal expression. This is used for
        * element-available and function-available functions, among
        * others. Also, the default namespace must be ignored.
                 */
                String namespace = null;
                final int index = string.lastIndexOf(':');
                if (index > 0) {
                    final String prefix = string.substring(0, index);
                    namespace = parser._symbolTable.lookupNamespace(prefix);
                }
                Expression result = (namespace == null) ? new LiteralExpr(string)
                        : new LiteralExpr(string, namespace);
                parser_result = new Symbol(17, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 104: // PrimaryExpr ::= INT
            {
                Expression result = null;
                Long num = (Long) (parser_stack.get(parser_top - 0)).value;
                if (num < Integer.MIN_VALUE || num > Integer.MAX_VALUE) {
                    result = new RealExpr(num);
                } else if (num.doubleValue() == -0) {
                    result = new RealExpr(num.doubleValue());
                } else if (num.intValue() == 0) {
                    result = new IntExpr(num.intValue());
                } else if (num.doubleValue() == 0.0) {
                    result = new RealExpr(num.doubleValue());
                } else {
                    result = new IntExpr(num.intValue());
                }
                parser_result = new Symbol(17, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 105: // PrimaryExpr ::= REAL
            {
                Double num = (Double) (parser_stack.get(parser_top - 0)).value;
                Expression result = new RealExpr(num);
                parser_result = new Symbol(17, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 106: // PrimaryExpr ::= FunctionCall
            {
                Expression fc = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(17, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, fc);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 107: // VariableReference ::= DOLLAR VariableName
            {
                Expression result = null;
                QName varName = (QName) (parser_stack.get(parser_top - 0)).value;
                // An empty qname prefix for a variable or parameter reference
                // should map to the null namespace and not the default URI.
                SyntaxTreeNode node = parser.lookupName(varName);
                if (node != null) {
                    if (node instanceof Variable) {
                        result = new VariableRef((Variable) node);
                    } else if (node instanceof Param) {
                        result = new ParameterRef((Param) node);
                    } else {
                        result = new UnresolvedRef(varName);
                    }
                }
                if (node == null) {
                    result = new UnresolvedRef(varName);
                }
                parser_result = new Symbol(15, (parser_stack.get(parser_top - 1)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 108: // FunctionCall ::= FunctionName LPAREN RPAREN
            {
                Expression result = null;
                QName fname = (QName) (parser_stack.get(parser_top - 2)).value;
                if (fname == parser.getQNameIgnoreDefaultNs("current")) {
                    result = new CurrentCall(fname);
                } else if (fname == parser.getQNameIgnoreDefaultNs("number")) {
                    result = new NumberCall(fname, XPathParser.EmptyArgs);
                } else if (fname == parser.getQNameIgnoreDefaultNs("string")) {
                    result = new StringCall(fname, XPathParser.EmptyArgs);
                } else if (fname == parser.getQNameIgnoreDefaultNs("concat")) {
                    result = new ConcatCall(fname, XPathParser.EmptyArgs);
                } else if (fname == parser.getQNameIgnoreDefaultNs("true")) {
                    result = new BooleanExpr(true);
                } else if (fname == parser.getQNameIgnoreDefaultNs("false")) {
                    result = new BooleanExpr(false);
                } else if (fname == parser.getQNameIgnoreDefaultNs("name")) {
                    result = new NameCall(fname);
                } else if (fname == parser.getQNameIgnoreDefaultNs("generate-id")) {
                    result = new GenerateIdCall(fname, XPathParser.EmptyArgs);
                } else if (fname == parser.getQNameIgnoreDefaultNs("string-length")) {
                    result = new StringLengthCall(fname, XPathParser.EmptyArgs);
                } else if (fname == parser.getQNameIgnoreDefaultNs("position")) {
                    result = new PositionCall(fname);
                } else if (fname == parser.getQNameIgnoreDefaultNs("last")) {
                    result = new LastCall(fname);
                } else if (fname == parser.getQNameIgnoreDefaultNs("local-name")) {
                    result = new LocalNameCall(fname);
                } else if (fname == parser.getQNameIgnoreDefaultNs("namespace-uri")) {
                    result = new NamespaceUriCall(fname);
                } else {
                    result = new FunctionCall(fname, XPathParser.EmptyArgs);
                }
                parser_result = new Symbol(16, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 109: // FunctionCall ::= FunctionName LPAREN NonemptyArgumentList RPAREN
            {
                Expression result = null;
                QName fname = (QName) (parser_stack.get(parser_top - 3)).value;
                @SuppressWarnings("unchecked")
                List<Expression> argl = (ArrayList<Expression>) (parser_stack.get(parser_top - 1)).value;
                if (fname == parser.getQNameIgnoreDefaultNs("concat")) {
                    result = new ConcatCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("number")) {
                    result = new NumberCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("document")) {
                    parser.setMultiDocument(true);
                    result = new DocumentCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("string")) {
                    result = new StringCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("boolean")) {
                    result = new BooleanCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("name")) {
                    result = new NameCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("generate-id")) {
                    result = new GenerateIdCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("not")) {
                    result = new NotCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("format-number")) {
                    result = new FormatNumberCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("unparsed-entity-uri")) {
                    result = new UnparsedEntityUriCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("key")) {
                    result = new KeyCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("id")) {
                    result = new KeyCall(fname, argl);
                    parser.setHasIdCall(true);
                } else if (fname == parser.getQNameIgnoreDefaultNs("ceiling")) {
                    result = new CeilingCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("round")) {
                    result = new RoundCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("floor")) {
                    result = new FloorCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("contains")) {
                    result = new ContainsCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("string-length")) {
                    result = new StringLengthCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("starts-with")) {
                    result = new StartsWithCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("function-available")) {
                    result = new FunctionAvailableCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("element-available")) {
                    result = new ElementAvailableCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("local-name")) {
                    result = new LocalNameCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("lang")) {
                    result = new LangCall(fname, argl);
                } else if (fname == parser.getQNameIgnoreDefaultNs("namespace-uri")) {
                    result = new NamespaceUriCall(fname, argl);
                } else if (fname == parser.getQName(Constants.TRANSLET_URI, "xsltc", "cast")) {
                    result = new CastCall(fname, argl);
                } // Special case for extension function nodeset()
                else if (fname.getLocalPart().equals("nodeset") || fname.getLocalPart().equals("node-set")) {
                    parser.setCallsNodeset(true);  // implies MultiDOM
                    result = new FunctionCall(fname, argl);
                } else {
                    result = new FunctionCall(fname, argl);
                }
                parser_result = new Symbol(16, (parser_stack.get(parser_top - 3)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 110: // NonemptyArgumentList ::= Argument
            {
                Expression arg = (Expression) (parser_stack.get(parser_top - 0)).value;
                List<Expression> temp = new ArrayList<>();
                temp.add(arg);
                parser_result = new Symbol(36, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, temp);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 111: // NonemptyArgumentList ::= Argument COMMA NonemptyArgumentList
            {
                Expression arg = (Expression) (parser_stack.get(parser_top - 2)).value;
                @SuppressWarnings("unchecked")
                List<Expression> argl = (ArrayList<Expression>) (parser_stack.get(parser_top - 0)).value;
                argl.add(0, arg);
                parser_result = new Symbol(36, (parser_stack.get(parser_top - 2)).left,
                        (parser_stack.get(parser_top - 0)).right, argl);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 112: // FunctionName ::= QName
            {
                QName fname = (QName) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(38, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, fname);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 113: // VariableName ::= QName
            {
                QName vname = (QName) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(39, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, vname);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 114: // Argument ::= Expr
            {
                Expression ex = (Expression) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(3, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, ex);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 115: // NodeTest ::= NameTest
            {
                Object nt = parser_stack.get(parser_top - 0).value;
                parser_result = new Symbol(25, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, nt);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 116: // NodeTest ::= NODE
            {
                Object result = NodeTest.ANODE;
                parser_result = new Symbol(25, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 117: // NodeTest ::= TEXT
            {
                Object result = NodeTest.TEXT;
                parser_result = new Symbol(25, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 118: // NodeTest ::= COMMENT
            {
                Object result = NodeTest.COMMENT;
                parser_result = new Symbol(25, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 119: // NodeTest ::= PIPARAM LPAREN Literal RPAREN
            {
                String l = (String) (parser_stack.get(parser_top - 1)).value;
                QName name = parser.getQNameIgnoreDefaultNs("name");
                Expression exp = new EqualityExpr(Operators.EQ,
                        new NameCall(name),
                        new LiteralExpr(l));
                List<Predicate> predicates = new ArrayList<>();
                predicates.add(new Predicate(exp));
                Object result = new Step(Axis.CHILD, NodeTest.PI, predicates);
                parser_result = new Symbol(25, (parser_stack.get(parser_top - 3)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 120: // NodeTest ::= PI
            {
                Object result = NodeTest.PI;
                parser_result = new Symbol(25, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 121: // NameTest ::= STAR
            {
                Object result = null;
                parser_result = new Symbol(26, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 122: // NameTest ::= QName
            {
                QName qn = (QName) (parser_stack.get(parser_top - 0)).value;
                parser_result = new Symbol(26, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, qn);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 123: // QName ::= QNAME
            {
                String qname = (String) (parser_stack.get(parser_top - 0)).value;
                QName result = parser.getQNameIgnoreDefaultNs(qname);
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 124: // QName ::= DIV
            {
                QName result = parser.getQNameIgnoreDefaultNs("div");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 125: // QName ::= MOD
            {
                QName result = parser.getQNameIgnoreDefaultNs("mod");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 126: // QName ::= KEY
            {
                QName result = parser.getQNameIgnoreDefaultNs("key");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 127: // QName ::= ANCESTOR
            {
                QName result = parser.getQNameIgnoreDefaultNs("child");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 128: // QName ::= ANCESTORORSELF
            {
                QName result = parser.getQNameIgnoreDefaultNs("ancestor-or-self");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 129: // QName ::= ATTRIBUTE
            {
                QName result = parser.getQNameIgnoreDefaultNs("attribute");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 130: // QName ::= CHILD
            {
                QName result = parser.getQNameIgnoreDefaultNs("child");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 131: // QName ::= DESCENDANT
            {
                QName result = parser.getQNameIgnoreDefaultNs("decendant");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 132: // QName ::= DESCENDANTORSELF
            {
                QName result = parser.getQNameIgnoreDefaultNs("decendant-or-self");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 133: // QName ::= FOLLOWING
            {
                QName result = parser.getQNameIgnoreDefaultNs("following");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 134: // QName ::= FOLLOWINGSIBLING
            {
                QName result = parser.getQNameIgnoreDefaultNs("following-sibling");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 135: // QName ::= NAMESPACE
            {
                QName result = parser.getQNameIgnoreDefaultNs("namespace");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 136: // QName ::= PARENT
            {
                QName result = parser.getQNameIgnoreDefaultNs("parent");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 137: // QName ::= PRECEDING
            {
                QName result = parser.getQNameIgnoreDefaultNs("preceding");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 138: // QName ::= PRECEDINGSIBLING
            {
                QName result = parser.getQNameIgnoreDefaultNs("preceding-sibling");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 139: // QName ::= SELF
            {
                QName result = parser.getQNameIgnoreDefaultNs("self");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 140: // QName ::= ID
            {
                QName result = parser.getQNameIgnoreDefaultNs("id");
                parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
                        (parser_stack.get(parser_top - 0)).right, result);
            }
            return parser_result;

            /* . . . . . .*/
            default:
                throw new Exception(
                        "Invalid action number found in internal parse table");

        }
    }
}
