#
# Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

# This file contains error and warning messages related to XML Schema
# The messages are arranged in key and value tuples in a ListResourceBundle.

        BadMessageKey = Impossibile trovare il messaggio di errore corrispondente alla chiave di messaggio.
        FormatFailed = Si \u00E8 verificato un errore interno durante la formattazione del seguente messaggio:\n

# For internal use

        Internal-Error = Errore interno: {0}.
        dt-whitespace = Spazio vuoto non disponibile come valore di facet per il simpleType di unione ''{0}''
        GrammarConflict = Una grammatica restituita dal pool di grammatiche dell'utente \u00E8 in conflitto con un'altra grammatica.

# Identity constraints

        AbsentKeyValue = cvc-identity-constraint.4.2.1.a: l''elemento "{0}" non contiene valori per la chiave "{1}".
        DuplicateField = Corrispondenza duplicata nell''ambito per il campo "{0}".
        DuplicateKey = cvc-identity-constraint.4.2.2: valore chiave duplicato [{0}] dichiarato per il vincolo di identit\u00E0 "{2}" dell''elemento "{1}".
        DuplicateUnique = cvc-identity-constraint.4.1: valore univoco duplicato [{0}] dichiarato per il vincolo di identit\u00E0 "{2}" dell''elemento "{1}".
        FieldMultipleMatch = cvc-identity-constraint.3: il campo "{0}" del vincolo di identit\u00E0 "{1}" corrisponde a pi\u00F9 valori nell''ambito del proprio selettore; i campi devono corrispondere a valori univoci.
        FixedDiffersFromActual = Il contenuto di questo elemento non equivale al valore dell'attributo "fixed" nella dichiarazione dell'elemento nello schema.
        KeyMatchesNillable = cvc-identity-constraint.4.2.3: l''elemento "{0}" ha la chiave "{1}" che corrisponde a un elemento che ha l''attributo nillable impostato su true.
        KeyNotEnoughValues = cvc-identity-constraint.4.2.1.b: valori insufficienti forniti per il vincolo di identit\u00E0 <key name="{1}"> specificato per l''elemento "{0}".
        KeyNotFound = cvc-identity-constraint.4.3: chiave ''{0}'' con valore ''{1}'' non trovata per il vincolo di identit\u00E0 dell''elemento ''{2}''.
        KeyRefOutOfScope = Errore del vincolo di identit\u00E0: il vincolo di identit\u00E0 "{0}" ha un keyref che fa riferimento a una chiave o a un valore univoco fuori ambito.
        KeyRefReferNotFound = La dichiarazione "{0}" del riferimento chiave fa riferimento a una chiave sconosciuta denominata "{1}".
        UnknownField = Errore interno del vincolo di identit\u00E0; campo "{0}" sconosciuto per il vincolo di identit\u00E0 "{2}" specificato per l''elemento "{1}".

# Ideally, we should only use the following error keys, not the ones under
# "Identity constraints". And we should cover all of the following errors.

#validation (3.X.4)

        cvc-attribute.3 = cvc-attribute.3: il valore ''{2}'' dell''attributo ''{1}'' sull''elemento ''{0}'' non \u00E8 valido rispetto al suo tipo ''{3}''.
        cvc-attribute.4 = cvc-attribute.4: il valore ''{2}'' dell''attributo ''{1}'' sull''elemento ''{0}'' non \u00E8 valido rispetto al suo '{'value constraint'}' fisso. L''attributo deve avere un valore pari a ''{3}''.
        cvc-complex-type.2.1 = cvc-complex-type.2.1: l''elemento "{0}" non deve avere [children] di voci di informazioni di carattere o elemento perch\u00E9 il tipo di contenuto \u00E8 vuoto.
        cvc-complex-type.2.2 = cvc-complex-type.2.2: l''elemento "{0}" non deve avere [children] di tipo elemento e il valore deve essere valido.
        cvc-complex-type.2.3 = cvc-complex-type.2.3: l''elemento "{0}" non deve avere [children] di tipo carattere perch\u00E9 il tipo di contenuto \u00E8 di soli elementi.
        cvc-complex-type.2.4.a = cvc-complex-type.2.4.a: contenuto non valido che inizia con l''elemento "{0}". \u00C8 previsto un elemento "{1}".
        cvc-complex-type.2.4.b = cvc-complex-type.2.4.b: il contenuto dell''elemento "{0}" non \u00E8 completo. \u00C8 previsto un elemento "{1}".
        cvc-complex-type.2.4.c = cvc-complex-type.2.4.c: il carattere jolly corrispondente \u00E8 rigoroso ma non \u00E8 possibile trovare una dichiarazione per l''elemento "{0}".
        cvc-complex-type.2.4.d = cvc-complex-type.2.4.d: contenuto non valido che inizia con l''elemento "{0}". Non sono previsti elementi figlio in questo punto.
        cvc-complex-type.2.4.d.1 = cvc-complex-type.2.4.d: contenuto non valido che inizia con l''elemento "{0}". Non \u00E8 previsto un elemento figlio ''{1}'' in questo punto.
        cvc-complex-type.2.4.e = cvc-complex-type.2.4.e: ''{0}'' si pu\u00F2 verificare massimo ''{2}'' volte nella sequenza corrente. Questo limite \u00E8 stato superato. \u00C8 previsto un elemento ''{1}'' in questo punto.
        cvc-complex-type.2.4.f = cvc-complex-type.2.4.f: ''{0}'' si pu\u00F2 verificare massimo ''{1}'' volte nella sequenza corrente. Questo limite \u00E8 stato superato. Non \u00E8 previsto un elemento figlio in questo punto.
        cvc-complex-type.2.4.g = cvc-complex-type.2.4.g: contenuto non valido che inizia con l''elemento ''{0}'' trovato. \u00C8 previsto che ''{1}'' si verifichi almeno ''{2}'' volte nella sequenza corrente. Per soddisfare questo vincolo, \u00E8 necessaria un''altra istanza.
        cvc-complex-type.2.4.h = cvc-complex-type.2.4.h: contenuto non valido che inizia con l''elemento ''{0}'' trovato. \u00C8 previsto che ''{1}'' si verifichi almeno ''{2}'' volte nella sequenza corrente. Per soddisfare questo vincolo, sono necessarie altre ''{3}'' istanze.
        cvc-complex-type.2.4.i = cvc-complex-type.2.4.i: il contenuto dell''elemento ''{0}'' non \u00E8 completo. \u00C8 previsto che ''{1}'' si verifichi almeno ''{2}'' volte. Per soddisfare questo vincolo, \u00E8 necessaria un''altra istanza.
        cvc-complex-type.2.4.j = cvc-complex-type.2.4.j: il contenuto dell''elemento ''{0}'' non \u00E8 completo. \u00C8 previsto che ''{1}'' si verifichi almeno ''{2}'' volte. Per soddisfare questo vincolo, sono necessarie altre ''{3}'' istanze.
        cvc-complex-type.3.1 = cvc-complex-type.3.1: il valore "{2}" dell''attributo "{1}" dell''elemento "{0}" non \u00E8 valido rispetto al uso corrispondente dell''attributo. L''attributo ''{1}'' ha un valore fisso pari a ''{3}''.
        cvc-complex-type.3.2.1 = cvc-complex-type.3.2.1: l''elemento "{0}" non ha un carattere jolly di attributo per l''attributo "{1}".
        cvc-complex-type.3.2.2 = cvc-complex-type.3.2.2: l''attributo "{1}" non \u00E8 consentito nell''elemento "{0}".
        cvc-complex-type.4 = cvc-complex-type.4: l''attributo ''{1}'' deve apparire sull''elemento "{0}".
        cvc-complex-type.5.1 = cvc-complex-type.5.1: nell''elemento "{0}", l''attributo "{1}" \u00E8 un ID Wild ma esiste gi\u00E0 un ID Wild "{2}". Pu\u00F2 esisterne solo uno.
        cvc-complex-type.5.2 = cvc-complex-type.5.2: nell''elemento "{0}", l''attributo "{1}" \u00E8 un ID Wild ma esiste gi\u00E0 un attributo "{2}" derivato dall''ID tra '{'attribute uses'}'.
        cvc-datatype-valid.1.2.1 = cvc-datatype-valid.1.2.1: "{0}" non \u00E8 un valore valido per "{1}".
        cvc-datatype-valid.1.2.2 = cvc-datatype-valid.1.2.2: "{0}" non \u00E8 un valore valido per il tipo di lista "{1}".
        cvc-datatype-valid.1.2.3 = cvc-datatype-valid.1.2.3: "{0}" non \u00E8 un valore valido per il tipo di unione "{1}".
        cvc-elt.1.a = cvc-elt.1.a: impossibile trovare la dichiarazione dell''elemento "{0}".
        cvc-elt.1.b = cvc-elt.1.b: il nome dell''elemento non corrisponde al nome della dichiarazione dell''elemento. Visualizzato ''{0}''. Previsto ''{1}''.
        cvc-elt.2 = cvc-elt.2: il valore di '{'abstract'}' nella dichiarazione di elemento per "{0}" deve essere false.
        cvc-elt.3.1 = cvc-elt.3.1: l''attributo "{1}" non deve apparire sull''elemento "{0}" perch\u00E9 la propriet\u00E0 '{'nillable'}' di "{0}" \u00E8 false.
        cvc-elt.3.2.1 = cvc-elt.3.2.1: l''elemento "{0}" non deve avere [children] di informazioni di tipo carattere o elemento perch\u00E9 \u00E8 specificato "{1}".
        cvc-elt.3.2.2 = cvc-elt.3.2.2: non deve esistere alcun '{'value constraint'}' fisso per l''elemento "{0}" perch\u00E9 \u00E8 specificato "{1}".
        cvc-elt.4.1 = cvc-elt.4.1: il valore "{2}" dell''attributo "{1}" per l''elemento "{0}" non \u00E8 un QName valido.
        cvc-elt.4.2 = cvc-elt.4.2: impossibile risolvere "{1}" in una definizione tipo per l''elemento "{0}".
        cvc-elt.4.3 = cvc-elt.4.3: tipo "{1}" non derivato in modo valido dalla definizione tipo ''{2}'' dell''elemento "{0}".
        cvc-elt.5.1.1 = cvc-elt.5.1.1: '{'value constraint'}' "{2}" dell''elemento "{0}" non \u00E8 un valore predefinito valido per il tipo "{1}".
        cvc-elt.5.2.2.1 = cvc-elt.5.2.2.1: l''elemento "{0}" non deve avere [children] di voci di informazioni di elemento.
        cvc-elt.5.2.2.2.1 = cvc-elt.5.2.2.2.1: il valore "{1}" dell''elemento "{0}" non corrisponde al valore fisso di '{'value constraint'}' "{2}".
        cvc-elt.5.2.2.2.2 = cvc-elt.5.2.2.2.2: il valore "{1}" dell''elemento "{0}" non corrisponde al valore di '{'value constraint'}' "{2}".
        cvc-enumeration-valid = cvc-enumeration-valid: il valore "{0}" non \u00E8 valido come facet rispetto all''enumerazione "{1}". Deve essere un valore dell''enumerazione.
        cvc-fractionDigits-valid = cvc-fractionDigits-valid: il valore ''{0}'' ha {1} cifre di frazione, ma il numero di cifre di frazione \u00E8 stato limitato a {2}.
        cvc-id.1 = cvc-id.1: non esiste alcuna associazione ID/IDREF per l''IDREF "{0}".
        cvc-id.2 = cvc-id.2: esistono pi\u00F9 ricorrenze del valore di ID "{0}".
        cvc-id.3 = cvc-id.3: un campo del vincolo di identit\u00E0 "{0}" corrispondeva all''elemento "{1}" ma questo elemento non ha un tipo semplice.
        cvc-length-valid = cvc-length-valid: il valore "{0}" con lunghezza = "{1}" non \u00E8 valido come facet rispetto alla lunghezza "{2}" per il tipo "{3}".
        cvc-maxExclusive-valid = cvc-maxExclusive-valid: il valore "{0}" non \u00E8 valido come facet rispetto a maxExclusive "{1}" per il tipo ''{2}''.
        cvc-maxInclusive-valid = cvc-maxInclusive-valid: il valore "{0}" non \u00E8 valido come facet rispetto a maxInclusive "{1}" per il tipo ''{2}''.
        cvc-maxLength-valid = cvc-maxLength-valid: il valore "{0}" con lunghezza = "{1}" non \u00E8 valido come facet rispetto a maxLength "{2}" per il tipo "{3}".
        cvc-minExclusive-valid = cvc-minExclusive-valid: il valore "{0}" non \u00E8 valido come facet rispetto a minExclusive "{1}" per il tipo ''{2}''.
        cvc-minInclusive-valid = cvc-minInclusive-valid: il valore "{0}" non \u00E8 valido come facet rispetto a minExclusive "{1}" per il tipo ''{2}''.
        cvc-minLength-valid = cvc-minLength-valid: il valore "{0}" con lunghezza = "{1}" non \u00E8 valido come facet rispetto a minLength "{2}" per il tipo "{3}".
        cvc-pattern-valid = cvc-pattern-valid: il valore "{0}" non \u00E8 valido come facet rispetto al pattern "{1}" per il tipo ''{2}''.
        cvc-totalDigits-valid = cvc-totalDigits-valid: il valore ''{0}'' ha {1} cifre di totale, ma il numero di cifre di totale \u00E8 stato limitato a {2}.
        cvc-type.1 = cvc-type.1: definizione tipo ''{0}'' non trovata.
        cvc-type.2 = cvc-type.2: la definizione tipo non pu\u00F2 essere astratta per l''elemento {0}.
        cvc-type.3.1.1 = cvc-type.3.1.1: l''elemento ''{0}'' \u00E8 di tipo semplice, quindi non pu\u00F2 avere attributi, tranne quelli il cui spazio di nomi \u00E8 uguale ''http://www.w3.org/2001/XMLSchema-instance'' e il cui [local name] \u00E8 uno tra ''type'', ''nil'', ''schemaLocation'' o ''noNamespaceSchemaLocation''. \u00C8 stato trovato l''attributo ''{1}''.
        cvc-type.3.1.2 = cvc-type.3.1.2: l''elemento "{0}" \u00E8 di tipo semplice, quindi non deve avere [children] di voci di informazioni di elemento.
        cvc-type.3.1.3 = cvc-type.3.1.3: il valore "{1}" dell''elemento "{0}" non \u00E8 valido.

#schema valid (3.X.3)

        schema_reference.access = schema_reference: lettura del documento di schema ''{0}'' non riuscita. Accesso ''{1}'' non consentito a causa della limitazione definita dalla propriet\u00E0 accessExternalSchema. 
        schema_reference.4 = schema_reference.4: lettura del documento di schema "{0}" non riuscita perch\u00E9 1) non \u00E8 stato possibile trovare il documento; 2) non \u00E8 stato possibile leggere il documento; 3) l''elemento radice del documento non \u00E8 <xsd:schema>.
        src-annotation = src-annotation: possono essere contenuti soltanto elementi <appinfo> e <documentation>, ma \u00E8 stato trovato ''{0}''.
        src-attribute.1 = src-attribute.1: le propriet\u00E0 ''default'' e ''fixed'' non possono essere entrambi presenti nella dichiarazione di attributo ''{0}''. Utilizzarne solo una.
        src-attribute.2 = src-attribute.2: la propriet\u00E0 ''default'' \u00E8 presente nell''attributo ''{0}'', quindi il valore di ''use'' deve essere ''optional''.
        src-attribute.3.1 = src-attribute.3.1: in una dichiarazione di attributo locale deve essere presente 'ref' o 'name'.
        src-attribute.3.2 = src-attribute.3.2: il contenuto deve corrispondere a (annotation?) per il riferimento di attributo "{0}".
        src-attribute.4 = src-attribute.4: l''attributo "{0}" ha sia un attributo ''type'' che un elemento figlio "simpleType" anonimo. \u00C8 consentito uno solo di questi valori per un attributo.
        src-attribute_group.2 = src-attribute_group.2: non \u00E8 possibile esprimere l''intersezione di caratteri jolly per il gruppo di attributi ''{0}''.
        src-attribute_group.3 = src-attribute_group.3: sono state rilevate definizioni circolari per il gruppo di attributi ''{0}''. Se si seguono ricorsivamente i riferimenti ai gruppi di attributi, si torna inevitabilmente al punto di partenza.
        src-ct.1 = src-ct.1: errore di rappresentazione della definizione di tipo complesso per il tipo ''{0}''. Se si utilizza <complexContent>, il tipo di base deve essere un complexType. ''{1}'' \u00E8 simpleType.
        src-ct.2.1 = src-ct.2.1: errore di rappresentazione della definizione di tipo complesso per il tipo ''{0}''. Se si utilizza <complexContent>, il tipo di base deve essere un complexType con tipo di contenuto semplice oppure, se \u00E8 specificata solo la limitazione, un tipo complesso con contenuto misto e parte svuotabile oppure, se \u00E8 specificato solo l''estensione, un tipo semplice. ''{1}'' non soddisfa alcuna di queste condizioni.
        src-ct.2.2 = src-ct.2.2: errore di rappresentazione della definizione di tipo complesso per il tipo "{0}". Quando un complexType con simpleContent limita un complexType con contenuto misto e parte svuotabile, deve esistere un <simpleType> tra gli elementi figlio di <restriction>.
        src-ct.4 = src-ct.4: errore di rappresentazione della definizione di tipo complesso per il tipo ''{0}''. Non \u00E8 possibile esprimere l''intersezione di caratteri jolly.
        src-ct.5 = src-ct.5: errore di rappresentazione della definizione di tipo complesso per il tipo ''{0}''. Non \u00E8 possibile esprimere l''unione di caratteri jolly.
        src-element.1 = src-element.1: le propriet\u00E0 ''default'' e ''fixed'' non possono essere entrambi presenti nella dichiarazione di elemento ''{0}''. Utilizzarne solo una.
        src-element.2.1 = src-element.2.1: in una dichiarazione di elemento locale deve essere presente 'ref' o 'name'.
        src-element.2.2 = src-element.2.2: poich\u00E9 ''{0}'' contiene l''attributo ''ref'', il suo contenuto deve corrispondere a (annotation?), ma \u00E8 stato trovato ''{1}''.
        src-element.3 = src-element.3: l''elemento "{0}" ha sia un attributo ''type'' che un elemento figlio "anonymous type". \u00C8 consentito uno solo di questi valori per un elemento.
        src-import.1.1 = src-import.1.1: l''attributo "{0}" dello spazio di nomi di una voce di informazioni di elemento <import> non deve essere uguale al targetNamespace dello schema in cui esiste.
        src-import.1.2 = src-import.1.2: se l'attributo dello spazio di nomi non \u00E8 presente in una voce di informazioni di elemento <import>, lo schema che lo contiene deve avere un targetNamespace.
        src-import.2 = src-import.2: l''elemento radice del documento "{0}" deve avere lo spazio di nomi denominato ''http://www.w3.org/2001/XMLSchema'' e il nome locale ''schema''.
        src-import.3.1 = src-import.3.1: l''attributo "{0}" dello spazio di nomi di una voce di informazioni di elemento <import> deve essere uguale all''attributo targetNamespace ''{1}'' del documento importato.
        src-import.3.2 = src-import.3.2: non esiste alcun attributo dello spazio di nomi nella voce di informazioni di elemento <import>, pertanto il documento importato non pu\u00F2 avere alcun attributo targetNamespace. tuttavia, \u00E8 stato trovato targetNamespace ''{1}'' nel documento importato.
        src-include.1 = src-include.1: l''elemento radice del documento "{0}" deve avere lo spazio di nomi denominato ''http://www.w3.org/2001/XMLSchema'' e il nome locale ''schema''.
        src-include.2.1 = src-include.2.1: targetNamespace dello schema di riferimento (attualmente "{1}") deve essere identico a quello dello schema di inclusione (attualmente "{0}").
        src-redefine.2 = src-redefine.2: l''elemento radice del documento "{0}" deve avere lo spazio di nomi denominato ''http://www.w3.org/2001/XMLSchema'' e il nome locale ''schema''.
        src-redefine.3.1 = src-redefine.3.1: targetNamespace dello schema di riferimento (attualmente "{1}") deve essere identico a quello dello schema di ridefinizione (attualmente "{0}").
        src-redefine.5.a.a = src-redefine.5.a.a: non \u00E8 stato trovato alcun elemento figlio di non annotazione di tipo <simpleType>. Gli elementi figlio <simpleType> di elementi <redefine> devono avere discendenti <restriction>, con attributi 'base' che fanno riferimento a s\u00E9 stessi.
        src-redefine.5.a.b = src-redefine.5.a.b: ''{0}'' non \u00E8 un elemento figlio valido. Gli elementi figlio <simpleType> di elementi <redefine> devono avere discendenti <restriction>, con attributi ''base'' che fanno riferimento a s\u00E9 stessi.
        src-redefine.5.a.c = src-redefine.5.a.c: ''{0}'' non dispone di un attributo "base" che fa riferimento all''elemento ridefinito ''{1}''. Gli elementi figlio <simpleType> di elementi <redefine> devono avere discendenti <restriction>, con attributi ''base'' che fanno riferimento a s\u00E9 stessi.
        src-redefine.5.b.a = src-redefine.5.b.a: non \u00E8 stato trovato alcun elemento figlio di non annotazione di tipo <complexType>. Gli elementi figlio <complexType> di elementi <redefine> devono avere discendenti <extension> o <restriction>, con attributi 'base' che fanno riferimento a s\u00E9 stessi.
        src-redefine.5.b.b = src-redefine.5.b.b: non \u00E8 stato trovato alcun elemento nipote di non annotazione di tipo <complexType>. Gli elementi figlio <complexType> di elementi <redefine> devono avere discendenti <extension> o <restriction>, con attributi 'base' che fanno riferimento a s\u00E9 stessi.
        src-redefine.5.b.c = src-redefine.5.b.c: ''{0}'' non \u00E8 un elemento nipote valido. Gli elementi figlio <complexType> di elementi <redefine> devono avere discendenti <extension> o <restriction>, con attributi ''base'' che fanno riferimento a s\u00E9 stessi.
        src-redefine.5.b.d = src-redefine.5.b.d: ''{0}'' non dispone di un attributo "base" che fa riferimento all''elemento ridefinito ''{1}''. Gli elementi figlio <complexType> di elementi <redefine> devono avere discendenti <extension> o <restriction>, con attributi ''base'' che fanno riferimento a s\u00E9 stessi.
        src-redefine.6.1.1 = src-redefine.6.1.1: se un elemento figlio del gruppo di un elemento <redefine> contiene un gruppo che fa riferimento a s\u00E9 stesso, deve averne esattamente uno, mentre questo ne ha "{0}".
        src-redefine.6.1.2 = src-redefine.6.1.2: il gruppo "{0}" che contiene un riferimento a un gruppo in fase di ridefinizione deve avere minOccurs = maxOccurs = 1.
        src-redefine.6.2.1 = src-redefine.6.2.1: nessun gruppo nello schema ridefinito con nome corrispondente a "{0}".
        src-redefine.6.2.2 = src-redefine.6.2.2: il gruppo "{0}" non limita correttamente il gruppo che ridefinisce; vincolo violato: "{1}".
        src-redefine.7.1 = src-redefine.7.1: se un elemento figlio attributeGroup di un elemento <redefine> contiene un attributeGroup che fa riferimento a s\u00E9 stesso, deve averne esattamente uno, mentre questo ne ha "{0}".
        src-redefine.7.2.1 = src-redefine.7.2.1: nessun attributeGroup nello schema ridefinito con nome corrispondente a "{0}".
        src-redefine.7.2.2 = src-redefine.7.2.2: AttributeGroup "{0}" non limita correttamente l''AttributeGroup che ridefinisce; vincolo violato: "{1}".
        src-resolve = src-resolve: impossibile risolvere il nome "{0}" in un componente {1}.
        src-resolve.4.1 = src-resolve.4.1: errore durante la risoluzione del componente ''{2}''. \u00C8 stato rilevato che ''{2}'' non dispone di uno spazio di nomi, ma ai componenti senza spazi di nomi di destinazione non \u00E8 possibile fare riferimento dal documento di schema ''{0}''. Se \u00E8 previsto che ''{2}'' abbia uno spazio di nomi, \u00E8 probabile che sia necessario specificare un prefisso. Se, invece, \u00E8 previsto che ''{2}'' non abbia uno spazio di nomi, aggiungere ''import'' senza un attributo "namespace" a ''{0}''.
        src-resolve.4.2 = src-resolve.4.2: errore durante la risoluzione del componente ''{2}''. \u00C8 stato rilevato che ''{2}'' si trova nello spazio di nomi ''{1}'', ma ai componenti di questo spazio di nomi di destinazione non \u00E8 possibile fare riferimento dal documento di schema ''{0}''. Se questo spazio di nomi \u00E8 errato, \u00E8 probabile che sia necessario modificare il prefisso ''{2}''. Se lo spazio di nomi \u00E8 corretto, aggiungere la tag ''import'' adeguata a ''{0}''.
        src-simple-type.2.a = src-simple-type.2.a: \u00E8 stato trovato un elemento <restriction> che contiene sia un [attribute] di base che un elemento <simpleType> tra i rispettivi [children]. \u00C8 consentito solo uno.
        src-simple-type.2.b = src-simple-type.2.b: \u00E8 stato trovato un elemento <restriction> che non contiene n\u00E9 un [attribute] di base n\u00E9 un elemento <simpleType> tra i rispettivi [children]. Ne \u00E8 richiesto uno.
        src-simple-type.3.a = src-simple-type.3.a: \u00E8 stato trovato un elemento <list> che contiene sia un [attribute] itemType che un elemento <simpleType> tra i rispettivi [children]. \u00C8 consentito solo uno.
        src-simple-type.3.b = src-simple-type.3.b: \u00E8 stato trovato un elemento <list> che non contiene n\u00E9 un [attribute] itemType n\u00E9 un elemento <simpleType> tra i rispettivi [children]. Ne \u00E8 richiesto uno.
        src-single-facet-value = src-single-facet-value: il facet ''{0}'' \u00E8 stato definito pi\u00F9 volte.
        src-union-memberTypes-or-simpleTypes = src-union-memberTypes-or-simpleTypes: un elemento <union> deve avere un [attribute] memberTypes non vuoto o almeno un elemento <simpleType> tra i rispettivi [children].

#constraint valid (3.X.6)

        ag-props-correct.2 = ag-props-correct.2: errore per il gruppo di attributi "{0}". Sono specificati usi di attributi duplicati con lo stesso nome e spazio di nomi di destinazione. Il nome dell''uso dell''attributo duplicato \u00E8 "{1}".
        ag-props-correct.3 = ag-props-correct.3: errore per il gruppo di attributi "{0}". Due dichiarazioni di attributo, "{1}" e "{2}" hanno tipi derivati dall''ID.
        a-props-correct.2 = a-props-correct.2: valore di vincolo di valore "{1}" non valido nell''attributo "{0}".
        a-props-correct.3 = a-props-correct.3: l''attributo ''{0}'' non pu\u00F2 utilizzare il valore ''fixed'' o ''default'' poich\u00E9 la '{'type definition'}' dell''attributo \u00E8 un ID o \u00E8 derivata dall''ID.
        au-props-correct.2 = au-props-correct.2: nella dichiarazione di attributo di ''{0}'' \u00E8 stato specificato un valore fisso ''{1}''. Se, pertanto, l''uso dell''attributo che fa riferimento a ''{0}'' ha anche un valore '{'value constraint'}', deve essere fisso e il suo valore deve essere ''{1}''.
        cos-all-limited.1.2 = cos-all-limited.1.2: deve apparire un gruppo di modelli 'all' in una parte con '{'min occurs'}' = '{'max occurs'}' = 1 e la parte deve far parte di una coppia che costituisca il '{'content type'}' di una definizione di tipo complesso.
        cos-all-limited.2 = cos-all-limited.2: il valore '{'max occurs'}' di un elemento in un gruppo di modelli ''all'' deve essere 0 o 1. Il valore ''{0}'' per l''elemento ''{1}'' non \u00E8 valido.
        cos-applicable-facets = cos-applicable-facets: facet ''{0}'' non consentito dal tipo {1}.
        cos-ct-extends.1.1 = cos-ct-extends.1.1: il tipo ''{0}'' \u00E8 stato derivato mediante estensione dal tipo ''{1}'', ma l''attributo "final" di ''{1}'' impedisce la derivazione mediante estensione.
        cos-ct-extends.1.4.3.2.2.1.a = cos-ct-extends.1.4.3.2.2.1.a: Il tipo di contenuto di un tipo derivato e quello della rispettiva base devono essere entrambi misti o di soli elementi. Il tipo ''{0}'' \u00E8 di soli elementi, mentre la rispettiva base non lo \u00E8.
        cos-ct-extends.1.4.3.2.2.1.b = cos-ct-extends.1.4.3.2.2.1.b: Il tipo di contenuto di un tipo derivato e quello della rispettiva base devono essere entrambi misti o di soli elementi. Il tipo ''{0}'' \u00E8 misto, mentre la rispettiva base non lo \u00E8.
        cos-element-consistent = cos-element-consistent: errore per il tipo "{0}". Nel gruppo di modelli appaiono pi\u00F9 elementi con nome "{1}" e tipi diversi.
        cos-list-of-atomic = cos-list-of-atomic: nella definizione del tipo di lista ''{0}'', il tipo ''{1}'' non \u00E8 valido poich\u00E9 non \u00E8 indivisibile (''{1}'' \u00E8 un tipo di lista o un tipo di unione che contiene una lista).
        cos-nonambig = cos-nonambig: {0} e {1} (o gli elementi derivanti dal gruppo di sostituzione) violano "Unique Particle Attribution". Durante la convalida su questo schema, si creerebbe un''ambiguit\u00E0 per le due parti.
        cos-particle-restrict.a = cos-particle-restrict.a: la parte derivata \u00E8 vuota, mente la base non \u00E8 svuotabile.
        cos-particle-restrict.b = cos-particle-restrict.b: la parte della base \u00E8 vuota, mente la parte derivata non lo \u00E8.
        cos-particle-restrict.2 = cos-particle-restrict.2: limitazione di parte vietata: ''{0}''.
        cos-st-restricts.1.1 = cos-st-restricts.1.1: il tipo ''{1}'' \u00E8 indivisibile, quindi la '{'base type definition'}' "{0}" deve essere una definizione di tipo semplice indivisibile o un tipo di dati predefinito incorporato.
        cos-st-restricts.2.1 = cos-st-restricts.2.1: nella definizione del tipo di lista ''{0}'', il tipo ''{1}'' non \u00E8 valido poich\u00E9 \u00E8 un tipo di lista o un tipo di unione che contiene una lista.
        cos-st-restricts.2.3.1.1 = cos-st-restricts.2.3.1.1: il componente '{'final'}' di '{'item type definition'}' ''{0}'' contiene ''list'', pertanto ''{0}'' non pu\u00F2 essere utilizzato come tipo di elemento per il tipo di lista ''{1}''.
        cos-st-restricts.3.3.1.1 = cos-st-restricts.3.3.1.1: il componente '{'final'}' di '{'member type definitions'}' ''{0}'' contiene ''union'', pertanto ''{0}'' non pu\u00F2 essere utilizzato come tipo di membro per il tipo di unione ''{1}''.
        cos-valid-default.2.1 = cos-valid-default.2.1: l''elemento "{0}" ha un vincolo di valore e deve avere un modello di contenuto misto o semplice.
        cos-valid-default.2.2.2 = cos-valid-default.2.2.2: l''elemento ''{0}'' ha un '{'value constraint'}' e la rispettiva definizione del tipo contiene '{'content type'}' misto, quindi la parte di '{'content type'}' deve essere svuotabile.
        c-props-correct.2 = c-props-correct.2: la cardinalit\u00E0 dei campi per il keyref "{0}" e per la chiave "{1}" deve corrispondere.
        ct-props-correct.3 = ct-props-correct.3: sono state rilevate definizioni circolari per il tipo complesso ''{0}''. Ci\u00F2 significa che ''{0}'' si trova all''interno della sua stessa gerarchia di tipi, il che \u00E8 errato.
        ct-props-correct.4 = ct-props-correct.4: errore per il tipo "{0}". Sono specificati usi di attributi duplicati con lo stesso nome e spazio di nomi di destinazione. Il nome dell''uso dell''attributo duplicato \u00E8 "{1}".
        ct-props-correct.5 = ct-props-correct.5: errore per il tipo "{0}". Due dichiarazioni di attributo, "{1}" e "{2}" hanno tipi derivati dall''ID.
        derivation-ok-restriction.1 = derivation-ok-restriction.1: il tipo ''{0}'' \u00E8 stato derivato mediante limitazione dal tipo ''{1}'', ma ''{1}'' ha una propriet\u00E0 '{'final'}' che impedisce la derivazione mediante limitazione.
        derivation-ok-restriction.2.1.1 = derivation-ok-restriction.2.1.1: errore per il tipo "{0}". Un uso dell''attributo ''{1}'' in questo tipo ha un valore "use" ''{2}'' che \u00E8 incoerente con il valore di ''required'' in un uso corrispondente dell''attributo nel tipo di base.
        derivation-ok-restriction.2.1.2 = derivation-ok-restriction.2.12: errore per il tipo "{0}". Un uso dell''attributo ''{1}'' in questo tipo ha un valore tipo ''{2}'' che \u00E8 stato derivato in modo valido da ''{3}'', ovvero dal tipo di uso corrispondente dell''attributo nel tipo di base.
        derivation-ok-restriction.2.1.3.a = derivation-ok-restriction.2.1.3.a: errore per il tipo "{0}". L''uso dell''attributo ''{1}'' in questo tipo ha un vincolo di valore effettivo che \u00E8 fisso, mentre il vincolo di valore effettivo dell''uso dell''attributo corrispondente nel tipo di base \u00E8 fisso.
        derivation-ok-restriction.2.1.3.b = derivation-ok-restriction.2.1.3.b: errore per il tipo "{0}". L''uso dell''attributo ''{1}'' in questo tipo ha un vincolo di valore effettivo fisso con valore ''{2}'', che \u00E8 incoerente con il valore ''{3}'' per il vincolo di valore effettivo fisso dell''uso dell''attributo corrispondente nel tipo di base.
        derivation-ok-restriction.2.2.a = derivation-ok-restriction.2.2.a: errore per il tipo "{0}". L''uso dell''attributo ''{1}'' in questo tipo non ha un uso dell''attributo corrispondente nella base e il tipo di base non ha alcun attributo di carattere jolly.
        derivation-ok-restriction.2.2.b = derivation-ok-restriction.2.2.b: errore per il tipo "{0}". L''uso dell''attributo ''{1}'' in questo tipo non ha un uso dell''attributo corrispondente nella base e il carattere jolly nel tipo di base non consente lo spazio di nomi ''{2}'' di questo uso dell''attributo.
        derivation-ok-restriction.3 = derivation-ok-restriction.3: errore per il tipo "{0}". Nell''uso dell''attributo ''{1}'' nel tipo di base, REQUIRED \u00E8 impostato su true, ma non esiste alcun uso dell''attributo corrispondente nel tipo derivato.
        derivation-ok-restriction.4.1 = derivation-ok-restriction.4.1: errore per il tipo "{0}". La derivazione ha un carattere jolly dell''attributo, ma la base non ne ha uno.
        derivation-ok-restriction.4.2 = derivation-ok-restriction.4.2: errore per il tipo "{0}". Il carattere jolly nella derivazione non \u00E8 un subset di caratteri jolly valido di quello nella base.
        derivation-ok-restriction.4.3 = derivation-ok-restriction.4.3: errore per il tipo "{0}". Il contenuto del processo del carattere jolly nella derivazione ({1}) \u00E8 pi\u00F9 debole di quello nella base ({2}).
        derivation-ok-restriction.5.2.2.1 = derivation-ok-restriction.5.2.2.1: errore per il tipo ''{0}''. Il tipo di contenuto semplice ''del tipo ''{1}'' non \u00E8 una limitazione valida del tipo di contenuto semplice della base ''{2}''.
        derivation-ok-restriction.5.3.2 = derivation-ok-restriction.5.3.2: errore per il tipo ''{0}''. Il tipo di contenuto di questo tipo \u00E8 vuoto, ma il tipo di contenuto della base ''{1}'' non \u00E8 vuoto o svuotabile.
        derivation-ok-restriction.5.4.1.2 = derivation-ok-restriction.5.4.1.2: errore per il tipo "{0}". Il tipo di contenuto di questo tipo \u00E8 misto, ma il tipo di contenuto della base ''{1}'' non lo \u00E8.
        derivation-ok-restriction.5.4.2 = derivation-ok-restriction.5.4.2: errore per il tipo "{0}". La parte del tipo non \u00E8 una limitazione valida della parte della base.
        enumeration-required-notation = enumeration-required-notation: il tipo NOTATION ''{0}'' utilizzato da {2} ''{1}'' deve avere un valore di facet di enumerazione che specifica gli elementi di notazione utilizzati da questo tipo.
        enumeration-valid-restriction = enumeration-valid-restriction: il valore di enumerazione "{0}" non \u00E8 nello spazio dei valori del tipo di base {1}.
        e-props-correct.2 = e-props-correct.2: valore di vincolo di valore "{1}" non valido nell''elemento "{0}".
        e-props-correct.4 = e-props-correct.4: '{'type definition'}' dell''elemento "{0}" non \u00E8 stata derivata in modo valido da '{'type definition'}' di substitutionHead "{1}" o la propriet\u00E0 '{'substitution group exclusions'}' di ''{1}'' non consente questa derivazione.
        e-props-correct.5 = e-props-correct.5: non deve esistere '{'value constraint'}' sull''elemento "{0}" perch\u00E9 '{'type definition'}' dell''elemento o '{'content type'}' di '{'type definition'}' \u00E8 un ID o \u00E8 derivato da un ID.
        e-props-correct.6 = e-props-correct.6: gruppo di sostituzione circolare rilevato per l''elemento "{0}".
        fractionDigits-valid-restriction = fractionDigits-valid-restriction: nella definizione di {2}, il valore ''{0}'' per il facet ''fractionDigits'' non \u00E8 valido. Deve essere <= rispetto al valore per ''fractionDigits'', impostato su ''{1}'' in uno dei tipi di predecessore.
        fractionDigits-totalDigits = fractionDigits-totalDigits: nella definizione di {2}, il valore ''{0}'' per il facet ''fractionDigits'' non \u00E8 valido. Il valore deve essere <= rispetto al valore per ''totalDigits'', impostato su ''{1}''.
        length-minLength-maxLength.1.1 = length-minLength-maxLength.1.1: per il tipo {0}, il valore di lunghezza ''{1}'' non pu\u00F2 essere minore del valore di minLength ''{2}''.
        length-minLength-maxLength.1.2.a = length-minLength-maxLength.1.2.a: per il tipo {0}, la base non pu\u00F2 avere un facet minLength se la limitazione corrente ha un facet minLength e la limitazione corrente o la base ha un facet di lunghezza.
        length-minLength-maxLength.1.2.b = length-minLength-maxLength.1.2.b: per il tipo {0}, il valore corrente di minLength ''{1}'' deve essere uguale a valore di minLength ''{2}'' della base.
        length-minLength-maxLength.2.1 = length-minLength-maxLength.2.1: per il tipo {0}, il valore di lunghezza ''{1}'' non pu\u00F2 essere maggiore del valore di maxLength ''{2}''.
        length-minLength-maxLength.2.2.a = length-minLength-maxLength.2.2.a: per il tipo {0}, la base non pu\u00F2 avere un facet maxLength se la limitazione corrente ha un facet maxLength e la limitazione corrente o la base ha un facet di lunghezza.
        length-minLength-maxLength.2.2.b = length-minLength-maxLength.2.2.b: per il tipo {0}, il valore corrente di maxLength ''{1}'' deve essere uguale a valore di maxLength ''{2}'' della base.
        length-valid-restriction = length-valid-restriction: errore per il tipo ''{2}''. Il valore della lunghezza = "{0}" deve essere = al valore di quella del tipo di base "{1}".
        maxExclusive-valid-restriction.1 = maxExclusive-valid-restriction.1: errore per il tipo ''{2}''. Il valore maxExclusive ="{0}" deve essere <= maxExclusive del tipo di base "{1}".
        maxExclusive-valid-restriction.2 = maxExclusive-valid-restriction.2: errore per il tipo ''{2}''. Il valore maxInclusive ="{0}" deve essere <= maxExclusive del tipo di base "{1}".
        maxExclusive-valid-restriction.3 = maxExclusive-valid-restriction.3: errore per il tipo ''{2}''. Il valore maxExclusive ="{0}" deve essere > minInclusive del tipo di base "{1}".
        maxExclusive-valid-restriction.4 = maxExclusive-valid-restriction.2: errore per il tipo ''{2}''. Il valore maxExclusive ="{0}" deve essere > minExclusive del tipo di base "{1}".
        maxInclusive-maxExclusive = maxInclusive-maxExclusive: non \u00E8 possibile specificare sia maxInclusive che maxExclusive per lo stesso tipo di dati. In {2}, maxInclusive = ''{0}'' e maxExclusive = ''{1}''.
        maxInclusive-valid-restriction.1 = maxInclusive-valid-restriction.1: errore per il tipo ''{2}''. Il valore maxInclusive ="{0}" deve essere <= maxInclusive del tipo di base "{1}".
        maxInclusive-valid-restriction.2 = maxInclusive-valid-restriction.2: errore per il tipo ''{2}''. Il valore maxInclusive ="{0}" deve essere <= maxExclusive del tipo di base "{1}".
        maxInclusive-valid-restriction.3 = maxInclusive-valid-restriction.3: errore per il tipo ''{2}''. Il valore maxInclusive ="{0}" deve essere >= minInclusive del tipo di base "{1}".
        maxInclusive-valid-restriction.4 = maxInclusive-valid-restriction.4: errore per il tipo ''{2}''. Il valore maxInclusive ="{0}" deve essere > minExclusive del tipo di base "{1}".
        maxLength-valid-restriction = maxLength-valid-restriction: nella definizione di {2}, il valore maxLength = "{0}" deve essere <= rispetto a quello del tipo di base "{1}".
        mg-props-correct.2 = mg-props-correct.2: definizioni circolari rilevate per il gruppo ''{0}''. Se si seguono in maniera ricorsiva i valori '{'term'}' delle parti, se ne avr\u00E0 una il cui '{'term'}' \u00E8 il gruppo stesso.
        minExclusive-less-than-equal-to-maxExclusive = minExclusive-less-than-equal-to-maxExclusive: nella definizione di {2}, il valore minExclusive = ''{0}'' deve essere <= rispetto al valore maxExclusive = ''{1}''.
        minExclusive-less-than-maxInclusive = minExclusive-less-than-maxInclusive: nella definizione di {2}, il valore minExclusive = ''{0}'' deve essere <= rispetto al valore maxInclusive = ''{1}''.
        minExclusive-valid-restriction.1 = minExclusive-valid-restriction.1: errore per il tipo ''{2}''. Il valore minExclusive ="{0}" deve essere >= minExclusive del tipo di base "{1}".
        minExclusive-valid-restriction.2 = minExclusive-valid-restriction.2: errore per il tipo ''{2}''. Il valore minExclusive ="{0}" deve essere <= maxInclusive del tipo di base "{1}".
        minExclusive-valid-restriction.3 = minExclusive-valid-restriction.4: errore per il tipo ''{2}''. Il valore minExclusive ="{0}" deve essere >= minInclusive del tipo di base "{1}".
        minExclusive-valid-restriction.4 = minExclusive-valid-restriction.4: errore per il tipo ''{2}''. Il valore minExclusive ="{0}" deve essere < maxExclusive del tipo di base "{1}".
        minInclusive-less-than-equal-to-maxInclusive = minInclusive-less-than-equal-to-maxInclusive: nella definizione di {2}, il valore minInclusive = ''{0}'' deve essere <= rispetto al valore maxInclusive = ''{1}''.
        minInclusive-less-than-maxExclusive = minInclusive-less-than-maxExclusive: nella definizione di {2}, il valore minInclusive = ''{0}'' deve essere < rispetto al valore maxExclusive = ''{1}''.
        minInclusive-minExclusive = minInclusive-minExclusive: non \u00E8 possibile specificare sia minInclusive che minExclusive per lo stesso tipo di dati. In {2}, minInclusive = ''{0}'' e minExclusive = ''{1}''.
        minInclusive-valid-restriction.1 = minInclusive-valid-restriction.1: errore per il tipo ''{2}''. Il valore minInclusive ="{0}" deve essere >= minInclusive del tipo di base "{1}".
        minInclusive-valid-restriction.2 = minInclusive-valid-restriction.2: errore per il tipo ''{2}''. Il valore minInclusive ="{0}" deve essere <= maxInclusive del tipo di base "{1}".
        minInclusive-valid-restriction.3 = minInclusive-valid-restriction.3: errore per il tipo ''{2}''. Il valore minInclusive ="{0}" deve essere > minExclusive del tipo di base "{1}".
        minInclusive-valid-restriction.4 = minInclusive-valid-restriction.4: errore per il tipo ''{2}''. Il valore minInclusive ="{0}" deve essere < maxExclusive del tipo di base "{1}".
        minLength-less-than-equal-to-maxLength = minLength-less-than-equal-to-maxLength: nella definizione di {2}, il valore minLength = ''{0}'' deve essere < rispetto al valore maxLength = ''{1}''.
        minLength-valid-restriction = minLength-valid-restriction: nella definizione di {2}, minLength = ''{0}'' deve essere >= rispetto a quello del tipo di base ''{1}''.
        no-xmlns = no-xmlns: il {'name'} di una dichiarazione di attributo non deve corrispondere a 'xmlns'.
        no-xsi = no-xsi: il '{'target namespace'}' di una dichiarazione di attributo non deve corrispondere a "{0}".
        p-props-correct.2.1 = p-props-correct.2.1: nella dichiarazione di ''{0}'', il valore di ''minOccurs'' \u00E8 ''{1}'', ma non deve essere maggiore del valore di ''maxOccurs'', che \u00E8 ''{2}''.
        rcase-MapAndSum.1 = rcase-MapAndSum.1: non esiste un mapping funzionale completo tra le parti.
        rcase-MapAndSum.2 = rcase-MapAndSum.2: l''intervallo di ricorrenza ({0},{1}) del gruppo non \u00E8 una limitazione valida dell''intervallo di ricorrenza ({2},{3}) del gruppo di base.
        rcase-NameAndTypeOK.1 = rcase-NameAndTypeOK.1: alcuni elementi hanno nomi e spazi di nomi di destinazione che non sono uguali: l''elemento "{0}" nello spazio di nomi "{1}" e l''elemento "{2}" nello spazio di nomi "{3}".
        rcase-NameAndTypeOK.2 = rcase-NameAndTypeOK.2: errore per la parte il cui '{'term'}' \u00E8 la dichiarazione di elemento ''{0}''. Il valore '{'nillable'}' della dichiarazione di elemento \u00E8 impostato su true, ma la parte corrispondente nel tipo di base contiene una dichiarazione di elemento per la quale '{'nillable'}' \u00E8 impostato su false.
        rcase-NameAndTypeOK.3 = rcase-NameAndTypeOK.3: errore per la parte il cui '{'term'}' \u00E8 la dichiarazione di elemento ''{0}''. L''intervallo di ricorrenza ({1},{2}) non \u00E8 una limitazione valida dell''intervallo ({3},{4}) della parte corrispondente nel tipo di base.
        rcase-NameAndTypeOK.4.a = rcase-NameAndTypeOK.4.a: l''elemento "{0}" non \u00E8 fisso, ma l''elemento corrispondente nel tipo di base \u00E8 fisso con il valore ''{1}''.
        rcase-NameAndTypeOK.4.b = rcase-NameAndTypeOK.4.b: l''elemento "{0}" \u00E8 fisso con il valore ''{1}'', ma l''elemento corrispondente nel tipo di base \u00E8 fisso con il valore ''{2}''.
        rcase-NameAndTypeOK.5 = rcase-NameAndTypeOK.5: i vincoli di identit\u00E0 per l''elemento "{0}" non sono un subset di quelli nella base.
        rcase-NameAndTypeOK.6 = rcase-NameAndTypeOK.6: le sostituzioni non consentite per l''elemento "{0}" non sono un superset di quelle nella base.
        rcase-NameAndTypeOK.7 = rcase-NameAndTypeOK.7: il tipo "{1}" dell''elemento "{0}" non deriva dal tipo dell''elemento di base "{2}".
        rcase-NSCompat.1 = rcase-NSCompat.1: l''elemento "{0}" ha uno spazio di nomi "{1}" che non \u00E8 consentito dal carattere jolly nella base.
        rcase-NSCompat.2 = rcase-NSCompat.2: errore per la parte il cui '{'term'}' \u00E8 la dichiarazione di elemento ''{0}''. L''intervallo di ricorrenza ({1},{2}) non \u00E8 una limitazione valida dell''intervallo ({3},{4}) della parte corrispondente nel tipo di base.
        rcase-NSRecurseCheckCardinality.1 = rcase-NSRecurseCheckCardinality.1: non esiste un mapping funzionale completo tra le parti.
        rcase-NSRecurseCheckCardinality.2 = rcase-NSRecurseCheckCardinality.2: l''intervallo di ricorrenza ({0},{1}) del gruppo non \u00E8 una limitazione valida dell''intervallo ({2},{3}) del carattere jolly di base.
        rcase-NSSubset.1 = rcase-NSSubset.1: il carattere jolly non \u00E8 un subset del carattere jolly corrispondente nella base.
        rcase-NSSubset.2 = rcase-NSSubset.2: l''intervallo di ricorrenza ({0},{1}) del carattere jolly non \u00E8 una limitazione valida di quello nella base ({2},{3}).
        rcase-NSSubset.3 = rcase-NSSubset.3: il contenuto ''{0}'' del processo del carattere jolly \u00E8 pi\u00F9 debole di quello della base ''{1}''.
        rcase-Recurse.1 = rcase-Recurse.1: l''intervallo di ricorrenza ({0},{1}) del gruppo non \u00E8 una limitazione valida dell''intervallo di ricorrenza ({2},{3}) del gruppo di base.
        rcase-Recurse.2 = rcase-Recurse.2: non esiste un mapping funzionale completo tra le parti.
        rcase-RecurseLax.1 = rcase-RecurseLax.1: l''intervallo di ricorrenza ({0},{1}) del gruppo non \u00E8 una limitazione valida dell''intervallo di ricorrenza ({2},{3}) del gruppo di base.
        rcase-RecurseLax.2 = rcase-RecurseLax.2: non esiste un mapping funzionale completo tra le parti.
        rcase-RecurseUnordered.1 = rcase-RecurseUnordered.1: l''intervallo di ricorrenza ({0},{1}) del gruppo non \u00E8 una limitazione valida dell''intervallo di ricorrenza ({2},{3}) del gruppo di base.
        rcase-RecurseUnordered.2 = rcase-RecurseUnordered.2: non esiste un mapping funzionale completo tra le parti.
#        We're using sch-props-correct.2 instead of the old src-redefine.1
#        src-redefine.1 = src-redefine.1: The component ''{0}'' is begin redefined, but its corresponding component isn't in the schema document being redefined (with namespace ''{2}''), but in a different document, with namespace ''{1}''.
        sch-props-correct.2 = sch-props-correct.2: uno schema non pu\u00F2 contenere due componenti globali con lo stesso nome; questo contiene due ricorrenze di "{0}".
        st-props-correct.2 = st-props-correct.2: sono state rilevate definizioni circolari per il tipo semplice ''{0}''. Ci\u00F2 significa che ''{0}'' si trova all''interno della sua stessa gerarchia di tipi, il che \u00E8 errato.
        st-props-correct.3 = st-props-correct.3: errore per il tipo ''{0}''. Il valore di '{'final'}' per '{'base type definition'}', ''{1}'', impedisce la derivazione mediante limitazione.
        totalDigits-valid-restriction = totalDigits-valid-restriction: nella definizione di {2}, il valore ''{0}'' per il facet ''totalDigits'' non \u00E8 valido. Deve essere <= rispetto al valore per ''totalDigits'', impostato su ''{1}'' in uno dei tipi di predecessore.
        whiteSpace-valid-restriction.1 = whiteSpace-valid-restriction.1: nella definizione di {0}, il valore ''{1}'' per il facet ''whitespace'' non \u00E8 valido. Il valore per ''whitespace'' \u00E8 stato impostato su ''collapse'' in uno dei tipi di predecessore.
        whiteSpace-valid-restriction.2 = whiteSpace-valid-restriction.2: nella definizione di {0}, il valore ''preserve'' per il facet ''whitespace'' non \u00E8 valido. Il valore per ''whitespace'' \u00E8 stato impostato su ''replace'' in uno dei tipi di predecessore.

#schema for Schemas

        s4s-att-invalid-value = s4s-att-invalid-value: valore di attributo non valido per "{1}" nell''elemento "{0}": Motivo registrato: {2}
        s4s-att-must-appear = s4s-att-must-appear: l''attributo ''{1}'' deve apparire nell''elemento "{0}".
        s4s-att-not-allowed = s4s-att-not-allowed: l''attributo ''{1}'' non pu\u00F2 apparire nell''elemento "{0}".
        s4s-elt-invalid = s4s-elt-invalid: l''elemento "{0}" non \u00E8 un elemento valido nel documento dello schema.
        s4s-elt-must-match.1 = s4s-elt-must-match.1: il contenuto di "{0}" deve corrispondere a {1}. Si \u00E8 verificato un problema con inizio in {2}.
        s4s-elt-must-match.2 = s4s-elt-must-match.2: il contenuto di "{0}" deve corrispondere a {1}. Non sono stati trovati elementi sufficienti.
        # the "invalid-content" messages provide less information than the "must-match" counterparts above. They're used for complex types when providing a "match" would be an information dump
        s4s-elt-invalid-content.1 = s4s-elt-invalid-content.1: il contenuto di ''{0}'' non \u00E8 valido. L''elemento ''{1}'' non \u00E8 valido, si trova in una posizione errata o \u00E8 presente troppe volte.
        s4s-elt-invalid-content.2 = s4s-elt-invalid-content.2: il contenuto di ''{0}'' non \u00E8 valido. L''elemento ''{1}'' non pu\u00F2 essere vuoto.
        s4s-elt-invalid-content.3 = s4s-elt-invalid-content.3: gli elementi di tipo ''{0}'' non possono trovarsi dopo dichiarazioni come elementi figlio di un elemento <schema>.
        s4s-elt-schema-ns = s4s-elt-schema-ns: lo spazio di nomi dell''elemento ''{0}'' deve derivare dallo spazio di nomi dello schema ''http://www.w3.org/2001/XMLSchema''.
        s4s-elt-character = s4s-elt-character: non sono consentiti caratteri diversi dallo spazio negli elementi di schema diversi da ''xs:appinfo'' e ''xs:documentation''. Rilevato "{0}".

# codes not defined by the spec

        c-fields-xpaths = c-fields-xpaths: il valore di campo = "{0}" non \u00E8 valido.
        c-general-xpath = c-general-xpath: l''espressione "{0}" non \u00E8 valida rispetto al subset XPath supportato dallo schema XML.
        c-general-xpath-ns = c-general-xpath-ns: un prefisso dello spazio di nomi nell''espressione XPath "{0}" non \u00E8 associato a uno spazio di nomi.
        c-selector-xpath = c-selector-xpath: il valore del selettore = "{0}" non \u00E8 valido; gli XPath del selettore non possono contenere attributi.
        EmptyTargetNamespace = EmptyTargetNamespace: nel documento di schema ''{0}'' il valore dell''attributo ''targetNamespace'' non pu\u00F2 essere una stringa vuota.
        FacetValueFromBase = FacetValueFromBase: nella dichiarazione del tipo ''{0}'' il valore ''{1}'' del facet ''{2}'' deve provenire dallo spazio di valori del tipo di base ''{3}''.
        FixedFacetValue = FixedFacetValue: nella definizione di {3}, il valore ''{1}'' per il facet ''{0}'' non \u00E8 valido. Il valore per ''{0}'' \u00E8 stato impostato su ''{2}'' in uno dei tipi di predecessore e '{'fixed'}' = true.
        InvalidRegex = InvalidRegex: il valore di pattern "{0}" non \u00E8 un''espressione regolare valida. Errore segnalato ''{1}'' nella colonna ''{2}''.
        MaxOccurLimit = La configurazione corrente del parser non consente che un valore di attributo maxOccurs sia impostato su un valore maggiore del valore {0}.
        PublicSystemOnNotation = PublicSystemOnNotation: almeno uno tra ''public'' e ''system'' deve essere presente nell'elemento ''notation''.
        SchemaLocation = SchemaLocation: il valore = ''{0}'' di schemaLocation deve avere un numero pari di URI.
        TargetNamespace.1 = TargetNamespace.1: lo spazio di nomi previsto \u00E8 "{0}", ma lo spazio di nomi di destinazione del documento dello schema \u00E8 "{1}".
        TargetNamespace.2 = TargetNamespace.2: non \u00E8 previsto nessuno spazio di nomi, ma il documento dello schema ha uno spazio di nomi di destinazione ''{1}''.
        UndeclaredEntity = UndeclaredEntity: l''entit\u00E0 ''{0}'' non \u00E8 stata dichiarata.
        UndeclaredPrefix = UndeclaredPrefix: impossibile risolvere ''{0}'' come QName. Il prefisso ''{1}'' non \u00E8 stato dichiarato.


# JAXP 1.2 schema source property errors

        jaxp12-schema-source-type.1 = La propriet\u00E0 ''http://java.sun.com/xml/jaxp/properties/schemaSource'' non pu\u00F2 avere un valore di tipo ''{0}''. I tipi possibili di valori supportati sono String, File, InputStream, InputSource o un array di questi tipi.
        jaxp12-schema-source-type.2 = La propriet\u00E0 ''http://java.sun.com/xml/jaxp/properties/schemaSource'' non pu\u00F2 avere un valore di array di tipo ''{0}''. I tipi possibili di array supportati sono Object, String, File, InputStream e InputSource.
        jaxp12-schema-source-ns = Quando si utilizza un array di oggetti come valore della propriet\u00E0 'http://java.sun.com/xml/jaxp/properties/schemaSource', non \u00E8 possibile avere due schemi che condividono lo stesso spazio di nomi di destinazione.
