From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Liav A <liavalb@gmail.com>
Date: Fri, 7 Jul 2023 07:23:00 +0300
Subject: [PATCH] fixup! Don't compile various binaries that depend on extended
 LibC functions

---
 src/ar.c      |  1578 ------
 src/readelf.c | 12956 ------------------------------------------------
 src/strings.c |   747 ---
 src/strip.c   |  2775 -----------
 src/unstrip.c |  2630 ----------
 5 files changed, 20686 deletions(-)
 delete mode 100644 src/ar.c
 delete mode 100644 src/readelf.c
 delete mode 100644 src/strings.c
 delete mode 100644 src/strip.c
 delete mode 100644 src/unstrip.c

diff --git a/src/ar.c b/src/ar.c
deleted file mode 100644
index c69a2878be6fcf9ce2fdf101978f85c71722a7ab..0000000000000000000000000000000000000000
--- a/src/ar.c
+++ /dev/null
@@ -1,1578 +0,0 @@
-/* Create, modify, and extract from archives.
-   Copyright (C) 2005-2012, 2016, 2017 Red Hat, Inc.
-   This file is part of elfutils.
-   Written by Ulrich Drepper <drepper@redhat.com>, 2005.
-
-   This file is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   elfutils is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#include <argp.h>
-#include <alloca.h>
-#include <assert.h>
-#include <fcntl.h>
-#include <gelf.h>
-#include <libintl.h>
-#include <limits.h>
-#include <locale.h>
-#include <libgen.h>
-#include <search.h>
-#include <stdbool.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <stdio_ext.h>
-#include <string.h>
-#include <time.h>
-#include <unistd.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/time.h>
-
-#include <system.h>
-#include <printversion.h>
-
-#include "arlib.h"
-
-
-/* Name and version of program.  */
-ARGP_PROGRAM_VERSION_HOOK_DEF = print_version;
-
-/* Prototypes for local functions.  */
-static int do_oper_extract (int oper, const char *arfname, char **argv,
-			    int argc, long int instance);
-static int do_oper_delete (const char *arfname, char **argv, int argc,
-			   long int instance);
-static int do_oper_insert (int oper, const char *arfname, char **argv,
-			   int argc, const char *member);
-
-
-/* Bug report address.  */
-ARGP_PROGRAM_BUG_ADDRESS_DEF = PACKAGE_BUGREPORT;
-
-
-/* Definitions of arguments for argp functions.  */
-static const struct argp_option options[] =
-{
-  { NULL, 0, NULL, 0, N_("Commands:"), 1 },
-  { NULL, 'd', NULL, 0, N_("Delete files from archive."), 0 },
-  { NULL, 'm', NULL, 0, N_("Move files in archive."), 0 },
-  { NULL, 'p', NULL, 0, N_("Print files in archive."), 0 },
-  { NULL, 'q', NULL, 0, N_("Quick append files to archive."), 0 },
-  { NULL, 'r', NULL, 0,
-    N_("Replace existing or insert new file into archive."), 0 },
-  { NULL, 't', NULL, 0, N_("Display content of archive."), 0 },
-  { NULL, 'x', NULL, 0, N_("Extract files from archive."), 0 },
-
-  { NULL, 0, NULL, 0, N_("Command Modifiers:"), 2 },
-  { NULL, 'o', NULL, 0, N_("Preserve original dates."), 0 },
-  { NULL, 'N', NULL, 0, N_("Use instance [COUNT] of name."), 0 },
-  { NULL, 'C', NULL, 0,
-    N_("Do not replace existing files with extracted files."), 0 },
-  { NULL, 'T', NULL, 0, N_("Allow filename to be truncated if necessary."),
-    0 },
-  { NULL, 'v', NULL, 0, N_("Provide verbose output."), 0 },
-  { NULL, 's', NULL, 0, N_("Force regeneration of symbol table."), 0 },
-  { NULL, 'a', NULL, 0, N_("Insert file after [MEMBER]."), 0 },
-  { NULL, 'b', NULL, 0, N_("Insert file before [MEMBER]."), 0 },
-  { NULL, 'i', NULL, 0, N_("Same as -b."), 0 },
-  { NULL, 'c', NULL, 0, N_("Suppress message when library has to be created."),
-    0 },
-  { NULL, 'P', NULL, 0, N_("Use full path for file matching."), 0 },
-  { NULL, 'u', NULL, 0, N_("Update only older files in archive."), 0 },
-
-  { NULL, 0, NULL, 0, NULL, 0 }
-};
-
-/* Short description of program.  */
-static const char doc[] = N_("Create, modify, and extract from archives.");
-
-/* Strings for arguments in help texts.  */
-static const char args_doc[] = N_("[MEMBER] [COUNT] ARCHIVE [FILE...]");
-
-/* Prototype for option handler.  */
-static error_t parse_opt (int key, char *arg, struct argp_state *state);
-
-/* Data structure to communicate with argp functions.  */
-static struct argp argp =
-{
-  options, parse_opt, args_doc, doc, arlib_argp_children, NULL, NULL
-};
-
-
-/* What operation to perform.  */
-static enum
-  {
-    oper_none,
-    oper_delete,
-    oper_move,
-    oper_print,
-    oper_qappend,
-    oper_replace,
-    oper_list,
-    oper_extract
-  } operation;
-
-/* Modifiers.  */
-static bool verbose;
-static bool preserve_dates;
-static bool instance_specifed;
-static bool dont_replace_existing;
-static bool allow_truncate_fname;
-static bool force_symtab;
-static bool suppress_create_msg;
-static bool full_path;
-static bool update_newer;
-static enum { ipos_none, ipos_before, ipos_after } ipos;
-
-
-int
-main (int argc, char *argv[])
-{
-  /* We use no threads here which can interfere with handling a stream.  */
-  (void) __fsetlocking (stdin, FSETLOCKING_BYCALLER);
-  (void) __fsetlocking (stdout, FSETLOCKING_BYCALLER);
-  (void) __fsetlocking (stderr, FSETLOCKING_BYCALLER);
-
-  /* Set locale.  */
-  (void) setlocale (LC_ALL, "");
-
-  /* Make sure the message catalog can be found.  */
-  (void) bindtextdomain (PACKAGE_TARNAME, LOCALEDIR);
-
-  /* Initialize the message catalog.  */
-  (void) textdomain (PACKAGE_TARNAME);
-
-  /* For historical reasons the options in the first parameter need
-     not be preceded by a dash.  Add it now if necessary.  */
-  if (argc > 1 && argv[1][0] != '-')
-    {
-      size_t len = strlen (argv[1]) + 1;
-      char *newp = alloca (len + 1);
-      newp[0] = '-';
-      memcpy (&newp[1], argv[1], len);
-      argv[1] = newp;
-    }
-
-  /* Parse and process arguments.  */
-  int remaining;
-  (void) argp_parse (&argp, argc, argv, ARGP_IN_ORDER, &remaining, NULL);
-
-  /* Tell the library which version we are expecting.  */
-  (void) elf_version (EV_CURRENT);
-
-  /* Handle the [MEMBER] parameter.  */
-  const char *member = NULL;
-  if (ipos != ipos_none)
-    {
-      /* Only valid for certain operations.  */
-      if (operation != oper_move && operation != oper_replace)
-	error (1, 0, _("\
-'a', 'b', and 'i' are only allowed with the 'm' and 'r' options"));
-
-      if (remaining == argc)
-	{
-	  error (0, 0, _("\
-MEMBER parameter required for 'a', 'b', and 'i' modifiers"));
-	  argp_help (&argp, stderr, ARGP_HELP_USAGE | ARGP_HELP_SEE,
-		     program_invocation_short_name);
-	  exit (EXIT_FAILURE);
-	}
-
-      member = argv[remaining++];
-    }
-
-  /* Handle the [COUNT] parameter.  */
-  long int instance = -1;
-  if (instance_specifed)
-    {
-      /* Only valid for certain operations.  */
-      if (operation != oper_extract && operation != oper_delete)
-	error (1, 0, _("\
-'N' is only meaningful with the 'x' and 'd' options"));
-
-      if (remaining == argc)
-	{
-	  error (0, 0, _("COUNT parameter required"));
-	  argp_help (&argp, stderr, ARGP_HELP_SEE,
-		     program_invocation_short_name);
-	  exit (EXIT_FAILURE);
-	}
-
-      char *endp;
-      errno = 0;
-      if (((instance = strtol (argv[remaining], &endp, 10)) == LONG_MAX
-	   && errno == ERANGE)
-	  || instance <= 0
-	  || *endp != '\0')
-	error (1, 0, _("invalid COUNT parameter %s"), argv[remaining]);
-
-      ++remaining;
-    }
-
-  if ((dont_replace_existing || allow_truncate_fname)
-      && unlikely (operation != oper_extract))
-    error (1, 0, _("'%c' is only meaningful with the 'x' option"),
-	   dont_replace_existing ? 'C' : 'T');
-
-  /* There must at least be one more parameter specifying the archive.   */
-  if (remaining == argc)
-    {
-      error (0, 0, _("archive name required"));
-      argp_help (&argp, stderr, ARGP_HELP_SEE, program_invocation_short_name);
-      exit (EXIT_FAILURE);
-    }
-
-  const char *arfname = argv[remaining++];
-  argv += remaining;
-  argc -= remaining;
-
-  int status;
-  switch (operation)
-    {
-    case oper_none:
-      error (0, 0, _("command option required"));
-      argp_help (&argp, stderr, ARGP_HELP_STD_ERR,
-		 program_invocation_short_name);
-      status = 1;
-      break;
-
-    case oper_list:
-    case oper_print:
-      status = do_oper_extract (operation, arfname, argv, argc, -1);
-      break;
-
-    case oper_extract:
-      status = do_oper_extract (operation, arfname, argv, argc, instance);
-      break;
-
-    case oper_delete:
-      status = do_oper_delete (arfname, argv, argc, instance);
-      break;
-
-    case oper_move:
-    case oper_qappend:
-    case oper_replace:
-      status = do_oper_insert (operation, arfname, argv, argc, member);
-      break;
-
-    default:
-      assert (! "should not happen");
-      status = 1;
-      break;
-    }
-
-  return status;
-}
-
-
-/* Handle program arguments.  */
-static error_t
-parse_opt (int key, char *arg __attribute__ ((unused)),
-	   struct argp_state *state __attribute__ ((unused)))
-{
-  switch (key)
-    {
-    case 'd':
-    case 'm':
-    case 'p':
-    case 'q':
-    case 'r':
-    case 't':
-    case 'x':
-      if (operation != oper_none)
-	{
-	  error (0, 0, _("More than one operation specified"));
-	  argp_help (&argp, stderr, ARGP_HELP_SEE,
-		     program_invocation_short_name);
-	  exit (EXIT_FAILURE);
-	}
-
-      switch (key)
-	{
-	case 'd':
-	  operation = oper_delete;
-	  break;
-	case 'm':
-	  operation = oper_move;
-	  break;
-	case 'p':
-	  operation = oper_print;
-	  break;
-	case 'q':
-	  operation = oper_qappend;
-	  break;
-	case 'r':
-	  operation = oper_replace;
-	  break;
-	case 't':
-	  operation = oper_list;
-	  break;
-	case 'x':
-	  operation = oper_extract;
-	  break;
-	}
-      break;
-
-    case 'a':
-      ipos = ipos_after;
-      break;
-
-    case 'b':
-    case 'i':
-      ipos = ipos_before;
-      break;
-
-    case 'c':
-      suppress_create_msg = true;
-      break;
-
-    case 'C':
-      dont_replace_existing = true;
-      break;
-
-    case 'N':
-      instance_specifed = true;
-      break;
-
-    case 'o':
-      preserve_dates = true;
-      break;
-
-    case 'P':
-      full_path = true;
-      break;
-
-    case 's':
-      force_symtab = true;
-      break;
-
-    case 'T':
-      allow_truncate_fname = true;
-      break;
-
-    case 'u':
-      update_newer = true;
-      break;
-
-    case 'v':
-      verbose = true;
-      break;
-
-    default:
-      return ARGP_ERR_UNKNOWN;
-    }
-  return 0;
-}
-
-
-static int
-open_archive (const char *arfname, int flags, int mode, Elf **elf,
-	      struct stat *st, bool miss_allowed)
-{
-  int fd = open (arfname, flags, mode);
-  if (fd == -1)
-    {
-      if (miss_allowed)
-	return -1;
-
-      error (EXIT_FAILURE, errno, _("cannot open archive '%s'"),
-	     arfname);
-    }
-
-  if (elf != NULL)
-    {
-      Elf_Cmd cmd = flags == O_RDONLY ? ELF_C_READ_MMAP : ELF_C_RDWR_MMAP;
-
-      *elf = elf_begin (fd, cmd, NULL);
-      if (*elf == NULL)
-	error (EXIT_FAILURE, 0, _("cannot open archive '%s': %s"),
-	       arfname, elf_errmsg (-1));
-
-      if (flags == O_RDONLY && elf_kind (*elf) != ELF_K_AR)
-	error (EXIT_FAILURE, 0, _("%s: not an archive file"), arfname);
-    }
-
-  if (st != NULL && fstat (fd, st) != 0)
-    error (EXIT_FAILURE, errno, _("cannot stat archive '%s'"),
-	   arfname);
-
-  return fd;
-}
-
-
-static void
-not_found (int argc, char *argv[argc], bool found[argc])
-{
-  for (int i = 0; i < argc; ++i)
-    if (!found[i])
-      printf (_("no entry %s in archive\n"), argv[i]);
-}
-
-
-static int
-copy_content (Elf *elf, int newfd, off_t off, size_t n)
-{
-  size_t len;
-  char *rawfile = elf_rawfile (elf, &len);
-
-  assert (off + n <= len);
-
-  /* Tell the kernel we will read all the pages sequentially.  */
-  size_t ps = sysconf (_SC_PAGESIZE);
-  if (n > 2 * ps)
-    posix_madvise (rawfile + (off & ~(ps - 1)), n, POSIX_MADV_SEQUENTIAL);
-
-  return write_retry (newfd, rawfile + off, n) != (ssize_t) n;
-}
-
-static inline bool
-should_truncate_fname (size_t *name_max)
-{
-  if (errno == ENAMETOOLONG && allow_truncate_fname)
-    {
-      if (*name_max == 0)
-	{
-	  long int len = pathconf (".", _PC_NAME_MAX);
-	  if (len > 0)
-	    *name_max = len;
-	}
-      return *name_max != 0;
-    }
-  return false;
-}
-
-static int
-do_oper_extract (int oper, const char *arfname, char **argv, int argc,
-		 long int instance)
-{
-  bool found[argc > 0 ? argc : 1];
-  memset (found, '\0', sizeof (found));
-
-  size_t name_max = 0;
-  off_t index_off = -1;
-  size_t index_size = 0;
-  off_t cur_off = SARMAG;
-
-  int status = 0;
-  Elf *elf;
-  int fd = open_archive (arfname, O_RDONLY, 0, &elf, NULL, false);
-
-  if (hcreate (2 * argc) == 0)
-    error (EXIT_FAILURE, errno, _("cannot create hash table"));
-
-  for (int cnt = 0; cnt < argc; ++cnt)
-    {
-      ENTRY entry = { .key = argv[cnt], .data = &argv[cnt] };
-      if (hsearch (entry, ENTER) == NULL)
-	error (EXIT_FAILURE, errno,
-	       _("cannot insert into hash table"));
-    }
-
-  struct stat st;
-  if (force_symtab)
-    {
-      if (fstat (fd, &st) != 0)
-	{
-	  error (0, errno, _("cannot stat '%s'"), arfname);
-	  close (fd);
-	  return 1;
-	}
-      arlib_init ();
-    }
-
-  Elf_Cmd cmd = ELF_C_READ_MMAP;
-  Elf *subelf;
-  while ((subelf = elf_begin (fd, cmd, elf)) != NULL)
-    {
-      Elf_Arhdr *arhdr = elf_getarhdr (subelf);
-
-      if (strcmp (arhdr->ar_name, "/") == 0)
-	{
-	  index_off = elf_getaroff (subelf);
-	  index_size = arhdr->ar_size;
-	  goto next;
-	}
-      if (strcmp (arhdr->ar_name, "//") == 0)
-	goto next;
-
-      if (force_symtab)
-	{
-	  arlib_add_symbols (elf, arfname, arhdr->ar_name, cur_off);
-	  cur_off += (((arhdr->ar_size + 1) & ~((off_t) 1))
-		      + sizeof (struct ar_hdr));
-	}
-
-      bool do_extract = argc <= 0;
-      if (!do_extract)
-	{
-	  ENTRY entry;
-	  entry.key = arhdr->ar_name;
-	  ENTRY *res = hsearch (entry, FIND);
-	  if (res != NULL && (instance < 0 || instance-- == 0)
-	      && !found[(char **) res->data - argv])
-	    found[(char **) res->data - argv] = do_extract = true;
-	}
-
-      if (do_extract)
-	{
-	  if (verbose)
-	    {
-	      if (oper == oper_print)
-		{
-		  printf ("\n<%s>\n\n", arhdr->ar_name);
-
-		  /* We have to flush now because now we use the descriptor
-		     directly.  */
-		  fflush (stdout);
-		}
-	      else if (oper == oper_list)
-		{
-		  char datestr[100];
-		  struct tm *tp = localtime (&arhdr->ar_date);
-		  if (tp == NULL)
-		    {
-		      time_t time = 0;
-		      tp = localtime (&time);
-		    }
-
-		  strftime (datestr, sizeof (datestr), "%b %e %H:%M %Y", tp);
-
-		  printf ("%c%c%c%c%c%c%c%c%c %u/%u %6ju %s %s\n",
-			  (arhdr->ar_mode & S_IRUSR) ? 'r' : '-',
-			  (arhdr->ar_mode & S_IWUSR) ? 'w' : '-',
-			  (arhdr->ar_mode & S_IXUSR)
-			  ? ((arhdr->ar_mode & S_ISUID) ? 's' : 'x')
-			  : ((arhdr->ar_mode & S_ISUID) ? 'S' : '-'),
-			  (arhdr->ar_mode & S_IRGRP) ? 'r' : '-',
-			  (arhdr->ar_mode & S_IWGRP) ? 'w' : '-',
-			  (arhdr->ar_mode & S_IXGRP)
-			  ? ((arhdr->ar_mode & S_ISGID) ? 's' : 'x')
-			  : ((arhdr->ar_mode & S_ISGID) ? 'S' : '-'),
-			  (arhdr->ar_mode & S_IROTH) ? 'r' : '-',
-			  (arhdr->ar_mode & S_IWOTH) ? 'w' : '-',
-			  (arhdr->ar_mode & S_IXOTH)
-			  ? ((arhdr->ar_mode & S_ISVTX) ? 't' : 'x')
-			  : ((arhdr->ar_mode & S_ISVTX) ? 'T' : '-'),
-			  arhdr->ar_uid,
-			  arhdr->ar_gid,
-			  (uintmax_t) arhdr->ar_size,
-			  datestr,
-			  arhdr->ar_name);
-		}
-	      else
-		printf ("x - %s\n", arhdr->ar_name);
-	    }
-
-	  if (oper == oper_list)
-	    {
-	      if (!verbose)
-		puts (arhdr->ar_name);
-
-	      goto next;
-	    }
-
-	  size_t nleft;
-	  char *data = elf_rawfile (subelf, &nleft);
-	  if (data == NULL)
-	    {
-	      error (0, 0, _("cannot read content of %s: %s"),
-		     arhdr->ar_name, elf_errmsg (-1));
-	      status = 1;
-	      goto next;
-	    }
-
-	  int xfd;
-	  char tempfname[] = "XXXXXX";
-	  bool use_mkstemp = true;
-
-	  if (oper == oper_print)
-	    xfd = STDOUT_FILENO;
-	  else
-	    {
-	      xfd = mkstemp (tempfname);
-	      if (unlikely (xfd == -1))
-		{
-		  /* We cannot create a temporary file.  Try to overwrite
-		     the file or create it if it does not exist.  */
-		  int flags = O_WRONLY | O_CREAT;
-		  if (dont_replace_existing)
-		    flags |= O_EXCL;
-		  else
-		    flags |= O_TRUNC;
-		  xfd = open (arhdr->ar_name, flags, 0600);
-		  if (unlikely (xfd == -1))
-		    {
-		      int printlen = INT_MAX;
-
-		      if (should_truncate_fname (&name_max))
-			{
-			  /* Try to truncate the name.  First find out by how
-			     much.  */
-			  printlen = name_max;
-			  char truncfname[name_max + 1];
-			  *((char *) mempcpy (truncfname, arhdr->ar_name,
-					      name_max)) = '\0';
-
-			  xfd = open (truncfname, flags, 0600);
-			}
-
-		      if (xfd == -1)
-			{
-			  error (0, errno, _("cannot open %.*s"),
-				 (int) printlen, arhdr->ar_name);
-			  status = 1;
-			  goto next;
-			}
-		    }
-
-		  use_mkstemp = false;
-		}
-	    }
-
-	  ssize_t n;
-	  while ((n = TEMP_FAILURE_RETRY (write (xfd, data, nleft))) != -1)
-	    {
-	      nleft -= n;
-	      if (nleft == 0)
-		break;
-	      data += n;
-	    }
-
-	  if (unlikely (n == -1))
-	    {
-	      error (0, errno, _("failed to write %s"), arhdr->ar_name);
-	      status = 1;
-	      unlink (tempfname);
-	      close (xfd);
-	      goto next;
-	    }
-
-	  if (oper != oper_print)
-	    {
-	      /* Fix up the mode.  */
-	      if (unlikely (fchmod (xfd, arhdr->ar_mode) != 0))
-		{
-		  error (0, errno, _("cannot change mode of %s"),
-			 arhdr->ar_name);
-		  status = 0;
-		}
-
-	      if (preserve_dates)
-		{
-		  struct timespec tv[2];
-		  tv[0].tv_sec = arhdr->ar_date;
-		  tv[0].tv_nsec = 0;
-		  tv[1].tv_sec = arhdr->ar_date;
-		  tv[1].tv_nsec = 0;
-
-		  if (unlikely (futimens (xfd, tv) != 0))
-		    {
-		      error (0, errno,
-			     _("cannot change modification time of %s"),
-			     arhdr->ar_name);
-		      status = 1;
-		    }
-		}
-
-	      /* If we used a temporary file, move it do the right
-		 name now.  */
-	      if (use_mkstemp)
-		{
-		  int r;
-
-		  if (dont_replace_existing)
-		    {
-		      r = link (tempfname, arhdr->ar_name);
-		      if (likely (r == 0))
-			unlink (tempfname);
-		    }
-		  else
-		    r = rename (tempfname, arhdr->ar_name);
-
-		  if (unlikely (r) != 0)
-		    {
-		      int printlen = INT_MAX;
-
-		      if (should_truncate_fname (&name_max))
-			{
-			  /* Try to truncate the name.  First find out by how
-			     much.  */
-			  printlen = name_max;
-			  char truncfname[name_max + 1];
-			  *((char *) mempcpy (truncfname, arhdr->ar_name,
-					      name_max)) = '\0';
-
-			  if (dont_replace_existing)
-			    {
-			      r = link (tempfname, truncfname);
-			      if (likely (r == 0))
-				unlink (tempfname);
-			    }
-			  else
-			    r = rename (tempfname, truncfname);
-			}
-
-		      if (r != 0)
-			{
-			  error (0, errno, _("\
-cannot rename temporary file to %.*s"),
-				 printlen, arhdr->ar_name);
-			  unlink (tempfname);
-			  status = 1;
-			}
-		    }
-		}
-
-	      close (xfd);
-	    }
-	}
-
-    next:
-      cmd = elf_next (subelf);
-      if (elf_end (subelf) != 0)
-	error (1, 0, "%s: %s", arfname, elf_errmsg (-1));
-    }
-
-  hdestroy ();
-
-  if (force_symtab)
-    {
-      arlib_finalize ();
-
-      if (symtab.symsnamelen != 0
-	  /* We have to rewrite the file also if it initially had an index
-	     but now does not need one anymore.  */
-	  || (symtab.symsnamelen == 0 && index_size != 0))
-	{
-	  char tmpfname[strlen (arfname) + 7];
-	  strcpy (stpcpy (tmpfname, arfname), "XXXXXX");
-	  int newfd = mkstemp (tmpfname);
-	  if (unlikely (newfd == -1))
-	    {
-	    nonew:
-	      error (0, errno, _("cannot create new file"));
-	      status = 1;
-	    }
-	  else
-	    {
-	      /* Create the header.  */
-	      if (unlikely (write_retry (newfd, ARMAG, SARMAG) != SARMAG))
-		{
-		  // XXX Use /prof/self/fd/%d ???
-		nonew_unlink:
-		  unlink (tmpfname);
-		  if (newfd != -1)
-		    close (newfd);
-		  goto nonew;
-		}
-
-	      /* Create the new file.  There are three parts as far we are
-		 concerned: 1. original context before the index, 2. the
-		 new index, 3. everything after the new index.  */
-	      off_t rest_off;
-	      if (index_off != -1)
-		rest_off = (index_off + sizeof (struct ar_hdr)
-			    + ((index_size + 1) & ~1ul));
-	      else
-		rest_off = SARMAG;
-
-	      if (symtab.symsnamelen != 0
-		   && ((write_retry (newfd, symtab.symsoff,
-				     symtab.symsofflen)
-			!= (ssize_t) symtab.symsofflen)
-		       || (write_retry (newfd, symtab.symsname,
-					symtab.symsnamelen)
-			   != (ssize_t) symtab.symsnamelen)))
-		goto nonew_unlink;
-	      /* Even if the original file had content before the
-		 symbol table, we write it in the correct order.  */
-	      if ((index_off != SARMAG
-		   && copy_content (elf, newfd, SARMAG, index_off - SARMAG))
-		  || copy_content (elf, newfd, rest_off, st.st_size - rest_off))
-		goto nonew_unlink;
-
-	      /* Never complain about fchown failing.  */
-	      if (fchown (newfd, st.st_uid, st.st_gid) != 0) { ; }
-	      /* Set the mode of the new file to the same values the
-		 original file has.  */
-	      if (fchmod (newfd, st.st_mode & ALLPERMS) != 0
-		  || close (newfd) != 0)
-		goto nonew_unlink;
-	      newfd = -1;
-	      if (rename (tmpfname, arfname) != 0)
-		goto nonew_unlink;
-	    }
-	}
-    }
-
-  elf_end (elf);
-
-  close (fd);
-
-  not_found (argc, argv, found);
-
-  return status;
-}
-
-
-struct armem
-{
-  off_t off;
-  off_t old_off;
-  size_t size;
-  long int long_name_off;
-  struct armem *next;
-  void *mem;
-  time_t sec;
-  uid_t uid;
-  gid_t gid;
-  mode_t mode;
-  const char *name;
-  Elf *elf;
-};
-
-
-static int
-write_member (struct armem *memb, off_t *startp, off_t *lenp, Elf *elf,
-	      off_t end_off, int newfd)
-{
-  struct ar_hdr arhdr;
-  /* The ar_name is not actually zero terminated, but we need that for
-     snprintf.  Also if the name is too long, then the string starts
-     with '/' plus an index off number (decimal).  */
-  char tmpbuf[sizeof (arhdr.ar_name) + 2];
-
-  bool changed_header = memb->long_name_off != -1;
-  if (changed_header)
-    {
-      /* In case of a long file name we assume the archive header
-	 changed and we write it here.  */
-      memcpy (&arhdr, elf_rawfile (elf, NULL) + *startp, sizeof (arhdr));
-
-      snprintf (tmpbuf, sizeof (tmpbuf), "/%-*ld",
-		(int) sizeof (arhdr.ar_name), memb->long_name_off);
-      changed_header = memcmp (arhdr.ar_name, tmpbuf,
-			       sizeof (arhdr.ar_name)) != 0;
-    }
-
-  /* If the files are adjacent in the old file extend the range.  */
-  if (*startp != -1 && !changed_header && *startp + *lenp == memb->old_off)
-    {
-      /* Extend the current range.  */
-      *lenp += (memb->next != NULL
-		? memb->next->off : end_off) - memb->off;
-      return 0;
-    }
-
-  /* Write out the old range.  */
-  if (*startp != -1 && copy_content (elf, newfd, *startp, *lenp))
-    return -1;
-
-  *startp = memb->old_off;
-  *lenp = (memb->next != NULL ? memb->next->off : end_off) - memb->off;
-
-  if (changed_header)
-    {
-      memcpy (arhdr.ar_name, tmpbuf, sizeof (arhdr.ar_name));
-
-      if (unlikely (write_retry (newfd, &arhdr, sizeof (arhdr))
-		    != sizeof (arhdr)))
-	return -1;
-
-      *startp += sizeof (struct ar_hdr);
-      assert ((size_t) *lenp >= sizeof (struct ar_hdr));
-      *lenp -= sizeof (struct ar_hdr);
-    }
-
-  return 0;
-}
-
-/* Store the name in the long name table if necessary.
-   Record its offset or -1 if we did not need to use the table.  */
-static void
-remember_long_name (struct armem *mem, const char *name, size_t namelen)
-{
-  mem->long_name_off = (namelen > MAX_AR_NAME_LEN
-			? arlib_add_long_name (name, namelen)
-			: -1l);
-}
-
-static int
-do_oper_delete (const char *arfname, char **argv, int argc,
-		long int instance)
-{
-  bool *found = alloca (sizeof (bool) * argc);
-  memset (found, '\0', sizeof (bool) * argc);
-
-  /* List of the files we keep.  */
-  struct armem *to_copy = NULL;
-
-  int status = 0;
-  Elf *elf;
-  struct stat st;
-  int fd = open_archive (arfname, O_RDONLY, 0, &elf, &st, false);
-
-  if (hcreate (2 * argc) == 0)
-    error (EXIT_FAILURE, errno, _("cannot create hash table"));
-
-  for (int cnt = 0; cnt < argc; ++cnt)
-    {
-      ENTRY entry = { .key = argv[cnt], .data = &argv[cnt] };
-      if (hsearch (entry, ENTER) == NULL)
-	error (EXIT_FAILURE, errno,
-	       _("cannot insert into hash table"));
-    }
-
-  arlib_init ();
-
-  off_t cur_off = SARMAG;
-  Elf_Cmd cmd = ELF_C_READ_MMAP;
-  Elf *subelf;
-  while ((subelf = elf_begin (fd, cmd, elf)) != NULL)
-    {
-      Elf_Arhdr *arhdr = elf_getarhdr (subelf);
-
-      /* Ignore the symbol table and the long file name table here.  */
-      if (strcmp (arhdr->ar_name, "/") == 0
-	  || strcmp (arhdr->ar_name, "//") == 0)
-	goto next;
-
-      bool do_delete = argc <= 0;
-      if (!do_delete)
-	{
-	  ENTRY entry;
-	  entry.key = arhdr->ar_name;
-	  ENTRY *res = hsearch (entry, FIND);
-	  if (res != NULL && (instance < 0 || instance-- == 0)
-	      && !found[(char **) res->data - argv])
-	    found[(char **) res->data - argv] = do_delete = true;
-	}
-
-      if (do_delete)
-	{
-	  if (verbose)
-	    printf ("d - %s\n", arhdr->ar_name);
-	}
-      else
-	{
-	  struct armem *newp = alloca (sizeof (struct armem));
-	  newp->old_off = elf_getaroff (subelf);
-	  newp->off = cur_off;
-
-	  cur_off += (((arhdr->ar_size + 1) & ~((off_t) 1))
-		      + sizeof (struct ar_hdr));
-
-	  if (to_copy == NULL)
-	    to_copy = newp->next = newp;
-	  else
-	    {
-	      newp->next = to_copy->next;
-	      to_copy = to_copy->next = newp;
-	    }
-
-	  /* If we recreate the symbol table read the file's symbol
-	     table now.  */
-	  arlib_add_symbols (subelf, arfname, arhdr->ar_name, newp->off);
-
-	  /* Remember long file names.  */
-	  remember_long_name (newp, arhdr->ar_name, strlen (arhdr->ar_name));
-	}
-
-    next:
-      cmd = elf_next (subelf);
-      if (elf_end (subelf) != 0)
-	error (1, 0, "%s: %s", arfname, elf_errmsg (-1));
-    }
-
-  arlib_finalize ();
-
-  hdestroy ();
-
-  /* Create a new, temporary file in the same directory as the
-     original file.  */
-  char tmpfname[strlen (arfname) + 7];
-  strcpy (stpcpy (tmpfname, arfname), "XXXXXX");
-  int newfd = mkstemp (tmpfname);
-  if (unlikely (newfd == -1))
-    goto nonew;
-
-  /* Create the header.  */
-  if (unlikely (write_retry (newfd, ARMAG, SARMAG) != SARMAG))
-    {
-      // XXX Use /prof/self/fd/%d ???
-    nonew_unlink:
-      unlink (tmpfname);
-      if (newfd != -1)
-	close (newfd);
-    nonew:
-      error (0, errno, _("cannot create new file"));
-      status = 1;
-      goto errout;
-    }
-
-  /* If the archive is empty that is all we have to do.  */
-  if (likely (to_copy != NULL))
-    {
-      /* Write the symbol table or the long file name table or both.  */
-      if (symtab.symsnamelen != 0
-	  && ((write_retry (newfd, symtab.symsoff, symtab.symsofflen)
-	       != (ssize_t) symtab.symsofflen)
-	      || (write_retry (newfd, symtab.symsname, symtab.symsnamelen)
-		  != (ssize_t) symtab.symsnamelen)))
-	goto nonew_unlink;
-
-      if (symtab.longnameslen > sizeof (struct ar_hdr)
-	  && (write_retry (newfd, symtab.longnames, symtab.longnameslen)
-	      != (ssize_t) symtab.longnameslen))
-	goto nonew_unlink;
-
-      /* NULL-terminate the list of files to copy.  */
-      struct armem *last = to_copy;
-      to_copy = to_copy->next;
-      last->next = NULL;
-
-      off_t start = -1;
-      off_t len = -1;
-
-      do
-	if (write_member (to_copy, &start, &len, elf, cur_off, newfd) != 0)
-	  goto nonew_unlink;
-      while ((to_copy = to_copy->next) != NULL);
-
-      /* Write the last part.  */
-      if (copy_content (elf, newfd, start, len))
-	goto nonew_unlink;
-    }
-
-  /* Set the mode of the new file to the same values the original file
-     has.  Never complain about fchown failing.  But do it before
-     setting the mode (which might be reset/ignored if the owner is
-     wrong.  */
-  if (fchown (newfd, st.st_uid, st.st_gid) != 0) { ; }
-  if (fchmod (newfd, st.st_mode & ALLPERMS) != 0
-      || close (newfd) != 0)
-    goto nonew_unlink;
-  newfd = -1;
-  if (rename (tmpfname, arfname) != 0)
-    goto nonew_unlink;
-
- errout:
-  elf_end (elf);
-
-  arlib_fini ();
-
-  close (fd);
-
-  not_found (argc, argv, found);
-
-  return status;
-}
-
-
-/* Prints the given value in the given buffer without a trailing zero char.
-   Returns false if the given value doesn't fit in the given buffer.  */
-static bool
-no0print (bool ofmt, char *buf, int bufsize, long int val)
-{
-  char tmpbuf[bufsize + 1];
-  int ret = snprintf (tmpbuf, sizeof (tmpbuf), ofmt ? "%-*lo" : "%-*ld",
-		      bufsize, val);
-  if (ret >= (int) sizeof (tmpbuf))
-    return false;
-  memcpy (buf, tmpbuf, bufsize);
-  return true;
-}
-
-
-static int
-do_oper_insert (int oper, const char *arfname, char **argv, int argc,
-		const char *member)
-{
-  int status = 0;
-  Elf *elf = NULL;
-  struct stat st;
-  int fd = open_archive (arfname, O_RDONLY, 0, &elf, &st, oper != oper_move);
-
-  /* List of the files we keep.  */
-  struct armem *all = NULL;
-  struct armem *after_memberelem = NULL;
-  struct armem **found = alloca (sizeof (*found) * argc);
-  memset (found, '\0', sizeof (*found) * argc);
-
-  arlib_init ();
-
-  /* Initialize early for no_old case.  */
-  off_t cur_off = SARMAG;
-
-  if (fd == -1)
-    {
-      if (!suppress_create_msg)
-	fprintf (stderr, "%s: creating %s\n",
-		 program_invocation_short_name, arfname);
-
-      goto no_old;
-    }
-
-  /* Store the names of all files from the command line in a hash
-     table so that we can match it.  Note that when no file name is
-     given we are basically doing nothing except recreating the
-     index.  */
-  if (oper != oper_qappend)
-    {
-      if (hcreate (2 * argc) == 0)
-	error (EXIT_FAILURE, errno, _("cannot create hash table"));
-
-      for (int cnt = 0; cnt < argc; ++cnt)
-	{
-	  ENTRY entry;
-	  entry.key = full_path ? argv[cnt] : basename (argv[cnt]);
-	  entry.data = &argv[cnt];
-	  if (hsearch (entry, ENTER) == NULL)
-	    error (EXIT_FAILURE, errno,
-		   _("cannot insert into hash table"));
-	}
-    }
-
-  /* While iterating over the current content of the archive we must
-     determine a number of things: which archive members to keep,
-     which are replaced, and where to insert the new members.  */
-  Elf_Cmd cmd = ELF_C_READ_MMAP;
-  Elf *subelf;
-  while ((subelf = elf_begin (fd, cmd, elf)) != NULL)
-    {
-      Elf_Arhdr *arhdr = elf_getarhdr (subelf);
-
-      /* Ignore the symbol table and the long file name table here.  */
-      if (strcmp (arhdr->ar_name, "/") == 0
-	  || strcmp (arhdr->ar_name, "//") == 0)
-	goto next;
-
-      struct armem *newp = alloca (sizeof (struct armem));
-      newp->old_off = elf_getaroff (subelf);
-      newp->size = arhdr->ar_size;
-      newp->sec = arhdr->ar_date;
-      newp->mem = NULL;
-
-      /* Remember long file names.  */
-      remember_long_name (newp, arhdr->ar_name, strlen (arhdr->ar_name));
-
-      /* Check whether this is a file we are looking for.  */
-      if (oper != oper_qappend)
-	{
-	  /* Check whether this is the member used as the insert point.  */
-	  if (member != NULL && strcmp (arhdr->ar_name, member) == 0)
-	    {
-	      /* Note that all == NULL means insert at the beginning.  */
-	      if (ipos == ipos_before)
-		after_memberelem = all;
-	      else
-		after_memberelem = newp;
-	      member = NULL;
-	    }
-
-	  ENTRY entry;
-	  entry.key = arhdr->ar_name;
-	  ENTRY *res = hsearch (entry, FIND);
-	  if (res != NULL && found[(char **) res->data - argv] == NULL)
-	    {
-	      found[(char **) res->data - argv] = newp;
-
-	      /* If we insert before or after a certain element move
-		 all files to a special list.  */
-	      if (unlikely (ipos != ipos_none || oper == oper_move))
-		{
-		  if (after_memberelem == newp)
-		    /* Since we remove this element even though we should
-		       insert everything after it, we in fact insert
-		       everything after the previous element.  */
-		    after_memberelem = all;
-
-		  goto next;
-		}
-	    }
-	}
-
-      if (all == NULL)
-	all = newp->next = newp;
-      else
-	{
-	  newp->next = all->next;
-	  all = all->next = newp;
-	}
-
-    next:
-      cmd = elf_next (subelf);
-      if (elf_end (subelf) != 0)
-	error (EXIT_FAILURE, 0, "%s: %s", arfname, elf_errmsg (-1));
-    }
-
-  if (oper != oper_qappend)
-    hdestroy ();
-
- no_old:
-  if (member != NULL)
-    error (EXIT_FAILURE, 0, _("position member %s not found"),
-	   member);
-
-  if (oper == oper_move)
-    {
-      /* Make sure all requested elements are found in the archive.  */
-      for (int cnt = 0; cnt < argc; ++cnt)
-	{
-	  if (found[cnt] == NULL)
-	    {
-	      fprintf (stderr, _("%s: no entry %s in archive!\n"),
-		       program_invocation_short_name, argv[cnt]);
-	      status = 1;
-	    }
-
-	  if (verbose)
-	    printf ("m - %s\n", argv[cnt]);
-	}
-    }
-  else
-    {
-      /* Open all the new files, get their sizes and add all symbols.  */
-      for (int cnt = 0; cnt < argc; ++cnt)
-	{
-	  const char *bname = basename (argv[cnt]);
-	  size_t bnamelen = strlen (bname);
-	  if (found[cnt] == NULL)
-	    {
-	      found[cnt] = alloca (sizeof (struct armem));
-	      found[cnt]->old_off = -1;
-
-	      remember_long_name (found[cnt], bname, bnamelen);
-	    }
-
-	  struct stat newst;
-	  Elf *newelf;
-	  int newfd = open (argv[cnt], O_RDONLY);
-	  if (newfd == -1)
-	    {
-	      error (0, errno, _("cannot open %s"), argv[cnt]);
-	      status = 1;
-	    }
-	  else if (fstat (newfd, &newst) == -1)
-	    {
-	      error (0, errno, _("cannot stat %s"), argv[cnt]);
-	      close (newfd);
-	      status = 1;
-	    }
-	  else if (!S_ISREG (newst.st_mode))
-	    {
-	      error (0, errno, _("%s is no regular file"), argv[cnt]);
-	      close (newfd);
-	      status = 1;
-	    }
-	  else if (update_newer
-		   && found[cnt]->old_off != -1l
-		   && found[cnt]->sec > st.st_mtime)
-	    /* Do nothing, the file in the archive is younger.  */
-	    close (newfd);
-	  else if ((newelf = elf_begin (newfd, ELF_C_READ_MMAP, NULL))
-		   == NULL)
-	    {
-	      fprintf (stderr,
-		       _("cannot get ELF descriptor for %s: %s\n"),
-		       argv[cnt], elf_errmsg (-1));
-	      status = 1;
-	    }
-	  else
-	    {
-	      if (verbose)
-		printf ("%c - %s\n",
-			found[cnt]->old_off == -1l ? 'a' : 'r', argv[cnt]);
-
-	      found[cnt]->elf = newelf;
-	      found[cnt]->sec = arlib_deterministic_output ? 0 : newst.st_mtime;
-	      found[cnt]->uid = arlib_deterministic_output ? 0 : newst.st_uid;
-	      found[cnt]->gid = arlib_deterministic_output ? 0 : newst.st_gid;
-	      found[cnt]->mode = newst.st_mode;
-	      found[cnt]->name = bname;
-
-	      found[cnt]->mem = elf_rawfile (newelf, &found[cnt]->size);
-	      if (found[cnt]->mem == NULL
-		  || elf_cntl (newelf, ELF_C_FDDONE) != 0)
-		error (EXIT_FAILURE, 0, _("cannot read %s: %s"),
-		       argv[cnt], elf_errmsg (-1));
-
-	      close (newfd);
-
-	      if (found[cnt]->old_off != -1l)
-		/* Remember long file names.  */
-		remember_long_name (found[cnt], bname, bnamelen);
-	    }
-	}
-    }
-
-  if (status != 0)
-    {
-      elf_end (elf);
-
-      arlib_fini ();
-
-      close (fd);
-
-      return status;
-    }
-
-  /* If we have no entry point so far add at the end.  AFTER_MEMBERELEM
-     being NULL when adding before an entry means add at the beginning.  */
-  if (ipos != ipos_before && after_memberelem == NULL)
-    after_memberelem = all;
-
-  /* Convert the circular list into a normal list first.  */
-  if (all != NULL)
-    {
-      struct armem *tmp = all;
-      all = all->next;
-      tmp->next = NULL;
-    }
-
-  struct armem *last_added = after_memberelem;
-  for (int cnt = 0; cnt < argc; ++cnt)
-    if (oper != oper_replace || found[cnt]->old_off == -1)
-      {
-	if (last_added == NULL)
-	  {
-	    found[cnt]->next = all;
-	    last_added = all = found[cnt];
-	  }
-	else
-	  {
-	    found[cnt]->next = last_added->next;
-	    last_added = last_added->next = found[cnt];
-	  }
-      }
-
-  /* Finally compute the offset and add the symbols for the files
-     after the insert point.  */
-  if (likely (all != NULL))
-    for (struct armem *memp = all; memp != NULL; memp = memp->next)
-      {
-	memp->off = cur_off;
-
-	if (memp->mem == NULL)
-	  {
-	    Elf_Arhdr *arhdr;
-	    /* Fake initializing arhdr and subelf to keep gcc calm.  */
-	    asm ("" : "=m" (arhdr), "=m" (subelf));
-	    if (elf_rand (elf, memp->old_off) == 0
-		|| (subelf = elf_begin (fd, ELF_C_READ_MMAP, elf)) == NULL
-		|| (arhdr = elf_getarhdr (subelf)) == NULL)
-	      /* This should never happen since we already looked at the
-		 archive content.  But who knows...  */
-	      error (EXIT_FAILURE, 0, "%s: %s", arfname, elf_errmsg (-1));
-
-	    arlib_add_symbols (subelf, arfname, arhdr->ar_name, cur_off);
-
-	    elf_end (subelf);
-	  }
-	else
-	  arlib_add_symbols (memp->elf, arfname, memp->name, cur_off);
-
-	cur_off += (((memp->size + 1) & ~((off_t) 1))
-		    + sizeof (struct ar_hdr));
-      }
-
-  /* Now we have all the information for the symbol table and long
-     file name table.  Construct the final layout.  */
-  arlib_finalize ();
-
-  /* Create a new, temporary file in the same directory as the
-     original file.  */
-  char tmpfname[strlen (arfname) + 7];
-  strcpy (stpcpy (tmpfname, arfname), "XXXXXX");
-  int newfd;
-  if (fd != -1)
-    newfd = mkstemp (tmpfname);
-  else
-    {
-      newfd = open (arfname, O_RDWR | O_CREAT | O_EXCL, DEFFILEMODE);
-      if (newfd == -1 && errno == EEXIST)
-	/* Bah, first the file did not exist, now it does.  Restart.  */
-	return do_oper_insert (oper, arfname, argv, argc, member);
-    }
-  if (unlikely (newfd == -1))
-    goto nonew;
-
-  /* Create the header.  */
-  if (unlikely (write_retry (newfd, ARMAG, SARMAG) != SARMAG))
-    {
-    nonew_unlink:
-      if (fd != -1)
-	{
-	  // XXX Use /prof/self/fd/%d ???
-	  unlink (tmpfname);
-	  if (newfd != -1)
-	    close (newfd);
-	}
-    nonew:
-      error (0, errno, _("cannot create new file"));
-      status = 1;
-      goto errout;
-    }
-
-  /* If the new archive is not empty we actually have something to do.  */
-  if (likely (all != NULL))
-    {
-      /* Write the symbol table or the long file name table or both.  */
-      if (symtab.symsnamelen != 0
-	  && ((write_retry (newfd, symtab.symsoff, symtab.symsofflen)
-	       != (ssize_t) symtab.symsofflen)
-	      || (write_retry (newfd, symtab.symsname, symtab.symsnamelen)
-		  != (ssize_t) symtab.symsnamelen)))
-	goto nonew_unlink;
-
-      if (symtab.longnameslen > sizeof (struct ar_hdr)
-	  && (write_retry (newfd, symtab.longnames, symtab.longnameslen)
-	      != (ssize_t) symtab.longnameslen))
-	goto nonew_unlink;
-
-      off_t start = -1;
-      off_t len = -1;
-
-      while (all != NULL)
-	{
-	  if (all->mem != NULL)
-	    {
-	      /* This is a new file.  If there is anything from the
-		 archive left to be written do it now.  */
-	      if (start != -1  && copy_content (elf, newfd, start, len))
-		goto nonew_unlink;
-
-	      start = -1;
-	      len = -1;
-
-	      /* Create the header.  */
-	      struct ar_hdr arhdr;
-	      /* The ar_name is not actually zero terminated, but we
-		 need that for snprintf.  Also if the name is too
-		 long, then the string starts with '/' plus an index
-		 off number (decimal).  */
-	      char tmpbuf[sizeof (arhdr.ar_name) + 2];
-	      if (all->long_name_off == -1)
-		{
-		  size_t namelen = strlen (all->name);
-		  char *p = mempcpy (arhdr.ar_name, all->name, namelen);
-		  *p++ = '/';
-		  memset (p, ' ', sizeof (arhdr.ar_name) - namelen - 1);
-		}
-	      else
-		{
-		  snprintf (tmpbuf, sizeof (tmpbuf), "/%-*ld",
-			    (int) sizeof (arhdr.ar_name), all->long_name_off);
-		  memcpy (arhdr.ar_name, tmpbuf, sizeof (arhdr.ar_name));
-		}
-
-	      if (! no0print (false, arhdr.ar_date, sizeof (arhdr.ar_date),
-			      all->sec))
-		{
-		  error (0, errno, _("cannot represent ar_date"));
-		  goto nonew_unlink;
-		}
-	      if (! no0print (false, arhdr.ar_uid, sizeof (arhdr.ar_uid),
-			      all->uid))
-		{
-		  error (0, errno, _("cannot represent ar_uid"));
-		  goto nonew_unlink;
-		}
-	      if (! no0print (false, arhdr.ar_gid, sizeof (arhdr.ar_gid),
-			      all->gid))
-		{
-		  error (0, errno, _("cannot represent ar_gid"));
-		  goto nonew_unlink;
-		}
-	      if (! no0print (true, arhdr.ar_mode, sizeof (arhdr.ar_mode),
-			all->mode))
-		{
-		  error (0, errno, _("cannot represent ar_mode"));
-		  goto nonew_unlink;
-		}
-	      if (! no0print (false, arhdr.ar_size, sizeof (arhdr.ar_size),
-			all->size))
-		{
-		  error (0, errno, _("cannot represent ar_size"));
-		  goto nonew_unlink;
-		}
-	      memcpy (arhdr.ar_fmag, ARFMAG, sizeof (arhdr.ar_fmag));
-
-	      if (unlikely (write_retry (newfd, &arhdr, sizeof (arhdr))
-			    != sizeof (arhdr)))
-		goto nonew_unlink;
-
-	      /* Now the file itself.  */
-	      if (unlikely (write_retry (newfd, all->mem, all->size)
-			    != (off_t) all->size))
-		goto nonew_unlink;
-
-	      /* Pad the file if its size is odd.  */
-	      if ((all->size & 1) != 0)
-		if (unlikely (write_retry (newfd, "\n", 1) != 1))
-		  goto nonew_unlink;
-	    }
-	  else
-	    {
-	      /* This is a member from the archive.  */
-	      if (write_member (all, &start, &len, elf, cur_off, newfd)
-		  != 0)
-		goto nonew_unlink;
-	    }
-
-	  all = all->next;
-	}
-
-      /* Write the last part.  */
-      if (start != -1 && copy_content (elf, newfd, start, len))
-	goto nonew_unlink;
-    }
-
-  /* Set the mode of the new file to the same values the original file
-     has.  */
-  if (fd != -1)
-    {
-      /* Never complain about fchown failing.  But do it before
-	 setting the modes, or they might be reset/ignored if the
-	 owner is wrong.  */
-      if (fchown (newfd, st.st_uid, st.st_gid) != 0) { ; }
-      if (fchmod (newfd, st.st_mode & ALLPERMS) != 0
-	  || close (newfd) != 0)
-        goto nonew_unlink;
-      newfd = -1;
-      if (rename (tmpfname, arfname) != 0)
-	goto nonew_unlink;
-    }
-
- errout:
-  for (int cnt = 0; cnt < argc; ++cnt)
-    elf_end (found[cnt]->elf);
-
-  elf_end (elf);
-
-  arlib_fini ();
-
-  if (fd != -1)
-    close (fd);
-
-  if (newfd != -1)
-    close (newfd);
-
-  return status;
-}
-
-
-#include "debugpred.h"
diff --git a/src/readelf.c b/src/readelf.c
deleted file mode 100644
index 215d7a1f5e80917e1960e3e94c6cb75fc3cfb1c1..0000000000000000000000000000000000000000
--- a/src/readelf.c
+++ /dev/null
@@ -1,12956 +0,0 @@
-/* Print information from ELF file in human-readable form.
-   Copyright (C) 1999-2018 Red Hat, Inc.
-   This file is part of elfutils.
-
-   This file is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   elfutils is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#include <alloca.h>
-#include <argp.h>
-#include <assert.h>
-#include <ctype.h>
-#include <dwarf.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <gelf.h>
-#include <inttypes.h>
-#include <langinfo.h>
-#include <libdw.h>
-#include <libdwfl.h>
-#include <libintl.h>
-#include <locale.h>
-#include <stdarg.h>
-#include <stdbool.h>
-#include <stdio.h>
-#include <stdio_ext.h>
-#include <stdlib.h>
-#include <string.h>
-#include <strings.h>
-#include <time.h>
-#include <unistd.h>
-#include <sys/stat.h>
-#include <signal.h>
-
-#include <libeu.h>
-#include <system.h>
-#include <printversion.h>
-#include "../libelf/libelfP.h"
-#include "../libelf/common.h"
-#include "../libebl/libeblP.h"
-#include "../libdwelf/libdwelf.h"
-#include "../libdw/libdwP.h"
-#include "../libdwfl/libdwflP.h"
-#include "../libdw/memory-access.h"
-
-#include "../libdw/known-dwarf.h"
-
-#ifdef __linux__
-#define CORE_SIGILL  SIGILL
-#define CORE_SIGBUS  SIGBUS
-#define CORE_SIGFPE  SIGFPE
-#define CORE_SIGSEGV SIGSEGV
-#define CORE_SI_USER SI_USER
-#else
-/* We want the linux version of those as that is what shows up in the core files. */
-#define CORE_SIGILL  4  /* Illegal instruction (ANSI).  */
-#define CORE_SIGBUS  7  /* BUS error (4.2 BSD).  */
-#define CORE_SIGFPE  8  /* Floating-point exception (ANSI).  */
-#define CORE_SIGSEGV 11 /* Segmentation violation (ANSI).  */
-#define CORE_SI_USER 0  /* Sent by kill, sigsend.  */
-#endif
-
-/* Name and version of program.  */
-ARGP_PROGRAM_VERSION_HOOK_DEF = print_version;
-
-/* Bug report address.  */
-ARGP_PROGRAM_BUG_ADDRESS_DEF = PACKAGE_BUGREPORT;
-
-/* argp key value for --elf-section, non-ascii.  */
-#define ELF_INPUT_SECTION 256
-
-/* argp key value for --dwarf-skeleton, non-ascii.  */
-#define DWARF_SKELETON 257
-
-/* argp key value for --dyn-syms, non-ascii.  */
-#define PRINT_DYNSYM_TABLE 258
-
-/* Terrible hack for hooking unrelated skeleton/split compile units,
-   see __libdw_link_skel_split in print_debug.  */
-static bool do_not_close_dwfl = false;
-
-/* Definitions of arguments for argp functions.  */
-static const struct argp_option options[] =
-{
-  { NULL, 0, NULL, 0, N_("ELF input selection:"), 0 },
-  { "elf-section", ELF_INPUT_SECTION, "SECTION", OPTION_ARG_OPTIONAL,
-    N_("Use the named SECTION (default .gnu_debugdata) as (compressed) ELF "
-       "input data"), 0 },
-  { "dwarf-skeleton", DWARF_SKELETON, "FILE", 0,
-    N_("Used with -w to find the skeleton Compile Units in FILE associated "
-       "with the Split Compile units in a .dwo input file"), 0 },
-  { NULL, 0, NULL, 0, N_("ELF output selection:"), 0 },
-  { "all", 'a', NULL, 0,
-    N_("All these plus -p .strtab -p .dynstr -p .comment"), 0 },
-  { "dynamic", 'd', NULL, 0, N_("Display the dynamic segment"), 0 },
-  { "file-header", 'h', NULL, 0, N_("Display the ELF file header"), 0 },
-  { "histogram", 'I', NULL, 0,
-    N_("Display histogram of bucket list lengths"), 0 },
-  { "program-headers", 'l', NULL, 0, N_("Display the program headers"), 0 },
-  { "segments", 'l', NULL, OPTION_ALIAS | OPTION_HIDDEN, NULL, 0 },
-  { "relocs", 'r', NULL, 0, N_("Display relocations"), 0 },
-  { "section-groups", 'g', NULL, 0, N_("Display the section groups"), 0 },
-  { "section-headers", 'S', NULL, 0, N_("Display the sections' headers"), 0 },
-  { "sections", 'S', NULL, OPTION_ALIAS | OPTION_HIDDEN, NULL, 0 },
-  { "symbols", 's', "SECTION", OPTION_ARG_OPTIONAL,
-    N_("Display the symbol table sections"), 0 },
-  { "dyn-syms", PRINT_DYNSYM_TABLE, NULL, 0,
-    N_("Display (only) the dynamic symbol table"), 0 },
-  { "version-info", 'V', NULL, 0, N_("Display versioning information"), 0 },
-  { "notes", 'n', "SECTION", OPTION_ARG_OPTIONAL, N_("Display the ELF notes"), 0 },
-  { "arch-specific", 'A', NULL, 0,
-    N_("Display architecture specific information, if any"), 0 },
-  { "exception", 'e', NULL, 0,
-    N_("Display sections for exception handling"), 0 },
-
-  { NULL, 0, NULL, 0, N_("Additional output selection:"), 0 },
-  { "debug-dump", 'w', "SECTION", OPTION_ARG_OPTIONAL,
-    N_("Display DWARF section content.  SECTION can be one of abbrev, addr, "
-       "aranges, decodedaranges, frame, gdb_index, info, info+, loc, line, "
-       "decodedline, ranges, pubnames, str, macinfo, macro or exception"), 0 },
-  { "hex-dump", 'x', "SECTION", 0,
-    N_("Dump the uninterpreted contents of SECTION, by number or name"), 0 },
-  { "strings", 'p', "SECTION", OPTION_ARG_OPTIONAL,
-    N_("Print string contents of sections"), 0 },
-  { "string-dump", 'p', NULL, OPTION_ALIAS | OPTION_HIDDEN, NULL, 0 },
-  { "archive-index", 'c', NULL, 0,
-    N_("Display the symbol index of an archive"), 0 },
-
-  { NULL, 0, NULL, 0, N_("Output control:"), 0 },
-  { "numeric-addresses", 'N', NULL, 0,
-    N_("Do not find symbol names for addresses in DWARF data"), 0 },
-  { "unresolved-address-offsets", 'U', NULL, 0,
-    N_("Display just offsets instead of resolving values to addresses in DWARF data"), 0 },
-  { "wide", 'W', NULL, 0,
-    N_("Ignored for compatibility (lines always wide)"), 0 },
-  { "decompress", 'z', NULL, 0,
-    N_("Show compression information for compressed sections (when used with -S); decompress section before dumping data (when used with -p or -x)"), 0 },
-  { NULL, 0, NULL, 0, NULL, 0 }
-};
-
-/* Short description of program.  */
-static const char doc[] = N_("\
-Print information from ELF file in human-readable form.");
-
-/* Strings for arguments in help texts.  */
-static const char args_doc[] = N_("FILE...");
-
-/* Prototype for option handler.  */
-static error_t parse_opt (int key, char *arg, struct argp_state *state);
-
-/* Data structure to communicate with argp functions.  */
-static struct argp argp =
-{
-  options, parse_opt, args_doc, doc, NULL, NULL, NULL
-};
-
-/* If non-null, the section from which we should read to (compressed) ELF.  */
-static const char *elf_input_section = NULL;
-
-/* If non-null, the file that contains the skeleton CUs.  */
-static const char *dwarf_skeleton = NULL;
-
-/* Flags set by the option controlling the output.  */
-
-/* True if dynamic segment should be printed.  */
-static bool print_dynamic_table;
-
-/* True if the file header should be printed.  */
-static bool print_file_header;
-
-/* True if the program headers should be printed.  */
-static bool print_program_header;
-
-/* True if relocations should be printed.  */
-static bool print_relocations;
-
-/* True if the section headers should be printed.  */
-static bool print_section_header;
-
-/* True if the symbol table should be printed.  */
-static bool print_symbol_table;
-
-/* True if (only) the dynsym table should be printed.  */
-static bool print_dynsym_table;
-
-/* A specific section name, or NULL to print all symbol tables.  */
-static char *symbol_table_section;
-
-/* A specific section name, or NULL to print all ELF notes.  */
-static char *notes_section;
-
-/* True if the version information should be printed.  */
-static bool print_version_info;
-
-/* True if section groups should be printed.  */
-static bool print_section_groups;
-
-/* True if bucket list length histogram should be printed.  */
-static bool print_histogram;
-
-/* True if the architecture specific data should be printed.  */
-static bool print_arch;
-
-/* True if note section content should be printed.  */
-static bool print_notes;
-
-/* True if SHF_STRINGS section content should be printed.  */
-static bool print_string_sections;
-
-/* True if archive index should be printed.  */
-static bool print_archive_index;
-
-/* True if any of the control options except print_archive_index is set.  */
-static bool any_control_option;
-
-/* True if we should print addresses from DWARF in symbolic form.  */
-static bool print_address_names = true;
-
-/* True if we should print raw values instead of relativized addresses.  */
-static bool print_unresolved_addresses = false;
-
-/* True if we should print the .debug_aranges section using libdw.  */
-static bool decodedaranges = false;
-
-/* True if we should print the .debug_aranges section using libdw.  */
-static bool decodedline = false;
-
-/* True if we want to show more information about compressed sections.  */
-static bool print_decompress = false;
-
-/* True if we want to show split compile units for debug_info skeletons.  */
-static bool show_split_units = false;
-
-/* Select printing of debugging sections.  */
-static enum section_e
-{
-  section_abbrev = 1,		/* .debug_abbrev  */
-  section_aranges = 2,		/* .debug_aranges  */
-  section_frame = 4,		/* .debug_frame or .eh_frame & al.  */
-  section_info = 8,		/* .debug_info, (implies .debug_types)  */
-  section_line = 16,		/* .debug_line  */
-  section_loc = 32,		/* .debug_loc  */
-  section_pubnames = 64,	/* .debug_pubnames  */
-  section_str = 128,		/* .debug_str  */
-  section_macinfo = 256,	/* .debug_macinfo  */
-  section_ranges = 512, 	/* .debug_ranges  */
-  section_exception = 1024,	/* .eh_frame & al.  */
-  section_gdb_index = 2048,	/* .gdb_index  */
-  section_macro = 4096,		/* .debug_macro  */
-  section_addr = 8192,		/* .debug_addr  */
-  section_types = 16384,	/* .debug_types (implied by .debug_info)  */
-  section_all = (section_abbrev | section_aranges | section_frame
-		 | section_info | section_line | section_loc
-		 | section_pubnames | section_str | section_macinfo
-		 | section_ranges | section_exception | section_gdb_index
-		 | section_macro | section_addr | section_types)
-} print_debug_sections, implicit_debug_sections;
-
-/* Select hex dumping of sections.  */
-static struct section_argument *dump_data_sections;
-static struct section_argument **dump_data_sections_tail = &dump_data_sections;
-
-/* Select string dumping of sections.  */
-static struct section_argument *string_sections;
-static struct section_argument **string_sections_tail = &string_sections;
-
-struct section_argument
-{
-  struct section_argument *next;
-  const char *arg;
-  bool implicit;
-};
-
-/* Numbers of sections and program headers in the file.  */
-static size_t shnum;
-static size_t phnum;
-
-
-/* Declarations of local functions.  */
-static void process_file (int fd, const char *fname, bool only_one);
-static void process_elf_file (Dwfl_Module *dwflmod, int fd);
-static void print_ehdr (Ebl *ebl, GElf_Ehdr *ehdr);
-static void print_shdr (Ebl *ebl, GElf_Ehdr *ehdr);
-static void print_phdr (Ebl *ebl, GElf_Ehdr *ehdr);
-static void print_scngrp (Ebl *ebl);
-static void print_dynamic (Ebl *ebl);
-static void print_relocs (Ebl *ebl, GElf_Ehdr *ehdr);
-static void handle_relocs_rel (Ebl *ebl, GElf_Ehdr *ehdr, Elf_Scn *scn,
-			       GElf_Shdr *shdr);
-static void handle_relocs_rela (Ebl *ebl, GElf_Ehdr *ehdr, Elf_Scn *scn,
-				GElf_Shdr *shdr);
-static void print_symtab (Ebl *ebl, int type);
-static void handle_symtab (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr);
-static void print_verinfo (Ebl *ebl);
-static void handle_verneed (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr);
-static void handle_verdef (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr);
-static void handle_versym (Ebl *ebl, Elf_Scn *scn,
-			   GElf_Shdr *shdr);
-static void print_debug (Dwfl_Module *dwflmod, Ebl *ebl, GElf_Ehdr *ehdr);
-static void handle_hash (Ebl *ebl);
-static void handle_notes (Ebl *ebl, GElf_Ehdr *ehdr);
-static void print_liblist (Ebl *ebl);
-static void print_attributes (Ebl *ebl, const GElf_Ehdr *ehdr);
-static void dump_data (Ebl *ebl);
-static void dump_strings (Ebl *ebl);
-static void print_strings (Ebl *ebl);
-static void dump_archive_index (Elf *, const char *);
-
-
-/* Looked up once with gettext in main.  */
-static char *yes_str;
-static char *no_str;
-
-static void
-cleanup_list (struct section_argument *list)
-{
-  while (list != NULL)
-    {
-      struct section_argument *a = list;
-      list = a->next;
-      free (a);
-    }
-}
-
-int
-main (int argc, char *argv[])
-{
-  /* We use no threads here which can interfere with handling a stream.  */
-  (void) __fsetlocking (stdout, FSETLOCKING_BYCALLER);
-
-  /* Set locale.  */
-  setlocale (LC_ALL, "");
-
-  /* Initialize the message catalog.  */
-  textdomain (PACKAGE_TARNAME);
-
-  /* Look up once.  */
-  yes_str = _("yes");
-  no_str = _("no");
-
-  /* Parse and process arguments.  */
-  int remaining;
-  argp_parse (&argp, argc, argv, 0, &remaining, NULL);
-
-  /* Before we start tell the ELF library which version we are using.  */
-  elf_version (EV_CURRENT);
-
-  /* Now process all the files given at the command line.  */
-  bool only_one = remaining + 1 == argc;
-  do
-    {
-      /* Open the file.  */
-      int fd = open (argv[remaining], O_RDONLY);
-      if (fd == -1)
-	{
-	  error (0, errno, _("cannot open input file '%s'"), argv[remaining]);
-	  continue;
-	}
-
-      process_file (fd, argv[remaining], only_one);
-
-      close (fd);
-    }
-  while (++remaining < argc);
-
-  cleanup_list (dump_data_sections);
-  cleanup_list (string_sections);
-
-  return error_message_count != 0;
-}
-
-static void
-add_dump_section (const char *name,
-		  int key,
-		  bool implicit)
-{
-  struct section_argument *a = xmalloc (sizeof *a);
-  a->arg = name;
-  a->next = NULL;
-  a->implicit = implicit;
-  struct section_argument ***tailp
-    = key == 'x' ? &dump_data_sections_tail : &string_sections_tail;
-  **tailp = a;
-  *tailp = &a->next;
-}
-
-/* Handle program arguments.  */
-static error_t
-parse_opt (int key, char *arg,
-	   struct argp_state *state __attribute__ ((unused)))
-{
-  switch (key)
-    {
-    case 'a':
-      print_file_header = true;
-      print_program_header = true;
-      print_relocations = true;
-      print_section_header = true;
-      print_symbol_table = true;
-      print_version_info = true;
-      print_dynamic_table = true;
-      print_section_groups = true;
-      print_histogram = true;
-      print_arch = true;
-      print_notes = true;
-      implicit_debug_sections |= section_exception;
-      add_dump_section (".strtab", key, true);
-      add_dump_section (".dynstr", key, true);
-      add_dump_section (".comment", key, true);
-      any_control_option = true;
-      break;
-    case 'A':
-      print_arch = true;
-      any_control_option = true;
-      break;
-    case 'd':
-      print_dynamic_table = true;
-      any_control_option = true;
-      break;
-    case 'e':
-      print_debug_sections |= section_exception;
-      any_control_option = true;
-      break;
-    case 'g':
-      print_section_groups = true;
-      any_control_option = true;
-      break;
-    case 'h':
-      print_file_header = true;
-      any_control_option = true;
-      break;
-    case 'I':
-      print_histogram = true;
-      any_control_option = true;
-      break;
-    case 'l':
-      print_program_header = true;
-      any_control_option = true;
-      break;
-    case 'n':
-      print_notes = true;
-      any_control_option = true;
-      notes_section = arg;
-      break;
-    case 'r':
-      print_relocations = true;
-      any_control_option = true;
-     break;
-    case 'S':
-      print_section_header = true;
-      any_control_option = true;
-      break;
-    case 's':
-      print_symbol_table = true;
-      any_control_option = true;
-      symbol_table_section = arg;
-      break;
-    case PRINT_DYNSYM_TABLE:
-      print_dynsym_table = true;
-      any_control_option = true;
-      break;
-    case 'V':
-      print_version_info = true;
-      any_control_option = true;
-      break;
-    case 'c':
-      print_archive_index = true;
-      break;
-    case 'w':
-      if (arg == NULL)
-	{
-	  print_debug_sections = section_all;
-	  implicit_debug_sections = section_info;
-	  show_split_units = true;
-	}
-      else if (strcmp (arg, "abbrev") == 0)
-	print_debug_sections |= section_abbrev;
-      else if (strcmp (arg, "addr") == 0)
-	{
-	  print_debug_sections |= section_addr;
-	  implicit_debug_sections |= section_info;
-	}
-      else if (strcmp (arg, "aranges") == 0)
-	print_debug_sections |= section_aranges;
-      else if (strcmp (arg, "decodedaranges") == 0)
-	{
-	  print_debug_sections |= section_aranges;
-	  decodedaranges = true;
-	}
-      else if (strcmp (arg, "ranges") == 0)
-	{
-	  print_debug_sections |= section_ranges;
-	  implicit_debug_sections |= section_info;
-	}
-      else if (strcmp (arg, "frame") == 0 || strcmp (arg, "frames") == 0)
-	print_debug_sections |= section_frame;
-      else if (strcmp (arg, "info") == 0)
-	{
-	  print_debug_sections |= section_info;
-	  print_debug_sections |= section_types;
-	}
-      else if (strcmp (arg, "info+") == 0)
-	{
-	  print_debug_sections |= section_info;
-	  print_debug_sections |= section_types;
-	  show_split_units = true;
-	}
-      else if (strcmp (arg, "loc") == 0)
-	{
-	  print_debug_sections |= section_loc;
-	  implicit_debug_sections |= section_info;
-	}
-      else if (strcmp (arg, "line") == 0)
-	print_debug_sections |= section_line;
-      else if (strcmp (arg, "decodedline") == 0)
-	{
-	  print_debug_sections |= section_line;
-	  decodedline = true;
-	}
-      else if (strcmp (arg, "pubnames") == 0)
-	print_debug_sections |= section_pubnames;
-      else if (strcmp (arg, "str") == 0)
-	{
-	  print_debug_sections |= section_str;
-	  /* For mapping string offset tables to CUs.  */
-	  implicit_debug_sections |= section_info;
-	}
-      else if (strcmp (arg, "macinfo") == 0)
-	print_debug_sections |= section_macinfo;
-      else if (strcmp (arg, "macro") == 0)
-	print_debug_sections |= section_macro;
-      else if (strcmp (arg, "exception") == 0)
-	print_debug_sections |= section_exception;
-      else if (strcmp (arg, "gdb_index") == 0)
-	print_debug_sections |= section_gdb_index;
-      else
-	{
-	  fprintf (stderr, _("Unknown DWARF debug section `%s'.\n"),
-		   arg);
-	  argp_help (&argp, stderr, ARGP_HELP_SEE,
-		     program_invocation_short_name);
-	  exit (1);
-	}
-      any_control_option = true;
-      break;
-    case 'p':
-      any_control_option = true;
-      if (arg == NULL)
-	{
-	  print_string_sections = true;
-	  break;
-	}
-      FALLTHROUGH;
-    case 'x':
-      add_dump_section (arg, key, false);
-      any_control_option = true;
-      break;
-    case 'N':
-      print_address_names = false;
-      break;
-    case 'U':
-      print_unresolved_addresses = true;
-      break;
-    case ARGP_KEY_NO_ARGS:
-      fputs (_("Missing file name.\n"), stderr);
-      goto do_argp_help;
-    case ARGP_KEY_FINI:
-      if (! any_control_option && ! print_archive_index)
-	{
-	  fputs (_("No operation specified.\n"), stderr);
-	do_argp_help:
-	  argp_help (&argp, stderr, ARGP_HELP_SEE,
-		     program_invocation_short_name);
-	  exit (EXIT_FAILURE);
-	}
-      break;
-    case 'W':			/* Ignored.  */
-      break;
-    case 'z':
-      print_decompress = true;
-      break;
-    case ELF_INPUT_SECTION:
-      if (arg == NULL)
-	elf_input_section = ".gnu_debugdata";
-      else
-	elf_input_section = arg;
-      break;
-    case DWARF_SKELETON:
-      dwarf_skeleton = arg;
-      break;
-    default:
-      return ARGP_ERR_UNKNOWN;
-    }
-  return 0;
-}
-
-
-/* Create a file descriptor to read the data from the
-   elf_input_section given a file descriptor to an ELF file.  */
-static int
-open_input_section (int fd)
-{
-  size_t shnums;
-  size_t cnt;
-  size_t shstrndx;
-  Elf *elf = elf_begin (fd, ELF_C_READ_MMAP, NULL);
-  if (elf == NULL)
-    {
-      error (0, 0, _("cannot generate Elf descriptor: %s"),
-	     elf_errmsg (-1));
-      return -1;
-    }
-
-  if (elf_getshdrnum (elf, &shnums) < 0)
-    {
-      error (0, 0, _("cannot determine number of sections: %s"),
-	     elf_errmsg (-1));
-    open_error:
-      elf_end (elf);
-      return -1;
-    }
-
-  if (elf_getshdrstrndx (elf, &shstrndx) < 0)
-    {
-      error (0, 0, _("cannot get section header string table index"));
-      goto open_error;
-    }
-
-  for (cnt = 0; cnt < shnums; ++cnt)
-    {
-      Elf_Scn *scn = elf_getscn (elf, cnt);
-      if (scn == NULL)
-	{
-	  error (0, 0, _("cannot get section: %s"),
-		 elf_errmsg (-1));
-	  goto open_error;
-	}
-
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-      if (unlikely (shdr == NULL))
-	{
-	  error (0, 0, _("cannot get section header: %s"),
-		 elf_errmsg (-1));
-	  goto open_error;
-	}
-
-      const char *sname = elf_strptr (elf, shstrndx, shdr->sh_name);
-      if (sname == NULL)
-	{
-	  error (0, 0, _("cannot get section name"));
-	  goto open_error;
-	}
-
-      if (strcmp (sname, elf_input_section) == 0)
-	{
-	  Elf_Data *data = elf_rawdata (scn, NULL);
-	  if (data == NULL)
-	    {
-	      error (0, 0, _("cannot get %s content: %s"),
-		     sname, elf_errmsg (-1));
-	      goto open_error;
-	    }
-
-	  /* Create (and immediately unlink) a temporary file to store
-	     section data in to create a file descriptor for it.  */
-	  const char *tmpdir = getenv ("TMPDIR") ?: P_tmpdir;
-	  static const char suffix[] = "/readelfXXXXXX";
-	  int tmplen = strlen (tmpdir) + sizeof (suffix);
-	  char *tempname = alloca (tmplen);
-	  sprintf (tempname, "%s%s", tmpdir, suffix);
-
-	  int sfd = mkstemp (tempname);
-	  if (sfd == -1)
-	    {
-	      error (0, 0, _("cannot create temp file '%s'"),
-		     tempname);
-	      goto open_error;
-	    }
-	  unlink (tempname);
-
-	  ssize_t size = data->d_size;
-	  if (write_retry (sfd, data->d_buf, size) != size)
-	    {
-	      error (0, 0, _("cannot write section data"));
-	      goto open_error;
-	    }
-
-	  if (elf_end (elf) != 0)
-	    {
-	      error (0, 0, _("error while closing Elf descriptor: %s"),
-		     elf_errmsg (-1));
-	      return -1;
-	    }
-
-	  if (lseek (sfd, 0, SEEK_SET) == -1)
-	    {
-	      error (0, 0, _("error while rewinding file descriptor"));
-	      return -1;
-	    }
-
-	  return sfd;
-	}
-    }
-
-  /* Named section not found.  */
-  if (elf_end (elf) != 0)
-    error (0, 0, _("error while closing Elf descriptor: %s"),
-	   elf_errmsg (-1));
-  return -1;
-}
-
-/* Check if the file is an archive, and if so dump its index.  */
-static void
-check_archive_index (int fd, const char *fname, bool only_one)
-{
-  /* Create an `Elf' descriptor.  */
-  Elf *elf = elf_begin (fd, ELF_C_READ_MMAP, NULL);
-  if (elf == NULL)
-    error (0, 0, _("cannot generate Elf descriptor: %s"),
-	   elf_errmsg (-1));
-  else
-    {
-      if (elf_kind (elf) == ELF_K_AR)
-	{
-	  if (!only_one)
-	    printf ("\n%s:\n\n", fname);
-	  dump_archive_index (elf, fname);
-	}
-      else
-	error (0, 0,
-	       _("'%s' is not an archive, cannot print archive index"),
-	       fname);
-
-      /* Now we can close the descriptor.  */
-      if (elf_end (elf) != 0)
-	error (0, 0, _("error while closing Elf descriptor: %s"),
-	       elf_errmsg (-1));
-    }
-}
-
-/* Trivial callback used for checking if we opened an archive.  */
-static int
-count_dwflmod (Dwfl_Module *dwflmod __attribute__ ((unused)),
-	       void **userdata __attribute__ ((unused)),
-	       const char *name __attribute__ ((unused)),
-	       Dwarf_Addr base __attribute__ ((unused)),
-	       void *arg)
-{
-  if (*(bool *) arg)
-    return DWARF_CB_ABORT;
-  *(bool *) arg = true;
-  return DWARF_CB_OK;
-}
-
-struct process_dwflmod_args
-{
-  int fd;
-  bool only_one;
-};
-
-static int
-process_dwflmod (Dwfl_Module *dwflmod,
-		 void **userdata __attribute__ ((unused)),
-		 const char *name __attribute__ ((unused)),
-		 Dwarf_Addr base __attribute__ ((unused)),
-		 void *arg)
-{
-  const struct process_dwflmod_args *a = arg;
-
-  /* Print the file name.  */
-  if (!a->only_one)
-    {
-      const char *fname;
-      dwfl_module_info (dwflmod, NULL, NULL, NULL, NULL, NULL, &fname, NULL);
-
-      printf ("\n%s:\n\n", fname);
-    }
-
-  process_elf_file (dwflmod, a->fd);
-
-  return DWARF_CB_OK;
-}
-
-/* Stub libdwfl callback, only the ELF handle already open is ever used.
-   Only used for finding the alternate debug file if the Dwarf comes from
-   the main file.  We are not interested in separate debuginfo.  */
-static int
-find_no_debuginfo (Dwfl_Module *mod,
-		   void **userdata,
-		   const char *modname,
-		   Dwarf_Addr base,
-		   const char *file_name,
-		   const char *debuglink_file,
-		   GElf_Word debuglink_crc,
-		   char **debuginfo_file_name)
-{
-  Dwarf_Addr dwbias;
-  dwfl_module_info (mod, NULL, NULL, NULL, &dwbias, NULL, NULL, NULL);
-
-  /* We are only interested if the Dwarf has been setup on the main
-     elf file but is only missing the alternate debug link.  If dwbias
-     hasn't even been setup, this is searching for separate debuginfo
-     for the main elf.  We don't care in that case.  */
-  if (dwbias == (Dwarf_Addr) -1)
-    return -1;
-
-  return dwfl_standard_find_debuginfo (mod, userdata, modname, base,
-				       file_name, debuglink_file,
-				       debuglink_crc, debuginfo_file_name);
-}
-
-static Dwfl *
-create_dwfl (int fd, const char *fname)
-{
-  /* Duplicate an fd for dwfl_report_offline to swallow.  */
-  int dwfl_fd = dup (fd);
-  if (unlikely (dwfl_fd < 0))
-    error (EXIT_FAILURE, errno, "dup");
-
-  /* Use libdwfl in a trivial way to open the libdw handle for us.
-     This takes care of applying relocations to DWARF data in ET_REL files.  */
-  static const Dwfl_Callbacks callbacks =
-    {
-      .section_address = dwfl_offline_section_address,
-      .find_debuginfo = find_no_debuginfo
-    };
-  Dwfl *dwfl = dwfl_begin (&callbacks);
-  if (likely (dwfl != NULL))
-    /* Let 0 be the logical address of the file (or first in archive).  */
-    dwfl->offline_next_address = 0;
-  if (dwfl_report_offline (dwfl, fname, fname, dwfl_fd) == NULL)
-    {
-      struct stat st;
-      if (fstat (dwfl_fd, &st) != 0)
-	error (0, errno, _("cannot stat input file"));
-      else if (unlikely (st.st_size == 0))
-	error (0, 0, _("input file is empty"));
-      else
-	error (0, 0, _("failed reading '%s': %s"),
-	       fname, dwfl_errmsg (-1));
-      close (dwfl_fd);		/* Consumed on success, not on failure.  */
-      dwfl = NULL;
-    }
-  else
-    dwfl_report_end (dwfl, NULL, NULL);
-
-  return dwfl;
-}
-
-/* Process one input file.  */
-static void
-process_file (int fd, const char *fname, bool only_one)
-{
-  if (print_archive_index)
-    check_archive_index (fd, fname, only_one);
-
-  if (!any_control_option)
-    return;
-
-  if (elf_input_section != NULL)
-    {
-      /* Replace fname and fd with section content. */
-      char *fnname = alloca (strlen (fname) + strlen (elf_input_section) + 2);
-      sprintf (fnname, "%s:%s", fname, elf_input_section);
-      fd = open_input_section (fd);
-      if (fd == -1)
-        {
-          error (0, 0, _("No such section '%s' in '%s'"),
-		 elf_input_section, fname);
-          return;
-        }
-      fname = fnname;
-    }
-
-  Dwfl *dwfl = create_dwfl (fd, fname);
-  if (dwfl != NULL)
-    {
-      if (only_one)
-	{
-	  /* Clear ONLY_ONE if we have multiple modules, from an archive.  */
-	  bool seen = false;
-	  only_one = dwfl_getmodules (dwfl, &count_dwflmod, &seen, 0) == 0;
-	}
-
-      /* Process the one or more modules gleaned from this file.  */
-      struct process_dwflmod_args a = { .fd = fd, .only_one = only_one };
-      dwfl_getmodules (dwfl, &process_dwflmod, &a, 0);
-    }
-  /* Terrible hack for hooking unrelated skeleton/split compile units,
-     see __libdw_link_skel_split in print_debug.  */
-  if (! do_not_close_dwfl)
-    dwfl_end (dwfl);
-
-  /* Need to close the replaced fd if we created it.  Caller takes
-     care of original.  */
-  if (elf_input_section != NULL)
-    close (fd);
-}
-
-/* Check whether there are any compressed sections in the ELF file.  */
-static bool
-elf_contains_chdrs (Elf *elf)
-{
-  Elf_Scn *scn = NULL;
-  while ((scn = elf_nextscn (elf, scn)) != NULL)
-    {
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-      if (shdr != NULL && (shdr->sh_flags & SHF_COMPRESSED) != 0)
-	return true;
-    }
-  return false;
-}
-
-/* Process one ELF file.  */
-static void
-process_elf_file (Dwfl_Module *dwflmod, int fd)
-{
-  GElf_Addr dwflbias;
-  Elf *elf = dwfl_module_getelf (dwflmod, &dwflbias);
-
-  GElf_Ehdr ehdr_mem;
-  GElf_Ehdr *ehdr = gelf_getehdr (elf, &ehdr_mem);
-
-  if (ehdr == NULL)
-    {
-      error (0, 0, _("cannot read ELF header: %s"), elf_errmsg (-1));
-      return;
-    }
-
-  Ebl *ebl = ebl_openbackend (elf);
-  if (unlikely (ebl == NULL))
-    {
-    ebl_error:
-      error (0, errno, _("cannot create EBL handle"));
-      return;
-    }
-
-  /* Determine the number of sections.  */
-  if (unlikely (elf_getshdrnum (ebl->elf, &shnum) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot determine number of sections: %s"),
-	   elf_errmsg (-1));
-
-  /* Determine the number of phdrs.  */
-  if (unlikely (elf_getphdrnum (ebl->elf, &phnum) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot determine number of program headers: %s"),
-	   elf_errmsg (-1));
-
-  /* For an ET_REL file, libdwfl has adjusted the in-core shdrs and
-     may have applied relocation to some sections.  If there are any
-     compressed sections, any pass (or libdw/libdwfl) might have
-     uncompressed them.  So we need to get a fresh Elf handle on the
-     file to display those.  */
-  bool print_unchanged = ((print_section_header
-			   || print_relocations
-			   || dump_data_sections != NULL
-			   || print_notes)
-			  && (ehdr->e_type == ET_REL
-			      || elf_contains_chdrs (ebl->elf)));
-
-  Elf *pure_elf = NULL;
-  Ebl *pure_ebl = ebl;
-  if (print_unchanged)
-    {
-      /* Read the file afresh.  */
-      off_t aroff = elf_getaroff (elf);
-      pure_elf = dwelf_elf_begin (fd);
-      if (aroff > 0)
-	{
-	  /* Archive member.  */
-	  (void) elf_rand (pure_elf, aroff);
-	  Elf *armem = elf_begin (-1, ELF_C_READ_MMAP, pure_elf);
-	  elf_end (pure_elf);
-	  pure_elf = armem;
-	}
-      if (pure_elf == NULL)
-	{
-	  error (0, 0, _("cannot read ELF: %s"), elf_errmsg (-1));
-	  return;
-	}
-      pure_ebl = ebl_openbackend (pure_elf);
-      if (pure_ebl == NULL)
-	goto ebl_error;
-    }
-
-  if (print_file_header)
-    print_ehdr (ebl, ehdr);
-  if (print_section_header)
-    print_shdr (pure_ebl, ehdr);
-  if (print_program_header)
-    print_phdr (ebl, ehdr);
-  if (print_section_groups)
-    print_scngrp (ebl);
-  if (print_dynamic_table)
-    print_dynamic (ebl);
-  if (print_relocations)
-    print_relocs (pure_ebl, ehdr);
-  if (print_histogram)
-    handle_hash (ebl);
-  if (print_symbol_table || print_dynsym_table)
-    print_symtab (ebl, SHT_DYNSYM);
-  if (print_version_info)
-    print_verinfo (ebl);
-  if (print_symbol_table)
-    print_symtab (ebl, SHT_SYMTAB);
-  if (print_arch)
-    print_liblist (ebl);
-  if (print_arch)
-    print_attributes (ebl, ehdr);
-  if (dump_data_sections != NULL)
-    dump_data (pure_ebl);
-  if (string_sections != NULL)
-    dump_strings (ebl);
-  if ((print_debug_sections | implicit_debug_sections) != 0)
-    print_debug (dwflmod, ebl, ehdr);
-  if (print_notes)
-    handle_notes (pure_ebl, ehdr);
-  if (print_string_sections)
-    print_strings (ebl);
-
-  ebl_closebackend (ebl);
-
-  if (pure_ebl != ebl)
-    {
-      ebl_closebackend (pure_ebl);
-      elf_end (pure_elf);
-    }
-}
-
-
-/* Print file type.  */
-static void
-print_file_type (unsigned short int e_type)
-{
-  if (likely (e_type <= ET_CORE))
-    {
-      static const char *const knowntypes[] =
-      {
-	N_("NONE (None)"),
-	N_("REL (Relocatable file)"),
-	N_("EXEC (Executable file)"),
-	N_("DYN (Shared object file)"),
-	N_("CORE (Core file)")
-      };
-      puts (_(knowntypes[e_type]));
-    }
-  else if (e_type >= ET_LOOS && e_type <= ET_HIOS)
-    printf (_("OS Specific: (%x)\n"),  e_type);
-  else if (e_type >= ET_LOPROC /* && e_type <= ET_HIPROC always true */)
-    printf (_("Processor Specific: (%x)\n"),  e_type);
-  else
-    puts ("???");
-}
-
-
-/* Print ELF header.  */
-static void
-print_ehdr (Ebl *ebl, GElf_Ehdr *ehdr)
-{
-  fputs_unlocked (_("ELF Header:\n  Magic:  "), stdout);
-  for (size_t cnt = 0; cnt < EI_NIDENT; ++cnt)
-    printf (" %02hhx", ehdr->e_ident[cnt]);
-
-  printf (_("\n  Class:                             %s\n"),
-	  ehdr->e_ident[EI_CLASS] == ELFCLASS32 ? "ELF32"
-	  : ehdr->e_ident[EI_CLASS] == ELFCLASS64 ? "ELF64"
-	  : "\?\?\?");
-
-  printf (_("  Data:                              %s\n"),
-	  ehdr->e_ident[EI_DATA] == ELFDATA2LSB
-	  ? "2's complement, little endian"
-	  : ehdr->e_ident[EI_DATA] == ELFDATA2MSB
-	  ? "2's complement, big endian" : "\?\?\?");
-
-  printf (_("  Ident Version:                     %hhd %s\n"),
-	  ehdr->e_ident[EI_VERSION],
-	  ehdr->e_ident[EI_VERSION] == EV_CURRENT ? _("(current)")
-	  : "(\?\?\?)");
-
-  char buf[512];
-  printf (_("  OS/ABI:                            %s\n"),
-	  ebl_osabi_name (ebl, ehdr->e_ident[EI_OSABI], buf, sizeof (buf)));
-
-  printf (_("  ABI Version:                       %hhd\n"),
-	  ehdr->e_ident[EI_ABIVERSION]);
-
-  fputs_unlocked (_("  Type:                              "), stdout);
-  print_file_type (ehdr->e_type);
-
-  const char *machine = dwelf_elf_e_machine_string (ehdr->e_machine);
-  if (machine != NULL)
-    printf (_("  Machine:                           %s\n"), machine);
-  else
-    printf (_("  Machine:                           <unknown>: 0x%x\n"),
-	    ehdr->e_machine);
-
-  printf (_("  Version:                           %d %s\n"),
-	  ehdr->e_version,
-	  ehdr->e_version  == EV_CURRENT ? _("(current)") : "(\?\?\?)");
-
-  printf (_("  Entry point address:               %#" PRIx64 "\n"),
-	  ehdr->e_entry);
-
-  printf (_("  Start of program headers:          %" PRId64 " %s\n"),
-	  ehdr->e_phoff, _("(bytes into file)"));
-
-  printf (_("  Start of section headers:          %" PRId64 " %s\n"),
-	  ehdr->e_shoff, _("(bytes into file)"));
-
-  printf (_("  Flags:                             %s\n"),
-	  ebl_machine_flag_name (ebl, ehdr->e_flags, buf, sizeof (buf)));
-
-  printf (_("  Size of this header:               %" PRId16 " %s\n"),
-	  ehdr->e_ehsize, _("(bytes)"));
-
-  printf (_("  Size of program header entries:    %" PRId16 " %s\n"),
-	  ehdr->e_phentsize, _("(bytes)"));
-
-  printf (_("  Number of program headers entries: %" PRId16),
-	  ehdr->e_phnum);
-  if (ehdr->e_phnum == PN_XNUM)
-    {
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (elf_getscn (ebl->elf, 0), &shdr_mem);
-      if (shdr != NULL)
-	printf (_(" (%" PRIu32 " in [0].sh_info)"),
-		(uint32_t) shdr->sh_info);
-      else
-	fputs_unlocked (_(" ([0] not available)"), stdout);
-    }
-  fputc_unlocked ('\n', stdout);
-
-  printf (_("  Size of section header entries:    %" PRId16 " %s\n"),
-	  ehdr->e_shentsize, _("(bytes)"));
-
-  printf (_("  Number of section headers entries: %" PRId16),
-	  ehdr->e_shnum);
-  if (ehdr->e_shnum == 0)
-    {
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (elf_getscn (ebl->elf, 0), &shdr_mem);
-      if (shdr != NULL)
-	printf (_(" (%" PRIu32 " in [0].sh_size)"),
-		(uint32_t) shdr->sh_size);
-      else
-	fputs_unlocked (_(" ([0] not available)"), stdout);
-    }
-  fputc_unlocked ('\n', stdout);
-
-  if (unlikely (ehdr->e_shstrndx == SHN_XINDEX))
-    {
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (elf_getscn (ebl->elf, 0), &shdr_mem);
-      if (shdr != NULL)
-	/* We managed to get the zeroth section.  */
-	snprintf (buf, sizeof (buf), _(" (%" PRIu32 " in [0].sh_link)"),
-		  (uint32_t) shdr->sh_link);
-      else
-	{
-	  strncpy (buf, _(" ([0] not available)"), sizeof (buf));
-	  buf[sizeof (buf) - 1] = '\0';
-	}
-
-      printf (_("  Section header string table index: XINDEX%s\n\n"),
-	      buf);
-    }
-  else
-    printf (_("  Section header string table index: %" PRId16 "\n\n"),
-	    ehdr->e_shstrndx);
-}
-
-
-static const char *
-get_visibility_type (int value)
-{
-  switch (value)
-    {
-    case STV_DEFAULT:
-      return "DEFAULT";
-    case STV_INTERNAL:
-      return "INTERNAL";
-    case STV_HIDDEN:
-      return "HIDDEN";
-    case STV_PROTECTED:
-      return "PROTECTED";
-    default:
-      return "???";
-    }
-}
-
-static const char *
-elf_ch_type_name (unsigned int code)
-{
-  if (code == 0)
-    return "NONE";
-
-  if (code == ELFCOMPRESS_ZLIB)
-    return "ZLIB";
-
-  return "UNKNOWN";
-}
-
-/* Print the section headers.  */
-static void
-print_shdr (Ebl *ebl, GElf_Ehdr *ehdr)
-{
-  size_t cnt;
-  size_t shstrndx;
-
-  if (! print_file_header)
-    {
-      size_t sections;
-      if (unlikely (elf_getshdrnum (ebl->elf, &sections) < 0))
-	error (EXIT_FAILURE, 0,
-	       _("cannot get number of sections: %s"),
-	       elf_errmsg (-1));
-
-      printf (_("\
-There are %zd section headers, starting at offset %#" PRIx64 ":\n\
-\n"),
-	      sections, ehdr->e_shoff);
-    }
-
-  /* Get the section header string table index.  */
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index: %s"),
-	   elf_errmsg (-1));
-
-  puts (_("Section Headers:"));
-
-  if (ehdr->e_ident[EI_CLASS] == ELFCLASS32)
-    puts (_("[Nr] Name                 Type         Addr     Off    Size   ES Flags Lk Inf Al"));
-  else
-    puts (_("[Nr] Name                 Type         Addr             Off      Size     ES Flags Lk Inf Al"));
-
-  if (print_decompress)
-    {
-      if (ehdr->e_ident[EI_CLASS] == ELFCLASS32)
-	puts (_("     [Compression  Size   Al]"));
-      else
-	puts (_("     [Compression  Size     Al]"));
-    }
-
-  for (cnt = 0; cnt < shnum; ++cnt)
-    {
-      Elf_Scn *scn = elf_getscn (ebl->elf, cnt);
-
-      if (unlikely (scn == NULL))
-	error (EXIT_FAILURE, 0, _("cannot get section: %s"),
-	       elf_errmsg (-1));
-
-      /* Get the section header.  */
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-      if (unlikely (shdr == NULL))
-	error (EXIT_FAILURE, 0, _("cannot get section header: %s"),
-	       elf_errmsg (-1));
-
-      char flagbuf[20];
-      char *cp = flagbuf;
-      if (shdr->sh_flags & SHF_WRITE)
-	*cp++ = 'W';
-      if (shdr->sh_flags & SHF_ALLOC)
-	*cp++ = 'A';
-      if (shdr->sh_flags & SHF_EXECINSTR)
-	*cp++ = 'X';
-      if (shdr->sh_flags & SHF_MERGE)
-	*cp++ = 'M';
-      if (shdr->sh_flags & SHF_STRINGS)
-	*cp++ = 'S';
-      if (shdr->sh_flags & SHF_INFO_LINK)
-	*cp++ = 'I';
-      if (shdr->sh_flags & SHF_LINK_ORDER)
-	*cp++ = 'L';
-      if (shdr->sh_flags & SHF_OS_NONCONFORMING)
-	*cp++ = 'N';
-      if (shdr->sh_flags & SHF_GROUP)
-	*cp++ = 'G';
-      if (shdr->sh_flags & SHF_TLS)
-	*cp++ = 'T';
-      if (shdr->sh_flags & SHF_COMPRESSED)
-	*cp++ = 'C';
-      if (shdr->sh_flags & SHF_ORDERED)
-	*cp++ = 'O';
-      if (shdr->sh_flags & SHF_EXCLUDE)
-	*cp++ = 'E';
-      if (shdr->sh_flags & SHF_GNU_RETAIN)
-	*cp++ = 'R';
-      *cp = '\0';
-
-      const char *sname;
-      char buf[128];
-      sname = elf_strptr (ebl->elf, shstrndx, shdr->sh_name) ?: "<corrupt>";
-      printf ("[%2zu] %-20s %-12s %0*" PRIx64 " %0*" PRIx64 " %0*" PRIx64
-	      " %2" PRId64 " %-5s %2" PRId32 " %3" PRId32
-	      " %2" PRId64 "\n",
-	      cnt, sname,
-	      ebl_section_type_name (ebl, shdr->sh_type, buf, sizeof (buf)),
-	      ehdr->e_ident[EI_CLASS] == ELFCLASS32 ? 8 : 16, shdr->sh_addr,
-	      ehdr->e_ident[EI_CLASS] == ELFCLASS32 ? 6 : 8, shdr->sh_offset,
-	      ehdr->e_ident[EI_CLASS] == ELFCLASS32 ? 6 : 8, shdr->sh_size,
-	      shdr->sh_entsize, flagbuf, shdr->sh_link, shdr->sh_info,
-	      shdr->sh_addralign);
-
-      if (print_decompress)
-	{
-	  if ((shdr->sh_flags & SHF_COMPRESSED) != 0)
-	    {
-	      GElf_Chdr chdr;
-	      if (gelf_getchdr (scn, &chdr) != NULL)
-		printf ("     [ELF %s (%" PRId32 ") %0*" PRIx64
-			" %2" PRId64 "]\n",
-			elf_ch_type_name (chdr.ch_type),
-			chdr.ch_type,
-			ehdr->e_ident[EI_CLASS] == ELFCLASS32 ? 6 : 8,
-			chdr.ch_size, chdr.ch_addralign);
-	      else
-		error (0, 0,
-		       _("bad compression header for section %zd: %s"),
-		       elf_ndxscn (scn), elf_errmsg (-1));
-	    }
-	  else if (startswith (sname, ".zdebug"))
-	    {
-	      ssize_t size;
-	      if ((size = dwelf_scn_gnu_compressed_size (scn)) >= 0)
-		printf ("     [GNU ZLIB     %0*zx   ]\n",
-			ehdr->e_ident[EI_CLASS] == ELFCLASS32 ? 6 : 8, size);
-	      else
-		error (0, 0,
-		       _("bad gnu compressed size for section %zd: %s"),
-		       elf_ndxscn (scn), elf_errmsg (-1));
-	    }
-	}
-    }
-
-  fputc_unlocked ('\n', stdout);
-}
-
-
-/* Print the program header.  */
-static void
-print_phdr (Ebl *ebl, GElf_Ehdr *ehdr)
-{
-  if (phnum == 0)
-    /* No program header, this is OK in relocatable objects.  */
-    return;
-
-  puts (_("Program Headers:"));
-  if (ehdr->e_ident[EI_CLASS] == ELFCLASS32)
-    puts (_("\
-  Type           Offset   VirtAddr   PhysAddr   FileSiz  MemSiz   Flg Align"));
-  else
-    puts (_("\
-  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align"));
-
-  /* Process all program headers.  */
-  bool has_relro = false;
-  GElf_Addr relro_from = 0;
-  GElf_Addr relro_to = 0;
-  for (size_t cnt = 0; cnt < phnum; ++cnt)
-    {
-      char buf[128];
-      GElf_Phdr mem;
-      GElf_Phdr *phdr = gelf_getphdr (ebl->elf, cnt, &mem);
-
-      /* If for some reason the header cannot be returned show this.  */
-      if (unlikely (phdr == NULL))
-	{
-	  puts ("  ???");
-	  continue;
-	}
-
-      printf ("  %-14s 0x%06" PRIx64 " 0x%0*" PRIx64 " 0x%0*" PRIx64
-	      " 0x%06" PRIx64 " 0x%06" PRIx64 " %c%c%c 0x%" PRIx64 "\n",
-	      ebl_segment_type_name (ebl, phdr->p_type, buf, sizeof (buf)),
-	      phdr->p_offset,
-	      ehdr->e_ident[EI_CLASS] == ELFCLASS32 ? 8 : 16, phdr->p_vaddr,
-	      ehdr->e_ident[EI_CLASS] == ELFCLASS32 ? 8 : 16, phdr->p_paddr,
-	      phdr->p_filesz,
-	      phdr->p_memsz,
-	      phdr->p_flags & PF_R ? 'R' : ' ',
-	      phdr->p_flags & PF_W ? 'W' : ' ',
-	      phdr->p_flags & PF_X ? 'E' : ' ',
-	      phdr->p_align);
-
-      if (phdr->p_type == PT_INTERP)
-	{
-	  /* If we are sure the file offset is valid then we can show
-	     the user the name of the interpreter.  We check whether
-	     there is a section at the file offset.  Normally there
-	     would be a section called ".interp".  But in separate
-	     .debug files it is a NOBITS section (and so doesn't match
-	     with gelf_offscn).  Which probably means the offset is
-	     not valid another reason could be because the ELF file
-	     just doesn't contain any section headers, in that case
-	     just play it safe and don't display anything.  */
-
-	  Elf_Scn *scn = gelf_offscn (ebl->elf, phdr->p_offset);
-	  GElf_Shdr shdr_mem;
-	  GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-
-	  size_t maxsize;
-	  char *filedata = elf_rawfile (ebl->elf, &maxsize);
-
-	  if (shdr != NULL && shdr->sh_type == SHT_PROGBITS
-	      && filedata != NULL && phdr->p_offset < maxsize
-	      && phdr->p_filesz <= maxsize - phdr->p_offset
-	      && memchr (filedata + phdr->p_offset, '\0',
-			 phdr->p_filesz) != NULL)
-	    printf (_("\t[Requesting program interpreter: %s]\n"),
-		    filedata + phdr->p_offset);
-	}
-      else if (phdr->p_type == PT_GNU_RELRO)
-	{
-	  has_relro = true;
-	  relro_from = phdr->p_vaddr;
-	  relro_to = relro_from + phdr->p_memsz;
-	}
-    }
-
-  size_t sections;
-  if (unlikely (elf_getshdrnum (ebl->elf, &sections) < 0))
-    error (EXIT_FAILURE, 0,
-           _("cannot get number of sections: %s"),
-           elf_errmsg (-1));
-
-  if (sections == 0)
-    /* No sections in the file.  Punt.  */
-    return;
-
-  /* Get the section header string table index.  */
-  size_t shstrndx;
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  puts (_("\n Section to Segment mapping:\n  Segment Sections..."));
-
-  for (size_t cnt = 0; cnt < phnum; ++cnt)
-    {
-      /* Print the segment number.  */
-      printf ("   %2.2zu     ", cnt);
-
-      GElf_Phdr phdr_mem;
-      GElf_Phdr *phdr = gelf_getphdr (ebl->elf, cnt, &phdr_mem);
-      /* This must not happen.  */
-      if (unlikely (phdr == NULL))
-	error (EXIT_FAILURE, 0, _("cannot get program header: %s"),
-	       elf_errmsg (-1));
-
-      /* Iterate over the sections.  */
-      bool in_relro = false;
-      bool in_ro = false;
-      for (size_t inner = 1; inner < shnum; ++inner)
-	{
-	  Elf_Scn *scn = elf_getscn (ebl->elf, inner);
-	  /* This should not happen.  */
-	  if (unlikely (scn == NULL))
-	    error (EXIT_FAILURE, 0, _("cannot get section: %s"),
-		   elf_errmsg (-1));
-
-	  /* Get the section header.  */
-	  GElf_Shdr shdr_mem;
-	  GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-	  if (unlikely (shdr == NULL))
-	    error (EXIT_FAILURE, 0,
-		   _("cannot get section header: %s"),
-		   elf_errmsg (-1));
-
-	  if (shdr->sh_size > 0
-	      /* Compare allocated sections by VMA, unallocated
-		 sections by file offset.  */
-	      && (shdr->sh_flags & SHF_ALLOC
-		  ? (shdr->sh_addr >= phdr->p_vaddr
-		     && (shdr->sh_addr + shdr->sh_size
-			 <= phdr->p_vaddr + phdr->p_memsz))
-		  : (shdr->sh_offset >= phdr->p_offset
-		     && (shdr->sh_offset + shdr->sh_size
-			 <= phdr->p_offset + phdr->p_filesz))))
-	    {
-	      if (has_relro && !in_relro
-		  && shdr->sh_addr >= relro_from
-		  && shdr->sh_addr + shdr->sh_size <= relro_to)
-		{
-		  fputs_unlocked (" [RELRO:", stdout);
-		  in_relro = true;
-		}
-	      else if (has_relro && in_relro && shdr->sh_addr >= relro_to)
-		{
-		  fputs_unlocked ("]", stdout);
-		  in_relro =  false;
-		}
-	      else if (has_relro && in_relro
-		       && shdr->sh_addr + shdr->sh_size > relro_to)
-		fputs_unlocked ("] <RELRO:", stdout);
-	      else if (phdr->p_type == PT_LOAD && (phdr->p_flags & PF_W) == 0)
-		{
-		  if (!in_ro)
-		    {
-		      fputs_unlocked (" [RO:", stdout);
-		      in_ro = true;
-		    }
-		}
-	      else
-		{
-		  /* Determine the segment this section is part of.  */
-		  size_t cnt2;
-		  GElf_Phdr phdr2_mem;
-		  GElf_Phdr *phdr2 = NULL;
-		  for (cnt2 = 0; cnt2 < phnum; ++cnt2)
-		    {
-		      phdr2 = gelf_getphdr (ebl->elf, cnt2, &phdr2_mem);
-
-		      if (phdr2 != NULL && phdr2->p_type == PT_LOAD
-			  && shdr->sh_addr >= phdr2->p_vaddr
-			  && (shdr->sh_addr + shdr->sh_size
-			      <= phdr2->p_vaddr + phdr2->p_memsz))
-			break;
-		    }
-
-		  if (cnt2 < phnum)
-		    {
-		      if ((phdr2->p_flags & PF_W) == 0 && !in_ro)
-			{
-			  fputs_unlocked (" [RO:", stdout);
-			  in_ro = true;
-			}
-		      else if ((phdr2->p_flags & PF_W) != 0 && in_ro)
-			{
-			  fputs_unlocked ("]", stdout);
-			  in_ro = false;
-			}
-		    }
-		}
-
-	      printf (" %s",
-		      elf_strptr (ebl->elf, shstrndx, shdr->sh_name));
-
-	      /* Signal that this section is only partially covered.  */
-	      if (has_relro && in_relro
-		       && shdr->sh_addr + shdr->sh_size > relro_to)
-		{
-		  fputs_unlocked (">", stdout);
-		  in_relro =  false;
-		}
-	    }
-	}
-      if (in_relro || in_ro)
-	fputs_unlocked ("]", stdout);
-
-      /* Finish the line.  */
-      fputc_unlocked ('\n', stdout);
-    }
-}
-
-
-static const char *
-section_name (Ebl *ebl, GElf_Shdr *shdr)
-{
-  size_t shstrndx;
-  if (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0)
-    return "???";
-  return elf_strptr (ebl->elf, shstrndx, shdr->sh_name) ?: "???";
-}
-
-
-static void
-handle_scngrp (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr)
-{
-  /* Get the data of the section.  */
-  Elf_Data *data = elf_getdata (scn, NULL);
-
-  Elf_Scn *symscn = elf_getscn (ebl->elf, shdr->sh_link);
-  GElf_Shdr symshdr_mem;
-  GElf_Shdr *symshdr = gelf_getshdr (symscn, &symshdr_mem);
-  Elf_Data *symdata = elf_getdata (symscn, NULL);
-
-  if (data == NULL || data->d_size < sizeof (Elf32_Word) || symshdr == NULL
-      || symdata == NULL)
-    return;
-
-  /* Get the section header string table index.  */
-  size_t shstrndx;
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  Elf32_Word *grpref = (Elf32_Word *) data->d_buf;
-
-  GElf_Sym sym_mem;
-  GElf_Sym *sym = gelf_getsym (symdata, shdr->sh_info, &sym_mem);
-
-  printf ((grpref[0] & GRP_COMDAT)
-	  ? ngettext ("\
-\nCOMDAT section group [%2zu] '%s' with signature '%s' contains %zu entry:\n",
-		      "\
-\nCOMDAT section group [%2zu] '%s' with signature '%s' contains %zu entries:\n",
-		      data->d_size / sizeof (Elf32_Word) - 1)
-	  : ngettext ("\
-\nSection group [%2zu] '%s' with signature '%s' contains %zu entry:\n", "\
-\nSection group [%2zu] '%s' with signature '%s' contains %zu entries:\n",
-		      data->d_size / sizeof (Elf32_Word) - 1),
-	  elf_ndxscn (scn),
-	  elf_strptr (ebl->elf, shstrndx, shdr->sh_name),
-	  (sym == NULL ? NULL
-	   : elf_strptr (ebl->elf, symshdr->sh_link, sym->st_name))
-	  ?: _("<INVALID SYMBOL>"),
-	  data->d_size / sizeof (Elf32_Word) - 1);
-
-  for (size_t cnt = 1; cnt < data->d_size / sizeof (Elf32_Word); ++cnt)
-    {
-      GElf_Shdr grpshdr_mem;
-      GElf_Shdr *grpshdr = gelf_getshdr (elf_getscn (ebl->elf, grpref[cnt]),
-					 &grpshdr_mem);
-
-      const char *str;
-      printf ("  [%2u] %s\n",
-	      grpref[cnt],
-	      grpshdr != NULL
-	      && (str = elf_strptr (ebl->elf, shstrndx, grpshdr->sh_name))
-	      ? str : _("<INVALID SECTION>"));
-    }
-}
-
-
-static void
-print_scngrp (Ebl *ebl)
-{
-  /* Find all relocation sections and handle them.  */
-  Elf_Scn *scn = NULL;
-
-  while ((scn = elf_nextscn (ebl->elf, scn)) != NULL)
-    {
-       /* Handle the section if it is a symbol table.  */
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-
-      if (shdr != NULL && shdr->sh_type == SHT_GROUP)
-	{
-	  if ((shdr->sh_flags & SHF_COMPRESSED) != 0)
-	    {
-	      if (elf_compress (scn, 0, 0) < 0)
-		printf ("WARNING: %s [%zd]\n",
-			_("Couldn't uncompress section"),
-			elf_ndxscn (scn));
-	      shdr = gelf_getshdr (scn, &shdr_mem);
-	      if (unlikely (shdr == NULL))
-		error (EXIT_FAILURE, 0,
-		       _("cannot get section [%zd] header: %s"),
-		       elf_ndxscn (scn),
-		       elf_errmsg (-1));
-	    }
-	  handle_scngrp (ebl, scn, shdr);
-	}
-    }
-}
-
-
-static const struct flags
-{
-  int mask;
-  const char *str;
-} dt_flags[] =
-  {
-    { DF_ORIGIN, "ORIGIN" },
-    { DF_SYMBOLIC, "SYMBOLIC" },
-    { DF_TEXTREL, "TEXTREL" },
-    { DF_BIND_NOW, "BIND_NOW" },
-    { DF_STATIC_TLS, "STATIC_TLS" }
-  };
-static const int ndt_flags = sizeof (dt_flags) / sizeof (dt_flags[0]);
-
-static const struct flags dt_flags_1[] =
-  {
-    { DF_1_NOW, "NOW" },
-    { DF_1_GLOBAL, "GLOBAL" },
-    { DF_1_GROUP, "GROUP" },
-    { DF_1_NODELETE, "NODELETE" },
-    { DF_1_LOADFLTR, "LOADFLTR" },
-    { DF_1_INITFIRST, "INITFIRST" },
-    { DF_1_NOOPEN, "NOOPEN" },
-    { DF_1_ORIGIN, "ORIGIN" },
-    { DF_1_DIRECT, "DIRECT" },
-    { DF_1_TRANS, "TRANS" },
-    { DF_1_INTERPOSE, "INTERPOSE" },
-    { DF_1_NODEFLIB, "NODEFLIB" },
-    { DF_1_NODUMP, "NODUMP" },
-    { DF_1_CONFALT, "CONFALT" },
-    { DF_1_ENDFILTEE, "ENDFILTEE" },
-    { DF_1_DISPRELDNE, "DISPRELDNE" },
-    { DF_1_DISPRELPND, "DISPRELPND" },
-  };
-static const int ndt_flags_1 = sizeof (dt_flags_1) / sizeof (dt_flags_1[0]);
-
-static const struct flags dt_feature_1[] =
-  {
-    { DTF_1_PARINIT, "PARINIT" },
-    { DTF_1_CONFEXP, "CONFEXP" }
-  };
-static const int ndt_feature_1 = (sizeof (dt_feature_1)
-				  / sizeof (dt_feature_1[0]));
-
-static const struct flags dt_posflag_1[] =
-  {
-    { DF_P1_LAZYLOAD, "LAZYLOAD" },
-    { DF_P1_GROUPPERM, "GROUPPERM" }
-  };
-static const int ndt_posflag_1 = (sizeof (dt_posflag_1)
-				  / sizeof (dt_posflag_1[0]));
-
-
-static void
-print_flags (int class, GElf_Xword d_val, const struct flags *flags,
-		int nflags)
-{
-  bool first = true;
-  int cnt;
-
-  for (cnt = 0; cnt < nflags; ++cnt)
-    if (d_val & flags[cnt].mask)
-      {
-	if (!first)
-	  putchar_unlocked (' ');
-	fputs_unlocked (flags[cnt].str, stdout);
-	d_val &= ~flags[cnt].mask;
-	first = false;
-      }
-
-  if (d_val != 0)
-    {
-      if (!first)
-	putchar_unlocked (' ');
-      printf ("%#0*" PRIx64, class == ELFCLASS32 ? 10 : 18, d_val);
-    }
-
-  putchar_unlocked ('\n');
-}
-
-
-static void
-print_dt_flags (int class, GElf_Xword d_val)
-{
-  print_flags (class, d_val, dt_flags, ndt_flags);
-}
-
-
-static void
-print_dt_flags_1 (int class, GElf_Xword d_val)
-{
-  print_flags (class, d_val, dt_flags_1, ndt_flags_1);
-}
-
-
-static void
-print_dt_feature_1 (int class, GElf_Xword d_val)
-{
-  print_flags (class, d_val, dt_feature_1, ndt_feature_1);
-}
-
-
-static void
-print_dt_posflag_1 (int class, GElf_Xword d_val)
-{
-  print_flags (class, d_val, dt_posflag_1, ndt_posflag_1);
-}
-
-
-static void
-handle_dynamic (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr)
-{
-  int class = gelf_getclass (ebl->elf);
-  GElf_Shdr glink_mem;
-  GElf_Shdr *glink;
-  Elf_Data *data;
-  size_t cnt;
-  size_t shstrndx;
-  size_t sh_entsize;
-
-  /* Get the data of the section.  */
-  data = elf_getdata (scn, NULL);
-  if (data == NULL)
-    return;
-
-  /* Get the section header string table index.  */
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  sh_entsize = gelf_fsize (ebl->elf, ELF_T_DYN, 1, EV_CURRENT);
-
-  glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link), &glink_mem);
-  if (glink == NULL)
-    error (EXIT_FAILURE, 0, _("invalid sh_link value in section %zu"),
-	   elf_ndxscn (scn));
-
-  printf (ngettext ("\
-\nDynamic segment contains %lu entry:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
-		    "\
-\nDynamic segment contains %lu entries:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
-		    shdr->sh_size / sh_entsize),
-	  (unsigned long int) (shdr->sh_size / sh_entsize),
-	  class == ELFCLASS32 ? 10 : 18, shdr->sh_addr,
-	  shdr->sh_offset,
-	  (int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
-  fputs_unlocked (_("  Type              Value\n"), stdout);
-
-  for (cnt = 0; cnt < shdr->sh_size / sh_entsize; ++cnt)
-    {
-      GElf_Dyn dynmem;
-      GElf_Dyn *dyn = gelf_getdyn (data, cnt, &dynmem);
-      if (dyn == NULL)
-	break;
-
-      char buf[64];
-      printf ("  %-17s ",
-	      ebl_dynamic_tag_name (ebl, dyn->d_tag, buf, sizeof (buf)));
-
-      switch (dyn->d_tag)
-	{
-	case DT_NULL:
-	case DT_DEBUG:
-	case DT_BIND_NOW:
-	case DT_TEXTREL:
-	  /* No further output.  */
-	  fputc_unlocked ('\n', stdout);
-	  break;
-
-	case DT_NEEDED:
-	  printf (_("Shared library: [%s]\n"),
-		  elf_strptr (ebl->elf, shdr->sh_link, dyn->d_un.d_val));
-	  break;
-
-	case DT_SONAME:
-	  printf (_("Library soname: [%s]\n"),
-		  elf_strptr (ebl->elf, shdr->sh_link, dyn->d_un.d_val));
-	  break;
-
-	case DT_RPATH:
-	  printf (_("Library rpath: [%s]\n"),
-		  elf_strptr (ebl->elf, shdr->sh_link, dyn->d_un.d_val));
-	  break;
-
-	case DT_RUNPATH:
-	  printf (_("Library runpath: [%s]\n"),
-		  elf_strptr (ebl->elf, shdr->sh_link, dyn->d_un.d_val));
-	  break;
-
-	case DT_PLTRELSZ:
-	case DT_RELASZ:
-	case DT_STRSZ:
-	case DT_RELSZ:
-	case DT_RELAENT:
-	case DT_SYMENT:
-	case DT_RELENT:
-	case DT_PLTPADSZ:
-	case DT_MOVEENT:
-	case DT_MOVESZ:
-	case DT_INIT_ARRAYSZ:
-	case DT_FINI_ARRAYSZ:
-	case DT_SYMINSZ:
-	case DT_SYMINENT:
-	case DT_GNU_CONFLICTSZ:
-	case DT_GNU_LIBLISTSZ:
-	  printf (_("%" PRId64 " (bytes)\n"), dyn->d_un.d_val);
-	  break;
-
-	case DT_VERDEFNUM:
-	case DT_VERNEEDNUM:
-	case DT_RELACOUNT:
-	case DT_RELCOUNT:
-	  printf ("%" PRId64 "\n", dyn->d_un.d_val);
-	  break;
-
-	case DT_PLTREL:;
-	  const char *tagname = ebl_dynamic_tag_name (ebl, dyn->d_un.d_val,
-						      NULL, 0);
-	  puts (tagname ?: "???");
-	  break;
-
-	case DT_FLAGS:
-	  print_dt_flags (class, dyn->d_un.d_val);
-	  break;
-
-	case DT_FLAGS_1:
-	  print_dt_flags_1 (class, dyn->d_un.d_val);
-	  break;
-
-	case DT_FEATURE_1:
-	  print_dt_feature_1 (class, dyn->d_un.d_val);
-	  break;
-
-	case DT_POSFLAG_1:
-	  print_dt_posflag_1 (class, dyn->d_un.d_val);
-	  break;
-
-	default:
-	  printf ("%#0*" PRIx64 "\n",
-		  class == ELFCLASS32 ? 10 : 18, dyn->d_un.d_val);
-	  break;
-	}
-    }
-}
-
-
-/* Print the dynamic segment.  */
-static void
-print_dynamic (Ebl *ebl)
-{
-  for (size_t i = 0; i < phnum; ++i)
-    {
-      GElf_Phdr phdr_mem;
-      GElf_Phdr *phdr = gelf_getphdr (ebl->elf, i, &phdr_mem);
-
-      if (phdr != NULL && phdr->p_type == PT_DYNAMIC)
-	{
-	  Elf_Scn *scn = gelf_offscn (ebl->elf, phdr->p_offset);
-	  GElf_Shdr shdr_mem;
-	  GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-	  if (shdr != NULL && shdr->sh_type == SHT_DYNAMIC)
-	    handle_dynamic (ebl, scn, shdr);
-	  break;
-	}
-    }
-}
-
-
-/* Print relocations.  */
-static void
-print_relocs (Ebl *ebl, GElf_Ehdr *ehdr)
-{
-  /* Find all relocation sections and handle them.  */
-  Elf_Scn *scn = NULL;
-
-  while ((scn = elf_nextscn (ebl->elf, scn)) != NULL)
-    {
-       /* Handle the section if it is a symbol table.  */
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-
-      if (likely (shdr != NULL))
-	{
-	  if (shdr->sh_type == SHT_REL)
-	    handle_relocs_rel (ebl, ehdr, scn, shdr);
-	  else if (shdr->sh_type == SHT_RELA)
-	    handle_relocs_rela (ebl, ehdr, scn, shdr);
-	}
-    }
-}
-
-
-/* Handle a relocation section.  */
-static void
-handle_relocs_rel (Ebl *ebl, GElf_Ehdr *ehdr, Elf_Scn *scn, GElf_Shdr *shdr)
-{
-  int class = gelf_getclass (ebl->elf);
-  size_t sh_entsize = gelf_fsize (ebl->elf, ELF_T_REL, 1, EV_CURRENT);
-  int nentries = shdr->sh_size / sh_entsize;
-
-  /* Get the data of the section.  */
-  Elf_Data *data = elf_getdata (scn, NULL);
-  if (data == NULL)
-    return;
-
-  /* Get the symbol table information.  */
-  Elf_Scn *symscn = elf_getscn (ebl->elf, shdr->sh_link);
-  GElf_Shdr symshdr_mem;
-  GElf_Shdr *symshdr = gelf_getshdr (symscn, &symshdr_mem);
-  Elf_Data *symdata = elf_getdata (symscn, NULL);
-
-  /* Get the section header of the section the relocations are for.  */
-  GElf_Shdr destshdr_mem;
-  GElf_Shdr *destshdr = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_info),
-				      &destshdr_mem);
-
-  if (unlikely (symshdr == NULL || symdata == NULL || destshdr == NULL))
-    {
-      printf (_("\nInvalid symbol table at offset %#0" PRIx64 "\n"),
-	      shdr->sh_offset);
-      return;
-    }
-
-  /* Search for the optional extended section index table.  */
-  Elf_Data *xndxdata = NULL;
-  int xndxscnidx = elf_scnshndx (scn);
-  if (unlikely (xndxscnidx > 0))
-    xndxdata = elf_getdata (elf_getscn (ebl->elf, xndxscnidx), NULL);
-
-  /* Get the section header string table index.  */
-  size_t shstrndx;
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  if (shdr->sh_info != 0)
-    printf (ngettext ("\
-\nRelocation section [%2zu] '%s' for section [%2u] '%s' at offset %#0" PRIx64 " contains %d entry:\n",
-		    "\
-\nRelocation section [%2zu] '%s' for section [%2u] '%s' at offset %#0" PRIx64 " contains %d entries:\n",
-		      nentries),
-	    elf_ndxscn (scn),
-	    elf_strptr (ebl->elf, shstrndx, shdr->sh_name),
-	    (unsigned int) shdr->sh_info,
-	    elf_strptr (ebl->elf, shstrndx, destshdr->sh_name),
-	    shdr->sh_offset,
-	    nentries);
-  else
-    /* The .rel.dyn section does not refer to a specific section but
-       instead of section index zero.  Do not try to print a section
-       name.  */
-    printf (ngettext ("\
-\nRelocation section [%2u] '%s' at offset %#0" PRIx64 " contains %d entry:\n",
-		    "\
-\nRelocation section [%2u] '%s' at offset %#0" PRIx64 " contains %d entries:\n",
-		      nentries),
-	    (unsigned int) elf_ndxscn (scn),
-	    elf_strptr (ebl->elf, shstrndx, shdr->sh_name),
-	    shdr->sh_offset,
-	    nentries);
-  fputs_unlocked (class == ELFCLASS32
-		  ? _("\
-  Offset      Type                 Value       Name\n")
-		  : _("\
-  Offset              Type                 Value               Name\n"),
-	 stdout);
-
-  int is_statically_linked = 0;
-  for (int cnt = 0; cnt < nentries; ++cnt)
-    {
-      GElf_Rel relmem;
-      GElf_Rel *rel = gelf_getrel (data, cnt, &relmem);
-      if (likely (rel != NULL))
-	{
-	  char buf[128];
-	  GElf_Sym symmem;
-	  Elf32_Word xndx;
-	  GElf_Sym *sym = gelf_getsymshndx (symdata, xndxdata,
-					    GELF_R_SYM (rel->r_info),
-					    &symmem, &xndx);
-	  if (unlikely (sym == NULL))
-	    {
-	      /* As a special case we have to handle relocations in static
-		 executables.  This only happens for IRELATIVE relocations
-		 (so far).  There is no symbol table.  */
-	      if (is_statically_linked == 0)
-		{
-		  /* Find the program header and look for a PT_INTERP entry. */
-		  is_statically_linked = -1;
-		  if (ehdr->e_type == ET_EXEC)
-		    {
-		      is_statically_linked = 1;
-
-		      for (size_t inner = 0; inner < phnum; ++inner)
-			{
-			  GElf_Phdr phdr_mem;
-			  GElf_Phdr *phdr = gelf_getphdr (ebl->elf, inner,
-							  &phdr_mem);
-			  if (phdr != NULL && phdr->p_type == PT_INTERP)
-			    {
-			      is_statically_linked = -1;
-			      break;
-			    }
-			}
-		    }
-		}
-
-	      if (is_statically_linked > 0 && shdr->sh_link == 0)
-		printf ("\
-  %#0*" PRIx64 "  %-20s %*s  %s\n",
-			class == ELFCLASS32 ? 10 : 18, rel->r_offset,
-			ebl_reloc_type_check (ebl, GELF_R_TYPE (rel->r_info))
-			/* Avoid the leading R_ which isn't carrying any
-			   information.  */
-			? ebl_reloc_type_name (ebl, GELF_R_TYPE (rel->r_info),
-					       buf, sizeof (buf)) + 2
-			: _("<INVALID RELOC>"),
-			class == ELFCLASS32 ? 10 : 18, "",
-			elf_strptr (ebl->elf, shstrndx, destshdr->sh_name));
-	      else
-		printf ("  %#0*" PRIx64 "  %-20s <%s %ld>\n",
-			class == ELFCLASS32 ? 10 : 18, rel->r_offset,
-			ebl_reloc_type_check (ebl, GELF_R_TYPE (rel->r_info))
-			/* Avoid the leading R_ which isn't carrying any
-			   information.  */
-			? ebl_reloc_type_name (ebl, GELF_R_TYPE (rel->r_info),
-					       buf, sizeof (buf)) + 2
-			: _("<INVALID RELOC>"),
-			_("INVALID SYMBOL"),
-			(long int) GELF_R_SYM (rel->r_info));
-	    }
-	  else if (GELF_ST_TYPE (sym->st_info) != STT_SECTION)
-	    printf ("  %#0*" PRIx64 "  %-20s %#0*" PRIx64 "  %s\n",
-		    class == ELFCLASS32 ? 10 : 18, rel->r_offset,
-		    likely (ebl_reloc_type_check (ebl,
-						  GELF_R_TYPE (rel->r_info)))
-		    /* Avoid the leading R_ which isn't carrying any
-		       information.  */
-		    ? ebl_reloc_type_name (ebl, GELF_R_TYPE (rel->r_info),
-					   buf, sizeof (buf)) + 2
-		    : _("<INVALID RELOC>"),
-		    class == ELFCLASS32 ? 10 : 18, sym->st_value,
-		    elf_strptr (ebl->elf, symshdr->sh_link, sym->st_name));
-	  else
-	    {
-	      /* This is a relocation against a STT_SECTION symbol.  */
-	      GElf_Shdr secshdr_mem;
-	      GElf_Shdr *secshdr;
-	      secshdr = gelf_getshdr (elf_getscn (ebl->elf,
-						  sym->st_shndx == SHN_XINDEX
-						  ? xndx : sym->st_shndx),
-				      &secshdr_mem);
-
-	      if (unlikely (secshdr == NULL))
-		printf ("  %#0*" PRIx64 "  %-20s <%s %ld>\n",
-			class == ELFCLASS32 ? 10 : 18, rel->r_offset,
-			ebl_reloc_type_check (ebl, GELF_R_TYPE (rel->r_info))
-			/* Avoid the leading R_ which isn't carrying any
-			   information.  */
-			? ebl_reloc_type_name (ebl, GELF_R_TYPE (rel->r_info),
-					       buf, sizeof (buf)) + 2
-			: _("<INVALID RELOC>"),
-			_("INVALID SECTION"),
-			(long int) (sym->st_shndx == SHN_XINDEX
-				    ? xndx : sym->st_shndx));
-	      else
-		printf ("  %#0*" PRIx64 "  %-20s %#0*" PRIx64 "  %s\n",
-			class == ELFCLASS32 ? 10 : 18, rel->r_offset,
-			ebl_reloc_type_check (ebl, GELF_R_TYPE (rel->r_info))
-			/* Avoid the leading R_ which isn't carrying any
-			   information.  */
-			? ebl_reloc_type_name (ebl, GELF_R_TYPE (rel->r_info),
-					       buf, sizeof (buf)) + 2
-			: _("<INVALID RELOC>"),
-			class == ELFCLASS32 ? 10 : 18, sym->st_value,
-			elf_strptr (ebl->elf, shstrndx, secshdr->sh_name));
-	    }
-	}
-    }
-}
-
-
-/* Handle a relocation section.  */
-static void
-handle_relocs_rela (Ebl *ebl, GElf_Ehdr *ehdr, Elf_Scn *scn, GElf_Shdr *shdr)
-{
-  int class = gelf_getclass (ebl->elf);
-  size_t sh_entsize = gelf_fsize (ebl->elf, ELF_T_RELA, 1, EV_CURRENT);
-  int nentries = shdr->sh_size / sh_entsize;
-
-  /* Get the data of the section.  */
-  Elf_Data *data = elf_getdata (scn, NULL);
-  if (data == NULL)
-    return;
-
-  /* Get the symbol table information.  */
-  Elf_Scn *symscn = elf_getscn (ebl->elf, shdr->sh_link);
-  GElf_Shdr symshdr_mem;
-  GElf_Shdr *symshdr = gelf_getshdr (symscn, &symshdr_mem);
-  Elf_Data *symdata = elf_getdata (symscn, NULL);
-
-  /* Get the section header of the section the relocations are for.  */
-  GElf_Shdr destshdr_mem;
-  GElf_Shdr *destshdr = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_info),
-				      &destshdr_mem);
-
-  if (unlikely (symshdr == NULL || symdata == NULL || destshdr == NULL))
-    {
-      printf (_("\nInvalid symbol table at offset %#0" PRIx64 "\n"),
-	      shdr->sh_offset);
-      return;
-    }
-
-  /* Search for the optional extended section index table.  */
-  Elf_Data *xndxdata = NULL;
-  int xndxscnidx = elf_scnshndx (scn);
-  if (unlikely (xndxscnidx > 0))
-    xndxdata = elf_getdata (elf_getscn (ebl->elf, xndxscnidx), NULL);
-
-  /* Get the section header string table index.  */
-  size_t shstrndx;
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  if (shdr->sh_info != 0)
-    printf (ngettext ("\
-\nRelocation section [%2zu] '%s' for section [%2u] '%s' at offset %#0" PRIx64 " contains %d entry:\n",
-		    "\
-\nRelocation section [%2zu] '%s' for section [%2u] '%s' at offset %#0" PRIx64 " contains %d entries:\n",
-		    nentries),
-	  elf_ndxscn (scn),
-	  elf_strptr (ebl->elf, shstrndx, shdr->sh_name),
-	  (unsigned int) shdr->sh_info,
-	  elf_strptr (ebl->elf, shstrndx, destshdr->sh_name),
-	  shdr->sh_offset,
-	  nentries);
-  else
-    /* The .rela.dyn section does not refer to a specific section but
-       instead of section index zero.  Do not try to print a section
-       name.  */
-    printf (ngettext ("\
-\nRelocation section [%2u] '%s' at offset %#0" PRIx64 " contains %d entry:\n",
-		    "\
-\nRelocation section [%2u] '%s' at offset %#0" PRIx64 " contains %d entries:\n",
-		      nentries),
-	    (unsigned int) elf_ndxscn (scn),
-	    elf_strptr (ebl->elf, shstrndx, shdr->sh_name),
-	    shdr->sh_offset,
-	    nentries);
-  fputs_unlocked (class == ELFCLASS32
-		  ? _("\
-  Offset      Type            Value       Addend Name\n")
-		  : _("\
-  Offset              Type            Value               Addend Name\n"),
-		  stdout);
-
-  int is_statically_linked = 0;
-  for (int cnt = 0; cnt < nentries; ++cnt)
-    {
-      GElf_Rela relmem;
-      GElf_Rela *rel = gelf_getrela (data, cnt, &relmem);
-      if (likely (rel != NULL))
-	{
-	  char buf[64];
-	  GElf_Sym symmem;
-	  Elf32_Word xndx;
-	  GElf_Sym *sym = gelf_getsymshndx (symdata, xndxdata,
-					    GELF_R_SYM (rel->r_info),
-					    &symmem, &xndx);
-
-	  if (unlikely (sym == NULL))
-	    {
-	      /* As a special case we have to handle relocations in static
-		 executables.  This only happens for IRELATIVE relocations
-		 (so far).  There is no symbol table.  */
-	      if (is_statically_linked == 0)
-		{
-		  /* Find the program header and look for a PT_INTERP entry. */
-		  is_statically_linked = -1;
-		  if (ehdr->e_type == ET_EXEC)
-		    {
-		      is_statically_linked = 1;
-
-		      for (size_t inner = 0; inner < phnum; ++inner)
-			{
-			  GElf_Phdr phdr_mem;
-			  GElf_Phdr *phdr = gelf_getphdr (ebl->elf, inner,
-							  &phdr_mem);
-			  if (phdr != NULL && phdr->p_type == PT_INTERP)
-			    {
-			      is_statically_linked = -1;
-			      break;
-			    }
-			}
-		    }
-		}
-
-	      if (is_statically_linked > 0 && shdr->sh_link == 0)
-		printf ("\
-  %#0*" PRIx64 "  %-15s %*s  %#6" PRIx64 " %s\n",
-			class == ELFCLASS32 ? 10 : 18, rel->r_offset,
-			ebl_reloc_type_check (ebl, GELF_R_TYPE (rel->r_info))
-			/* Avoid the leading R_ which isn't carrying any
-			   information.  */
-			? ebl_reloc_type_name (ebl, GELF_R_TYPE (rel->r_info),
-					       buf, sizeof (buf)) + 2
-			: _("<INVALID RELOC>"),
-			class == ELFCLASS32 ? 10 : 18, "",
-			rel->r_addend,
-			elf_strptr (ebl->elf, shstrndx, destshdr->sh_name));
-	      else
-		printf ("  %#0*" PRIx64 "  %-15s <%s %ld>\n",
-			class == ELFCLASS32 ? 10 : 18, rel->r_offset,
-			ebl_reloc_type_check (ebl, GELF_R_TYPE (rel->r_info))
-			/* Avoid the leading R_ which isn't carrying any
-			   information.  */
-			? ebl_reloc_type_name (ebl, GELF_R_TYPE (rel->r_info),
-					       buf, sizeof (buf)) + 2
-			: _("<INVALID RELOC>"),
-			_("INVALID SYMBOL"),
-			(long int) GELF_R_SYM (rel->r_info));
-	    }
-	  else if (GELF_ST_TYPE (sym->st_info) != STT_SECTION)
-	    printf ("\
-  %#0*" PRIx64 "  %-15s %#0*" PRIx64 "  %+6" PRId64 " %s\n",
-		    class == ELFCLASS32 ? 10 : 18, rel->r_offset,
-		    likely (ebl_reloc_type_check (ebl,
-						  GELF_R_TYPE (rel->r_info)))
-		    /* Avoid the leading R_ which isn't carrying any
-		       information.  */
-		    ? ebl_reloc_type_name (ebl, GELF_R_TYPE (rel->r_info),
-					   buf, sizeof (buf)) + 2
-		    : _("<INVALID RELOC>"),
-		    class == ELFCLASS32 ? 10 : 18, sym->st_value,
-		    rel->r_addend,
-		    elf_strptr (ebl->elf, symshdr->sh_link, sym->st_name));
-	  else
-	    {
-	      /* This is a relocation against a STT_SECTION symbol.  */
-	      GElf_Shdr secshdr_mem;
-	      GElf_Shdr *secshdr;
-	      secshdr = gelf_getshdr (elf_getscn (ebl->elf,
-						  sym->st_shndx == SHN_XINDEX
-						  ? xndx : sym->st_shndx),
-				      &secshdr_mem);
-
-	      if (unlikely (secshdr == NULL))
-		printf ("  %#0*" PRIx64 "  %-15s <%s %ld>\n",
-			class == ELFCLASS32 ? 10 : 18, rel->r_offset,
-			ebl_reloc_type_check (ebl, GELF_R_TYPE (rel->r_info))
-			/* Avoid the leading R_ which isn't carrying any
-			   information.  */
-			? ebl_reloc_type_name (ebl, GELF_R_TYPE (rel->r_info),
-					       buf, sizeof (buf)) + 2
-			: _("<INVALID RELOC>"),
-			_("INVALID SECTION"),
-			(long int) (sym->st_shndx == SHN_XINDEX
-				    ? xndx : sym->st_shndx));
-	      else
-		printf ("\
-  %#0*" PRIx64 "  %-15s %#0*" PRIx64 "  %+6" PRId64 " %s\n",
-			class == ELFCLASS32 ? 10 : 18, rel->r_offset,
-			ebl_reloc_type_check (ebl, GELF_R_TYPE (rel->r_info))
-			/* Avoid the leading R_ which isn't carrying any
-			   information.  */
-			? ebl_reloc_type_name (ebl, GELF_R_TYPE (rel->r_info),
-					       buf, sizeof (buf)) + 2
-			: _("<INVALID RELOC>"),
-			class == ELFCLASS32 ? 10 : 18, sym->st_value,
-			rel->r_addend,
-			elf_strptr (ebl->elf, shstrndx, secshdr->sh_name));
-	    }
-	}
-    }
-}
-
-
-/* Print the program header.  */
-static void
-print_symtab (Ebl *ebl, int type)
-{
-  /* Find the symbol table(s).  For this we have to search through the
-     section table.  */
-  Elf_Scn *scn = NULL;
-
-  while ((scn = elf_nextscn (ebl->elf, scn)) != NULL)
-    {
-      /* Handle the section if it is a symbol table.  */
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-
-      if (shdr != NULL && shdr->sh_type == (GElf_Word) type)
-	{
-	  if (symbol_table_section != NULL)
-	    {
-	      /* Get the section header string table index.  */
-	      size_t shstrndx;
-	      const char *sname;
-	      if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-		error (EXIT_FAILURE, 0,
-		       _("cannot get section header string table index"));
-	      sname = elf_strptr (ebl->elf, shstrndx, shdr->sh_name);
-	      if (sname == NULL || strcmp (sname, symbol_table_section) != 0)
-		continue;
-	    }
-
-	  if ((shdr->sh_flags & SHF_COMPRESSED) != 0)
-	    {
-	      if (elf_compress (scn, 0, 0) < 0)
-		printf ("WARNING: %s [%zd]\n",
-			_("Couldn't uncompress section"),
-			elf_ndxscn (scn));
-	      shdr = gelf_getshdr (scn, &shdr_mem);
-	      if (unlikely (shdr == NULL))
-		error (EXIT_FAILURE, 0,
-		       _("cannot get section [%zd] header: %s"),
-		       elf_ndxscn (scn), elf_errmsg (-1));
-	    }
-	  handle_symtab (ebl, scn, shdr);
-	}
-    }
-}
-
-
-static void
-handle_symtab (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr)
-{
-  Elf_Data *versym_data = NULL;
-  Elf_Data *verneed_data = NULL;
-  Elf_Data *verdef_data = NULL;
-  Elf_Data *xndx_data = NULL;
-  int class = gelf_getclass (ebl->elf);
-  Elf32_Word verneed_stridx = 0;
-  Elf32_Word verdef_stridx = 0;
-
-  /* Get the data of the section.  */
-  Elf_Data *data = elf_getdata (scn, NULL);
-  if (data == NULL)
-    return;
-
-  /* Find out whether we have other sections we might need.  */
-  Elf_Scn *runscn = NULL;
-  while ((runscn = elf_nextscn (ebl->elf, runscn)) != NULL)
-    {
-      GElf_Shdr runshdr_mem;
-      GElf_Shdr *runshdr = gelf_getshdr (runscn, &runshdr_mem);
-
-      if (likely (runshdr != NULL))
-	{
-	  if (runshdr->sh_type == SHT_GNU_versym
-	      && runshdr->sh_link == elf_ndxscn (scn))
-	    /* Bingo, found the version information.  Now get the data.  */
-	    versym_data = elf_getdata (runscn, NULL);
-	  else if (runshdr->sh_type == SHT_GNU_verneed)
-	    {
-	      /* This is the information about the needed versions.  */
-	      verneed_data = elf_getdata (runscn, NULL);
-	      verneed_stridx = runshdr->sh_link;
-	    }
-	  else if (runshdr->sh_type == SHT_GNU_verdef)
-	    {
-	      /* This is the information about the defined versions.  */
-	      verdef_data = elf_getdata (runscn, NULL);
-	      verdef_stridx = runshdr->sh_link;
-	    }
-	  else if (runshdr->sh_type == SHT_SYMTAB_SHNDX
-	      && runshdr->sh_link == elf_ndxscn (scn))
-	    /* Extended section index.  */
-	    xndx_data = elf_getdata (runscn, NULL);
-	}
-    }
-
-  /* Get the section header string table index.  */
-  size_t shstrndx;
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  GElf_Shdr glink_mem;
-  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				   &glink_mem);
-  if (glink == NULL)
-    error (EXIT_FAILURE, 0, _("invalid sh_link value in section %zu"),
-	   elf_ndxscn (scn));
-
-  /* Now we can compute the number of entries in the section.  */
-  unsigned int nsyms = data->d_size / (class == ELFCLASS32
-				       ? sizeof (Elf32_Sym)
-				       : sizeof (Elf64_Sym));
-
-  printf (ngettext ("\nSymbol table [%2u] '%s' contains %u entry:\n",
-		    "\nSymbol table [%2u] '%s' contains %u entries:\n",
-		    nsyms),
-	  (unsigned int) elf_ndxscn (scn),
-	  elf_strptr (ebl->elf, shstrndx, shdr->sh_name), nsyms);
-  printf (ngettext (" %lu local symbol  String table: [%2u] '%s'\n",
-		    " %lu local symbols  String table: [%2u] '%s'\n",
-		    shdr->sh_info),
-	  (unsigned long int) shdr->sh_info,
-	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
-
-  fputs_unlocked (class == ELFCLASS32
-		  ? _("\
-  Num:    Value   Size Type    Bind   Vis          Ndx Name\n")
-		  : _("\
-  Num:            Value   Size Type    Bind   Vis          Ndx Name\n"),
-		  stdout);
-
-  for (unsigned int cnt = 0; cnt < nsyms; ++cnt)
-    {
-      char typebuf[64];
-      char bindbuf[64];
-      char scnbuf[64];
-      Elf32_Word xndx;
-      GElf_Sym sym_mem;
-      GElf_Sym *sym = gelf_getsymshndx (data, xndx_data, cnt, &sym_mem, &xndx);
-
-      if (unlikely (sym == NULL))
-	continue;
-
-      /* Determine the real section index.  */
-      if (likely (sym->st_shndx != SHN_XINDEX))
-	xndx = sym->st_shndx;
-
-      printf (_("\
-%5u: %0*" PRIx64 " %6" PRId64 " %-7s %-6s %-9s %6s %s"),
-	      cnt,
-	      class == ELFCLASS32 ? 8 : 16,
-	      sym->st_value,
-	      sym->st_size,
-	      ebl_symbol_type_name (ebl, GELF_ST_TYPE (sym->st_info),
-				    typebuf, sizeof (typebuf)),
-	      ebl_symbol_binding_name (ebl, GELF_ST_BIND (sym->st_info),
-				       bindbuf, sizeof (bindbuf)),
-	      get_visibility_type (GELF_ST_VISIBILITY (sym->st_other)),
-	      ebl_section_name (ebl, sym->st_shndx, xndx, scnbuf,
-				sizeof (scnbuf), NULL, shnum),
-	      elf_strptr (ebl->elf, shdr->sh_link, sym->st_name));
-
-      if (versym_data != NULL)
-	{
-	  /* Get the version information.  */
-	  GElf_Versym versym_mem;
-	  GElf_Versym *versym = gelf_getversym (versym_data, cnt, &versym_mem);
-
-	  if (versym != NULL && ((*versym & 0x8000) != 0 || *versym > 1))
-	    {
-	      bool is_nobits = false;
-	      bool check_def = xndx != SHN_UNDEF;
-
-	      if (xndx < SHN_LORESERVE || sym->st_shndx == SHN_XINDEX)
-		{
-		  GElf_Shdr symshdr_mem;
-		  GElf_Shdr *symshdr =
-		    gelf_getshdr (elf_getscn (ebl->elf, xndx), &symshdr_mem);
-
-		  is_nobits = (symshdr != NULL
-			       && symshdr->sh_type == SHT_NOBITS);
-		}
-
-	      if (is_nobits || ! check_def)
-		{
-		  /* We must test both.  */
-		  GElf_Vernaux vernaux_mem;
-		  GElf_Vernaux *vernaux = NULL;
-		  size_t vn_offset = 0;
-
-		  GElf_Verneed verneed_mem;
-		  GElf_Verneed *verneed = gelf_getverneed (verneed_data, 0,
-							   &verneed_mem);
-		  while (verneed != NULL)
-		    {
-		      size_t vna_offset = vn_offset;
-
-		      vernaux = gelf_getvernaux (verneed_data,
-						 vna_offset += verneed->vn_aux,
-						 &vernaux_mem);
-		      while (vernaux != NULL
-			     && vernaux->vna_other != *versym
-			     && vernaux->vna_next != 0
-			     && (verneed_data->d_size - vna_offset
-				 >= vernaux->vna_next))
-			{
-			  /* Update the offset.  */
-			  vna_offset += vernaux->vna_next;
-
-			  vernaux = (vernaux->vna_next == 0
-				     ? NULL
-				     : gelf_getvernaux (verneed_data,
-							vna_offset,
-							&vernaux_mem));
-			}
-
-		      /* Check whether we found the version.  */
-		      if (vernaux != NULL && vernaux->vna_other == *versym)
-			/* Found it.  */
-			break;
-
-		      if (verneed_data->d_size - vn_offset < verneed->vn_next)
-			break;
-
-		      vn_offset += verneed->vn_next;
-		      verneed = (verneed->vn_next == 0
-				 ? NULL
-				 : gelf_getverneed (verneed_data, vn_offset,
-						    &verneed_mem));
-		    }
-
-		  if (vernaux != NULL && vernaux->vna_other == *versym)
-		    {
-		      printf ("@%s (%u)",
-			      elf_strptr (ebl->elf, verneed_stridx,
-					  vernaux->vna_name),
-			      (unsigned int) vernaux->vna_other);
-		      check_def = 0;
-		    }
-		  else if (unlikely (! is_nobits))
-		    error (0, 0, _("bad dynamic symbol"));
-		  else
-		    check_def = 1;
-		}
-
-	      if (check_def && *versym != 0x8001)
-		{
-		  /* We must test both.  */
-		  size_t vd_offset = 0;
-
-		  GElf_Verdef verdef_mem;
-		  GElf_Verdef *verdef = gelf_getverdef (verdef_data, 0,
-							&verdef_mem);
-		  while (verdef != NULL)
-		    {
-		      if (verdef->vd_ndx == (*versym & 0x7fff))
-			/* Found the definition.  */
-			break;
-
-		      if (verdef_data->d_size - vd_offset < verdef->vd_next)
-			break;
-
-		      vd_offset += verdef->vd_next;
-		      verdef = (verdef->vd_next == 0
-				? NULL
-				: gelf_getverdef (verdef_data, vd_offset,
-						  &verdef_mem));
-		    }
-
-		  if (verdef != NULL)
-		    {
-		      GElf_Verdaux verdaux_mem;
-		      GElf_Verdaux *verdaux
-			= gelf_getverdaux (verdef_data,
-					   vd_offset + verdef->vd_aux,
-					   &verdaux_mem);
-
-		      if (verdaux != NULL)
-			printf ((*versym & 0x8000) ? "@%s" : "@@%s",
-				elf_strptr (ebl->elf, verdef_stridx,
-					    verdaux->vda_name));
-		    }
-		}
-	    }
-	}
-
-      putchar_unlocked ('\n');
-    }
-}
-
-
-/* Print version information.  */
-static void
-print_verinfo (Ebl *ebl)
-{
-  /* Find the version information sections.  For this we have to
-     search through the section table.  */
-  Elf_Scn *scn = NULL;
-
-  while ((scn = elf_nextscn (ebl->elf, scn)) != NULL)
-    {
-      /* Handle the section if it is part of the versioning handling.  */
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-
-      if (likely (shdr != NULL))
-	{
-	  if (shdr->sh_type == SHT_GNU_verneed)
-	    handle_verneed (ebl, scn, shdr);
-	  else if (shdr->sh_type == SHT_GNU_verdef)
-	    handle_verdef (ebl, scn, shdr);
-	  else if (shdr->sh_type == SHT_GNU_versym)
-	    handle_versym (ebl, scn, shdr);
-	}
-    }
-}
-
-
-static const char *
-get_ver_flags (unsigned int flags)
-{
-  static char buf[32];
-  char *endp;
-
-  if (flags == 0)
-    return _("none");
-
-  if (flags & VER_FLG_BASE)
-    endp = stpcpy (buf, "BASE ");
-  else
-    endp = buf;
-
-  if (flags & VER_FLG_WEAK)
-    {
-      if (endp != buf)
-	endp = stpcpy (endp, "| ");
-
-      endp = stpcpy (endp, "WEAK ");
-    }
-
-  if (unlikely (flags & ~(VER_FLG_BASE | VER_FLG_WEAK)))
-    {
-      strncpy (endp, _("| <unknown>"), buf + sizeof (buf) - endp);
-      buf[sizeof (buf) - 1] = '\0';
-    }
-
-  return buf;
-}
-
-
-static void
-handle_verneed (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr)
-{
-  int class = gelf_getclass (ebl->elf);
-
-  /* Get the data of the section.  */
-  Elf_Data *data = elf_getdata (scn, NULL);
-  if (data == NULL)
-    return;
-
-  /* Get the section header string table index.  */
-  size_t shstrndx;
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  GElf_Shdr glink_mem;
-  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				   &glink_mem);
-  if (glink == NULL)
-    error (EXIT_FAILURE, 0, _("invalid sh_link value in section %zu"),
-	   elf_ndxscn (scn));
-
-  printf (ngettext ("\
-\nVersion needs section [%2u] '%s' contains %d entry:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
-		    "\
-\nVersion needs section [%2u] '%s' contains %d entries:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
-		    shdr->sh_info),
-	  (unsigned int) elf_ndxscn (scn),
-	  elf_strptr (ebl->elf, shstrndx, shdr->sh_name), shdr->sh_info,
-	  class == ELFCLASS32 ? 10 : 18, shdr->sh_addr,
-	  shdr->sh_offset,
-	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
-
-  unsigned int offset = 0;
-  for (int cnt = shdr->sh_info; --cnt >= 0; )
-    {
-      /* Get the data at the next offset.  */
-      GElf_Verneed needmem;
-      GElf_Verneed *need = gelf_getverneed (data, offset, &needmem);
-      if (unlikely (need == NULL))
-	break;
-
-      printf (_("  %#06x: Version: %hu  File: %s  Cnt: %hu\n"),
-	      offset, (unsigned short int) need->vn_version,
-	      elf_strptr (ebl->elf, shdr->sh_link, need->vn_file),
-	      (unsigned short int) need->vn_cnt);
-
-      unsigned int auxoffset = offset + need->vn_aux;
-      for (int cnt2 = need->vn_cnt; --cnt2 >= 0; )
-	{
-	  GElf_Vernaux auxmem;
-	  GElf_Vernaux *aux = gelf_getvernaux (data, auxoffset, &auxmem);
-	  if (unlikely (aux == NULL))
-	    break;
-
-	  printf (_("  %#06x: Name: %s  Flags: %s  Version: %hu\n"),
-		  auxoffset,
-		  elf_strptr (ebl->elf, shdr->sh_link, aux->vna_name),
-		  get_ver_flags (aux->vna_flags),
-		  (unsigned short int) aux->vna_other);
-
-	  if (aux->vna_next == 0)
-	    break;
-
-	  auxoffset += aux->vna_next;
-	}
-
-      /* Find the next offset.  */
-      if (need->vn_next == 0)
-	break;
-
-      offset += need->vn_next;
-    }
-}
-
-
-static void
-handle_verdef (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr)
-{
-  /* Get the data of the section.  */
-  Elf_Data *data = elf_getdata (scn, NULL);
-  if (data == NULL)
-    return;
-
-  /* Get the section header string table index.  */
-  size_t shstrndx;
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  GElf_Shdr glink_mem;
-  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				   &glink_mem);
-  if (glink == NULL)
-    error (EXIT_FAILURE, 0, _("invalid sh_link value in section %zu"),
-	   elf_ndxscn (scn));
-
-  int class = gelf_getclass (ebl->elf);
-  printf (ngettext ("\
-\nVersion definition section [%2u] '%s' contains %d entry:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
-		    "\
-\nVersion definition section [%2u] '%s' contains %d entries:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
-		    shdr->sh_info),
-	  (unsigned int) elf_ndxscn (scn),
-	  elf_strptr (ebl->elf, shstrndx, shdr->sh_name),
-	  shdr->sh_info,
-	  class == ELFCLASS32 ? 10 : 18, shdr->sh_addr,
-	  shdr->sh_offset,
-	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
-
-  unsigned int offset = 0;
-  for (int cnt = shdr->sh_info; --cnt >= 0; )
-    {
-      /* Get the data at the next offset.  */
-      GElf_Verdef defmem;
-      GElf_Verdef *def = gelf_getverdef (data, offset, &defmem);
-      if (unlikely (def == NULL))
-	break;
-
-      unsigned int auxoffset = offset + def->vd_aux;
-      GElf_Verdaux auxmem;
-      GElf_Verdaux *aux = gelf_getverdaux (data, auxoffset, &auxmem);
-      if (unlikely (aux == NULL))
-	break;
-
-      printf (_("\
-  %#06x: Version: %hd  Flags: %s  Index: %hd  Cnt: %hd  Name: %s\n"),
-	      offset, def->vd_version,
-	      get_ver_flags (def->vd_flags),
-	      def->vd_ndx,
-	      def->vd_cnt,
-	      elf_strptr (ebl->elf, shdr->sh_link, aux->vda_name));
-
-      auxoffset += aux->vda_next;
-      for (int cnt2 = 1; cnt2 < def->vd_cnt; ++cnt2)
-	{
-	  aux = gelf_getverdaux (data, auxoffset, &auxmem);
-	  if (unlikely (aux == NULL))
-	    break;
-
-	  printf (_("  %#06x: Parent %d: %s\n"),
-		  auxoffset, cnt2,
-		  elf_strptr (ebl->elf, shdr->sh_link, aux->vda_name));
-
-	  if (aux->vda_next == 0)
-	    break;
-
-	  auxoffset += aux->vda_next;
-	}
-
-      /* Find the next offset.  */
-      if (def->vd_next == 0)
-	break;
-      offset += def->vd_next;
-    }
-}
-
-
-static void
-handle_versym (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr)
-{
-  int class = gelf_getclass (ebl->elf);
-  const char **vername;
-  const char **filename;
-
-  /* Get the data of the section.  */
-  Elf_Data *data = elf_getdata (scn, NULL);
-  if (data == NULL)
-    return;
-
-  /* Get the section header string table index.  */
-  size_t shstrndx;
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  /* We have to find the version definition section and extract the
-     version names.  */
-  Elf_Scn *defscn = NULL;
-  Elf_Scn *needscn = NULL;
-
-  Elf_Scn *verscn = NULL;
-  while ((verscn = elf_nextscn (ebl->elf, verscn)) != NULL)
-    {
-      GElf_Shdr vershdr_mem;
-      GElf_Shdr *vershdr = gelf_getshdr (verscn, &vershdr_mem);
-
-      if (likely (vershdr != NULL))
-	{
-	  if (vershdr->sh_type == SHT_GNU_verdef)
-	    defscn = verscn;
-	  else if (vershdr->sh_type == SHT_GNU_verneed)
-	    needscn = verscn;
-	}
-    }
-
-  size_t nvername;
-  if (defscn != NULL || needscn != NULL)
-    {
-      /* We have a version information (better should have).  Now get
-	 the version names.  First find the maximum version number.  */
-      nvername = 0;
-      if (defscn != NULL)
-	{
-	  /* Run through the version definitions and find the highest
-	     index.  */
-	  unsigned int offset = 0;
-	  Elf_Data *defdata;
-	  GElf_Shdr defshdrmem;
-	  GElf_Shdr *defshdr;
-
-	  defdata = elf_getdata (defscn, NULL);
-	  if (unlikely (defdata == NULL))
-	    return;
-
-	  defshdr = gelf_getshdr (defscn, &defshdrmem);
-	  if (unlikely (defshdr == NULL))
-	    return;
-
-	  for (unsigned int cnt = 0; cnt < defshdr->sh_info; ++cnt)
-	    {
-	      GElf_Verdef defmem;
-	      GElf_Verdef *def;
-
-	      /* Get the data at the next offset.  */
-	      def = gelf_getverdef (defdata, offset, &defmem);
-	      if (unlikely (def == NULL))
-		break;
-
-	      nvername = MAX (nvername, (size_t) (def->vd_ndx & 0x7fff));
-
-	      if (def->vd_next == 0)
-		break;
-	      offset += def->vd_next;
-	    }
-	}
-      if (needscn != NULL)
-	{
-	  unsigned int offset = 0;
-	  Elf_Data *needdata;
-	  GElf_Shdr needshdrmem;
-	  GElf_Shdr *needshdr;
-
-	  needdata = elf_getdata (needscn, NULL);
-	  if (unlikely (needdata == NULL))
-	    return;
-
-	  needshdr = gelf_getshdr (needscn, &needshdrmem);
-	  if (unlikely (needshdr == NULL))
-	    return;
-
-	  for (unsigned int cnt = 0; cnt < needshdr->sh_info; ++cnt)
-	    {
-	      GElf_Verneed needmem;
-	      GElf_Verneed *need;
-	      unsigned int auxoffset;
-	      int cnt2;
-
-	      /* Get the data at the next offset.  */
-	      need = gelf_getverneed (needdata, offset, &needmem);
-	      if (unlikely (need == NULL))
-		break;
-
-	      /* Run through the auxiliary entries.  */
-	      auxoffset = offset + need->vn_aux;
-	      for (cnt2 = need->vn_cnt; --cnt2 >= 0; )
-		{
-		  GElf_Vernaux auxmem;
-		  GElf_Vernaux *aux;
-
-		  aux = gelf_getvernaux (needdata, auxoffset, &auxmem);
-		  if (unlikely (aux == NULL))
-		    break;
-
-		  nvername = MAX (nvername,
-				  (size_t) (aux->vna_other & 0x7fff));
-
-		  if (aux->vna_next == 0)
-		    break;
-		  auxoffset += aux->vna_next;
-		}
-
-	      if (need->vn_next == 0)
-		break;
-	      offset += need->vn_next;
-	    }
-	}
-
-      /* This is the number of versions we know about.  */
-      ++nvername;
-
-      /* Allocate the array.  */
-      vername = (const char **) alloca (nvername * sizeof (const char *));
-      memset(vername, 0, nvername * sizeof (const char *));
-      filename = (const char **) alloca (nvername * sizeof (const char *));
-      memset(filename, 0, nvername * sizeof (const char *));
-
-      /* Run through the data structures again and collect the strings.  */
-      if (defscn != NULL)
-	{
-	  /* Run through the version definitions and find the highest
-	     index.  */
-	  unsigned int offset = 0;
-	  Elf_Data *defdata;
-	  GElf_Shdr defshdrmem;
-	  GElf_Shdr *defshdr;
-
-	  defdata = elf_getdata (defscn, NULL);
-	  if (unlikely (defdata == NULL))
-	    return;
-
-	  defshdr = gelf_getshdr (defscn, &defshdrmem);
-	  if (unlikely (defshdr == NULL))
-	    return;
-
-	  for (unsigned int cnt = 0; cnt < defshdr->sh_info; ++cnt)
-	    {
-
-	      /* Get the data at the next offset.  */
-	      GElf_Verdef defmem;
-	      GElf_Verdef *def = gelf_getverdef (defdata, offset, &defmem);
-	      if (unlikely (def == NULL))
-		break;
-
-	      GElf_Verdaux auxmem;
-	      GElf_Verdaux *aux = gelf_getverdaux (defdata,
-						   offset + def->vd_aux,
-						   &auxmem);
-	      if (unlikely (aux == NULL))
-		break;
-
-	      vername[def->vd_ndx & 0x7fff]
-		= elf_strptr (ebl->elf, defshdr->sh_link, aux->vda_name);
-	      filename[def->vd_ndx & 0x7fff] = NULL;
-
-	      if (def->vd_next == 0)
-		break;
-	      offset += def->vd_next;
-	    }
-	}
-      if (needscn != NULL)
-	{
-	  unsigned int offset = 0;
-
-	  Elf_Data *needdata = elf_getdata (needscn, NULL);
-	  GElf_Shdr needshdrmem;
-	  GElf_Shdr *needshdr = gelf_getshdr (needscn, &needshdrmem);
-	  if (unlikely (needdata == NULL || needshdr == NULL))
-	    return;
-
-	  for (unsigned int cnt = 0; cnt < needshdr->sh_info; ++cnt)
-	    {
-	      /* Get the data at the next offset.  */
-	      GElf_Verneed needmem;
-	      GElf_Verneed *need = gelf_getverneed (needdata, offset,
-						    &needmem);
-	      if (unlikely (need == NULL))
-		break;
-
-	      /* Run through the auxiliary entries.  */
-	      unsigned int auxoffset = offset + need->vn_aux;
-	      for (int cnt2 = need->vn_cnt; --cnt2 >= 0; )
-		{
-		  GElf_Vernaux auxmem;
-		  GElf_Vernaux *aux = gelf_getvernaux (needdata, auxoffset,
-						       &auxmem);
-		  if (unlikely (aux == NULL))
-		    break;
-
-		  vername[aux->vna_other & 0x7fff]
-		    = elf_strptr (ebl->elf, needshdr->sh_link, aux->vna_name);
-		  filename[aux->vna_other & 0x7fff]
-		    = elf_strptr (ebl->elf, needshdr->sh_link, need->vn_file);
-
-		  if (aux->vna_next == 0)
-		    break;
-		  auxoffset += aux->vna_next;
-		}
-
-	      if (need->vn_next == 0)
-		break;
-	      offset += need->vn_next;
-	    }
-	}
-    }
-  else
-    {
-      vername = NULL;
-      nvername = 1;
-      filename = NULL;
-    }
-
-  GElf_Shdr glink_mem;
-  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				   &glink_mem);
-  size_t sh_entsize = gelf_fsize (ebl->elf, ELF_T_HALF, 1, EV_CURRENT);
-  if (glink == NULL)
-    error (EXIT_FAILURE, 0, _("invalid sh_link value in section %zu"),
-	   elf_ndxscn (scn));
-
-  /* Print the header.  */
-  printf (ngettext ("\
-\nVersion symbols section [%2u] '%s' contains %d entry:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'",
-		    "\
-\nVersion symbols section [%2u] '%s' contains %d entries:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'",
-		    shdr->sh_size / sh_entsize),
-	  (unsigned int) elf_ndxscn (scn),
-	  elf_strptr (ebl->elf, shstrndx, shdr->sh_name),
-	  (int) (shdr->sh_size / sh_entsize),
-	  class == ELFCLASS32 ? 10 : 18, shdr->sh_addr,
-	  shdr->sh_offset,
-	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
-
-  /* Now we can finally look at the actual contents of this section.  */
-  for (unsigned int cnt = 0; cnt < shdr->sh_size / sh_entsize; ++cnt)
-    {
-      if (cnt % 2 == 0)
-	printf ("\n %4d:", cnt);
-
-      GElf_Versym symmem;
-      GElf_Versym *sym = gelf_getversym (data, cnt, &symmem);
-      if (sym == NULL)
-	break;
-
-      switch (*sym)
-	{
-	  ssize_t n;
-	case 0:
-	  fputs_unlocked (_("   0 *local*                     "),
-			  stdout);
-	  break;
-
-	case 1:
-	  fputs_unlocked (_("   1 *global*                    "),
-			  stdout);
-	  break;
-
-	default:
-	  n = printf ("%4d%c%s",
-		      *sym & 0x7fff, *sym & 0x8000 ? 'h' : ' ',
-		      (vername != NULL
-		       && (unsigned int) (*sym & 0x7fff) < nvername)
-		      ? vername[*sym & 0x7fff] : "???");
-	  if ((unsigned int) (*sym & 0x7fff) < nvername
-	      && filename != NULL && filename[*sym & 0x7fff] != NULL)
-	    n += printf ("(%s)", filename[*sym & 0x7fff]);
-	  printf ("%*s", MAX (0, 33 - (int) n), " ");
-	  break;
-	}
-    }
-  putchar_unlocked ('\n');
-}
-
-
-static void
-print_hash_info (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr, size_t shstrndx,
-		 uint_fast32_t maxlength, Elf32_Word nbucket,
-		 uint_fast32_t nsyms, uint32_t *lengths, const char *extrastr)
-{
-  uint32_t *counts = xcalloc (maxlength + 1, sizeof (uint32_t));
-
-  for (Elf32_Word cnt = 0; cnt < nbucket; ++cnt)
-    ++counts[lengths[cnt]];
-
-  GElf_Shdr glink_mem;
-  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf,
-					       shdr->sh_link),
-				   &glink_mem);
-  if (glink == NULL)
-    {
-      error (0, 0, _("invalid sh_link value in section %zu"),
-	     elf_ndxscn (scn));
-      return;
-    }
-
-  printf (ngettext ("\
-\nHistogram for bucket list length in section [%2u] '%s' (total of %d bucket):\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
-		    "\
-\nHistogram for bucket list length in section [%2u] '%s' (total of %d buckets):\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
-		    nbucket),
-	  (unsigned int) elf_ndxscn (scn),
-	  elf_strptr (ebl->elf, shstrndx, shdr->sh_name),
-	  (int) nbucket,
-	  gelf_getclass (ebl->elf) == ELFCLASS32 ? 10 : 18,
-	  shdr->sh_addr,
-	  shdr->sh_offset,
-	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
-
-  if (extrastr != NULL)
-    fputs (extrastr, stdout);
-
-  if (likely (nbucket > 0))
-    {
-      uint64_t success = 0;
-
-      /* xgettext:no-c-format */
-      fputs_unlocked (_("\
- Length  Number  % of total  Coverage\n"), stdout);
-      printf (_("      0  %6" PRIu32 "      %5.1f%%\n"),
-	      counts[0], (counts[0] * 100.0) / nbucket);
-
-      uint64_t nzero_counts = 0;
-      for (Elf32_Word cnt = 1; cnt <= maxlength; ++cnt)
-	{
-	  nzero_counts += counts[cnt] * cnt;
-	  printf (_("\
-%7d  %6" PRIu32 "      %5.1f%%    %5.1f%%\n"),
-		  (int) cnt, counts[cnt], (counts[cnt] * 100.0) / nbucket,
-		  (nzero_counts * 100.0) / nsyms);
-	}
-
-      Elf32_Word acc = 0;
-      for (Elf32_Word cnt = 1; cnt <= maxlength; ++cnt)
-	{
-	  acc += cnt;
-	  success += counts[cnt] * acc;
-	}
-
-      printf (_("\
- Average number of tests:   successful lookup: %f\n\
-			  unsuccessful lookup: %f\n"),
-	      (double) success / (double) nzero_counts,
-	      (double) nzero_counts / (double) nbucket);
-    }
-
-  free (counts);
-}
-
-
-/* This function handles the traditional System V-style hash table format.  */
-static void
-handle_sysv_hash (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr, size_t shstrndx)
-{
-  Elf_Data *data = elf_getdata (scn, NULL);
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get data for section %d: %s"),
-	     (int) elf_ndxscn (scn), elf_errmsg (-1));
-      return;
-    }
-
-  if (unlikely (data->d_size < 2 * sizeof (Elf32_Word)))
-    {
-    invalid_data:
-      error (0, 0, _("invalid data in sysv.hash section %d"),
-	     (int) elf_ndxscn (scn));
-      return;
-    }
-
-  Elf32_Word nbucket = ((Elf32_Word *) data->d_buf)[0];
-  Elf32_Word nchain = ((Elf32_Word *) data->d_buf)[1];
-
-  uint64_t used_buf = (2ULL + nchain + nbucket) * sizeof (Elf32_Word);
-  if (used_buf > data->d_size)
-    goto invalid_data;
-
-  Elf32_Word *bucket = &((Elf32_Word *) data->d_buf)[2];
-  Elf32_Word *chain = &((Elf32_Word *) data->d_buf)[2 + nbucket];
-
-  uint32_t *lengths = xcalloc (nbucket, sizeof (uint32_t));
-
-  uint_fast32_t maxlength = 0;
-  uint_fast32_t nsyms = 0;
-  for (Elf32_Word cnt = 0; cnt < nbucket; ++cnt)
-    {
-      Elf32_Word inner = bucket[cnt];
-      Elf32_Word chain_len = 0;
-      while (inner > 0 && inner < nchain)
-	{
-	  ++nsyms;
-	  ++chain_len;
-	  if (chain_len > nchain)
-	    {
-	      error (0, 0, _("invalid chain in sysv.hash section %d"),
-		     (int) elf_ndxscn (scn));
-	      free (lengths);
-	      return;
-	    }
-	  if (maxlength < ++lengths[cnt])
-	    ++maxlength;
-
-	  inner = chain[inner];
-	}
-    }
-
-  print_hash_info (ebl, scn, shdr, shstrndx, maxlength, nbucket, nsyms,
-		   lengths, NULL);
-
-  free (lengths);
-}
-
-
-/* This function handles the incorrect, System V-style hash table
-   format some 64-bit architectures use.  */
-static void
-handle_sysv_hash64 (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr, size_t shstrndx)
-{
-  Elf_Data *data = elf_getdata (scn, NULL);
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get data for section %d: %s"),
-	     (int) elf_ndxscn (scn), elf_errmsg (-1));
-      return;
-    }
-
-  if (unlikely (data->d_size < 2 * sizeof (Elf64_Xword)))
-    {
-    invalid_data:
-      error (0, 0, _("invalid data in sysv.hash64 section %d"),
-	     (int) elf_ndxscn (scn));
-      return;
-    }
-
-  Elf64_Xword nbucket = ((Elf64_Xword *) data->d_buf)[0];
-  Elf64_Xword nchain = ((Elf64_Xword *) data->d_buf)[1];
-
-  uint64_t maxwords = data->d_size / sizeof (Elf64_Xword);
-  if (maxwords < 2
-      || maxwords - 2 < nbucket
-      || maxwords - 2 - nbucket < nchain)
-    goto invalid_data;
-
-  Elf64_Xword *bucket = &((Elf64_Xword *) data->d_buf)[2];
-  Elf64_Xword *chain = &((Elf64_Xword *) data->d_buf)[2 + nbucket];
-
-  uint32_t *lengths = xcalloc (nbucket, sizeof (uint32_t));
-
-  uint_fast32_t maxlength = 0;
-  uint_fast32_t nsyms = 0;
-  for (Elf64_Xword cnt = 0; cnt < nbucket; ++cnt)
-    {
-      Elf64_Xword inner = bucket[cnt];
-      Elf64_Xword chain_len = 0;
-      while (inner > 0 && inner < nchain)
-	{
-	  ++nsyms;
-	  ++chain_len;
-	  if (chain_len > nchain)
-	    {
-	      error (0, 0, _("invalid chain in sysv.hash64 section %d"),
-		     (int) elf_ndxscn (scn));
-	      free (lengths);
-	      return;
-	    }
-	  if (maxlength < ++lengths[cnt])
-	    ++maxlength;
-
-	  inner = chain[inner];
-	}
-    }
-
-  print_hash_info (ebl, scn, shdr, shstrndx, maxlength, nbucket, nsyms,
-		   lengths, NULL);
-
-  free (lengths);
-}
-
-
-/* This function handles the GNU-style hash table format.  */
-static void
-handle_gnu_hash (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr, size_t shstrndx)
-{
-  uint32_t *lengths = NULL;
-  Elf_Data *data = elf_getdata (scn, NULL);
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get data for section %d: %s"),
-	     (int) elf_ndxscn (scn), elf_errmsg (-1));
-      return;
-    }
-
-  if (unlikely (data->d_size < 4 * sizeof (Elf32_Word)))
-    {
-    invalid_data:
-      free (lengths);
-      error (0, 0, _("invalid data in gnu.hash section %d"),
-	     (int) elf_ndxscn (scn));
-      return;
-    }
-
-  Elf32_Word nbucket = ((Elf32_Word *) data->d_buf)[0];
-  Elf32_Word symbias = ((Elf32_Word *) data->d_buf)[1];
-
-  /* Next comes the size of the bitmap.  It's measured in words for
-     the architecture.  It's 32 bits for 32 bit archs, and 64 bits for
-     64 bit archs.  There is always a bloom filter present, so zero is
-     an invalid value.  */
-  Elf32_Word bitmask_words = ((Elf32_Word *) data->d_buf)[2];
-  if (gelf_getclass (ebl->elf) == ELFCLASS64)
-    bitmask_words *= 2;
-
-  if (bitmask_words == 0)
-    goto invalid_data;
-
-  Elf32_Word shift = ((Elf32_Word *) data->d_buf)[3];
-
-  /* Is there still room for the sym chain?
-     Use uint64_t calculation to prevent 32bit overflow.  */
-  uint64_t used_buf = (4ULL + bitmask_words + nbucket) * sizeof (Elf32_Word);
-  uint32_t max_nsyms = (data->d_size - used_buf) / sizeof (Elf32_Word);
-  if (used_buf > data->d_size)
-    goto invalid_data;
-
-  lengths = xcalloc (nbucket, sizeof (uint32_t));
-
-  Elf32_Word *bitmask = &((Elf32_Word *) data->d_buf)[4];
-  Elf32_Word *bucket = &((Elf32_Word *) data->d_buf)[4 + bitmask_words];
-  Elf32_Word *chain = &((Elf32_Word *) data->d_buf)[4 + bitmask_words
-						    + nbucket];
-
-  /* Compute distribution of chain lengths.  */
-  uint_fast32_t maxlength = 0;
-  uint_fast32_t nsyms = 0;
-  for (Elf32_Word cnt = 0; cnt < nbucket; ++cnt)
-    if (bucket[cnt] != 0)
-      {
-	Elf32_Word inner = bucket[cnt] - symbias;
-	do
-	  {
-	    ++nsyms;
-	    if (maxlength < ++lengths[cnt])
-	      ++maxlength;
-	    if (inner >= max_nsyms)
-	      goto invalid_data;
-	  }
-	while ((chain[inner++] & 1) == 0);
-      }
-
-  /* Count bits in bitmask.  */
-  uint_fast32_t nbits = 0;
-  for (Elf32_Word cnt = 0; cnt < bitmask_words; ++cnt)
-    {
-      uint_fast32_t word = bitmask[cnt];
-
-      word = (word & 0x55555555) + ((word >> 1) & 0x55555555);
-      word = (word & 0x33333333) + ((word >> 2) & 0x33333333);
-      word = (word & 0x0f0f0f0f) + ((word >> 4) & 0x0f0f0f0f);
-      word = (word & 0x00ff00ff) + ((word >> 8) & 0x00ff00ff);
-      nbits += (word & 0x0000ffff) + ((word >> 16) & 0x0000ffff);
-    }
-
-  char *str = xasprintf (_("\
- Symbol Bias: %u\n\
- Bitmask Size: %zu bytes  %" PRIuFAST32 "%% bits set  2nd hash shift: %u\n"),
-			 (unsigned int) symbias,
-			 bitmask_words * sizeof (Elf32_Word),
-			 ((nbits * 100 + 50)
-			  / (uint_fast32_t) (bitmask_words
-					      * sizeof (Elf32_Word) * 8)),
-			  (unsigned int) shift);
-
-  print_hash_info (ebl, scn, shdr, shstrndx, maxlength, nbucket, nsyms,
-		   lengths, str);
-
-  free (str);
-  free (lengths);
-}
-
-
-/* Find the symbol table(s).  For this we have to search through the
-   section table.  */
-static void
-handle_hash (Ebl *ebl)
-{
-  /* Get the section header string table index.  */
-  size_t shstrndx;
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  Elf_Scn *scn = NULL;
-  while ((scn = elf_nextscn (ebl->elf, scn)) != NULL)
-    {
-      /* Handle the section if it is a symbol table.  */
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-
-      if (likely (shdr != NULL))
-	{
-	  if ((shdr->sh_type == SHT_HASH || shdr->sh_type == SHT_GNU_HASH)
-	      && (shdr->sh_flags & SHF_COMPRESSED) != 0)
-	    {
-	      if (elf_compress (scn, 0, 0) < 0)
-		printf ("WARNING: %s [%zd]\n",
-			_("Couldn't uncompress section"),
-			elf_ndxscn (scn));
-	      shdr = gelf_getshdr (scn, &shdr_mem);
-	      if (unlikely (shdr == NULL))
-		error (EXIT_FAILURE, 0,
-		       _("cannot get section [%zd] header: %s"),
-		       elf_ndxscn (scn), elf_errmsg (-1));
-	    }
-
-	  if (shdr->sh_type == SHT_HASH)
-	    {
-	      if (ebl_sysvhash_entrysize (ebl) == sizeof (Elf64_Xword))
-		handle_sysv_hash64 (ebl, scn, shdr, shstrndx);
-	      else
-		handle_sysv_hash (ebl, scn, shdr, shstrndx);
-	    }
-	  else if (shdr->sh_type == SHT_GNU_HASH)
-	    handle_gnu_hash (ebl, scn, shdr, shstrndx);
-	}
-    }
-}
-
-
-static void
-print_liblist (Ebl *ebl)
-{
-  /* Find the library list sections.  For this we have to search
-     through the section table.  */
-  Elf_Scn *scn = NULL;
-
-  /* Get the section header string table index.  */
-  size_t shstrndx;
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  while ((scn = elf_nextscn (ebl->elf, scn)) != NULL)
-    {
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-
-      if (shdr != NULL && shdr->sh_type == SHT_GNU_LIBLIST)
-	{
-	  size_t sh_entsize = gelf_fsize (ebl->elf, ELF_T_LIB, 1, EV_CURRENT);
-	  int nentries = shdr->sh_size / sh_entsize;
-	  printf (ngettext ("\
-\nLibrary list section [%2zu] '%s' at offset %#0" PRIx64 " contains %d entry:\n",
-			    "\
-\nLibrary list section [%2zu] '%s' at offset %#0" PRIx64 " contains %d entries:\n",
-			    nentries),
-		  elf_ndxscn (scn),
-		  elf_strptr (ebl->elf, shstrndx, shdr->sh_name),
-		  shdr->sh_offset,
-		  nentries);
-
-	  Elf_Data *data = elf_getdata (scn, NULL);
-	  if (data == NULL)
-	    return;
-
-	  puts (_("\
-       Library                       Time Stamp          Checksum Version Flags"));
-
-	  for (int cnt = 0; cnt < nentries; ++cnt)
-	    {
-	      GElf_Lib lib_mem;
-	      GElf_Lib *lib = gelf_getlib (data, cnt, &lib_mem);
-	      if (unlikely (lib == NULL))
-		continue;
-
-	      time_t t = (time_t) lib->l_time_stamp;
-	      struct tm *tm = gmtime (&t);
-	      if (unlikely (tm == NULL))
-		continue;
-
-	      printf ("  [%2d] %-29s %04u-%02u-%02uT%02u:%02u:%02u %08x %-7u %u\n",
-		      cnt, elf_strptr (ebl->elf, shdr->sh_link, lib->l_name),
-		      tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
-		      tm->tm_hour, tm->tm_min, tm->tm_sec,
-		      (unsigned int) lib->l_checksum,
-		      (unsigned int) lib->l_version,
-		      (unsigned int) lib->l_flags);
-	    }
-	}
-    }
-}
-
-static inline size_t
-left (Elf_Data *data,
-      const unsigned char *p)
-{
-  return (const unsigned char *) data->d_buf + data->d_size - p;
-}
-
-static void
-print_attributes (Ebl *ebl, const GElf_Ehdr *ehdr)
-{
-  /* Find the object attributes sections.  For this we have to search
-     through the section table.  */
-  Elf_Scn *scn = NULL;
-
-  /* Get the section header string table index.  */
-  size_t shstrndx;
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  while ((scn = elf_nextscn (ebl->elf, scn)) != NULL)
-    {
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-
-      if (shdr == NULL || (shdr->sh_type != SHT_GNU_ATTRIBUTES
-			   && (shdr->sh_type != SHT_ARM_ATTRIBUTES
-			       || ehdr->e_machine != EM_ARM)
-			   && (shdr->sh_type != SHT_CSKY_ATTRIBUTES
-			       || ehdr->e_machine != EM_CSKY)))
-	continue;
-
-      printf (_("\
-\nObject attributes section [%2zu] '%s' of %" PRIu64
-		       " bytes at offset %#0" PRIx64 ":\n"),
-	      elf_ndxscn (scn),
-	      elf_strptr (ebl->elf, shstrndx, shdr->sh_name),
-	      shdr->sh_size, shdr->sh_offset);
-
-      Elf_Data *data = elf_rawdata (scn, NULL);
-      if (unlikely (data == NULL || data->d_size == 0))
-	return;
-
-      const unsigned char *p = data->d_buf;
-
-      /* There is only one 'version', A.  */
-      if (unlikely (*p++ != 'A'))
-	return;
-
-      fputs_unlocked (_("  Owner          Size\n"), stdout);
-
-      /* Loop over the sections.  */
-      while (left (data, p) >= 4)
-	{
-	  /* Section length.  */
-	  uint32_t len;
-	  memcpy (&len, p, sizeof len);
-
-	  if (MY_ELFDATA != ehdr->e_ident[EI_DATA])
-	    CONVERT (len);
-
-	  if (unlikely (len > left (data, p)))
-	    break;
-
-	  /* Section vendor name.  */
-	  const unsigned char *name = p + sizeof len;
-	  p += len;
-
-	  unsigned const char *q = memchr (name, '\0', len);
-	  if (unlikely (q == NULL))
-	    break;
-	  ++q;
-
-	  printf (_("  %-13s  %4" PRIu32 "\n"), name, len);
-
-	  bool gnu_vendor = (q - name == sizeof "gnu"
-			     && !memcmp (name, "gnu", sizeof "gnu"));
-
-	  /* Loop over subsections.  */
-	  if (shdr->sh_type != SHT_GNU_ATTRIBUTES
-	      || gnu_vendor)
-	    while (q < p)
-	      {
-		const unsigned char *const sub = q;
-
-		unsigned int subsection_tag;
-		get_uleb128 (subsection_tag, q, p);
-		if (unlikely (q >= p))
-		  break;
-
-		uint32_t subsection_len;
-		if (unlikely (p - sub < (ptrdiff_t) sizeof subsection_len))
-		  break;
-
-		memcpy (&subsection_len, q, sizeof subsection_len);
-
-		if (MY_ELFDATA != ehdr->e_ident[EI_DATA])
-		  CONVERT (subsection_len);
-
-		/* Don't overflow, ptrdiff_t might be 32bits, but signed.  */
-		if (unlikely (subsection_len == 0
-			      || subsection_len >= (uint32_t) PTRDIFF_MAX
-			      || p - sub < (ptrdiff_t) subsection_len))
-		  break;
-
-		const unsigned char *r = q + sizeof subsection_len;
-		q = sub + subsection_len;
-
-		switch (subsection_tag)
-		  {
-		  default:
-		    /* Unknown subsection, print and skip.  */
-		    printf (_("    %-4u %12" PRIu32 "\n"),
-			    subsection_tag, subsection_len);
-		    break;
-
-		  case 1:	/* Tag_File */
-		    printf (_("    File: %11" PRIu32 "\n"),
-			    subsection_len);
-
-		    while (r < q)
-		      {
-			unsigned int tag;
-			get_uleb128 (tag, r, q);
-			if (unlikely (r >= q))
-			  break;
-
-			/* GNU style tags have either a uleb128 value,
-			   when lowest bit is not set, or a string
-			   when the lowest bit is set.
-			   "compatibility" (32) is special.  It has
-			   both a string and a uleb128 value.  For
-			   non-gnu we assume 6 till 31 only take ints.
-			   XXX see arm backend, do we need a separate
-			   hook?  */
-			uint64_t value = 0;
-			const char *string = NULL;
-			if (tag == 32 || (tag & 1) == 0
-			    || (! gnu_vendor && (tag > 5 && tag < 32)))
-			  {
-			    get_uleb128 (value, r, q);
-			    if (r > q)
-			      break;
-			  }
-			if (tag == 32
-			    || ((tag & 1) != 0
-				&& (gnu_vendor
-				    || (! gnu_vendor && tag > 32)))
-			    || (! gnu_vendor && tag > 3 && tag < 6))
-			  {
-			    string = (const char *) r;
-			    r = memchr (r, '\0', q - r);
-			    if (r == NULL)
-			      break;
-			    ++r;
-			  }
-
-			const char *tag_name = NULL;
-			const char *value_name = NULL;
-			ebl_check_object_attribute (ebl, (const char *) name,
-						    tag, value,
-						    &tag_name, &value_name);
-
-			if (tag_name != NULL)
-			  {
-			    if (tag == 32)
-			      printf (_("      %s: %" PRId64 ", %s\n"),
-				      tag_name, value, string);
-			    else if (string == NULL && value_name == NULL)
-			      printf (_("      %s: %" PRId64 "\n"),
-				      tag_name, value);
-			    else
-			      printf (_("      %s: %s\n"),
-				      tag_name, string ?: value_name);
-			  }
-			else
-			  {
-			    /* For "gnu" vendor 32 "compatibility" has
-			       already been handled above.  */
-			    assert (tag != 32
-				    || strcmp ((const char *) name, "gnu"));
-			    if (string == NULL)
-			      printf (_("      %u: %" PRId64 "\n"),
-				      tag, value);
-			    else
-			      printf (_("      %u: %s\n"),
-				      tag, string);
-			  }
-		      }
-		  }
-	      }
-	}
-    }
-}
-
-
-void
-print_dwarf_addr (Dwfl_Module *dwflmod,
-		  int address_size, Dwarf_Addr address, Dwarf_Addr raw)
-{
-  /* See if there is a name we can give for this address.  */
-  GElf_Sym sym;
-  GElf_Off off = 0;
-  const char *name = (print_address_names && ! print_unresolved_addresses)
-    ? dwfl_module_addrinfo (dwflmod, address, &off, &sym, NULL, NULL, NULL)
-    : NULL;
-
-  const char *scn;
-  if (print_unresolved_addresses)
-    {
-      address = raw;
-      scn = NULL;
-    }
-  else
-    {
-      /* Relativize the address.  */
-      int n = dwfl_module_relocations (dwflmod);
-      int i = n < 1 ? -1 : dwfl_module_relocate_address (dwflmod, &address);
-
-      /* In an ET_REL file there is a section name to refer to.  */
-      scn = (i < 0 ? NULL
-	     : dwfl_module_relocation_info (dwflmod, i, NULL));
-    }
-
-  if ((name != NULL
-       ? (off != 0
-	  ? (scn != NULL
-	     ? (address_size == 0
-		? printf ("%s+%#" PRIx64 " <%s+%#" PRIx64 ">",
-			  scn, address, name, off)
-		: printf ("%s+%#0*" PRIx64 " <%s+%#" PRIx64 ">",
-			  scn, 2 + address_size * 2, address,
-			  name, off))
-	     : (address_size == 0
-		? printf ("%#" PRIx64 " <%s+%#" PRIx64 ">",
-			  address, name, off)
-		: printf ("%#0*" PRIx64 " <%s+%#" PRIx64 ">",
-			  2 + address_size * 2, address,
-			  name, off)))
-	  : (scn != NULL
-	     ? (address_size == 0
-		? printf ("%s+%#" PRIx64 " <%s>", scn, address, name)
-		: printf ("%s+%#0*" PRIx64 " <%s>",
-			   scn, 2 + address_size * 2, address, name))
-	     : (address_size == 0
-		? printf ("%#" PRIx64 " <%s>", address, name)
-		: printf ("%#0*" PRIx64 " <%s>",
-			  2 + address_size * 2, address, name))))
-       : (scn != NULL
-	  ? (address_size == 0
-	     ? printf ("%s+%#" PRIx64, scn, address)
-	     : printf ("%s+%#0*" PRIx64, scn, 2 + address_size * 2, address))
-	  : (address_size == 0
-	     ? printf ("%#" PRIx64, address)
-	     : printf ("%#0*" PRIx64, 2 + address_size * 2, address)))) < 0)
-    error (EXIT_FAILURE, 0, _("sprintf failure"));
-}
-
-
-static const char *
-dwarf_tag_string (unsigned int tag)
-{
-  switch (tag)
-    {
-#define DWARF_ONE_KNOWN_DW_TAG(NAME, CODE) case CODE: return #NAME;
-      DWARF_ALL_KNOWN_DW_TAG
-#undef DWARF_ONE_KNOWN_DW_TAG
-    default:
-      return NULL;
-    }
-}
-
-
-static const char *
-dwarf_attr_string (unsigned int attrnum)
-{
-  switch (attrnum)
-    {
-#define DWARF_ONE_KNOWN_DW_AT(NAME, CODE) case CODE: return #NAME;
-      DWARF_ALL_KNOWN_DW_AT
-#undef DWARF_ONE_KNOWN_DW_AT
-    default:
-      return NULL;
-    }
-}
-
-
-static const char *
-dwarf_form_string (unsigned int form)
-{
-  switch (form)
-    {
-#define DWARF_ONE_KNOWN_DW_FORM(NAME, CODE) case CODE: return #NAME;
-      DWARF_ALL_KNOWN_DW_FORM
-#undef DWARF_ONE_KNOWN_DW_FORM
-    default:
-      return NULL;
-    }
-}
-
-
-static const char *
-dwarf_lang_string (unsigned int lang)
-{
-  switch (lang)
-    {
-#define DWARF_ONE_KNOWN_DW_LANG(NAME, CODE) case CODE: return #NAME;
-      DWARF_ALL_KNOWN_DW_LANG
-#undef DWARF_ONE_KNOWN_DW_LANG
-    default:
-      return NULL;
-    }
-}
-
-
-static const char *
-dwarf_inline_string (unsigned int code)
-{
-  static const char *const known[] =
-    {
-#define DWARF_ONE_KNOWN_DW_INL(NAME, CODE) [CODE] = #NAME,
-      DWARF_ALL_KNOWN_DW_INL
-#undef DWARF_ONE_KNOWN_DW_INL
-    };
-
-  if (likely (code < sizeof (known) / sizeof (known[0])))
-    return known[code];
-
-  return NULL;
-}
-
-
-static const char *
-dwarf_encoding_string (unsigned int code)
-{
-  static const char *const known[] =
-    {
-#define DWARF_ONE_KNOWN_DW_ATE(NAME, CODE) [CODE] = #NAME,
-      DWARF_ALL_KNOWN_DW_ATE
-#undef DWARF_ONE_KNOWN_DW_ATE
-    };
-
-  if (likely (code < sizeof (known) / sizeof (known[0])))
-    return known[code];
-
-  return NULL;
-}
-
-
-static const char *
-dwarf_access_string (unsigned int code)
-{
-  static const char *const known[] =
-    {
-#define DWARF_ONE_KNOWN_DW_ACCESS(NAME, CODE) [CODE] = #NAME,
-      DWARF_ALL_KNOWN_DW_ACCESS
-#undef DWARF_ONE_KNOWN_DW_ACCESS
-    };
-
-  if (likely (code < sizeof (known) / sizeof (known[0])))
-    return known[code];
-
-  return NULL;
-}
-
-
-static const char *
-dwarf_defaulted_string (unsigned int code)
-{
-  static const char *const known[] =
-    {
-#define DWARF_ONE_KNOWN_DW_DEFAULTED(NAME, CODE) [CODE] = #NAME,
-      DWARF_ALL_KNOWN_DW_DEFAULTED
-#undef DWARF_ONE_KNOWN_DW_DEFAULTED
-    };
-
-  if (likely (code < sizeof (known) / sizeof (known[0])))
-    return known[code];
-
-  return NULL;
-}
-
-
-static const char *
-dwarf_visibility_string (unsigned int code)
-{
-  static const char *const known[] =
-    {
-#define DWARF_ONE_KNOWN_DW_VIS(NAME, CODE) [CODE] = #NAME,
-      DWARF_ALL_KNOWN_DW_VIS
-#undef DWARF_ONE_KNOWN_DW_VIS
-    };
-
-  if (likely (code < sizeof (known) / sizeof (known[0])))
-    return known[code];
-
-  return NULL;
-}
-
-
-static const char *
-dwarf_virtuality_string (unsigned int code)
-{
-  static const char *const known[] =
-    {
-#define DWARF_ONE_KNOWN_DW_VIRTUALITY(NAME, CODE) [CODE] = #NAME,
-      DWARF_ALL_KNOWN_DW_VIRTUALITY
-#undef DWARF_ONE_KNOWN_DW_VIRTUALITY
-    };
-
-  if (likely (code < sizeof (known) / sizeof (known[0])))
-    return known[code];
-
-  return NULL;
-}
-
-
-static const char *
-dwarf_identifier_case_string (unsigned int code)
-{
-  static const char *const known[] =
-    {
-#define DWARF_ONE_KNOWN_DW_ID(NAME, CODE) [CODE] = #NAME,
-      DWARF_ALL_KNOWN_DW_ID
-#undef DWARF_ONE_KNOWN_DW_ID
-    };
-
-  if (likely (code < sizeof (known) / sizeof (known[0])))
-    return known[code];
-
-  return NULL;
-}
-
-
-static const char *
-dwarf_calling_convention_string (unsigned int code)
-{
-  static const char *const known[] =
-    {
-#define DWARF_ONE_KNOWN_DW_CC(NAME, CODE) [CODE] = #NAME,
-      DWARF_ALL_KNOWN_DW_CC
-#undef DWARF_ONE_KNOWN_DW_CC
-    };
-
-  if (likely (code < sizeof (known) / sizeof (known[0])))
-    return known[code];
-
-  return NULL;
-}
-
-
-static const char *
-dwarf_ordering_string (unsigned int code)
-{
-  static const char *const known[] =
-    {
-#define DWARF_ONE_KNOWN_DW_ORD(NAME, CODE) [CODE] = #NAME,
-      DWARF_ALL_KNOWN_DW_ORD
-#undef DWARF_ONE_KNOWN_DW_ORD
-    };
-
-  if (likely (code < sizeof (known) / sizeof (known[0])))
-    return known[code];
-
-  return NULL;
-}
-
-
-static const char *
-dwarf_discr_list_string (unsigned int code)
-{
-  static const char *const known[] =
-    {
-#define DWARF_ONE_KNOWN_DW_DSC(NAME, CODE) [CODE] = #NAME,
-      DWARF_ALL_KNOWN_DW_DSC
-#undef DWARF_ONE_KNOWN_DW_DSC
-    };
-
-  if (likely (code < sizeof (known) / sizeof (known[0])))
-    return known[code];
-
-  return NULL;
-}
-
-
-static const char *
-dwarf_locexpr_opcode_string (unsigned int code)
-{
-  static const char *const known[] =
-    {
-      /* Normally we can't afford building huge table of 64K entries,
-	 most of them zero, just because there are a couple defined
-	 values at the far end.  In case of opcodes, it's OK.  */
-#define DWARF_ONE_KNOWN_DW_OP(NAME, CODE) [CODE] = #NAME,
-      DWARF_ALL_KNOWN_DW_OP
-#undef DWARF_ONE_KNOWN_DW_OP
-    };
-
-  if (likely (code < sizeof (known) / sizeof (known[0])))
-    return known[code];
-
-  return NULL;
-}
-
-
-static const char *
-dwarf_unit_string (unsigned int type)
-{
-  switch (type)
-    {
-#define DWARF_ONE_KNOWN_DW_UT(NAME, CODE) case CODE: return #NAME;
-      DWARF_ALL_KNOWN_DW_UT
-#undef DWARF_ONE_KNOWN_DW_UT
-    default:
-      return NULL;
-    }
-}
-
-
-static const char *
-dwarf_range_list_encoding_string (unsigned int kind)
-{
-  switch (kind)
-    {
-#define DWARF_ONE_KNOWN_DW_RLE(NAME, CODE) case CODE: return #NAME;
-      DWARF_ALL_KNOWN_DW_RLE
-#undef DWARF_ONE_KNOWN_DW_RLE
-    default:
-      return NULL;
-    }
-}
-
-
-static const char *
-dwarf_loc_list_encoding_string (unsigned int kind)
-{
-  switch (kind)
-    {
-#define DWARF_ONE_KNOWN_DW_LLE(NAME, CODE) case CODE: return #NAME;
-      DWARF_ALL_KNOWN_DW_LLE
-#undef DWARF_ONE_KNOWN_DW_LLE
-    default:
-      return NULL;
-    }
-}
-
-
-static const char *
-dwarf_line_content_description_string (unsigned int kind)
-{
-  switch (kind)
-    {
-#define DWARF_ONE_KNOWN_DW_LNCT(NAME, CODE) case CODE: return #NAME;
-      DWARF_ALL_KNOWN_DW_LNCT
-#undef DWARF_ONE_KNOWN_DW_LNCT
-    default:
-      return NULL;
-    }
-}
-
-
-/* Used by all dwarf_foo_name functions.  */
-static const char *
-string_or_unknown (const char *known, unsigned int code,
-                   unsigned int lo_user, unsigned int hi_user,
-		   bool print_unknown_num)
-{
-  static char unknown_buf[20];
-
-  if (likely (known != NULL))
-    return known;
-
-  if (lo_user != 0 && code >= lo_user && code <= hi_user)
-    {
-      snprintf (unknown_buf, sizeof unknown_buf, "lo_user+%#x",
-		code - lo_user);
-      return unknown_buf;
-    }
-
-  if (print_unknown_num)
-    {
-      snprintf (unknown_buf, sizeof unknown_buf, "??? (%#x)", code);
-      return unknown_buf;
-    }
-
-  return "???";
-}
-
-
-static const char *
-dwarf_tag_name (unsigned int tag)
-{
-  const char *ret = dwarf_tag_string (tag);
-  return string_or_unknown (ret, tag, DW_TAG_lo_user, DW_TAG_hi_user, true);
-}
-
-static const char *
-dwarf_attr_name (unsigned int attr)
-{
-  const char *ret = dwarf_attr_string (attr);
-  return string_or_unknown (ret, attr, DW_AT_lo_user, DW_AT_hi_user, true);
-}
-
-
-static const char *
-dwarf_form_name (unsigned int form)
-{
-  const char *ret = dwarf_form_string (form);
-  return string_or_unknown (ret, form, 0, 0, true);
-}
-
-
-static const char *
-dwarf_lang_name (unsigned int lang)
-{
-  const char *ret = dwarf_lang_string (lang);
-  return string_or_unknown (ret, lang, DW_LANG_lo_user, DW_LANG_hi_user, false);
-}
-
-
-static const char *
-dwarf_inline_name (unsigned int code)
-{
-  const char *ret = dwarf_inline_string (code);
-  return string_or_unknown (ret, code, 0, 0, false);
-}
-
-
-static const char *
-dwarf_encoding_name (unsigned int code)
-{
-  const char *ret = dwarf_encoding_string (code);
-  return string_or_unknown (ret, code, DW_ATE_lo_user, DW_ATE_hi_user, false);
-}
-
-
-static const char *
-dwarf_access_name (unsigned int code)
-{
-  const char *ret = dwarf_access_string (code);
-  return string_or_unknown (ret, code, 0, 0, false);
-}
-
-
-static const char *
-dwarf_defaulted_name (unsigned int code)
-{
-  const char *ret = dwarf_defaulted_string (code);
-  return string_or_unknown (ret, code, 0, 0, false);
-}
-
-
-static const char *
-dwarf_visibility_name (unsigned int code)
-{
-  const char *ret = dwarf_visibility_string (code);
-  return string_or_unknown (ret, code, 0, 0, false);
-}
-
-
-static const char *
-dwarf_virtuality_name (unsigned int code)
-{
-  const char *ret = dwarf_virtuality_string (code);
-  return string_or_unknown (ret, code, 0, 0, false);
-}
-
-
-static const char *
-dwarf_identifier_case_name (unsigned int code)
-{
-  const char *ret = dwarf_identifier_case_string (code);
-  return string_or_unknown (ret, code, 0, 0, false);
-}
-
-
-static const char *
-dwarf_calling_convention_name (unsigned int code)
-{
-  const char *ret = dwarf_calling_convention_string (code);
-  return string_or_unknown (ret, code, DW_CC_lo_user, DW_CC_hi_user, false);
-}
-
-
-static const char *
-dwarf_ordering_name (unsigned int code)
-{
-  const char *ret = dwarf_ordering_string (code);
-  return string_or_unknown (ret, code, 0, 0, false);
-}
-
-
-static const char *
-dwarf_discr_list_name (unsigned int code)
-{
-  const char *ret = dwarf_discr_list_string (code);
-  return string_or_unknown (ret, code, 0, 0, false);
-}
-
-
-static const char *
-dwarf_unit_name (unsigned int type)
-{
-  const char *ret = dwarf_unit_string (type);
-  return string_or_unknown (ret, type, DW_UT_lo_user, DW_UT_hi_user, true);
-}
-
-
-static const char *
-dwarf_range_list_encoding_name (unsigned int kind)
-{
-  const char *ret = dwarf_range_list_encoding_string (kind);
-  return string_or_unknown (ret, kind, 0, 0, false);
-}
-
-
-static const char *
-dwarf_loc_list_encoding_name (unsigned int kind)
-{
-  const char *ret = dwarf_loc_list_encoding_string (kind);
-  return string_or_unknown (ret, kind, 0, 0, false);
-}
-
-
-static const char *
-dwarf_line_content_description_name (unsigned int kind)
-{
-  const char *ret = dwarf_line_content_description_string (kind);
-  return string_or_unknown (ret, kind, DW_LNCT_lo_user, DW_LNCT_hi_user,
-			    false);
-}
-
-
-static void
-print_block (size_t n, const void *block)
-{
-  if (n == 0)
-    puts (_("empty block"));
-  else
-    {
-      printf (_("%zu byte block:"), n);
-      const unsigned char *data = block;
-      do
-	printf (" %02x", *data++);
-      while (--n > 0);
-      putchar ('\n');
-    }
-}
-
-static void
-print_bytes (size_t n, const unsigned char *bytes)
-{
-  while (n-- > 0)
-    {
-      printf ("%02x", *bytes++);
-      if (n > 0)
-	printf (" ");
-    }
-}
-
-static int
-get_indexed_addr (Dwarf_CU *cu, Dwarf_Word idx, Dwarf_Addr *addr)
-{
-  if (cu == NULL)
-    return -1;
-
-  Elf_Data *debug_addr = cu->dbg->sectiondata[IDX_debug_addr];
-  if (debug_addr == NULL)
-    return -1;
-
-  Dwarf_Off base = __libdw_cu_addr_base (cu);
-  Dwarf_Word off = idx * cu->address_size;
-  if (base > debug_addr->d_size
-      || off > debug_addr->d_size - base
-      || cu->address_size > debug_addr->d_size - base - off)
-    return -1;
-
-  const unsigned char *addrp = debug_addr->d_buf + base + off;
-  if (cu->address_size == 4)
-    *addr = read_4ubyte_unaligned (cu->dbg, addrp);
-  else
-    *addr = read_8ubyte_unaligned (cu->dbg, addrp);
-
-  return 0;
-}
-
-static void
-print_ops (Dwfl_Module *dwflmod, Dwarf *dbg, int indent, int indentrest,
-	   unsigned int vers, unsigned int addrsize, unsigned int offset_size,
-	   struct Dwarf_CU *cu, Dwarf_Word len, const unsigned char *data)
-{
-  const unsigned int ref_size = vers < 3 ? addrsize : offset_size;
-
-  if (len == 0)
-    {
-      printf ("%*s(empty)\n", indent, "");
-      return;
-    }
-
-#define NEED(n)		if (len < (Dwarf_Word) (n)) goto invalid
-#define CONSUME(n)	NEED (n); else len -= (n)
-
-  Dwarf_Word offset = 0;
-  while (len-- > 0)
-    {
-      uint_fast8_t op = *data++;
-
-      const char *op_name = dwarf_locexpr_opcode_string (op);
-      if (unlikely (op_name == NULL))
-	{
-	  static char buf[20];
-	  if (op >= DW_OP_lo_user)
-	    snprintf (buf, sizeof buf, "lo_user+%#x", op - DW_OP_lo_user);
-	  else
-	    snprintf (buf, sizeof buf, "??? (%#x)", op);
-	  op_name = buf;
-	}
-
-      switch (op)
-	{
-	case DW_OP_addr:;
-	  /* Address operand.  */
-	  Dwarf_Word addr;
-	  NEED (addrsize);
-	  if (addrsize == 4)
-	    addr = read_4ubyte_unaligned (dbg, data);
-	  else if (addrsize == 8)
-	    addr = read_8ubyte_unaligned (dbg, data);
-	  else
-	    goto invalid;
-	  data += addrsize;
-	  CONSUME (addrsize);
-
-	  printf ("%*s[%2" PRIuMAX "] %s ",
-		  indent, "", (uintmax_t) offset, op_name);
-	  print_dwarf_addr (dwflmod, 0, addr, addr);
-	  printf ("\n");
-
-	  offset += 1 + addrsize;
-	  break;
-
-	case DW_OP_call_ref:
-	case DW_OP_GNU_variable_value:
-	  /* Offset operand.  */
-	  if (ref_size != 4 && ref_size != 8)
-	    goto invalid; /* Cannot be used in CFA.  */
-	  NEED (ref_size);
-	  if (ref_size == 4)
-	    addr = read_4ubyte_unaligned (dbg, data);
-	  else
-	    addr = read_8ubyte_unaligned (dbg, data);
-	  data += ref_size;
-	  CONSUME (ref_size);
-	  /* addr is a DIE offset, so format it as one.  */
-	  printf ("%*s[%2" PRIuMAX "] %s [%6" PRIxMAX "]\n",
-		  indent, "", (uintmax_t) offset,
-		  op_name, (uintmax_t) addr);
-	  offset += 1 + ref_size;
-	  break;
-
-	case DW_OP_deref_size:
-	case DW_OP_xderef_size:
-	case DW_OP_pick:
-	case DW_OP_const1u:
-	  // XXX value might be modified by relocation
-	  NEED (1);
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRIu8 "\n",
-		  indent, "", (uintmax_t) offset,
-		  op_name, *((uint8_t *) data));
-	  ++data;
-	  --len;
-	  offset += 2;
-	  break;
-
-	case DW_OP_const2u:
-	  NEED (2);
-	  // XXX value might be modified by relocation
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRIu16 "\n",
-		  indent, "", (uintmax_t) offset,
-		  op_name, read_2ubyte_unaligned (dbg, data));
-	  CONSUME (2);
-	  data += 2;
-	  offset += 3;
-	  break;
-
-	case DW_OP_const4u:
-	  NEED (4);
-	  // XXX value might be modified by relocation
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRIu32 "\n",
-		  indent, "", (uintmax_t) offset,
-		  op_name, read_4ubyte_unaligned (dbg, data));
-	  CONSUME (4);
-	  data += 4;
-	  offset += 5;
-	  break;
-
-	case DW_OP_const8u:
-	  NEED (8);
-	  // XXX value might be modified by relocation
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRIu64 "\n",
-		  indent, "", (uintmax_t) offset,
-		  op_name, (uint64_t) read_8ubyte_unaligned (dbg, data));
-	  CONSUME (8);
-	  data += 8;
-	  offset += 9;
-	  break;
-
-	case DW_OP_const1s:
-	  NEED (1);
-	  // XXX value might be modified by relocation
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRId8 "\n",
-		  indent, "", (uintmax_t) offset,
-		  op_name, *((int8_t *) data));
-	  ++data;
-	  --len;
-	  offset += 2;
-	  break;
-
-	case DW_OP_const2s:
-	  NEED (2);
-	  // XXX value might be modified by relocation
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRId16 "\n",
-		  indent, "", (uintmax_t) offset,
-		  op_name, read_2sbyte_unaligned (dbg, data));
-	  CONSUME (2);
-	  data += 2;
-	  offset += 3;
-	  break;
-
-	case DW_OP_const4s:
-	  NEED (4);
-	  // XXX value might be modified by relocation
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRId32 "\n",
-		  indent, "", (uintmax_t) offset,
-		  op_name, read_4sbyte_unaligned (dbg, data));
-	  CONSUME (4);
-	  data += 4;
-	  offset += 5;
-	  break;
-
-	case DW_OP_const8s:
-	  NEED (8);
-	  // XXX value might be modified by relocation
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRId64 "\n",
-		  indent, "", (uintmax_t) offset,
-		  op_name, read_8sbyte_unaligned (dbg, data));
-	  CONSUME (8);
-	  data += 8;
-	  offset += 9;
-	  break;
-
-	case DW_OP_piece:
-	case DW_OP_regx:
-	case DW_OP_plus_uconst:
-	case DW_OP_constu:;
-	  const unsigned char *start = data;
-	  uint64_t uleb;
-	  NEED (1);
-	  get_uleb128 (uleb, data, data + len);
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRIu64 "\n",
-		  indent, "", (uintmax_t) offset, op_name, uleb);
-	  CONSUME (data - start);
-	  offset += 1 + (data - start);
-	  break;
-
-	case DW_OP_addrx:
-	case DW_OP_GNU_addr_index:
-	case DW_OP_constx:
-	case DW_OP_GNU_const_index:;
-	  start = data;
-	  NEED (1);
-	  get_uleb128 (uleb, data, data + len);
-	  printf ("%*s[%2" PRIuMAX "] %s [%" PRIu64 "] ",
-		  indent, "", (uintmax_t) offset, op_name, uleb);
-	  CONSUME (data - start);
-	  offset += 1 + (data - start);
-	  if (get_indexed_addr (cu, uleb, &addr) != 0)
-	    printf ("???\n");
-	  else
-	    {
-	      print_dwarf_addr (dwflmod, 0, addr, addr);
-	      printf ("\n");
-	    }
-	  break;
-
-	case DW_OP_bit_piece:
-	  start = data;
-	  uint64_t uleb2;
-	  NEED (1);
-	  get_uleb128 (uleb, data, data + len);
-	  NEED (1);
-	  get_uleb128 (uleb2, data, data + len);
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRIu64 ", %" PRIu64 "\n",
-		  indent, "", (uintmax_t) offset, op_name, uleb, uleb2);
-	  CONSUME (data - start);
-	  offset += 1 + (data - start);
-	  break;
-
-	case DW_OP_fbreg:
-	case DW_OP_breg0 ... DW_OP_breg31:
-	case DW_OP_consts:
-	  start = data;
-	  int64_t sleb;
-	  NEED (1);
-	  get_sleb128 (sleb, data, data + len);
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRId64 "\n",
-		  indent, "", (uintmax_t) offset, op_name, sleb);
-	  CONSUME (data - start);
-	  offset += 1 + (data - start);
-	  break;
-
-	case DW_OP_bregx:
-	  start = data;
-	  NEED (1);
-	  get_uleb128 (uleb, data, data + len);
-	  NEED (1);
-	  get_sleb128 (sleb, data, data + len);
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRIu64 " %" PRId64 "\n",
-		  indent, "", (uintmax_t) offset, op_name, uleb, sleb);
-	  CONSUME (data - start);
-	  offset += 1 + (data - start);
-	  break;
-
-	case DW_OP_call2:
-	  NEED (2);
-	  printf ("%*s[%2" PRIuMAX "] %s [%6" PRIx16 "]\n",
-		  indent, "", (uintmax_t) offset, op_name,
-		  read_2ubyte_unaligned (dbg, data));
-	  CONSUME (2);
-	  data += 2;
-	  offset += 3;
-	  break;
-
-	case DW_OP_call4:
-	  NEED (4);
-	  printf ("%*s[%2" PRIuMAX "] %s [%6" PRIx32 "]\n",
-		  indent, "", (uintmax_t) offset, op_name,
-		  read_4ubyte_unaligned (dbg, data));
-	  CONSUME (4);
-	  data += 4;
-	  offset += 5;
-	  break;
-
-	case DW_OP_skip:
-	case DW_OP_bra:
-	  NEED (2);
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRIuMAX "\n",
-		  indent, "", (uintmax_t) offset, op_name,
-		  (uintmax_t) (offset + read_2sbyte_unaligned (dbg, data) + 3));
-	  CONSUME (2);
-	  data += 2;
-	  offset += 3;
-	  break;
-
-	case DW_OP_implicit_value:
-	  start = data;
-	  NEED (1);
-	  get_uleb128 (uleb, data, data + len);
-	  printf ("%*s[%2" PRIuMAX "] %s: ",
-		  indent, "", (uintmax_t) offset, op_name);
-	  NEED (uleb);
-	  print_block (uleb, data);
-	  data += uleb;
-	  CONSUME (data - start);
-	  offset += 1 + (data - start);
-	  break;
-
-	case DW_OP_implicit_pointer:
-	case DW_OP_GNU_implicit_pointer:
-	  /* DIE offset operand.  */
-	  start = data;
-	  NEED (ref_size);
-	  if (ref_size != 4 && ref_size != 8)
-	    goto invalid; /* Cannot be used in CFA.  */
-	  if (ref_size == 4)
-	    addr = read_4ubyte_unaligned (dbg, data);
-	  else
-	    addr = read_8ubyte_unaligned (dbg, data);
-	  data += ref_size;
-	  /* Byte offset operand.  */
-	  NEED (1);
-	  get_sleb128 (sleb, data, data + len);
-
-	  printf ("%*s[%2" PRIuMAX "] %s [%6" PRIxMAX "] %+" PRId64 "\n",
-		  indent, "", (intmax_t) offset,
-		  op_name, (uintmax_t) addr, sleb);
-	  CONSUME (data - start);
-	  offset += 1 + (data - start);
-	  break;
-
-	case DW_OP_entry_value:
-	case DW_OP_GNU_entry_value:
-	  /* Size plus expression block.  */
-	  start = data;
-	  NEED (1);
-	  get_uleb128 (uleb, data, data + len);
-	  printf ("%*s[%2" PRIuMAX "] %s:\n",
-		  indent, "", (uintmax_t) offset, op_name);
-	  NEED (uleb);
-	  print_ops (dwflmod, dbg, indent + 5, indent + 5, vers,
-		     addrsize, offset_size, cu, uleb, data);
-	  data += uleb;
-	  CONSUME (data - start);
-	  offset += 1 + (data - start);
-	  break;
-
-	case DW_OP_const_type:
-	case DW_OP_GNU_const_type:
-	  /* uleb128 CU relative DW_TAG_base_type DIE offset, 1-byte
-	     unsigned size plus block.  */
-	  start = data;
-	  NEED (1);
-	  get_uleb128 (uleb, data, data + len);
-	  if (! print_unresolved_addresses && cu != NULL)
-	    uleb += cu->start;
-	  NEED (1);
-	  uint8_t usize = *(uint8_t *) data++;
-	  NEED (usize);
-	  printf ("%*s[%2" PRIuMAX "] %s [%6" PRIxMAX "] ",
-		  indent, "", (uintmax_t) offset, op_name, uleb);
-	  print_block (usize, data);
-	  data += usize;
-	  CONSUME (data - start);
-	  offset += 1 + (data - start);
-	  break;
-
-	case DW_OP_regval_type:
-	case DW_OP_GNU_regval_type:
-	  /* uleb128 register number, uleb128 CU relative
-	     DW_TAG_base_type DIE offset.  */
-	  start = data;
-	  NEED (1);
-	  get_uleb128 (uleb, data, data + len);
-	  NEED (1);
-	  get_uleb128 (uleb2, data, data + len);
-	  if (! print_unresolved_addresses && cu != NULL)
-	    uleb2 += cu->start;
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRIu64 " [%6" PRIx64 "]\n",
-		  indent, "", (uintmax_t) offset, op_name, uleb, uleb2);
-	  CONSUME (data - start);
-	  offset += 1 + (data - start);
-	  break;
-
-	case DW_OP_deref_type:
-	case DW_OP_GNU_deref_type:
-	  /* 1-byte unsigned size of value, uleb128 CU relative
-	     DW_TAG_base_type DIE offset.  */
-	  start = data;
-	  NEED (1);
-	  usize = *(uint8_t *) data++;
-	  NEED (1);
-	  get_uleb128 (uleb, data, data + len);
-	  if (! print_unresolved_addresses && cu != NULL)
-	    uleb += cu->start;
-	  printf ("%*s[%2" PRIuMAX "] %s %" PRIu8 " [%6" PRIxMAX "]\n",
-		  indent, "", (uintmax_t) offset,
-		  op_name, usize, uleb);
-	  CONSUME (data - start);
-	  offset += 1 + (data - start);
-	  break;
-
-	case DW_OP_xderef_type:
-	  /* 1-byte unsigned size of value, uleb128 base_type DIE offset.  */
-	  start = data;
-	  NEED (1);
-	  usize = *(uint8_t *) data++;
-	  NEED (1);
-	  get_uleb128 (uleb, data, data + len);
-	  printf ("%*s[%4" PRIuMAX "] %s %" PRIu8 " [%6" PRIxMAX "]\n",
-		  indent, "", (uintmax_t) offset,
-		  op_name, usize, uleb);
-	  CONSUME (data - start);
-	  offset += 1 + (data - start);
-	  break;
-
-	case DW_OP_convert:
-	case DW_OP_GNU_convert:
-	case DW_OP_reinterpret:
-	case DW_OP_GNU_reinterpret:
-	  /* uleb128 CU relative offset to DW_TAG_base_type, or zero
-	     for conversion to untyped.  */
-	  start = data;
-	  NEED (1);
-	  get_uleb128 (uleb, data, data + len);
-	  if (uleb != 0 && ! print_unresolved_addresses && cu != NULL)
-	    uleb += cu->start;
-	  printf ("%*s[%2" PRIuMAX "] %s [%6" PRIxMAX "]\n",
-		  indent, "", (uintmax_t) offset, op_name, uleb);
-	  CONSUME (data - start);
-	  offset += 1 + (data - start);
-	  break;
-
-	case DW_OP_GNU_parameter_ref:
-	  /* 4 byte CU relative reference to the abstract optimized away
-	     DW_TAG_formal_parameter.  */
-	  NEED (4);
-	  uintmax_t param_off = (uintmax_t) read_4ubyte_unaligned (dbg, data);
-	  if (! print_unresolved_addresses && cu != NULL)
-	    param_off += cu->start;
-	  printf ("%*s[%2" PRIuMAX "] %s [%6" PRIxMAX "]\n",
-		  indent, "", (uintmax_t) offset, op_name, param_off);
-	  CONSUME (4);
-	  data += 4;
-	  offset += 5;
-	  break;
-
-	default:
-	  /* No Operand.  */
-	  printf ("%*s[%2" PRIuMAX "] %s\n",
-		  indent, "", (uintmax_t) offset, op_name);
-	  ++offset;
-	  break;
-	}
-
-      indent = indentrest;
-      continue;
-
-    invalid:
-      printf (_("%*s[%2" PRIuMAX "] %s  <TRUNCATED>\n"),
-	      indent, "", (uintmax_t) offset, op_name);
-      break;
-    }
-}
-
-
-struct listptr
-{
-  Dwarf_Off offset:(64 - 3);
-  bool addr64:1;
-  bool dwarf64:1;
-  bool warned:1;
-  struct Dwarf_CU *cu;
-  unsigned int attr;
-};
-
-#define listptr_offset_size(p)	((p)->dwarf64 ? 8 : 4)
-#define listptr_address_size(p)	((p)->addr64 ? 8 : 4)
-
-static Dwarf_Addr
-cudie_base (Dwarf_Die *cudie)
-{
-  Dwarf_Addr base;
-  /* Find the base address of the compilation unit.  It will normally
-     be specified by DW_AT_low_pc.  In DWARF-3 draft 4, the base
-     address could be overridden by DW_AT_entry_pc.  It's been
-     removed, but GCC emits DW_AT_entry_pc and not DW_AT_lowpc for
-     compilation units with discontinuous ranges.  */
-  if (unlikely (dwarf_lowpc (cudie, &base) != 0))
-    {
-      Dwarf_Attribute attr_mem;
-      if (dwarf_formaddr (dwarf_attr (cudie, DW_AT_entry_pc, &attr_mem),
-			  &base) != 0)
-	base = 0;
-    }
-  return base;
-}
-
-static Dwarf_Addr
-listptr_base (struct listptr *p)
-{
-  Dwarf_Die cu = CUDIE (p->cu);
-  return cudie_base (&cu);
-}
-
-/* To store the name used in compare_listptr */
-static const char *sort_listptr_name;
-
-static int
-compare_listptr (const void *a, const void *b)
-{
-  const char *name = sort_listptr_name;
-  struct listptr *p1 = (void *) a;
-  struct listptr *p2 = (void *) b;
-
-  if (p1->offset < p2->offset)
-    return -1;
-  if (p1->offset > p2->offset)
-    return 1;
-
-  if (!p1->warned && !p2->warned)
-    {
-      if (p1->addr64 != p2->addr64)
-	{
-	  p1->warned = p2->warned = true;
-	  error (0, 0,
-		 _("%s %#" PRIx64 " used with different address sizes"),
-		 name, (uint64_t) p1->offset);
-	}
-      if (p1->dwarf64 != p2->dwarf64)
-	{
-	  p1->warned = p2->warned = true;
-	  error (0, 0,
-		 _("%s %#" PRIx64 " used with different offset sizes"),
-		 name, (uint64_t) p1->offset);
-	}
-      if (listptr_base (p1) != listptr_base (p2))
-	{
-	  p1->warned = p2->warned = true;
-	  error (0, 0,
-		 _("%s %#" PRIx64 " used with different base addresses"),
-		 name, (uint64_t) p1->offset);
-	}
-      if (p1->attr != p2 ->attr)
-	{
-	  p1->warned = p2->warned = true;
-	  error (0, 0,
-		 _("%s %#" PRIx64
-			  " used with different attribute %s and %s"),
-		 name, (uint64_t) p1->offset, dwarf_attr_name (p1->attr),
-		 dwarf_attr_name (p2->attr));
-	}
-    }
-
-  return 0;
-}
-
-struct listptr_table
-{
-  size_t n;
-  size_t alloc;
-  struct listptr *table;
-};
-
-static struct listptr_table known_locsptr;
-static struct listptr_table known_loclistsptr;
-static struct listptr_table known_rangelistptr;
-static struct listptr_table known_rnglistptr;
-static struct listptr_table known_addrbases;
-static struct listptr_table known_stroffbases;
-
-static void
-reset_listptr (struct listptr_table *table)
-{
-  free (table->table);
-  table->table = NULL;
-  table->n = table->alloc = 0;
-}
-
-/* Returns false if offset doesn't fit.  See struct listptr.  */
-static bool
-notice_listptr (enum section_e section, struct listptr_table *table,
-		uint_fast8_t address_size, uint_fast8_t offset_size,
-		struct Dwarf_CU *cu, Dwarf_Off offset, unsigned int attr)
-{
-  if (print_debug_sections & section)
-    {
-      if (table->n == table->alloc)
-	{
-	  if (table->alloc == 0)
-	    table->alloc = 128;
-	  else
-	    table->alloc *= 2;
-	  table->table = xrealloc (table->table,
-				   table->alloc * sizeof table->table[0]);
-	}
-
-      struct listptr *p = &table->table[table->n++];
-
-      *p = (struct listptr)
-	{
-	  .addr64 = address_size == 8,
-	  .dwarf64 = offset_size == 8,
-	  .offset = offset,
-	  .cu = cu,
-	  .attr = attr
-	};
-
-      if (p->offset != offset)
-	{
-	  table->n--;
-	  return false;
-	}
-    }
-  return true;
-}
-
-static void
-sort_listptr (struct listptr_table *table, const char *name)
-{
-  if (table->n > 0)
-    {
-      sort_listptr_name = name;
-      qsort (table->table, table->n, sizeof table->table[0],
-	     &compare_listptr);
-    }
-}
-
-static bool
-skip_listptr_hole (struct listptr_table *table, size_t *idxp,
-		   uint_fast8_t *address_sizep, uint_fast8_t *offset_sizep,
-		   Dwarf_Addr *base, struct Dwarf_CU **cu, ptrdiff_t offset,
-		   unsigned char **readp, unsigned char *endp,
-		   unsigned int *attr)
-{
-  if (table->n == 0)
-    return false;
-
-  while (*idxp < table->n && table->table[*idxp].offset < (Dwarf_Off) offset)
-    ++*idxp;
-
-  struct listptr *p = &table->table[*idxp];
-
-  if (*idxp == table->n
-      || p->offset >= (Dwarf_Off) (endp - *readp + offset))
-    {
-      *readp = endp;
-      printf (_(" [%6tx]  <UNUSED GARBAGE IN REST OF SECTION>\n"),
-	      offset);
-      return true;
-    }
-
-  if (p->offset != (Dwarf_Off) offset)
-    {
-      *readp += p->offset - offset;
-      printf (_(" [%6tx]  <UNUSED GARBAGE> ... %" PRIu64 " bytes ...\n"),
-	      offset, (Dwarf_Off) p->offset - offset);
-      return true;
-    }
-
-  if (address_sizep != NULL)
-    *address_sizep = listptr_address_size (p);
-  if (offset_sizep != NULL)
-    *offset_sizep = listptr_offset_size (p);
-  if (base != NULL)
-    *base = listptr_base (p);
-  if (cu != NULL)
-    *cu = p->cu;
-  if (attr != NULL)
-    *attr = p->attr;
-
-  return false;
-}
-
-static Dwarf_Off
-next_listptr_offset (struct listptr_table *table, size_t *idxp, Dwarf_Off off)
-{
-  /* Note that multiple attributes could in theory point to the same loclist
-     offset, so make sure we pick one that is bigger than the current one.
-     The table is sorted on offset.  */
-  if (*idxp < table->n)
-    {
-      while (++*idxp < table->n)
-	{
-	  Dwarf_Off next = table->table[*idxp].offset;
-	  if (next > off)
-	    return next;
-	}
-    }
-  return 0;
-}
-
-/* Returns the listptr associated with the given index, or NULL.  */
-static struct listptr *
-get_listptr (struct listptr_table *table, size_t idx)
-{
-  if (idx >= table->n)
-    return NULL;
-  return &table->table[idx];
-}
-
-/* Returns the next index, base address and CU associated with the
-   list unit offsets.  If there is none false is returned, otherwise
-   true.  Assumes the table has been sorted.  */
-static bool
-listptr_cu (struct listptr_table *table, size_t *idxp,
-	    Dwarf_Off start, Dwarf_Off end,
-	    Dwarf_Addr *base, struct Dwarf_CU **cu)
-{
-  while (*idxp < table->n
-	 && table->table[*idxp].offset < start)
-    ++*idxp;
-
-  if (*idxp < table->n
-      && table->table[*idxp].offset >= start
-      && table->table[*idxp].offset < end)
-    {
-      struct listptr *p = &table->table[*idxp];
-      *base = listptr_base (p);
-      *cu = p->cu;
-      return true;
-    }
-
-  return false;
-}
-
-/* Returns the next index with the current CU for the given attribute.
-   If there is none false is returned, otherwise true.  Assumes the
-   table has been sorted.  */
-static bool
-listptr_attr (struct listptr_table *table, size_t idxp,
-	      Dwarf_Off offset, unsigned int attr)
-{
-  struct listptr *listptr;
-  do
-    {
-      listptr = get_listptr (table, idxp);
-      if (listptr == NULL)
-	return false;
-
-      if (listptr->offset == offset && listptr->attr == attr)
-	return true;
-
-      idxp++;
-    }
-  while (listptr->offset <= offset);
-
-  return false;
-}
-
-static void
-print_debug_abbrev_section (Dwfl_Module *dwflmod __attribute__ ((unused)),
-			    Ebl *ebl, GElf_Ehdr *ehdr __attribute__ ((unused)),
-			    Elf_Scn *scn, GElf_Shdr *shdr, Dwarf *dbg)
-{
-  const size_t sh_size = (dbg->sectiondata[IDX_debug_abbrev] ?
-			  dbg->sectiondata[IDX_debug_abbrev]->d_size : 0);
-
-  printf (_("\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n"
-		   " [ Code]\n"),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset);
-
-  Dwarf_Off offset = 0;
-  while (offset < sh_size)
-    {
-      printf (_("\nAbbreviation section at offset %" PRIu64 ":\n"),
-	      offset);
-
-      while (1)
-	{
-	  size_t length;
-	  Dwarf_Abbrev abbrev;
-
-	  int res = dwarf_offabbrev (dbg, offset, &length, &abbrev);
-	  if (res != 0)
-	    {
-	      if (unlikely (res < 0))
-		{
-		  printf (_("\
- *** error while reading abbreviation: %s\n"),
-			  dwarf_errmsg (-1));
-		  return;
-		}
-
-	      /* This is the NUL byte at the end of the section.  */
-	      ++offset;
-	      break;
-	    }
-
-	  /* We know these calls can never fail.  */
-	  unsigned int code = dwarf_getabbrevcode (&abbrev);
-	  unsigned int tag = dwarf_getabbrevtag (&abbrev);
-	  int has_children = dwarf_abbrevhaschildren (&abbrev);
-
-	  printf (_(" [%5u] offset: %" PRId64
-			   ", children: %s, tag: %s\n"),
-		  code, (int64_t) offset,
-		  has_children ? yes_str : no_str,
-		  dwarf_tag_name (tag));
-
-	  size_t cnt = 0;
-	  unsigned int name;
-	  unsigned int form;
-	  Dwarf_Sword data;
-	  Dwarf_Off enoffset;
-	  while (dwarf_getabbrevattr_data (&abbrev, cnt, &name, &form,
-					   &data, &enoffset) == 0)
-	    {
-	      printf ("          attr: %s, form: %s",
-		      dwarf_attr_name (name), dwarf_form_name (form));
-	      if (form == DW_FORM_implicit_const)
-		printf (" (%" PRId64 ")", data);
-	      printf (", offset: %#" PRIx64 "\n", (uint64_t) enoffset);
-	      ++cnt;
-	    }
-
-	  offset += length;
-	}
-    }
-}
-
-
-static void
-print_debug_addr_section (Dwfl_Module *dwflmod __attribute__ ((unused)),
-			  Ebl *ebl, GElf_Ehdr *ehdr,
-			  Elf_Scn *scn, GElf_Shdr *shdr, Dwarf *dbg)
-{
-  printf (_("\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n"),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset);
-
-  if (shdr->sh_size == 0)
-    return;
-
-  /* We like to get the section from libdw to make sure they are relocated.  */
-  Elf_Data *data = (dbg->sectiondata[IDX_debug_addr]
-		    ?: elf_rawdata (scn, NULL));
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get .debug_addr section data: %s"),
-	     elf_errmsg (-1));
-      return;
-    }
-
-  size_t idx = 0;
-  sort_listptr (&known_addrbases, "addr_base");
-
-  const unsigned char *start = (const unsigned char *) data->d_buf;
-  const unsigned char *readp = start;
-  const unsigned char *readendp = ((const unsigned char *) data->d_buf
-				   + data->d_size);
-
-  while (readp < readendp)
-    {
-      /* We cannot really know whether or not there is an header.  The
-	 DebugFission extension to DWARF4 doesn't add one.  The DWARF5
-	 .debug_addr variant does.  Whether or not we have an header,
-	 DW_AT_[GNU_]addr_base points at "index 0".  So if the current
-	 offset equals the CU addr_base then we can just start
-	 printing addresses.  If there is no CU with an exact match
-	 then we'll try to parse the header first.  */
-      Dwarf_Off off = (Dwarf_Off) (readp
-				   - (const unsigned char *) data->d_buf);
-
-      printf ("Table at offset %" PRIx64 " ", off);
-
-      struct listptr *listptr = get_listptr (&known_addrbases, idx++);
-      const unsigned char *next_unitp;
-
-      uint64_t unit_length;
-      uint16_t version;
-      uint8_t address_size;
-      uint8_t segment_size;
-      if (listptr == NULL)
-	{
-	  error (0, 0, "Warning: No CU references .debug_addr after %" PRIx64,
-		 off);
-
-	  /* We will have to assume it is just addresses to the end... */
-	  address_size = ehdr->e_ident[EI_CLASS] == ELFCLASS32 ? 4 : 8;
-	  next_unitp = readendp;
-	  printf ("Unknown CU:\n");
-	}
-      else
-	{
-	  Dwarf_Die cudie;
-	  if (dwarf_cu_die (listptr->cu, &cudie,
-			    NULL, NULL, NULL, NULL,
-			    NULL, NULL) == NULL)
-	    printf ("Unknown CU (%s):\n", dwarf_errmsg (-1));
-	  else
-	    printf ("for CU [%6" PRIx64 "]:\n", dwarf_dieoffset (&cudie));
-
-	  if (listptr->offset == off)
-	    {
-	      address_size = listptr_address_size (listptr);
-	      segment_size = 0;
-	      version = 4;
-
-	      /* The addresses start here, but where do they end?  */
-	      listptr = get_listptr (&known_addrbases, idx);
-	      if (listptr == NULL)
-		next_unitp = readendp;
-	      else if (listptr->cu->version < 5)
-		{
-		  next_unitp = start + listptr->offset;
-		  if (listptr->offset < off || listptr->offset > data->d_size)
-		    {
-		      error (0, 0,
-			     "Warning: Bad address base for next unit at %"
-			     PRIx64, off);
-		      next_unitp = readendp;
-		    }
-		}
-	      else
-		{
-		  /* Tricky, we don't have a header for this unit, but
-		     there is one for the next.  We will have to
-		     "guess" how big it is and subtract it from the
-		     offset (because that points after the header).  */
-		  unsigned int offset_size = listptr_offset_size (listptr);
-		  Dwarf_Off next_off = (listptr->offset
-					- (offset_size == 4 ? 4 : 12) /* len */
-					- 2 /* version */
-					- 1 /* address size */
-					- 1); /* segment selector size */
-		  next_unitp = start + next_off;
-		  if (next_off < off || next_off > data->d_size)
-		    {
-		      error (0, 0,
-			     "Warning: Couldn't calculate .debug_addr "
-			     " unit length at %" PRIx64, off);
-		      next_unitp = readendp;
-		    }
-		}
-	      unit_length = (uint64_t) (next_unitp - readp);
-
-	      /* Pretend we have a header.  */
-	      printf ("\n");
-	      printf (_(" Length:         %8" PRIu64 "\n"),
-		      unit_length);
-	      printf (_(" DWARF version:  %8" PRIu16 "\n"), version);
-	      printf (_(" Address size:   %8" PRIu64 "\n"),
-		      (uint64_t) address_size);
-	      printf (_(" Segment size:   %8" PRIu64 "\n"),
-		      (uint64_t) segment_size);
-	      printf ("\n");
-	    }
-	  else
-	    {
-	      /* OK, we have to parse an header first.  */
-	      unit_length = read_4ubyte_unaligned_inc (dbg, readp);
-	      if (unlikely (unit_length == 0xffffffff))
-		{
-		  if (unlikely (readp > readendp - 8))
-		    {
-		    invalid_data:
-		      error (0, 0, "Invalid data");
-		      return;
-		    }
-		  unit_length = read_8ubyte_unaligned_inc (dbg, readp);
-		}
-	      printf ("\n");
-	      printf (_(" Length:         %8" PRIu64 "\n"),
-		      unit_length);
-
-	      /* We need at least 2-bytes (version) + 1-byte
-		 (addr_size) + 1-byte (segment_size) = 4 bytes to
-		 complete the header.  And this unit cannot go beyond
-		 the section data.  */
-	      if (readp > readendp - 4
-		  || unit_length < 4
-		  || unit_length > (uint64_t) (readendp - readp))
-		goto invalid_data;
-
-	      next_unitp = readp + unit_length;
-
-	      version = read_2ubyte_unaligned_inc (dbg, readp);
-	      printf (_(" DWARF version:  %8" PRIu16 "\n"), version);
-
-	      if (version != 5)
-		{
-		  error (0, 0, _("Unknown version"));
-		  goto next_unit;
-		}
-
-	      address_size = *readp++;
-	      printf (_(" Address size:   %8" PRIu64 "\n"),
-		      (uint64_t) address_size);
-
-	      if (address_size != 4 && address_size != 8)
-		{
-		  error (0, 0, _("unsupported address size"));
-		  goto next_unit;
-		}
-
-	      segment_size = *readp++;
-	      printf (_(" Segment size:   %8" PRIu64 "\n"),
-		      (uint64_t) segment_size);
-	      printf ("\n");
-
-	      if (segment_size != 0)
-		{
-		  error (0, 0, _("unsupported segment size"));
-		  goto next_unit;
-		}
-
-	      if (listptr->offset != (Dwarf_Off) (readp - start))
-		{
-		  error (0, 0, "Address index doesn't start after header");
-		  goto next_unit;
-		}
-	    }
-	}
-
-      int digits = 1;
-      size_t addresses = (next_unitp - readp) / address_size;
-      while (addresses >= 10)
-	{
-	  ++digits;
-	  addresses /= 10;
-	}
-
-      unsigned int uidx = 0;
-      size_t index_offset =  readp - (const unsigned char *) data->d_buf;
-      printf (" Addresses start at offset 0x%zx:\n", index_offset);
-      while (readp <= next_unitp - address_size)
-	{
-	  Dwarf_Addr addr = read_addr_unaligned_inc (address_size, dbg,
-						     readp);
-	  printf (" [%*u] ", digits, uidx++);
-	  print_dwarf_addr (dwflmod, address_size, addr, addr);
-	  printf ("\n");
-	}
-      printf ("\n");
-
-      if (readp != next_unitp)
-	error (0, 0, "extra %zd bytes at end of unit",
-	       (size_t) (next_unitp - readp));
-
-    next_unit:
-      readp = next_unitp;
-    }
-}
-
-/* Print content of DWARF .debug_aranges section.  We fortunately do
-   not have to know a bit about the structure of the section, libdwarf
-   takes care of it.  */
-static void
-print_decoded_aranges_section (Ebl *ebl, GElf_Ehdr *ehdr, Elf_Scn *scn,
-			       GElf_Shdr *shdr, Dwarf *dbg)
-{
-  Dwarf_Aranges *aranges;
-  size_t cnt;
-  if (unlikely (dwarf_getaranges (dbg, &aranges, &cnt) != 0))
-    {
-      error (0, 0, _("cannot get .debug_aranges content: %s"),
-	     dwarf_errmsg (-1));
-      return;
-    }
-
-  GElf_Shdr glink_mem;
-  GElf_Shdr *glink;
-  glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link), &glink_mem);
-  if (glink == NULL)
-    {
-      error (0, 0, _("invalid sh_link value in section %zu"),
-	     elf_ndxscn (scn));
-      return;
-    }
-
-  printf (ngettext ("\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 " contains %zu entry:\n",
-		    "\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 " contains %zu entries:\n",
-		    cnt),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset, cnt);
-
-  /* Compute floor(log16(cnt)).  */
-  size_t tmp = cnt;
-  int digits = 1;
-  while (tmp >= 16)
-    {
-      ++digits;
-      tmp >>= 4;
-    }
-
-  for (size_t n = 0; n < cnt; ++n)
-    {
-      Dwarf_Arange *runp = dwarf_onearange (aranges, n);
-      if (unlikely (runp == NULL))
-	{
-	  printf ("cannot get arange %zu: %s\n", n, dwarf_errmsg (-1));
-	  return;
-	}
-
-      Dwarf_Addr start;
-      Dwarf_Word length;
-      Dwarf_Off offset;
-
-      if (unlikely (dwarf_getarangeinfo (runp, &start, &length, &offset) != 0))
-	printf (_(" [%*zu] ???\n"), digits, n);
-      else
-	printf (_(" [%*zu] start: %0#*" PRIx64
-			 ", length: %5" PRIu64 ", CU DIE offset: %6"
-			 PRId64 "\n"),
-		digits, n, ehdr->e_ident[EI_CLASS] == ELFCLASS32 ? 10 : 18,
-		(uint64_t) start, (uint64_t) length, (int64_t) offset);
-    }
-}
-
-
-/* Print content of DWARF .debug_aranges section.  */
-static void
-print_debug_aranges_section (Dwfl_Module *dwflmod __attribute__ ((unused)),
-			     Ebl *ebl, GElf_Ehdr *ehdr, Elf_Scn *scn,
-			     GElf_Shdr *shdr, Dwarf *dbg)
-{
-  if (decodedaranges)
-    {
-      print_decoded_aranges_section (ebl, ehdr, scn, shdr, dbg);
-      return;
-    }
-
-  Elf_Data *data = (dbg->sectiondata[IDX_debug_aranges]
-		    ?: elf_rawdata (scn, NULL));
-
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get .debug_aranges content: %s"),
-	     elf_errmsg (-1));
-      return;
-    }
-
-  printf (_("\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n"),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset);
-
-  const unsigned char *readp = data->d_buf;
-  const unsigned char *readendp = readp + data->d_size;
-
-  while (readp < readendp)
-    {
-      const unsigned char *hdrstart = readp;
-      size_t start_offset = hdrstart - (const unsigned char *) data->d_buf;
-
-      printf (_("\nTable at offset %zu:\n"), start_offset);
-      if (readp + 4 > readendp)
-	{
-	invalid_data:
-	  error (0, 0, _("invalid data in section [%zu] '%s'"),
-		 elf_ndxscn (scn), section_name (ebl, shdr));
-	  return;
-	}
-
-      Dwarf_Word length = read_4ubyte_unaligned_inc (dbg, readp);
-      unsigned int length_bytes = 4;
-      if (length == DWARF3_LENGTH_64_BIT)
-	{
-	  if (readp + 8 > readendp)
-	    goto invalid_data;
-	  length = read_8ubyte_unaligned_inc (dbg, readp);
-	  length_bytes = 8;
-	}
-
-      const unsigned char *nexthdr = readp + length;
-      printf (_("\n Length:        %6" PRIu64 "\n"),
-	      (uint64_t) length);
-
-      if (unlikely (length > (size_t) (readendp - readp)))
-	goto invalid_data;
-
-      if (length == 0)
-	continue;
-
-      if (readp + 2 > readendp)
-	goto invalid_data;
-      uint_fast16_t version = read_2ubyte_unaligned_inc (dbg, readp);
-      printf (_(" DWARF version: %6" PRIuFAST16 "\n"),
-	      version);
-      if (version != 2)
-	{
-	  error (0, 0, _("unsupported aranges version"));
-	  goto next_table;
-	}
-
-      Dwarf_Word offset;
-      if (readp + length_bytes > readendp)
-	goto invalid_data;
-      if (length_bytes == 8)
-	offset = read_8ubyte_unaligned_inc (dbg, readp);
-      else
-	offset = read_4ubyte_unaligned_inc (dbg, readp);
-      printf (_(" CU offset:     %6" PRIx64 "\n"),
-	      (uint64_t) offset);
-
-      if (readp + 1 > readendp)
-	goto invalid_data;
-      unsigned int address_size = *readp++;
-      printf (_(" Address size:  %6" PRIu64 "\n"),
-	      (uint64_t) address_size);
-      if (address_size != 4 && address_size != 8)
-	{
-	  error (0, 0, _("unsupported address size"));
-	  goto next_table;
-	}
-
-      if (readp + 1 > readendp)
-	goto invalid_data;
-      unsigned int segment_size = *readp++;
-      printf (_(" Segment size:  %6" PRIu64 "\n\n"),
-	      (uint64_t) segment_size);
-      if (segment_size != 0 && segment_size != 4 && segment_size != 8)
-	{
-	  error (0, 0, _("unsupported segment size"));
-	  goto next_table;
-	}
-
-      /* Round the address to the next multiple of 2*address_size.  */
-      readp += ((2 * address_size - ((readp - hdrstart) % (2 * address_size)))
-		% (2 * address_size));
-
-      while (readp < nexthdr)
-	{
-	  Dwarf_Word range_address;
-	  Dwarf_Word range_length;
-	  Dwarf_Word segment = 0;
-	  if (readp + 2 * address_size + segment_size > readendp)
-	    goto invalid_data;
-	  if (address_size == 4)
-	    {
-	      range_address = read_4ubyte_unaligned_inc (dbg, readp);
-	      range_length = read_4ubyte_unaligned_inc (dbg, readp);
-	    }
-	  else
-	    {
-	      range_address = read_8ubyte_unaligned_inc (dbg, readp);
-	      range_length = read_8ubyte_unaligned_inc (dbg, readp);
-	    }
-
-	  if (segment_size == 4)
-	    segment = read_4ubyte_unaligned_inc (dbg, readp);
-	  else if (segment_size == 8)
-	    segment = read_8ubyte_unaligned_inc (dbg, readp);
-
-	  if (range_address == 0 && range_length == 0 && segment == 0)
-	    break;
-
-	  printf ("   ");
-	  print_dwarf_addr (dwflmod, address_size, range_address,
-			    range_address);
-	  printf ("..");
-	  print_dwarf_addr (dwflmod, address_size,
-			    range_address + range_length - 1,
-			    range_length);
-	  if (segment_size != 0)
-	    printf (" (%" PRIx64 ")\n", (uint64_t) segment);
-	  else
-	    printf ("\n");
-	}
-
-    next_table:
-      if (readp != nexthdr)
-	{
-	  size_t padding = nexthdr - readp;
-	  printf (_("   %zu padding bytes\n"), padding);
-	  readp = nexthdr;
-	}
-    }
-}
-
-
-static bool is_split_dwarf (Dwarf *dbg, uint64_t *id, Dwarf_CU **split_cu);
-
-/* Returns true and sets cu and cu_base if the given Dwarf is a split
-   DWARF (.dwo) file.  */
-static bool
-split_dwarf_cu_base (Dwarf *dbg, Dwarf_CU **cu, Dwarf_Addr *cu_base)
-{
-  uint64_t id;
-  if (is_split_dwarf (dbg, &id, cu))
-    {
-      Dwarf_Die cudie;
-      if (dwarf_cu_info (*cu, NULL, NULL, &cudie, NULL, NULL, NULL, NULL) == 0)
-	{
-	  *cu_base = cudie_base (&cudie);
-	  return true;
-	}
-    }
-  return false;
-}
-
-/* Print content of DWARF .debug_rnglists section.  */
-static void
-print_debug_rnglists_section (Dwfl_Module *dwflmod,
-			      Ebl *ebl,
-			      GElf_Ehdr *ehdr __attribute__ ((unused)),
-			      Elf_Scn *scn, GElf_Shdr *shdr,
-			      Dwarf *dbg __attribute__((unused)))
-{
-  printf (_("\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n"),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset);
-
-  Elf_Data *data =(dbg->sectiondata[IDX_debug_rnglists]
-		   ?: elf_rawdata (scn, NULL));
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get .debug_rnglists content: %s"),
-	     elf_errmsg (-1));
-      return;
-    }
-
-  /* For the listptr to get the base address/CU.  */
-  sort_listptr (&known_rnglistptr, "rnglistptr");
-  size_t listptr_idx = 0;
-
-  const unsigned char *readp = data->d_buf;
-  const unsigned char *const dataend = ((unsigned char *) data->d_buf
-					+ data->d_size);
-  while (readp < dataend)
-    {
-      if (unlikely (readp > dataend - 4))
-	{
-	invalid_data:
-	  error (0, 0, _("invalid data in section [%zu] '%s'"),
-		 elf_ndxscn (scn), section_name (ebl, shdr));
-	  return;
-	}
-
-      ptrdiff_t offset = readp - (unsigned char *) data->d_buf;
-      printf (_("Table at Offset 0x%" PRIx64 ":\n\n"),
-	      (uint64_t) offset);
-
-      uint64_t unit_length = read_4ubyte_unaligned_inc (dbg, readp);
-      unsigned int offset_size = 4;
-      if (unlikely (unit_length == 0xffffffff))
-	{
-	  if (unlikely (readp > dataend - 8))
-	    goto invalid_data;
-
-	  unit_length = read_8ubyte_unaligned_inc (dbg, readp);
-	  offset_size = 8;
-	}
-      printf (_(" Length:         %8" PRIu64 "\n"), unit_length);
-
-      /* We need at least 2-bytes + 1-byte + 1-byte + 4-bytes = 8
-	 bytes to complete the header.  And this unit cannot go beyond
-	 the section data.  */
-      if (readp > dataend - 8
-	  || unit_length < 8
-	  || unit_length > (uint64_t) (dataend - readp))
-	goto invalid_data;
-
-      const unsigned char *nexthdr = readp + unit_length;
-
-      uint16_t version = read_2ubyte_unaligned_inc (dbg, readp);
-      printf (_(" DWARF version:  %8" PRIu16 "\n"), version);
-
-      if (version != 5)
-	{
-	  error (0, 0, _("Unknown version"));
-	  goto next_table;
-	}
-
-      uint8_t address_size = *readp++;
-      printf (_(" Address size:   %8" PRIu64 "\n"),
-	      (uint64_t) address_size);
-
-      if (address_size != 4 && address_size != 8)
-	{
-	  error (0, 0, _("unsupported address size"));
-	  goto next_table;
-	}
-
-      uint8_t segment_size = *readp++;
-      printf (_(" Segment size:   %8" PRIu64 "\n"),
-	      (uint64_t) segment_size);
-
-      if (segment_size != 0 && segment_size != 4 && segment_size != 8)
-        {
-          error (0, 0, _("unsupported segment size"));
-          goto next_table;
-        }
-
-      uint32_t offset_entry_count = read_4ubyte_unaligned_inc (dbg, readp);
-      printf (_(" Offset entries: %8" PRIu64 "\n"),
-	      (uint64_t) offset_entry_count);
-
-      /* We need the CU that uses this unit to get the initial base address. */
-      Dwarf_Addr cu_base = 0;
-      struct Dwarf_CU *cu = NULL;
-      if (listptr_cu (&known_rnglistptr, &listptr_idx,
-		      (Dwarf_Off) offset,
-		      (Dwarf_Off) (nexthdr - (unsigned char *) data->d_buf),
-		      &cu_base, &cu)
-	  || split_dwarf_cu_base (dbg, &cu, &cu_base))
-	{
-	  Dwarf_Die cudie;
-	  if (dwarf_cu_die (cu, &cudie,
-			    NULL, NULL, NULL, NULL,
-			    NULL, NULL) == NULL)
-	    printf (_(" Unknown CU base: "));
-	  else
-	    printf (_(" CU [%6" PRIx64 "] base: "),
-		    dwarf_dieoffset (&cudie));
-	  print_dwarf_addr (dwflmod, address_size, cu_base, cu_base);
-	  printf ("\n");
-	}
-      else
-	printf (_(" Not associated with a CU.\n"));
-
-      printf ("\n");
-
-      const unsigned char *offset_array_start = readp;
-      if (offset_entry_count > 0)
-	{
-	  uint64_t max_entries = (unit_length - 8) / offset_size;
-	  if (offset_entry_count > max_entries)
-	    {
-	      error (0, 0,
-		     _("too many offset entries for unit length"));
-	      offset_entry_count = max_entries;
-	    }
-
-	  printf (_("  Offsets starting at 0x%" PRIx64 ":\n"),
-		  (uint64_t) (offset_array_start
-			      - (unsigned char *) data->d_buf));
-	  for (uint32_t idx = 0; idx < offset_entry_count; idx++)
-	    {
-	      printf ("   [%6" PRIu32 "] ", idx);
-	      if (offset_size == 4)
-		{
-		  uint32_t off = read_4ubyte_unaligned_inc (dbg, readp);
-		  printf ("0x%" PRIx32 "\n", off);
-		}
-	      else
-		{
-		  uint64_t off = read_8ubyte_unaligned_inc (dbg, readp);
-		  printf ("0x%" PRIx64 "\n", off);
-		}
-	    }
-	  printf ("\n");
-	}
-
-      Dwarf_Addr base = cu_base;
-      bool start_of_list = true;
-      while (readp < nexthdr)
-	{
-	  uint8_t kind = *readp++;
-	  uint64_t op1, op2;
-
-	  /* Skip padding.  */
-	  if (start_of_list && kind == DW_RLE_end_of_list)
-	    continue;
-
-	  if (start_of_list)
-	    {
-	      base = cu_base;
-	      printf ("  Offset: %" PRIx64 ", Index: %" PRIx64 "\n",
-		      (uint64_t) (readp - (unsigned char *) data->d_buf - 1),
-		      (uint64_t) (readp - offset_array_start - 1));
-	      start_of_list = false;
-	    }
-
-	  printf ("    %s", dwarf_range_list_encoding_name (kind));
-	  switch (kind)
-	    {
-	    case DW_RLE_end_of_list:
-	      start_of_list = true;
-	      printf ("\n\n");
-	      break;
-
-	    case DW_RLE_base_addressx:
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		{
-		invalid_range:
-		  error (0, 0, _("invalid range list data"));
-		  goto next_table;
-		}
-	      get_uleb128 (op1, readp, nexthdr);
-	      printf (" %" PRIx64 "\n", op1);
-	      if (! print_unresolved_addresses)
-		{
-		  Dwarf_Addr addr;
-		  if (get_indexed_addr (cu, op1, &addr) != 0)
-		    printf ("      ???\n");
-		  else
-		    {
-		      printf ("      ");
-		      print_dwarf_addr (dwflmod, address_size, addr, addr);
-		      printf ("\n");
-		    }
-		}
-	      break;
-
-	    case DW_RLE_startx_endx:
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_range;
-	      get_uleb128 (op1, readp, nexthdr);
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_range;
-	      get_uleb128 (op2, readp, nexthdr);
-	      printf (" %" PRIx64 ", %" PRIx64 "\n", op1, op2);
-	      if (! print_unresolved_addresses)
-		{
-		  Dwarf_Addr addr1;
-		  Dwarf_Addr addr2;
-		  if (get_indexed_addr (cu, op1, &addr1) != 0
-		      || get_indexed_addr (cu, op2, &addr2) != 0)
-		    {
-		      printf ("      ???..\n");
-		      printf ("      ???\n");
-		    }
-		  else
-		    {
-		      printf ("      ");
-		      print_dwarf_addr (dwflmod, address_size, addr1, addr1);
-		      printf ("..\n      ");
-		      print_dwarf_addr (dwflmod, address_size,
-					addr2 - 1, addr2);
-		      printf ("\n");
-		    }
-		}
-	      break;
-
-	    case DW_RLE_startx_length:
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_range;
-	      get_uleb128 (op1, readp, nexthdr);
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_range;
-	      get_uleb128 (op2, readp, nexthdr);
-	      printf (" %" PRIx64 ", %" PRIx64 "\n", op1, op2);
-	      if (! print_unresolved_addresses)
-		{
-		  Dwarf_Addr addr1;
-		  Dwarf_Addr addr2;
-		  if (get_indexed_addr (cu, op1, &addr1) != 0)
-		    {
-		      printf ("      ???..\n");
-		      printf ("      ???\n");
-		    }
-		  else
-		    {
-		      addr2 = addr1 + op2;
-		      printf ("      ");
-		      print_dwarf_addr (dwflmod, address_size, addr1, addr1);
-		      printf ("..\n      ");
-		      print_dwarf_addr (dwflmod, address_size,
-					addr2 - 1, addr2);
-		      printf ("\n");
-		    }
-		}
-	      break;
-
-	    case DW_RLE_offset_pair:
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_range;
-	      get_uleb128 (op1, readp, nexthdr);
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_range;
-	      get_uleb128 (op2, readp, nexthdr);
-	      printf (" %" PRIx64 ", %" PRIx64 "\n", op1, op2);
-	      if (! print_unresolved_addresses)
-		{
-		  op1 += base;
-		  op2 += base;
-		  printf ("      ");
-		  print_dwarf_addr (dwflmod, address_size, op1, op1);
-		  printf ("..\n      ");
-		  print_dwarf_addr (dwflmod, address_size, op2 - 1, op2);
-		  printf ("\n");
-		}
-	      break;
-
-	    case DW_RLE_base_address:
-	      if (address_size == 4)
-		{
-		  if ((uint64_t) (nexthdr - readp) < 4)
-		    goto invalid_range;
-		  op1 = read_4ubyte_unaligned_inc (dbg, readp);
-		}
-	      else
-		{
-		  if ((uint64_t) (nexthdr - readp) < 8)
-		    goto invalid_range;
-		  op1 = read_8ubyte_unaligned_inc (dbg, readp);
-		}
-	      base = op1;
-	      printf (" 0x%" PRIx64 "\n", base);
-	      if (! print_unresolved_addresses)
-		{
-		  printf ("      ");
-		  print_dwarf_addr (dwflmod, address_size, base, base);
-		  printf ("\n");
-		}
-	      break;
-
-	    case DW_RLE_start_end:
-	      if (address_size == 4)
-		{
-		  if ((uint64_t) (nexthdr - readp) < 8)
-		    goto invalid_range;
-		  op1 = read_4ubyte_unaligned_inc (dbg, readp);
-		  op2 = read_4ubyte_unaligned_inc (dbg, readp);
-		}
-	      else
-		{
-		  if ((uint64_t) (nexthdr - readp) < 16)
-		    goto invalid_range;
-		  op1 = read_8ubyte_unaligned_inc (dbg, readp);
-		  op2 = read_8ubyte_unaligned_inc (dbg, readp);
-		}
-	      printf (" 0x%" PRIx64 "..0x%" PRIx64 "\n", op1, op2);
-	      if (! print_unresolved_addresses)
-		{
-		  printf ("      ");
-		  print_dwarf_addr (dwflmod, address_size, op1, op1);
-		  printf ("..\n      ");
-		  print_dwarf_addr (dwflmod, address_size, op2 - 1, op2);
-		  printf ("\n");
-		}
-	      break;
-
-	    case DW_RLE_start_length:
-	      if (address_size == 4)
-		{
-		  if ((uint64_t) (nexthdr - readp) < 4)
-		    goto invalid_range;
-		  op1 = read_4ubyte_unaligned_inc (dbg, readp);
-		}
-	      else
-		{
-		  if ((uint64_t) (nexthdr - readp) < 8)
-		    goto invalid_range;
-		  op1 = read_8ubyte_unaligned_inc (dbg, readp);
-		}
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_range;
-	      get_uleb128 (op2, readp, nexthdr);
-	      printf (" 0x%" PRIx64 ", %" PRIx64 "\n", op1, op2);
-	      if (! print_unresolved_addresses)
-		{
-		  op2 = op1 + op2;
-		  printf ("      ");
-		  print_dwarf_addr (dwflmod, address_size, op1, op1);
-		  printf ("..\n      ");
-		  print_dwarf_addr (dwflmod, address_size, op2 - 1, op2);
-		  printf ("\n");
-		}
-	      break;
-
-	    default:
-	      goto invalid_range;
-	    }
-	}
-
-    next_table:
-      if (readp != nexthdr)
-	{
-          size_t padding = nexthdr - readp;
-          printf (_("   %zu padding bytes\n\n"), padding);
-	  readp = nexthdr;
-	}
-    }
-}
-
-/* Print content of DWARF .debug_ranges section.  */
-static void
-print_debug_ranges_section (Dwfl_Module *dwflmod,
-			    Ebl *ebl, GElf_Ehdr *ehdr,
-			    Elf_Scn *scn, GElf_Shdr *shdr,
-			    Dwarf *dbg)
-{
-  Elf_Data *data = (dbg->sectiondata[IDX_debug_ranges]
-		    ?: elf_rawdata (scn, NULL));
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get .debug_ranges content: %s"),
-	     elf_errmsg (-1));
-      return;
-    }
-
-  printf (_("\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n"),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset);
-
-  sort_listptr (&known_rangelistptr, "rangelistptr");
-  size_t listptr_idx = 0;
-
-  uint_fast8_t address_size = ehdr->e_ident[EI_CLASS] == ELFCLASS32 ? 4 : 8;
-
-  bool first = true;
-  Dwarf_Addr base = 0;
-  unsigned char *const endp = (unsigned char *) data->d_buf + data->d_size;
-  unsigned char *readp = data->d_buf;
-  Dwarf_CU *last_cu = NULL;
-  while (readp < endp)
-    {
-      ptrdiff_t offset = readp - (unsigned char *) data->d_buf;
-      Dwarf_CU *cu = last_cu;
-
-      if (first && skip_listptr_hole (&known_rangelistptr, &listptr_idx,
-				      &address_size, NULL, &base, &cu,
-				      offset, &readp, endp, NULL))
-	continue;
-
-      if (last_cu != cu)
-	{
-	  Dwarf_Die cudie;
-	  if (dwarf_cu_die (cu, &cudie,
-			    NULL, NULL, NULL, NULL,
-			    NULL, NULL) == NULL)
-	    printf (_("\n Unknown CU base: "));
-	  else
-	    printf (_("\n CU [%6" PRIx64 "] base: "),
-		    dwarf_dieoffset (&cudie));
-	  print_dwarf_addr (dwflmod, address_size, base, base);
-	  printf ("\n");
-	}
-      last_cu = cu;
-
-      if (unlikely (data->d_size - offset < (size_t) address_size * 2))
-	{
-	  printf (_(" [%6tx]  <INVALID DATA>\n"), offset);
-	  break;
-	}
-
-      Dwarf_Addr begin;
-      Dwarf_Addr end;
-      if (address_size == 8)
-	{
-	  begin = read_8ubyte_unaligned_inc (dbg, readp);
-	  end = read_8ubyte_unaligned_inc (dbg, readp);
-	}
-      else
-	{
-	  begin = read_4ubyte_unaligned_inc (dbg, readp);
-	  end = read_4ubyte_unaligned_inc (dbg, readp);
-	  if (begin == (Dwarf_Addr) (uint32_t) -1)
-	    begin = (Dwarf_Addr) -1l;
-	}
-
-      if (begin == (Dwarf_Addr) -1l) /* Base address entry.  */
-	{
-	  if (first)
-	    printf (" [%6tx] ", offset);
-	  else
-	    printf ("          ");
-	  puts (_("base address"));
-	  printf ("          ");
-	  print_dwarf_addr (dwflmod, address_size, end, end);
-	  printf ("\n");
-	  base = end;
-	  first = false;
-	}
-      else if (begin == 0 && end == 0) /* End of list entry.  */
-	{
-	  if (first)
-	    printf (_(" [%6tx] empty list\n"), offset);
-	  first = true;
-	}
-      else
-	{
-	  /* We have an address range entry.  */
-	  if (first)		/* First address range entry in a list.  */
-	    printf (" [%6tx] ", offset);
-	  else
-	    printf ("          ");
-
-	  printf ("range %" PRIx64 ", %" PRIx64 "\n", begin, end);
-	  if (! print_unresolved_addresses)
-	    {
-	      printf ("          ");
-	      print_dwarf_addr (dwflmod, address_size, base + begin,
-			        base + begin);
-	      printf ("..\n          ");
-	      print_dwarf_addr (dwflmod, address_size,
-				base + end - 1, base + end);
-	      printf ("\n");
-	    }
-
-	  first = false;
-	}
-    }
-}
-
-#define REGNAMESZ 16
-static const char *
-register_info (Ebl *ebl, unsigned int regno, const Ebl_Register_Location *loc,
-	       char name[REGNAMESZ], int *bits, int *type)
-{
-  const char *set;
-  const char *pfx;
-  int ignore;
-  ssize_t n = ebl_register_info (ebl, regno, name, REGNAMESZ, &pfx, &set,
-				 bits ?: &ignore, type ?: &ignore);
-  if (n <= 0)
-    {
-      if (loc != NULL)
-	snprintf (name, REGNAMESZ, "reg%u", loc->regno);
-      else
-	snprintf (name, REGNAMESZ, "??? 0x%x", regno);
-      if (bits != NULL)
-	*bits = loc != NULL ? loc->bits : 0;
-      if (type != NULL)
-	*type = DW_ATE_unsigned;
-      set = "??? unrecognized";
-    }
-  else
-    {
-      if (bits != NULL && *bits <= 0)
-	*bits = loc != NULL ? loc->bits : 0;
-      if (type != NULL && *type == DW_ATE_void)
-	*type = DW_ATE_unsigned;
-
-    }
-  return set;
-}
-
-static const unsigned char *
-read_encoded (unsigned int encoding, const unsigned char *readp,
-	      const unsigned char *const endp, uint64_t *res, Dwarf *dbg)
-{
-  if ((encoding & 0xf) == DW_EH_PE_absptr)
-    encoding = gelf_getclass (dbg->elf) == ELFCLASS32
-      ? DW_EH_PE_udata4 : DW_EH_PE_udata8;
-
-  switch (encoding & 0xf)
-    {
-    case DW_EH_PE_uleb128:
-      get_uleb128 (*res, readp, endp);
-      break;
-    case DW_EH_PE_sleb128:
-      get_sleb128 (*res, readp, endp);
-      break;
-    case DW_EH_PE_udata2:
-      if (readp + 2 > endp)
-	goto invalid;
-      *res = read_2ubyte_unaligned_inc (dbg, readp);
-      break;
-    case DW_EH_PE_udata4:
-      if (readp + 4 > endp)
-	goto invalid;
-      *res = read_4ubyte_unaligned_inc (dbg, readp);
-      break;
-    case DW_EH_PE_udata8:
-      if (readp + 8 > endp)
-	goto invalid;
-      *res = read_8ubyte_unaligned_inc (dbg, readp);
-      break;
-    case DW_EH_PE_sdata2:
-      if (readp + 2 > endp)
-	goto invalid;
-      *res = read_2sbyte_unaligned_inc (dbg, readp);
-      break;
-    case DW_EH_PE_sdata4:
-      if (readp + 4 > endp)
-	goto invalid;
-      *res = read_4sbyte_unaligned_inc (dbg, readp);
-      break;
-    case DW_EH_PE_sdata8:
-      if (readp + 8 > endp)
-	goto invalid;
-      *res = read_8sbyte_unaligned_inc (dbg, readp);
-      break;
-    default:
-    invalid:
-      error (1, 0,
-	     _("invalid encoding"));
-    }
-
-  return readp;
-}
-
-static const char *
-regname (Ebl *ebl, unsigned int regno, char *regnamebuf)
-{
-  register_info (ebl, regno, NULL, regnamebuf, NULL, NULL);
-
-  return regnamebuf;
-}
-
-static void
-print_cfa_program (const unsigned char *readp, const unsigned char *const endp,
-		   Dwarf_Word vma_base, unsigned int code_align,
-		   int data_align,
-		   unsigned int version, unsigned int ptr_size,
-		   unsigned int encoding,
-		   Dwfl_Module *dwflmod, Ebl *ebl, GElf_Ehdr *ehdr, Dwarf *dbg)
-{
-  char regnamebuf[REGNAMESZ];
-
-  puts ("\n   Program:");
-  Dwarf_Word pc = vma_base;
-  while (readp < endp)
-    {
-      unsigned int opcode = *readp++;
-
-      if (opcode < DW_CFA_advance_loc)
-	/* Extended opcode.  */
-	switch (opcode)
-	  {
-	    uint64_t op1;
-	    int64_t sop1;
-	    uint64_t op2;
-	    int64_t sop2;
-
-	  case DW_CFA_nop:
-	    puts ("     nop");
-	    break;
-	  case DW_CFA_set_loc:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    readp = read_encoded (encoding, readp, endp, &op1, dbg);
-	    printf ("     set_loc %#" PRIx64 " to %#" PRIx64 "\n",
-		    op1, pc = vma_base + op1);
-	    break;
-	  case DW_CFA_advance_loc1:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    printf ("     advance_loc1 %u to %#" PRIx64 "\n",
-		    *readp, pc += *readp * code_align);
-	    ++readp;
-	    break;
-	  case DW_CFA_advance_loc2:
-	    if ((uint64_t) (endp - readp) < 2)
-	      goto invalid;
-	    op1 = read_2ubyte_unaligned_inc (dbg, readp);
-	    printf ("     advance_loc2 %" PRIu64 " to %#" PRIx64 "\n",
-		    op1, pc += op1 * code_align);
-	    break;
-	  case DW_CFA_advance_loc4:
-	    if ((uint64_t) (endp - readp) < 4)
-	      goto invalid;
-	    op1 = read_4ubyte_unaligned_inc (dbg, readp);
-	    printf ("     advance_loc4 %" PRIu64 " to %#" PRIx64 "\n",
-		    op1, pc += op1 * code_align);
-	    break;
-	  case DW_CFA_offset_extended:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op2, readp, endp);
-	    printf ("     offset_extended r%" PRIu64 " (%s) at cfa%+" PRId64
-		    "\n",
-		    op1, regname (ebl, op1, regnamebuf), op2 * data_align);
-	    break;
-	  case DW_CFA_restore_extended:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    printf ("     restore_extended r%" PRIu64 " (%s)\n",
-		    op1, regname (ebl, op1, regnamebuf));
-	    break;
-	  case DW_CFA_undefined:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    printf ("     undefined r%" PRIu64 " (%s)\n", op1,
-		    regname (ebl, op1, regnamebuf));
-	    break;
-	  case DW_CFA_same_value:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    printf ("     same_value r%" PRIu64 " (%s)\n", op1,
-		    regname (ebl, op1, regnamebuf));
-	    break;
-	  case DW_CFA_register:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op2, readp, endp);
-	    printf ("     register r%" PRIu64 " (%s) in r%" PRIu64 " (%s)\n",
-		    op1, regname (ebl, op1, regnamebuf), op2,
-		    regname (ebl, op2, regnamebuf));
-	    break;
-	  case DW_CFA_remember_state:
-	    puts ("     remember_state");
-	    break;
-	  case DW_CFA_restore_state:
-	    puts ("     restore_state");
-	    break;
-	  case DW_CFA_def_cfa:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op2, readp, endp);
-	    printf ("     def_cfa r%" PRIu64 " (%s) at offset %" PRIu64 "\n",
-		    op1, regname (ebl, op1, regnamebuf), op2);
-	    break;
-	  case DW_CFA_def_cfa_register:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    printf ("     def_cfa_register r%" PRIu64 " (%s)\n",
-		    op1, regname (ebl, op1, regnamebuf));
-	    break;
-	  case DW_CFA_def_cfa_offset:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    printf ("     def_cfa_offset %" PRIu64 "\n", op1);
-	    break;
-	  case DW_CFA_def_cfa_expression:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);	/* Length of DW_FORM_block.  */
-	    printf ("     def_cfa_expression %" PRIu64 "\n", op1);
-	    if ((uint64_t) (endp - readp) < op1)
-	      {
-	    invalid:
-	        fputs (_("         <INVALID DATA>\n"), stdout);
-		return;
-	      }
-	    print_ops (dwflmod, dbg, 10, 10, version, ptr_size, 0, NULL,
-		       op1, readp);
-	    readp += op1;
-	    break;
-	  case DW_CFA_expression:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op2, readp, endp);	/* Length of DW_FORM_block.  */
-	    printf ("     expression r%" PRIu64 " (%s) \n",
-		    op1, regname (ebl, op1, regnamebuf));
-	    if ((uint64_t) (endp - readp) < op2)
-	      goto invalid;
-	    print_ops (dwflmod, dbg, 10, 10, version, ptr_size, 0, NULL,
-		       op2, readp);
-	    readp += op2;
-	    break;
-	  case DW_CFA_offset_extended_sf:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_sleb128 (sop2, readp, endp);
-	    printf ("     offset_extended_sf r%" PRIu64 " (%s) at cfa%+"
-		    PRId64 "\n",
-		    op1, regname (ebl, op1, regnamebuf), sop2 * data_align);
-	    break;
-	  case DW_CFA_def_cfa_sf:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_sleb128 (sop2, readp, endp);
-	    printf ("     def_cfa_sf r%" PRIu64 " (%s) at offset %" PRId64 "\n",
-		    op1, regname (ebl, op1, regnamebuf), sop2 * data_align);
-	    break;
-	  case DW_CFA_def_cfa_offset_sf:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_sleb128 (sop1, readp, endp);
-	    printf ("     def_cfa_offset_sf %" PRId64 "\n", sop1 * data_align);
-	    break;
-	  case DW_CFA_val_offset:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op2, readp, endp);
-	    printf ("     val_offset %" PRIu64 " at offset %" PRIu64 "\n",
-		    op1, op2 * data_align);
-	    break;
-	  case DW_CFA_val_offset_sf:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_sleb128 (sop2, readp, endp);
-	    printf ("     val_offset_sf %" PRIu64 " at offset %" PRId64 "\n",
-		    op1, sop2 * data_align);
-	    break;
-	  case DW_CFA_val_expression:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op2, readp, endp);	/* Length of DW_FORM_block.  */
-	    printf ("     val_expression r%" PRIu64 " (%s)\n",
-		    op1, regname (ebl, op1, regnamebuf));
-	    if ((uint64_t) (endp - readp) < op2)
-	      goto invalid;
-	    print_ops (dwflmod, dbg, 10, 10, version, ptr_size, 0,
-		       NULL, op2, readp);
-	    readp += op2;
-	    break;
-	  case DW_CFA_MIPS_advance_loc8:
-	    if ((uint64_t) (endp - readp) < 8)
-	      goto invalid;
-	    op1 = read_8ubyte_unaligned_inc (dbg, readp);
-	    printf ("     MIPS_advance_loc8 %" PRIu64 " to %#" PRIx64 "\n",
-		    op1, pc += op1 * code_align);
-	    break;
-	  case DW_CFA_GNU_window_save:  /* DW_CFA_AARCH64_negate_ra_state  */
-	    if (ehdr->e_machine == EM_AARCH64)
-	      puts ("     AARCH64_negate_ra_state");
-	    else
-	      puts ("     GNU_window_save");
-	    break;
-	  case DW_CFA_GNU_args_size:
-	    if ((uint64_t) (endp - readp) < 1)
-	      goto invalid;
-	    get_uleb128 (op1, readp, endp);
-	    printf ("     args_size %" PRIu64 "\n", op1);
-	    break;
-	  default:
-	    printf ("     ??? (%u)\n", opcode);
-	    break;
-	  }
-      else if (opcode < DW_CFA_offset)
-	printf ("     advance_loc %u to %#" PRIx64 "\n",
-		opcode & 0x3f, pc += (opcode & 0x3f) * code_align);
-      else if (opcode < DW_CFA_restore)
-	{
-	  uint64_t offset;
-	  if ((uint64_t) (endp - readp) < 1)
-	    goto invalid;
-	  get_uleb128 (offset, readp, endp);
-	  printf ("     offset r%u (%s) at cfa%+" PRId64 "\n",
-		  opcode & 0x3f, regname (ebl, opcode & 0x3f, regnamebuf),
-		  offset * data_align);
-	}
-      else
-	printf ("     restore r%u (%s)\n",
-		opcode & 0x3f, regname (ebl, opcode & 0x3f, regnamebuf));
-    }
-}
-
-
-static unsigned int
-encoded_ptr_size (int encoding, unsigned int ptr_size)
-{
-  switch (encoding & 7)
-    {
-    case DW_EH_PE_udata4:
-      return 4;
-    case DW_EH_PE_udata8:
-      return 8;
-    case 0:
-      return ptr_size;
-    }
-
-  fprintf (stderr, "Unsupported pointer encoding: %#x, "
-	   "assuming pointer size of %d.\n", encoding, ptr_size);
-  return ptr_size;
-}
-
-
-static unsigned int
-print_encoding (unsigned int val)
-{
-  switch (val & 0xf)
-    {
-    case DW_EH_PE_absptr:
-      fputs ("absptr", stdout);
-      break;
-    case DW_EH_PE_uleb128:
-      fputs ("uleb128", stdout);
-      break;
-    case DW_EH_PE_udata2:
-      fputs ("udata2", stdout);
-      break;
-    case DW_EH_PE_udata4:
-      fputs ("udata4", stdout);
-      break;
-    case DW_EH_PE_udata8:
-      fputs ("udata8", stdout);
-      break;
-    case DW_EH_PE_sleb128:
-      fputs ("sleb128", stdout);
-      break;
-    case DW_EH_PE_sdata2:
-      fputs ("sdata2", stdout);
-      break;
-    case DW_EH_PE_sdata4:
-      fputs ("sdata4", stdout);
-      break;
-    case DW_EH_PE_sdata8:
-      fputs ("sdata8", stdout);
-      break;
-    default:
-      /* We did not use any of the bits after all.  */
-      return val;
-    }
-
-  return val & ~0xf;
-}
-
-
-static unsigned int
-print_relinfo (unsigned int val)
-{
-  switch (val & 0x70)
-    {
-    case DW_EH_PE_pcrel:
-      fputs ("pcrel", stdout);
-      break;
-    case DW_EH_PE_textrel:
-      fputs ("textrel", stdout);
-      break;
-    case DW_EH_PE_datarel:
-      fputs ("datarel", stdout);
-      break;
-    case DW_EH_PE_funcrel:
-      fputs ("funcrel", stdout);
-      break;
-    case DW_EH_PE_aligned:
-      fputs ("aligned", stdout);
-      break;
-    default:
-      return val;
-    }
-
-  return val & ~0x70;
-}
-
-
-static void
-print_encoding_base (const char *pfx, unsigned int fde_encoding)
-{
-  printf ("(%s", pfx);
-
-  if (fde_encoding == DW_EH_PE_omit)
-    puts ("omit)");
-  else
-    {
-      unsigned int w = fde_encoding;
-
-      w = print_encoding (w);
-
-      if (w & 0x70)
-	{
-	  if (w != fde_encoding)
-	    fputc_unlocked (' ', stdout);
-
-	  w = print_relinfo (w);
-	}
-
-      if (w != 0)
-	printf ("%s%x", w != fde_encoding ? " " : "", w);
-
-      puts (")");
-    }
-}
-
-
-static void
-print_debug_frame_section (Dwfl_Module *dwflmod, Ebl *ebl, GElf_Ehdr *ehdr,
-			   Elf_Scn *scn, GElf_Shdr *shdr, Dwarf *dbg)
-{
-  size_t shstrndx;
-  /* We know this call will succeed since it did in the caller.  */
-  (void) elf_getshdrstrndx (ebl->elf, &shstrndx);
-  const char *scnname = elf_strptr (ebl->elf, shstrndx, shdr->sh_name);
-
-  /* Needed if we find PC-relative addresses.  */
-  GElf_Addr bias;
-  if (dwfl_module_getelf (dwflmod, &bias) == NULL)
-    {
-      error (0, 0, _("cannot get ELF: %s"), dwfl_errmsg (-1));
-      return;
-    }
-
-  bool is_eh_frame = strcmp (scnname, ".eh_frame") == 0;
-  Elf_Data *data = (is_eh_frame
-		    ? elf_rawdata (scn, NULL)
-		    : (dbg->sectiondata[IDX_debug_frame]
-		       ?: elf_rawdata (scn, NULL)));
-
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get %s content: %s"),
-	     scnname, elf_errmsg (-1));
-      return;
-    }
-
-  if (is_eh_frame)
-    printf (_("\
-\nCall frame information section [%2zu] '%s' at offset %#" PRIx64 ":\n"),
-	    elf_ndxscn (scn), scnname, (uint64_t) shdr->sh_offset);
-  else
-    printf (_("\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n"),
-	    elf_ndxscn (scn), scnname, (uint64_t) shdr->sh_offset);
-
-  struct cieinfo
-  {
-    ptrdiff_t cie_offset;
-    const char *augmentation;
-    unsigned int code_alignment_factor;
-    unsigned int data_alignment_factor;
-    uint8_t address_size;
-    uint8_t fde_encoding;
-    uint8_t lsda_encoding;
-    struct cieinfo *next;
-  } *cies = NULL;
-
-  const unsigned char *readp = data->d_buf;
-  const unsigned char *const dataend = ((unsigned char *) data->d_buf
-					+ data->d_size);
-  while (readp < dataend)
-    {
-      if (unlikely (readp + 4 > dataend))
-	{
-	invalid_data:
-	  error (0, 0, _("invalid data in section [%zu] '%s'"),
-		     elf_ndxscn (scn), scnname);
-	      return;
-	}
-
-      /* At the beginning there must be a CIE.  There can be multiple,
-	 hence we test tis in a loop.  */
-      ptrdiff_t offset = readp - (unsigned char *) data->d_buf;
-
-      Dwarf_Word unit_length = read_4ubyte_unaligned_inc (dbg, readp);
-      unsigned int length = 4;
-      if (unlikely (unit_length == 0xffffffff))
-	{
-	  if (unlikely (readp + 8 > dataend))
-	    goto invalid_data;
-
-	  unit_length = read_8ubyte_unaligned_inc (dbg, readp);
-	  length = 8;
-	}
-
-      if (unlikely (unit_length == 0))
-	{
-	  printf (_("\n [%6tx] Zero terminator\n"), offset);
-	  continue;
-	}
-
-      Dwarf_Word maxsize = dataend - readp;
-      if (unlikely (unit_length > maxsize))
-	goto invalid_data;
-
-      unsigned int ptr_size = ehdr->e_ident[EI_CLASS] == ELFCLASS32 ? 4 : 8;
-
-      ptrdiff_t start = readp - (unsigned char *) data->d_buf;
-      const unsigned char *const cieend = readp + unit_length;
-      if (unlikely (cieend > dataend))
-	goto invalid_data;
-
-      Dwarf_Off cie_id;
-      if (length == 4)
-	{
-	  if (unlikely (cieend - readp < 4))
-	    goto invalid_data;
-	  cie_id = read_4ubyte_unaligned_inc (dbg, readp);
-	  if (!is_eh_frame && cie_id == DW_CIE_ID_32)
-	    cie_id = DW_CIE_ID_64;
-	}
-      else
-	{
-	  if (unlikely (cieend - readp < 8))
-	    goto invalid_data;
-	  cie_id = read_8ubyte_unaligned_inc (dbg, readp);
-	}
-
-      uint_fast8_t version = 2;
-      unsigned int code_alignment_factor;
-      int data_alignment_factor;
-      unsigned int fde_encoding = 0;
-      unsigned int lsda_encoding = 0;
-      Dwarf_Word initial_location = 0;
-      Dwarf_Word vma_base = 0;
-
-      if (cie_id == (is_eh_frame ? 0 : DW_CIE_ID_64))
-	{
-	  if (unlikely (cieend - readp < 2))
-	    goto invalid_data;
-	  version = *readp++;
-	  const char *const augmentation = (const char *) readp;
-	  readp = memchr (readp, '\0', cieend - readp);
-	  if (unlikely (readp == NULL))
-	    goto invalid_data;
-	  ++readp;
-
-	  uint_fast8_t segment_size = 0;
-	  if (version >= 4)
-	    {
-	      if (cieend - readp < 5)
-		goto invalid_data;
-	      ptr_size = *readp++;
-	      segment_size = *readp++;
-	    }
-
-	  if (cieend - readp < 1)
-	    goto invalid_data;
-	  get_uleb128 (code_alignment_factor, readp, cieend);
-	  if (cieend - readp < 1)
-	    goto invalid_data;
-	  get_sleb128 (data_alignment_factor, readp, cieend);
-
-	  /* In some variant for unwind data there is another field.  */
-	  if (strcmp (augmentation, "eh") == 0)
-	    readp += ehdr->e_ident[EI_CLASS] == ELFCLASS32 ? 4 : 8;
-
-	  unsigned int return_address_register;
-	  if (cieend - readp < 1)
-	    goto invalid_data;
-	  if (unlikely (version == 1))
-	    return_address_register = *readp++;
-	  else
-	    get_uleb128 (return_address_register, readp, cieend);
-
-	  printf ("\n [%6tx] CIE length=%" PRIu64 "\n"
-		  "   CIE_id:                   %" PRIu64 "\n"
-		  "   version:                  %u\n"
-		  "   augmentation:             \"%s\"\n",
-		  offset, (uint64_t) unit_length, (uint64_t) cie_id,
-		  version, augmentation);
-	  if (version >= 4)
-	    printf ("   address_size:             %u\n"
-		    "   segment_size:             %u\n",
-		    ptr_size, segment_size);
-	  printf ("   code_alignment_factor:    %u\n"
-		  "   data_alignment_factor:    %d\n"
-		  "   return_address_register:  %u\n",
-		  code_alignment_factor,
-		  data_alignment_factor, return_address_register);
-
-	  if (augmentation[0] == 'z')
-	    {
-	      unsigned int augmentationlen;
-	      get_uleb128 (augmentationlen, readp, cieend);
-
-	      if (augmentationlen > (size_t) (cieend - readp))
-		{
-		  error (0, 0, _("invalid augmentation length"));
-		  readp = cieend;
-		  continue;
-		}
-
-	      const char *hdr = "Augmentation data:";
-	      const char *cp = augmentation + 1;
-	      while (*cp != '\0' && cp < augmentation + augmentationlen + 1)
-		{
-		  printf ("   %-26s%#x ", hdr, *readp);
-		  hdr = "";
-
-		  if (*cp == 'R')
-		    {
-		      fde_encoding = *readp++;
-		      print_encoding_base (_("FDE address encoding: "),
-					   fde_encoding);
-		    }
-		  else if (*cp == 'L')
-		    {
-		      lsda_encoding = *readp++;
-		      print_encoding_base (_("LSDA pointer encoding: "),
-					   lsda_encoding);
-		    }
-		  else if (*cp == 'P')
-		    {
-		      /* Personality.  This field usually has a relocation
-			 attached pointing to __gcc_personality_v0.  */
-		      const unsigned char *startp = readp;
-		      unsigned int encoding = *readp++;
-		      uint64_t val = 0;
-		      readp = read_encoded (encoding, readp,
-					    readp - 1 + augmentationlen,
-					    &val, dbg);
-
-		      while (++startp < readp)
-			printf ("%#x ", *startp);
-
-		      putchar ('(');
-		      print_encoding (encoding);
-		      putchar (' ');
-		      switch (encoding & 0xf)
-			{
-			case DW_EH_PE_sleb128:
-			case DW_EH_PE_sdata2:
-			case DW_EH_PE_sdata4:
-			  printf ("%" PRId64 ")\n", val);
-			  break;
-			default:
-			  printf ("%#" PRIx64 ")\n", val);
-			  break;
-			}
-		    }
-		  else
-		    printf ("(%x)\n", *readp++);
-
-		  ++cp;
-		}
-	    }
-
-	  if (likely (ptr_size == 4 || ptr_size == 8))
-	    {
-	      struct cieinfo *newp = alloca (sizeof (*newp));
-	      newp->cie_offset = offset;
-	      newp->augmentation = augmentation;
-	      newp->fde_encoding = fde_encoding;
-	      newp->lsda_encoding = lsda_encoding;
-	      newp->address_size = ptr_size;
-	      newp->code_alignment_factor = code_alignment_factor;
-	      newp->data_alignment_factor = data_alignment_factor;
-	      newp->next = cies;
-	      cies = newp;
-	    }
-	}
-      else
-	{
-	  struct cieinfo *cie = cies;
-	  while (cie != NULL)
-	    if (is_eh_frame
-		? ((Dwarf_Off) start - cie_id) == (Dwarf_Off) cie->cie_offset
-		: cie_id == (Dwarf_Off) cie->cie_offset)
-	      break;
-	    else
-	      cie = cie->next;
-	  if (unlikely (cie == NULL))
-	    {
-	      puts ("invalid CIE reference in FDE");
-	      return;
-	    }
-
-	  /* Initialize from CIE data.  */
-	  fde_encoding = cie->fde_encoding;
-	  lsda_encoding = cie->lsda_encoding;
-	  ptr_size = encoded_ptr_size (fde_encoding, cie->address_size);
-	  code_alignment_factor = cie->code_alignment_factor;
-	  data_alignment_factor = cie->data_alignment_factor;
-
-	  const unsigned char *base = readp;
-	  // XXX There are sometimes relocations for this value
-	  initial_location = read_addr_unaligned_inc (ptr_size, dbg, readp);
-	  Dwarf_Word address_range
-	    = read_addr_unaligned_inc (ptr_size, dbg, readp);
-
-	  /* pcrel for an FDE address is relative to the runtime
-	     address of the start_address field itself.  Sign extend
-	     if necessary to make sure the calculation is done on the
-	     full 64 bit address even when initial_location only holds
-	     the lower 32 bits.  */
-	  Dwarf_Addr pc_start = initial_location;
-	  if (ptr_size == 4)
-	    pc_start = (uint64_t) (int32_t) pc_start;
-	  if ((fde_encoding & 0x70) == DW_EH_PE_pcrel)
-	    pc_start += ((uint64_t) shdr->sh_addr
-			 + (base - (const unsigned char *) data->d_buf)
-			 - bias);
-
-	  printf ("\n [%6tx] FDE length=%" PRIu64 " cie=[%6tx]\n"
-		  "   CIE_pointer:              %" PRIu64 "\n"
-		  "   initial_location:         ",
-		  offset, (uint64_t) unit_length,
-		  cie->cie_offset, (uint64_t) cie_id);
-	  print_dwarf_addr (dwflmod, cie->address_size,
-			    pc_start, initial_location);
-	  if ((fde_encoding & 0x70) == DW_EH_PE_pcrel)
-	    {
-	      vma_base = (((uint64_t) shdr->sh_offset
-			   + (base - (const unsigned char *) data->d_buf)
-			   + (uint64_t) initial_location)
-			  & (ptr_size == 4
-			     ? UINT64_C (0xffffffff)
-			     : UINT64_C (0xffffffffffffffff)));
-	      printf (_(" (offset: %#" PRIx64 ")"),
-		      (uint64_t) vma_base);
-	    }
-
-	  printf ("\n   address_range:            %#" PRIx64,
-		  (uint64_t) address_range);
-	  if ((fde_encoding & 0x70) == DW_EH_PE_pcrel)
-	    printf (_(" (end offset: %#" PRIx64 ")"),
-		    ((uint64_t) vma_base + (uint64_t) address_range)
-		    & (ptr_size == 4
-		       ? UINT64_C (0xffffffff)
-		       : UINT64_C (0xffffffffffffffff)));
-	  putchar ('\n');
-
-	  if (cie->augmentation[0] == 'z')
-	    {
-	      unsigned int augmentationlen;
-	      if (cieend - readp < 1)
-		goto invalid_data;
-	      get_uleb128 (augmentationlen, readp, cieend);
-
-	      if (augmentationlen > (size_t) (cieend - readp))
-		{
-		  error (0, 0, _("invalid augmentation length"));
-		  readp = cieend;
-		  continue;
-		}
-
-	      if (augmentationlen > 0)
-		{
-		  const char *hdr = "Augmentation data:";
-		  const char *cp = cie->augmentation + 1;
-		  unsigned int u = 0;
-		  while (*cp != '\0'
-			 && cp < cie->augmentation + augmentationlen + 1)
-		    {
-		      if (*cp == 'L')
-			{
-			  uint64_t lsda_pointer;
-			  const unsigned char *p
-			    = read_encoded (lsda_encoding, &readp[u],
-					    &readp[augmentationlen],
-					    &lsda_pointer, dbg);
-			  u = p - readp;
-			  printf (_("\
-   %-26sLSDA pointer: %#" PRIx64 "\n"),
-				  hdr, lsda_pointer);
-			  hdr = "";
-			}
-		      ++cp;
-		    }
-
-		  while (u < augmentationlen)
-		    {
-		      printf ("   %-26s%#x\n", hdr, readp[u++]);
-		      hdr = "";
-		    }
-		}
-
-	      readp += augmentationlen;
-	    }
-	}
-
-      /* Handle the initialization instructions.  */
-      if (ptr_size != 4 && ptr_size !=8)
-	printf ("invalid CIE pointer size (%u), must be 4 or 8.\n", ptr_size);
-      else
-	print_cfa_program (readp, cieend, vma_base, code_alignment_factor,
-			   data_alignment_factor, version, ptr_size,
-			   fde_encoding, dwflmod, ebl, ehdr, dbg);
-      readp = cieend;
-    }
-}
-
-
-/* Returns the signedness (or false if it cannot be determined) and
-   the byte size (or zero if it cannot be gotten) of the given DIE
-   DW_AT_type attribute.  Uses dwarf_peel_type and dwarf_aggregate_size.  */
-static void
-die_type_sign_bytes (Dwarf_Die *die, bool *is_signed, int *bytes)
-{
-  Dwarf_Attribute attr;
-  Dwarf_Die type;
-
-  *bytes = 0;
-  *is_signed = false;
-
-  if (dwarf_peel_type (dwarf_formref_die (dwarf_attr_integrate (die,
-								DW_AT_type,
-								&attr), &type),
-		       &type) == 0)
-    {
-      Dwarf_Word val;
-      *is_signed = (dwarf_formudata (dwarf_attr (&type, DW_AT_encoding,
-						 &attr), &val) == 0
-		    && (val == DW_ATE_signed || val == DW_ATE_signed_char));
-
-      if (dwarf_aggregate_size (&type, &val) == 0)
-	*bytes = val;
-    }
-}
-
-struct attrcb_args
-{
-  Dwfl_Module *dwflmod;
-  Dwarf *dbg;
-  Dwarf_Die *dies;
-  int level;
-  bool silent;
-  bool is_split;
-  unsigned int version;
-  unsigned int addrsize;
-  unsigned int offset_size;
-  struct Dwarf_CU *cu;
-};
-
-
-static int
-attr_callback (Dwarf_Attribute *attrp, void *arg)
-{
-  struct attrcb_args *cbargs = (struct attrcb_args *) arg;
-  const int level = cbargs->level;
-  Dwarf_Die *die = &cbargs->dies[level];
-  bool is_split = cbargs->is_split;
-
-  unsigned int attr = dwarf_whatattr (attrp);
-  if (unlikely (attr == 0))
-    {
-      if (!cbargs->silent)
-	error (0, 0, _("DIE [%" PRIx64 "] "
-			      "cannot get attribute code: %s"),
-	       dwarf_dieoffset (die), dwarf_errmsg (-1));
-      return DWARF_CB_ABORT;
-    }
-
-  unsigned int form = dwarf_whatform (attrp);
-  if (unlikely (form == 0))
-    {
-      if (!cbargs->silent)
-	error (0, 0, _("DIE [%" PRIx64 "] "
-			      "cannot get attribute form: %s"),
-	       dwarf_dieoffset (die), dwarf_errmsg (-1));
-      return DWARF_CB_ABORT;
-    }
-
-  switch (form)
-    {
-    case DW_FORM_addr:
-    case DW_FORM_addrx:
-    case DW_FORM_addrx1:
-    case DW_FORM_addrx2:
-    case DW_FORM_addrx3:
-    case DW_FORM_addrx4:
-    case DW_FORM_GNU_addr_index:
-      if (!cbargs->silent)
-	{
-	  Dwarf_Addr addr;
-	  if (unlikely (dwarf_formaddr (attrp, &addr) != 0))
-	    {
-	    attrval_out:
-	      if (!cbargs->silent)
-		error (0, 0, _("DIE [%" PRIx64 "] "
-				      "cannot get attribute '%s' (%s) value: "
-				      "%s"),
-		       dwarf_dieoffset (die),
-		       dwarf_attr_name (attr),
-		       dwarf_form_name (form),
-		       dwarf_errmsg (-1));
-	      /* Don't ABORT, it might be other attributes can be resolved.  */
-	      return DWARF_CB_OK;
-	    }
-	  if (form != DW_FORM_addr )
-	    {
-	      Dwarf_Word word;
-	      if (dwarf_formudata (attrp, &word) != 0)
-		goto attrval_out;
-	      printf ("           %*s%-20s (%s) [%" PRIx64 "] ",
-		      (int) (level * 2), "", dwarf_attr_name (attr),
-		      dwarf_form_name (form), word);
-	    }
-	  else
-	    printf ("           %*s%-20s (%s) ",
-		    (int) (level * 2), "", dwarf_attr_name (attr),
-		    dwarf_form_name (form));
-	  print_dwarf_addr (cbargs->dwflmod, cbargs->addrsize, addr, addr);
-	  printf ("\n");
-	}
-      break;
-
-    case DW_FORM_indirect:
-    case DW_FORM_strp:
-    case DW_FORM_line_strp:
-    case DW_FORM_strx:
-    case DW_FORM_strx1:
-    case DW_FORM_strx2:
-    case DW_FORM_strx3:
-    case DW_FORM_strx4:
-    case DW_FORM_string:
-    case DW_FORM_GNU_strp_alt:
-    case DW_FORM_GNU_str_index:
-      if (cbargs->silent)
-	break;
-      const char *str = dwarf_formstring (attrp);
-      if (unlikely (str == NULL))
-	goto attrval_out;
-      printf ("           %*s%-20s (%s) \"%s\"\n",
-	      (int) (level * 2), "", dwarf_attr_name (attr),
-	      dwarf_form_name (form), str);
-      break;
-
-    case DW_FORM_ref_addr:
-    case DW_FORM_ref_udata:
-    case DW_FORM_ref8:
-    case DW_FORM_ref4:
-    case DW_FORM_ref2:
-    case DW_FORM_ref1:
-    case DW_FORM_GNU_ref_alt:
-    case DW_FORM_ref_sup4:
-    case DW_FORM_ref_sup8:
-      if (cbargs->silent)
-	break;
-      Dwarf_Die ref;
-      if (unlikely (dwarf_formref_die (attrp, &ref) == NULL))
-	goto attrval_out;
-
-      printf ("           %*s%-20s (%s) ",
-	      (int) (level * 2), "", dwarf_attr_name (attr),
-	      dwarf_form_name (form));
-      if (is_split)
-	printf ("{%6" PRIxMAX "}\n", (uintmax_t) dwarf_dieoffset (&ref));
-      else
-	printf ("[%6" PRIxMAX "]\n", (uintmax_t) dwarf_dieoffset (&ref));
-      break;
-
-    case DW_FORM_ref_sig8:
-      if (cbargs->silent)
-	break;
-      printf ("           %*s%-20s (%s) {%6" PRIx64 "}\n",
-	      (int) (level * 2), "", dwarf_attr_name (attr),
-	      dwarf_form_name (form),
-	      (uint64_t) read_8ubyte_unaligned (attrp->cu->dbg, attrp->valp));
-      break;
-
-    case DW_FORM_sec_offset:
-    case DW_FORM_rnglistx:
-    case DW_FORM_loclistx:
-    case DW_FORM_implicit_const:
-    case DW_FORM_udata:
-    case DW_FORM_sdata:
-    case DW_FORM_data8: /* Note no data16 here, we see that as block. */
-    case DW_FORM_data4:
-    case DW_FORM_data2:
-    case DW_FORM_data1:;
-      Dwarf_Word num;
-      if (unlikely (dwarf_formudata (attrp, &num) != 0))
-	goto attrval_out;
-
-      const char *valuestr = NULL;
-      bool as_hex_id = false;
-      switch (attr)
-	{
-	  /* This case can take either a constant or a loclistptr.  */
-	case DW_AT_data_member_location:
-	  if (form != DW_FORM_sec_offset
-	      && (cbargs->version >= 4
-		  || (form != DW_FORM_data4 && form != DW_FORM_data8)))
-	    {
-	      if (!cbargs->silent)
-		printf ("           %*s%-20s (%s) %" PRIuMAX "\n",
-			(int) (level * 2), "", dwarf_attr_name (attr),
-			dwarf_form_name (form), (uintmax_t) num);
-	      return DWARF_CB_OK;
-	    }
-	  FALLTHROUGH;
-
-	/* These cases always take a loclist[ptr] and no constant. */
-	case DW_AT_location:
-	case DW_AT_data_location:
-	case DW_AT_vtable_elem_location:
-	case DW_AT_string_length:
-	case DW_AT_use_location:
-	case DW_AT_frame_base:
-	case DW_AT_return_addr:
-	case DW_AT_static_link:
-	case DW_AT_segment:
-	case DW_AT_GNU_call_site_value:
-	case DW_AT_GNU_call_site_data_value:
-	case DW_AT_GNU_call_site_target:
-	case DW_AT_GNU_call_site_target_clobbered:
-	case DW_AT_GNU_locviews:
-	  {
-	    bool nlpt;
-	    if (cbargs->cu->version < 5)
-	      {
-		if (! cbargs->is_split)
-		  {
-		    nlpt = notice_listptr (section_loc, &known_locsptr,
-					   cbargs->addrsize,
-					   cbargs->offset_size,
-					   cbargs->cu, num, attr);
-		  }
-		else
-		  nlpt = true;
-	      }
-	    else
-	      {
-		/* Only register for a real section offset.  Otherwise
-		   it is a DW_FORM_loclistx which is just an index
-		   number and we should already have registered the
-		   section offset for the index when we saw the
-		   DW_AT_loclists_base CU attribute.  */
-		if (form == DW_FORM_sec_offset)
-		  nlpt = notice_listptr (section_loc, &known_loclistsptr,
-					 cbargs->addrsize, cbargs->offset_size,
-					 cbargs->cu, num, attr);
-		else
-		  nlpt = true;
-
-	      }
-
-	    if (!cbargs->silent)
-	      {
-		if (cbargs->cu->version < 5 || form == DW_FORM_sec_offset)
-		  printf ("           %*s%-20s (%s) location list [%6"
-			  PRIxMAX "]%s\n",
-			  (int) (level * 2), "", dwarf_attr_name (attr),
-			  dwarf_form_name (form), (uintmax_t) num,
-			  nlpt ? "" : " <WARNING offset too big>");
-		else
-		  printf ("           %*s%-20s (%s) location index [%6"
-			  PRIxMAX "]\n",
-			  (int) (level * 2), "", dwarf_attr_name (attr),
-			  dwarf_form_name (form), (uintmax_t) num);
-	      }
-	  }
-	  return DWARF_CB_OK;
-
-	case DW_AT_loclists_base:
-	  {
-	    bool nlpt = notice_listptr (section_loc, &known_loclistsptr,
-                                        cbargs->addrsize, cbargs->offset_size,
-                                        cbargs->cu, num, attr);
-
-	    if (!cbargs->silent)
-	      printf ("           %*s%-20s (%s) location list [%6" PRIxMAX "]%s\n",
-		      (int) (level * 2), "", dwarf_attr_name (attr),
-		      dwarf_form_name (form), (uintmax_t) num,
-		      nlpt ? "" : " <WARNING offset too big>");
-	  }
-	  return DWARF_CB_OK;
-
-	case DW_AT_ranges:
-	case DW_AT_start_scope:
-	  {
-	    bool nlpt;
-	    if (cbargs->cu->version < 5)
-	      nlpt = notice_listptr (section_ranges, &known_rangelistptr,
-				     cbargs->addrsize, cbargs->offset_size,
-				     cbargs->cu, num, attr);
-	    else
-	      {
-		/* Only register for a real section offset.  Otherwise
-		   it is a DW_FORM_rangelistx which is just an index
-		   number and we should already have registered the
-		   section offset for the index when we saw the
-		   DW_AT_rnglists_base CU attribute.  */
-		if (form == DW_FORM_sec_offset)
-		  nlpt = notice_listptr (section_ranges, &known_rnglistptr,
-					 cbargs->addrsize, cbargs->offset_size,
-					 cbargs->cu, num, attr);
-		else
-		  nlpt = true;
-	      }
-
-	    if (!cbargs->silent)
-	      {
-		if (cbargs->cu->version < 5 || form == DW_FORM_sec_offset)
-		  printf ("           %*s%-20s (%s) range list [%6"
-			  PRIxMAX "]%s\n",
-			  (int) (level * 2), "", dwarf_attr_name (attr),
-			  dwarf_form_name (form), (uintmax_t) num,
-			  nlpt ? "" : " <WARNING offset too big>");
-		else
-		  printf ("           %*s%-20s (%s) range index [%6"
-			  PRIxMAX "]\n",
-			  (int) (level * 2), "", dwarf_attr_name (attr),
-			  dwarf_form_name (form), (uintmax_t) num);
-	      }
-	  }
-	  return DWARF_CB_OK;
-
-	case DW_AT_rnglists_base:
-	  {
-	    bool nlpt = notice_listptr (section_ranges, &known_rnglistptr,
-					cbargs->addrsize, cbargs->offset_size,
-					cbargs->cu, num, attr);
-	    if (!cbargs->silent)
-	      printf ("           %*s%-20s (%s) range list [%6"
-		      PRIxMAX "]%s\n",
-		      (int) (level * 2), "", dwarf_attr_name (attr),
-		      dwarf_form_name (form), (uintmax_t) num,
-		      nlpt ? "" : " <WARNING offset too big>");
-	  }
-	  return DWARF_CB_OK;
-
-	case DW_AT_addr_base:
-	case DW_AT_GNU_addr_base:
-	  {
-	    bool addrbase = notice_listptr (section_addr, &known_addrbases,
-					    cbargs->addrsize,
-					    cbargs->offset_size,
-					    cbargs->cu, num, attr);
-	    if (!cbargs->silent)
-	      printf ("           %*s%-20s (%s) address base [%6"
-		      PRIxMAX "]%s\n",
-		      (int) (level * 2), "", dwarf_attr_name (attr),
-		      dwarf_form_name (form), (uintmax_t) num,
-		      addrbase ? "" : " <WARNING offset too big>");
-	  }
-	  return DWARF_CB_OK;
-
-	case DW_AT_str_offsets_base:
-	  {
-	    bool stroffbase = notice_listptr (section_str, &known_stroffbases,
-					      cbargs->addrsize,
-					      cbargs->offset_size,
-					      cbargs->cu, num, attr);
-	    if (!cbargs->silent)
-	      printf ("           %*s%-20s (%s) str offsets base [%6"
-		      PRIxMAX "]%s\n",
-		      (int) (level * 2), "", dwarf_attr_name (attr),
-		      dwarf_form_name (form), (uintmax_t) num,
-		      stroffbase ? "" : " <WARNING offset too big>");
-	  }
-	  return DWARF_CB_OK;
-
-	case DW_AT_language:
-	  valuestr = dwarf_lang_name (num);
-	  break;
-	case DW_AT_encoding:
-	  valuestr = dwarf_encoding_name (num);
-	  break;
-	case DW_AT_accessibility:
-	  valuestr = dwarf_access_name (num);
-	  break;
-	case DW_AT_defaulted:
-	  valuestr = dwarf_defaulted_name (num);
-	  break;
-	case DW_AT_visibility:
-	  valuestr = dwarf_visibility_name (num);
-	  break;
-	case DW_AT_virtuality:
-	  valuestr = dwarf_virtuality_name (num);
-	  break;
-	case DW_AT_identifier_case:
-	  valuestr = dwarf_identifier_case_name (num);
-	  break;
-	case DW_AT_calling_convention:
-	  valuestr = dwarf_calling_convention_name (num);
-	  break;
-	case DW_AT_inline:
-	  valuestr = dwarf_inline_name (num);
-	  break;
-	case DW_AT_ordering:
-	  valuestr = dwarf_ordering_name (num);
-	  break;
-	case DW_AT_decl_file:
-	case DW_AT_call_file:
-	  {
-	    if (cbargs->silent)
-	      break;
-
-	    /* Try to get the actual file, the current interface only
-	       gives us full paths, but we only want to show the file
-	       name for now.  */
-	    Dwarf_Die cudie;
-	    if (dwarf_cu_die (cbargs->cu, &cudie,
-			      NULL, NULL, NULL, NULL, NULL, NULL) != NULL)
-	      {
-		Dwarf_Files *files;
-		size_t nfiles;
-		if (dwarf_getsrcfiles (&cudie, &files, &nfiles) == 0)
-		  {
-		    valuestr = dwarf_filesrc (files, num, NULL, NULL);
-		    if (valuestr != NULL)
-		      {
-			char *filename = strrchr (valuestr, '/');
-			if (filename != NULL)
-			  valuestr = filename + 1;
-		      }
-		    else
-		      error (0, 0, _("invalid file (%" PRId64 "): %s"),
-			     num, dwarf_errmsg (-1));
-		  }
-		else
-		  error (0, 0, _("no srcfiles for CU [%" PRIx64 "]"),
-			 dwarf_dieoffset (&cudie));
-	      }
-	    else
-	     error (0, 0, _("couldn't get DWARF CU: %s"),
-		    dwarf_errmsg (-1));
-	    if (valuestr == NULL)
-	      valuestr = "???";
-	  }
-	  break;
-	case DW_AT_GNU_dwo_id:
-	  as_hex_id = true;
-	  break;
-
-	default:
-	  /* Nothing.  */
-	  break;
-	}
-
-      if (cbargs->silent)
-	break;
-
-      /* When highpc is in constant form it is relative to lowpc.
-	 In that case also show the address.  */
-      Dwarf_Addr highpc;
-      if (attr == DW_AT_high_pc && dwarf_highpc (die, &highpc) == 0)
-	{
-	  printf ("           %*s%-20s (%s) %" PRIuMAX " (",
-		  (int) (level * 2), "", dwarf_attr_name (attr),
-		  dwarf_form_name (form), (uintmax_t) num);
-	  print_dwarf_addr (cbargs->dwflmod, cbargs->addrsize, highpc, highpc);
-	  printf (")\n");
-	}
-      else
-	{
-	  if (as_hex_id)
-	    {
-	      printf ("           %*s%-20s (%s) 0x%.16" PRIx64 "\n",
-		      (int) (level * 2), "", dwarf_attr_name (attr),
-		      dwarf_form_name (form), num);
-	    }
-	  else
-	    {
-	      Dwarf_Sword snum = 0;
-	      bool is_signed;
-	      int bytes = 0;
-	      if (attr == DW_AT_const_value)
-		die_type_sign_bytes (die, &is_signed, &bytes);
-	      else
-		is_signed = (form == DW_FORM_sdata
-			     || form == DW_FORM_implicit_const);
-
-	      if (is_signed)
-		if (unlikely (dwarf_formsdata (attrp, &snum) != 0))
-		  goto attrval_out;
-
-	      if (valuestr == NULL)
-		{
-		  printf ("           %*s%-20s (%s) ",
-			  (int) (level * 2), "", dwarf_attr_name (attr),
-			  dwarf_form_name (form));
-		}
-	      else
-		{
-		  printf ("           %*s%-20s (%s) %s (",
-			  (int) (level * 2), "", dwarf_attr_name (attr),
-			  dwarf_form_name (form), valuestr);
-		}
-
-	      switch (bytes)
-		{
-		case 1:
-		  if (is_signed)
-		    printf ("%" PRId8, (int8_t) snum);
-		  else
-		    printf ("%" PRIu8, (uint8_t) num);
-		  break;
-
-		case 2:
-		  if (is_signed)
-		    printf ("%" PRId16, (int16_t) snum);
-		  else
-		    printf ("%" PRIu16, (uint16_t) num);
-		  break;
-
-		case 4:
-		  if (is_signed)
-		    printf ("%" PRId32, (int32_t) snum);
-		  else
-		    printf ("%" PRIu32, (uint32_t) num);
-		  break;
-
-		case 8:
-		  if (is_signed)
-		    printf ("%" PRId64, (int64_t) snum);
-		  else
-		    printf ("%" PRIu64, (uint64_t) num);
-		  break;
-
-		default:
-		  if (is_signed)
-		    printf ("%" PRIdMAX, (intmax_t) snum);
-		  else
-		    printf ("%" PRIuMAX, (uintmax_t) num);
-		  break;
-		}
-
-	      /* Make clear if we switched from a signed encoding to
-		 an unsigned value.  */
-	      if (attr == DW_AT_const_value
-		  && (form == DW_FORM_sdata || form == DW_FORM_implicit_const)
-		  && !is_signed)
-		printf (" (%" PRIdMAX ")", (intmax_t) num);
-
-	      if (valuestr == NULL)
-		printf ("\n");
-	      else
-		printf (")\n");
-	    }
-	}
-      break;
-
-    case DW_FORM_flag:
-      if (cbargs->silent)
-	break;
-      bool flag;
-      if (unlikely (dwarf_formflag (attrp, &flag) != 0))
-	goto attrval_out;
-
-      printf ("           %*s%-20s (%s) %s\n",
-	      (int) (level * 2), "", dwarf_attr_name (attr),
-	      dwarf_form_name (form), flag ? yes_str : no_str);
-      break;
-
-    case DW_FORM_flag_present:
-      if (cbargs->silent)
-	break;
-      printf ("           %*s%-20s (%s) %s\n",
-	      (int) (level * 2), "", dwarf_attr_name (attr),
-	      dwarf_form_name (form), yes_str);
-      break;
-
-    case DW_FORM_exprloc:
-    case DW_FORM_block4:
-    case DW_FORM_block2:
-    case DW_FORM_block1:
-    case DW_FORM_block:
-    case DW_FORM_data16: /* DWARF5 calls this a constant class.  */
-      if (cbargs->silent)
-	break;
-      Dwarf_Block block;
-      if (unlikely (dwarf_formblock (attrp, &block) != 0))
-	goto attrval_out;
-
-      printf ("           %*s%-20s (%s) ",
-	      (int) (level * 2), "", dwarf_attr_name (attr),
-	      dwarf_form_name (form));
-
-      switch (attr)
-	{
-	default:
-	  if (form != DW_FORM_exprloc)
-	    {
-	      print_block (block.length, block.data);
-	      break;
-	    }
-	  FALLTHROUGH;
-
-	case DW_AT_location:
-	case DW_AT_data_location:
-	case DW_AT_data_member_location:
-	case DW_AT_vtable_elem_location:
-	case DW_AT_string_length:
-	case DW_AT_use_location:
-	case DW_AT_frame_base:
-	case DW_AT_return_addr:
-	case DW_AT_static_link:
-	case DW_AT_allocated:
-	case DW_AT_associated:
-	case DW_AT_bit_size:
-	case DW_AT_bit_offset:
-	case DW_AT_bit_stride:
-	case DW_AT_byte_size:
-	case DW_AT_byte_stride:
-	case DW_AT_count:
-	case DW_AT_lower_bound:
-	case DW_AT_upper_bound:
-	case DW_AT_GNU_call_site_value:
-	case DW_AT_GNU_call_site_data_value:
-	case DW_AT_GNU_call_site_target:
-	case DW_AT_GNU_call_site_target_clobbered:
-	  if (form == DW_FORM_exprloc
-	      || (form != DW_FORM_data16
-		  && attrp->cu->version < 4)) /* blocks were expressions.  */
-	    {
-	      putchar ('\n');
-	      print_ops (cbargs->dwflmod, cbargs->dbg,
-			 12 + level * 2, 12 + level * 2,
-			 cbargs->version, cbargs->addrsize, cbargs->offset_size,
-			 attrp->cu, block.length, block.data);
-	    }
-	  else
-	    print_block (block.length, block.data);
-	  break;
-
-	case DW_AT_discr_list:
-	  if (block.length == 0)
-	    puts ("<default>");
-	  else if (form != DW_FORM_data16)
-	    {
-	      const unsigned char *readp = block.data;
-	      const unsigned char *readendp = readp + block.length;
-
-	      /* See if we are dealing with a signed or unsigned
-		 values.  If the parent of this variant DIE is a
-		 variant_part then it will either have a discriminant
-		 which points to the member which type is the
-		 discriminant type.  Or the variant_part itself has a
-		 type representing the discriminant.  */
-	      bool is_signed = false;
-	      if (level > 0)
-		{
-		  Dwarf_Die *parent = &cbargs->dies[level - 1];
-		  if (dwarf_tag (die) == DW_TAG_variant
-		      && dwarf_tag (parent) == DW_TAG_variant_part)
-		    {
-		      Dwarf_Die member;
-		      Dwarf_Attribute discr_attr;
-		      int bytes;
-		      if (dwarf_formref_die (dwarf_attr (parent,
-							 DW_AT_discr,
-							 &discr_attr),
-					     &member) != NULL)
-			die_type_sign_bytes (&member, &is_signed, &bytes);
-		      else
-			die_type_sign_bytes (parent, &is_signed, &bytes);
-		    }
-		}
-	      while (readp < readendp)
-		{
-		  int d = (int) *readp++;
-		  printf ("%s ", dwarf_discr_list_name (d));
-		  if (readp >= readendp)
-		    goto attrval_out;
-
-		  Dwarf_Word val;
-		  Dwarf_Sword sval;
-		  if (d == DW_DSC_label)
-		    {
-		      if (is_signed)
-			{
-			  get_sleb128 (sval, readp, readendp);
-			  printf ("%" PRId64 "", sval);
-			}
-		      else
-			{
-			  get_uleb128 (val, readp, readendp);
-			  printf ("%" PRIu64 "", val);
-			}
-		    }
-		  else if (d == DW_DSC_range)
-		    {
-		      if (is_signed)
-			{
-			  get_sleb128 (sval, readp, readendp);
-			  printf ("%" PRId64 "..", sval);
-			  if (readp >= readendp)
-			    goto attrval_out;
-			  get_sleb128 (sval, readp, readendp);
-			  printf ("%" PRId64 "", sval);
-			}
-		      else
-			{
-			  get_uleb128 (val, readp, readendp);
-			  printf ("%" PRIu64 "..", val);
-			  if (readp >= readendp)
-			    goto attrval_out;
-			  get_uleb128 (val, readp, readendp);
-			  printf ("%" PRIu64 "", val);
-			}
-		    }
-		  else
-		    {
-		      print_block (readendp - readp, readp);
-		      break;
-		    }
-		  if (readp < readendp)
-		    printf (", ");
-		}
-	      putchar ('\n');
-	    }
-	  else
-	    print_block (block.length, block.data);
-	  break;
-	}
-      break;
-
-    default:
-      if (cbargs->silent)
-	break;
-      printf ("           %*s%-20s (%s) ???\n",
-	      (int) (level * 2), "", dwarf_attr_name (attr),
-	      dwarf_form_name (form));
-      break;
-    }
-
-  return DWARF_CB_OK;
-}
-
-static void
-print_debug_units (Dwfl_Module *dwflmod,
-		   Ebl *ebl, GElf_Ehdr *ehdr __attribute__ ((unused)),
-		   Elf_Scn *scn, GElf_Shdr *shdr,
-		   Dwarf *dbg, bool debug_types)
-{
-  const bool silent = !(print_debug_sections & section_info) && !debug_types;
-  const char *secname = section_name (ebl, shdr);
-
-  if (!silent)
-    printf (_("\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n [Offset]\n"),
-	    elf_ndxscn (scn), secname, (uint64_t) shdr->sh_offset);
-
-  /* If the section is empty we don't have to do anything.  */
-  if (!silent && shdr->sh_size == 0)
-    return;
-
-  int maxdies = 20;
-  Dwarf_Die *dies = xmalloc (maxdies * sizeof (Dwarf_Die));
-
-  /* New compilation unit.  */
-  Dwarf_Half version;
-
-  Dwarf_Die result;
-  Dwarf_Off abbroffset;
-  uint8_t addrsize;
-  uint8_t offsize;
-  uint64_t unit_id;
-  Dwarf_Off subdie_off;
-
-  int unit_res;
-  Dwarf_CU *cu;
-  Dwarf_CU cu_mem;
-  uint8_t unit_type;
-  Dwarf_Die cudie;
-
-  /* We cheat a little because we want to see only the CUs from .debug_info
-     or .debug_types.  We know the Dwarf_CU struct layout.  Set it up at
-     the end of .debug_info if we want .debug_types only.  Check the returned
-     Dwarf_CU is still in the expected section.  */
-  if (debug_types)
-    {
-      cu_mem.dbg = dbg;
-      cu_mem.end = dbg->sectiondata[IDX_debug_info]->d_size;
-      cu_mem.sec_idx = IDX_debug_info;
-      cu = &cu_mem;
-    }
-  else
-    cu = NULL;
-
- next_cu:
-  unit_res = dwarf_get_units (dbg, cu, &cu, &version, &unit_type,
-			      &cudie, NULL);
-  if (unit_res == 1)
-    goto do_return;
-
-  if (unit_res == -1)
-    {
-      if (!silent)
-	error (0, 0, _("cannot get next unit: %s"), dwarf_errmsg (-1));
-      goto do_return;
-    }
-
-  if (cu->sec_idx != (size_t) (debug_types ? IDX_debug_types : IDX_debug_info))
-    goto do_return;
-
-  dwarf_cu_die (cu, &result, NULL, &abbroffset, &addrsize, &offsize,
-		&unit_id, &subdie_off);
-
-  if (!silent)
-    {
-      Dwarf_Off offset = cu->start;
-      if (debug_types && version < 5)
-	{
-	  Dwarf_Die typedie;
-	  Dwarf_Off dieoffset;
-	  dieoffset = dwarf_dieoffset (dwarf_offdie_types (dbg, cu->start
-							   + subdie_off,
-							   &typedie));
-	  printf (_(" Type unit at offset %" PRIu64 ":\n"
-			   " Version: %" PRIu16
-			   ", Abbreviation section offset: %" PRIu64
-			   ", Address size: %" PRIu8
-			   ", Offset size: %" PRIu8
-			   "\n Type signature: %#" PRIx64
-			   ", Type offset: %#" PRIx64 " [%" PRIx64 "]\n"),
-		  (uint64_t) offset, version, abbroffset, addrsize, offsize,
-		  unit_id, (uint64_t) subdie_off, dieoffset);
-	}
-      else
-	{
-	  printf (_(" Compilation unit at offset %" PRIu64 ":\n"
-			   " Version: %" PRIu16
-			   ", Abbreviation section offset: %" PRIu64
-			   ", Address size: %" PRIu8
-			   ", Offset size: %" PRIu8 "\n"),
-		  (uint64_t) offset, version, abbroffset, addrsize, offsize);
-
-	  if (version >= 5 || (unit_type != DW_UT_compile
-			       && unit_type != DW_UT_partial))
-	    {
-	      printf (_(" Unit type: %s (%" PRIu8 ")"),
-			       dwarf_unit_name (unit_type), unit_type);
-	      if (unit_type == DW_UT_type
-		  || unit_type == DW_UT_skeleton
-		  || unit_type == DW_UT_split_compile
-		  || unit_type == DW_UT_split_type)
-		printf (", Unit id: 0x%.16" PRIx64 "", unit_id);
-	      if (unit_type == DW_UT_type
-		  || unit_type == DW_UT_split_type)
-		{
-		  Dwarf_Die typedie;
-		  Dwarf_Off dieoffset;
-		  dwarf_cu_info (cu, NULL, NULL, NULL, &typedie,
-				 NULL, NULL, NULL);
-		  dieoffset = dwarf_dieoffset (&typedie);
-		  printf (", Unit DIE off: %#" PRIx64 " [%" PRIx64 "]",
-			  subdie_off, dieoffset);
-		}
-	      printf ("\n");
-	    }
-	}
-    }
-
-  if (version < 2 || version > 5
-      || unit_type < DW_UT_compile || unit_type > DW_UT_split_type)
-    {
-      if (!silent)
-	error (0, 0, _("unknown version (%d) or unit type (%d)"),
-	       version, unit_type);
-      goto next_cu;
-    }
-
-  struct attrcb_args args =
-    {
-      .dwflmod = dwflmod,
-      .silent = silent,
-      .version = version,
-      .addrsize = addrsize,
-      .offset_size = offsize
-    };
-
-  bool is_split = false;
-  int level = 0;
-  dies[0] = cudie;
-  args.cu = dies[0].cu;
-  args.dbg = dbg;
-  args.is_split = is_split;
-
-  /* We might return here again for the split CU subdie.  */
-  do_cu:
-  do
-    {
-      Dwarf_Off offset = dwarf_dieoffset (&dies[level]);
-      if (unlikely (offset == (Dwarf_Off) -1))
-	{
-	  if (!silent)
-	    error (0, 0, _("cannot get DIE offset: %s"),
-		   dwarf_errmsg (-1));
-	  goto do_return;
-	}
-
-      int tag = dwarf_tag (&dies[level]);
-      if (unlikely (tag == DW_TAG_invalid))
-	{
-	  if (!silent)
-	    error (0, 0, _("cannot get tag of DIE at offset [%" PRIx64
-				  "] in section '%s': %s"),
-		   (uint64_t) offset, secname, dwarf_errmsg (-1));
-	  goto do_return;
-	}
-
-      if (!silent)
-	{
-	  unsigned int code = dwarf_getabbrevcode (dies[level].abbrev);
-	  if (is_split)
-	    printf (" {%6" PRIx64 "}  ", (uint64_t) offset);
-	  else
-	    printf (" [%6" PRIx64 "]  ", (uint64_t) offset);
-	  printf ("%*s%-20s abbrev: %u\n", (int) (level * 2), "",
-		  dwarf_tag_name (tag), code);
-	}
-
-      /* Print the attribute values.  */
-      args.level = level;
-      args.dies = dies;
-      (void) dwarf_getattrs (&dies[level], attr_callback, &args, 0);
-
-      /* Make room for the next level's DIE.  */
-      if (level + 1 == maxdies)
-	dies = xrealloc (dies, (maxdies += 10) * sizeof (Dwarf_Die));
-
-      int res = dwarf_child (&dies[level], &dies[level + 1]);
-      if (res > 0)
-	{
-	  while ((res = dwarf_siblingof (&dies[level], &dies[level])) == 1)
-	    if (level-- == 0)
-	      break;
-
-	  if (unlikely (res == -1))
-	    {
-	      if (!silent)
-		error (0, 0, _("cannot get next DIE: %s\n"),
-		       dwarf_errmsg (-1));
-	      goto do_return;
-	    }
-	}
-      else if (unlikely (res < 0))
-	{
-	  if (!silent)
-	    error (0, 0, _("cannot get next DIE: %s"),
-		   dwarf_errmsg (-1));
-	  goto do_return;
-	}
-      else
-	++level;
-    }
-  while (level >= 0);
-
-  /* We might want to show the split compile unit if this was a skeleton.
-     We need to scan it if we are requesting printing .debug_ranges for
-     DWARF4 since GNU DebugFission uses "offsets" into the main ranges
-     section.  */
-  if (unit_type == DW_UT_skeleton
-      && ((!silent && show_split_units)
-	  || (version < 5 && (print_debug_sections & section_ranges) != 0)))
-    {
-      Dwarf_Die subdie;
-      if (dwarf_cu_info (cu, NULL, NULL, NULL, &subdie, NULL, NULL, NULL) != 0
-	  || dwarf_tag (&subdie) == DW_TAG_invalid)
-	{
-	  if (!silent)
-	    {
-	      Dwarf_Attribute dwo_at;
-	      const char *dwo_name =
-		(dwarf_formstring (dwarf_attr (&cudie, DW_AT_dwo_name,
-					       &dwo_at))
-		 ?: (dwarf_formstring (dwarf_attr (&cudie, DW_AT_GNU_dwo_name,
-						   &dwo_at))
-		     ?: "<unknown>"));
-	      fprintf (stderr,
-		       "Could not find split unit '%s', id: %" PRIx64 "\n",
-		       dwo_name, unit_id);
-	    }
-	}
-      else
-	{
-	  Dwarf_CU *split_cu = subdie.cu;
-	  dwarf_cu_die (split_cu, &result, NULL, &abbroffset,
-			&addrsize, &offsize, &unit_id, &subdie_off);
-	  Dwarf_Off offset = cu->start;
-
-	  if (!silent)
-	    {
-	      printf (_(" Split compilation unit at offset %"
-			       PRIu64 ":\n"
-			       " Version: %" PRIu16
-			       ", Abbreviation section offset: %" PRIu64
-			       ", Address size: %" PRIu8
-			       ", Offset size: %" PRIu8 "\n"),
-		      (uint64_t) offset, version, abbroffset,
-		      addrsize, offsize);
-	      printf (_(" Unit type: %s (%" PRIu8 ")"),
-		      dwarf_unit_name (unit_type), unit_type);
-	      printf (", Unit id: 0x%.16" PRIx64 "", unit_id);
-	      printf ("\n");
-	    }
-
-	  unit_type = DW_UT_split_compile;
-	  is_split = true;
-	  level = 0;
-	  dies[0] = subdie;
-	  args.cu = dies[0].cu;
-	  args.dbg = split_cu->dbg;
-	  args.is_split = is_split;
-	  goto do_cu;
-	}
-    }
-
-  /* And again... */
-  goto next_cu;
-
- do_return:
-  free (dies);
-}
-
-static void
-print_debug_info_section (Dwfl_Module *dwflmod, Ebl *ebl, GElf_Ehdr *ehdr,
-			  Elf_Scn *scn, GElf_Shdr *shdr, Dwarf *dbg)
-{
-  print_debug_units (dwflmod, ebl, ehdr, scn, shdr, dbg, false);
-}
-
-static void
-print_debug_types_section (Dwfl_Module *dwflmod, Ebl *ebl, GElf_Ehdr *ehdr,
-			   Elf_Scn *scn, GElf_Shdr *shdr, Dwarf *dbg)
-{
-  print_debug_units (dwflmod, ebl, ehdr, scn, shdr, dbg, true);
-}
-
-
-static void
-print_decoded_line_section (Dwfl_Module *dwflmod, Ebl *ebl,
-			    GElf_Ehdr *ehdr __attribute__ ((unused)),
-			    Elf_Scn *scn, GElf_Shdr *shdr, Dwarf *dbg)
-{
-  printf (_("\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n\n"),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset);
-
-  size_t address_size
-    = elf_getident (ebl->elf, NULL)[EI_CLASS] == ELFCLASS32 ? 4 : 8;
-
-  Dwarf_Lines *lines;
-  size_t nlines;
-  Dwarf_Off off, next_off = 0;
-  Dwarf_CU *cu = NULL;
-  while (dwarf_next_lines (dbg, off = next_off, &next_off, &cu, NULL, NULL,
-			   &lines, &nlines) == 0)
-    {
-      Dwarf_Die cudie;
-      if (cu != NULL && dwarf_cu_info (cu, NULL, NULL, &cudie,
-				       NULL, NULL, NULL, NULL) == 0)
-	printf (" CU [%" PRIx64 "] %s\n",
-		dwarf_dieoffset (&cudie), dwarf_diename (&cudie));
-      else
-	{
-	  /* DWARF5 lines can be independent of any CU, but they probably
-	     are used by some CU.  Determine the CU this block is for.  */
-	  Dwarf_Off cuoffset;
-	  Dwarf_Off ncuoffset = 0;
-	  size_t hsize;
-	  while (dwarf_nextcu (dbg, cuoffset = ncuoffset, &ncuoffset, &hsize,
-			       NULL, NULL, NULL) == 0)
-	    {
-	      if (dwarf_offdie (dbg, cuoffset + hsize, &cudie) == NULL)
-		continue;
-	      Dwarf_Attribute stmt_list;
-	      if (dwarf_attr (&cudie, DW_AT_stmt_list, &stmt_list) == NULL)
-		continue;
-	      Dwarf_Word lineoff;
-	      if (dwarf_formudata (&stmt_list, &lineoff) != 0)
-		continue;
-	      if (lineoff == off)
-		{
-		  /* Found the CU.  */
-		  cu = cudie.cu;
-		  break;
-		}
-	    }
-
-	  if (cu != NULL)
-	    printf (" CU [%" PRIx64 "] %s\n",
-		    dwarf_dieoffset (&cudie), dwarf_diename (&cudie));
-	  else
-	    printf (" No CU\n");
-	}
-
-      printf ("  line:col SBPE* disc isa op address"
-	      " (Statement Block Prologue Epilogue *End)\n");
-      const char *last_file = "";
-      for (size_t n = 0; n < nlines; n++)
-	{
-	  Dwarf_Line *line = dwarf_onesrcline (lines, n);
-	  if (line == NULL)
-	    {
-	      printf ("  dwarf_onesrcline: %s\n", dwarf_errmsg (-1));
-	      continue;
-	    }
-	  Dwarf_Word mtime, length;
-	  const char *file = dwarf_linesrc (line, &mtime, &length);
-	  if (file == NULL)
-	    {
-	      printf ("  <%s> (mtime: ?, length: ?)\n", dwarf_errmsg (-1));
-	      last_file = "";
-	    }
-	  else if (strcmp (last_file, file) != 0)
-	    {
-	      printf ("  %s (mtime: %" PRIu64 ", length: %" PRIu64 ")\n",
-		      file, mtime, length);
-	      last_file = file;
-	    }
-
-	  int lineno, colno;
-	  bool statement, endseq, block, prologue_end, epilogue_begin;
-	  unsigned int lineop, isa, disc;
-	  Dwarf_Addr address;
-	  dwarf_lineaddr (line, &address);
-	  dwarf_lineno (line, &lineno);
-	  dwarf_linecol (line, &colno);
-	  dwarf_lineop_index (line, &lineop);
-	  dwarf_linebeginstatement (line, &statement);
-	  dwarf_lineendsequence (line, &endseq);
-	  dwarf_lineblock (line, &block);
-	  dwarf_lineprologueend (line, &prologue_end);
-	  dwarf_lineepiloguebegin (line, &epilogue_begin);
-	  dwarf_lineisa (line, &isa);
-	  dwarf_linediscriminator (line, &disc);
-
-	  /* End sequence is special, it is one byte past.  */
-	  printf ("  %4d:%-3d %c%c%c%c%c %4d %3d %2d ",
-		  lineno, colno,
-		  (statement ? 'S' : ' '),
-		  (block ? 'B' : ' '),
-		  (prologue_end ? 'P' : ' '),
-		  (epilogue_begin ? 'E' : ' '),
-		  (endseq ? '*' : ' '),
-		  disc, isa, lineop);
-	  print_dwarf_addr (dwflmod, address_size,
-			    address - (endseq ? 1 : 0), address);
-	  printf ("\n");
-
-	  if (endseq)
-	    printf("\n");
-	}
-    }
-}
-
-
-/* Print the value of a form.
-   Returns new value of readp, or readendp on failure.  */
-static const unsigned char *
-print_form_data (Dwarf *dbg, int form, const unsigned char *readp,
-		 const unsigned char *readendp, unsigned int offset_len,
-		 Dwarf_Off str_offsets_base)
-{
-  Dwarf_Word val;
-  unsigned char *endp;
-  Elf_Data *data;
-  char *str;
-  switch (form)
-    {
-    case DW_FORM_data1:
-      if (readendp - readp < 1)
-	{
-	invalid_data:
-	  error (0, 0, "invalid data");
-	  return readendp;
-	}
-      val = *readp++;
-      printf (" %" PRIx8, (unsigned int) val);
-      break;
-
-    case DW_FORM_data2:
-      if (readendp - readp < 2)
-	goto invalid_data;
-      val = read_2ubyte_unaligned_inc (dbg, readp);
-      printf(" %" PRIx16, (unsigned int) val);
-      break;
-
-    case DW_FORM_data4:
-      if (readendp - readp < 4)
-	goto invalid_data;
-      val = read_4ubyte_unaligned_inc (dbg, readp);
-      printf (" %" PRIx32, (unsigned int) val);
-      break;
-
-    case DW_FORM_data8:
-      if (readendp - readp < 8)
-	goto invalid_data;
-      val = read_8ubyte_unaligned_inc (dbg, readp);
-      printf (" %" PRIx64, val);
-      break;
-
-    case DW_FORM_sdata:
-      if (readendp - readp < 1)
-	goto invalid_data;
-      get_sleb128 (val, readp, readendp);
-      printf (" %" PRIx64, val);
-      break;
-
-    case DW_FORM_udata:
-      if (readendp - readp < 1)
-	goto invalid_data;
-      get_uleb128 (val, readp, readendp);
-      printf (" %" PRIx64, val);
-      break;
-
-    case DW_FORM_block:
-      if (readendp - readp < 1)
-	goto invalid_data;
-      get_uleb128 (val, readp, readendp);
-      if ((size_t) (readendp - readp) < val)
-	goto invalid_data;
-      print_bytes (val, readp);
-      readp += val;
-      break;
-
-    case DW_FORM_block1:
-      if (readendp - readp < 1)
-	goto invalid_data;
-      val = *readp++;
-      if ((size_t) (readendp - readp) < val)
-	goto invalid_data;
-      print_bytes (val, readp);
-      readp += val;
-      break;
-
-    case DW_FORM_block2:
-      if (readendp - readp < 2)
-	goto invalid_data;
-      val = read_2ubyte_unaligned_inc (dbg, readp);
-      if ((size_t) (readendp - readp) < val)
-	goto invalid_data;
-      print_bytes (val, readp);
-      readp += val;
-      break;
-
-    case DW_FORM_block4:
-      if (readendp - readp < 4)
-	goto invalid_data;
-      val = read_4ubyte_unaligned_inc (dbg, readp);
-      if ((size_t) (readendp - readp) < val)
-	goto invalid_data;
-      print_bytes (val, readp);
-      readp += val;
-      break;
-
-    case DW_FORM_data16:
-      if (readendp - readp < 16)
-	goto invalid_data;
-      print_bytes (16, readp);
-      readp += 16;
-      break;
-
-    case DW_FORM_flag:
-      if (readendp - readp < 1)
-	goto invalid_data;
-      val = *readp++;
-      printf ("%s", val != 0 ? yes_str : no_str);
-      break;
-
-    case DW_FORM_string:
-      endp = memchr (readp, '\0', readendp - readp);
-      if (endp == NULL)
-	goto invalid_data;
-      printf ("%s", readp);
-      readp = endp + 1;
-      break;
-
-    case DW_FORM_strp:
-    case DW_FORM_line_strp:
-    case DW_FORM_strp_sup:
-      if ((size_t) (readendp - readp) < offset_len)
-	goto invalid_data;
-      if (offset_len == 8)
-	val = read_8ubyte_unaligned_inc (dbg, readp);
-      else
-	val = read_4ubyte_unaligned_inc (dbg, readp);
-      if (form == DW_FORM_strp)
-	data = dbg->sectiondata[IDX_debug_str];
-      else if (form == DW_FORM_line_strp)
-	data = dbg->sectiondata[IDX_debug_line_str];
-      else /* form == DW_FORM_strp_sup */
-	{
-	  Dwarf *alt = dwarf_getalt (dbg);
-	  data = alt != NULL ? alt->sectiondata[IDX_debug_str] : NULL;
-	}
-      if (data == NULL || val >= data->d_size
-	  || memchr (data->d_buf + val, '\0', data->d_size - val) == NULL)
-	str = "???";
-      else
-	str = (char *) data->d_buf + val;
-      printf ("%s (%" PRIu64 ")", str, val);
-      break;
-
-    case DW_FORM_sec_offset:
-      if ((size_t) (readendp - readp) < offset_len)
-	goto invalid_data;
-      if (offset_len == 8)
-	val = read_8ubyte_unaligned_inc (dbg, readp);
-      else
-	val = read_4ubyte_unaligned_inc (dbg, readp);
-      printf ("[%" PRIx64 "]", val);
-      break;
-
-    case DW_FORM_strx:
-    case DW_FORM_GNU_str_index:
-      if (readendp - readp < 1)
-	goto invalid_data;
-      get_uleb128 (val, readp, readendp);
-    strx_val:
-      data = dbg->sectiondata[IDX_debug_str_offsets];
-      if (data == NULL
-	  || data->d_size - str_offsets_base < val)
-	str = "???";
-      else
-	{
-	  const unsigned char *strreadp = data->d_buf + str_offsets_base + val;
-	  const unsigned char *strreadendp = data->d_buf + data->d_size;
-	  if ((size_t) (strreadendp - strreadp) < offset_len)
-	    str = "???";
-	  else
-	    {
-	      Dwarf_Off idx;
-	      if (offset_len == 8)
-		idx = read_8ubyte_unaligned (dbg, strreadp);
-	      else
-		idx = read_4ubyte_unaligned (dbg, strreadp);
-
-	      data = dbg->sectiondata[IDX_debug_str];
-	      if (data == NULL || idx >= data->d_size
-		  || memchr (data->d_buf + idx, '\0',
-			     data->d_size - idx) == NULL)
-		str = "???";
-	      else
-		str = (char *) data->d_buf + idx;
-	    }
-	}
-      printf ("%s (%" PRIu64 ")", str, val);
-      break;
-
-    case DW_FORM_strx1:
-      if (readendp - readp < 1)
-	goto invalid_data;
-      val = *readp++;
-      goto strx_val;
-
-    case DW_FORM_strx2:
-      if (readendp - readp < 2)
-	goto invalid_data;
-      val = read_2ubyte_unaligned_inc (dbg, readp);
-      goto strx_val;
-
-    case DW_FORM_strx3:
-      if (readendp - readp < 3)
-	goto invalid_data;
-      val = read_3ubyte_unaligned_inc (dbg, readp);
-      goto strx_val;
-
-    case DW_FORM_strx4:
-      if (readendp - readp < 4)
-	goto invalid_data;
-      val = read_4ubyte_unaligned_inc (dbg, readp);
-      goto strx_val;
-
-    default:
-      error (0, 0, _("unknown form: %s"), dwarf_form_name (form));
-      return readendp;
-    }
-
-  return readp;
-}
-
-/* Only used via run_advance_pc() macro */
-static inline void
-run_advance_pc (unsigned int op_advance,
-                unsigned int minimum_instr_len,
-                unsigned int max_ops_per_instr,
-                unsigned int *op_addr_advance,
-                Dwarf_Word *address,
-                unsigned int *op_index)
-{
-  const unsigned int advanced_op_index = (*op_index) + op_advance;
-
-  *op_addr_advance = minimum_instr_len * (advanced_op_index
-                                         / max_ops_per_instr);
-  *address = *address + *op_addr_advance;
-  *op_index = advanced_op_index % max_ops_per_instr;
-}
-
-static void
-print_debug_line_section (Dwfl_Module *dwflmod, Ebl *ebl, GElf_Ehdr *ehdr,
-			  Elf_Scn *scn, GElf_Shdr *shdr, Dwarf *dbg)
-{
-  if (decodedline)
-    {
-      print_decoded_line_section (dwflmod, ebl, ehdr, scn, shdr, dbg);
-      return;
-    }
-
-  printf (_("\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n"),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset);
-
-  if (shdr->sh_size == 0)
-    return;
-
-  /* There is no functionality in libdw to read the information in the
-     way it is represented here.  Hardcode the decoder.  */
-  Elf_Data *data = (dbg->sectiondata[IDX_debug_line]
-		    ?: elf_rawdata (scn, NULL));
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get line data section data: %s"),
-	     elf_errmsg (-1));
-      return;
-    }
-
-  const unsigned char *linep = (const unsigned char *) data->d_buf;
-  const unsigned char *lineendp;
-
-  while (linep
-	 < (lineendp = (const unsigned char *) data->d_buf + data->d_size))
-    {
-      size_t start_offset = linep - (const unsigned char *) data->d_buf;
-
-      printf (_("\nTable at offset %zu:\n"), start_offset);
-
-      if (unlikely (linep + 4 > lineendp))
-	goto invalid_data;
-      Dwarf_Word unit_length = read_4ubyte_unaligned_inc (dbg, linep);
-      unsigned int length = 4;
-      if (unlikely (unit_length == 0xffffffff))
-	{
-	  if (unlikely (linep + 8 > lineendp))
-	    {
-	    invalid_data:
-	      error (0, 0, _("invalid data in section [%zu] '%s'"),
-		     elf_ndxscn (scn), section_name (ebl, shdr));
-	      return;
-	    }
-	  unit_length = read_8ubyte_unaligned_inc (dbg, linep);
-	  length = 8;
-	}
-
-      /* Check whether we have enough room in the section.  */
-      if (unlikely (unit_length > (size_t) (lineendp - linep)))
-	goto invalid_data;
-      lineendp = linep + unit_length;
-
-      /* The next element of the header is the version identifier.  */
-      if ((size_t) (lineendp - linep) < 2)
-	goto invalid_data;
-      uint_fast16_t version = read_2ubyte_unaligned_inc (dbg, linep);
-
-      size_t address_size
-	= elf_getident (ebl->elf, NULL)[EI_CLASS] == ELFCLASS32 ? 4 : 8;
-      unsigned char segment_selector_size = 0;
-      if (version > 4)
-	{
-	  if ((size_t) (lineendp - linep) < 2)
-	    goto invalid_data;
-	  address_size = *linep++;
-	  segment_selector_size = *linep++;
-	}
-
-      /* Next comes the header length.  */
-      Dwarf_Word header_length;
-      if (length == 4)
-	{
-	  if ((size_t) (lineendp - linep) < 4)
-	    goto invalid_data;
-	  header_length = read_4ubyte_unaligned_inc (dbg, linep);
-	}
-      else
-	{
-	  if ((size_t) (lineendp - linep) < 8)
-	    goto invalid_data;
-	  header_length = read_8ubyte_unaligned_inc (dbg, linep);
-	}
-
-      const unsigned char *header_start = linep;
-
-      /* Next the minimum instruction length.  */
-      if ((size_t) (lineendp - linep) < 1)
-	goto invalid_data;
-      uint_fast8_t minimum_instr_len = *linep++;
-
-      /* Next the maximum operations per instruction, in version 4 format.  */
-      uint_fast8_t max_ops_per_instr;
-      if (version < 4)
-	max_ops_per_instr = 1;
-      else
-	{
-	  if ((size_t) (lineendp - linep) < 1)
-	    goto invalid_data;
-	  max_ops_per_instr = *linep++;
-	}
-
-      /* We need at least 4 more bytes.  */
-      if ((size_t) (lineendp - linep) < 4)
-	goto invalid_data;
-
-      /* Then the flag determining the default value of the is_stmt
-	 register.  */
-      uint_fast8_t default_is_stmt = *linep++;
-
-      /* Now the line base.  */
-      int_fast8_t line_base = *linep++;
-
-      /* And the line range.  */
-      uint_fast8_t line_range = *linep++;
-
-      /* The opcode base.  */
-      uint_fast8_t opcode_base = *linep++;
-
-      /* Print what we got so far.  */
-      printf (_("\n"
-		       " Length:                         %" PRIu64 "\n"
-		       " DWARF version:                  %" PRIuFAST16 "\n"
-		       " Prologue length:                %" PRIu64 "\n"
-		       " Address size:                   %zd\n"
-		       " Segment selector size:          %zd\n"
-		       " Min instruction length:         %" PRIuFAST8 "\n"
-		       " Max operations per instruction: %" PRIuFAST8 "\n"
-		       " Initial value if 'is_stmt':     %" PRIuFAST8 "\n"
-		       " Line base:                      %" PRIdFAST8 "\n"
-		       " Line range:                     %" PRIuFAST8 "\n"
-		       " Opcode base:                    %" PRIuFAST8 "\n"
-		       "\n"
-		       "Opcodes:\n"),
-	      (uint64_t) unit_length, version, (uint64_t) header_length,
-	      address_size, (size_t) segment_selector_size,
-	      minimum_instr_len, max_ops_per_instr,
-	      default_is_stmt, line_base,
-	      line_range, opcode_base);
-
-      if (version < 2 || version > 5)
-	{
-	  error (0, 0, _("cannot handle .debug_line version: %u\n"),
-		 (unsigned int) version);
-	  linep = lineendp;
-	  continue;
-	}
-
-      if (address_size != 4 && address_size != 8)
-	{
-	  error (0, 0, _("cannot handle address size: %u\n"),
-		 (unsigned int) address_size);
-	  linep = lineendp;
-	  continue;
-	}
-
-      if (segment_selector_size != 0)
-	{
-	  error (0, 0, _("cannot handle segment selector size: %u\n"),
-		 (unsigned int) segment_selector_size);
-	  linep = lineendp;
-	  continue;
-	}
-
-      if (unlikely (linep + opcode_base - 1 >= lineendp))
-	{
-	invalid_unit:
-	  error (0, 0,
-		 _("invalid data at offset %tu in section [%zu] '%s'"),
-		 linep - (const unsigned char *) data->d_buf,
-		 elf_ndxscn (scn), section_name (ebl, shdr));
-	  linep = lineendp;
-	  continue;
-	}
-      int opcode_base_l10 = 1;
-      unsigned int tmp = opcode_base;
-      while (tmp > 10)
-	{
-	  tmp /= 10;
-	  ++opcode_base_l10;
-	}
-      const uint8_t *standard_opcode_lengths = linep - 1;
-      for (uint_fast8_t cnt = 1; cnt < opcode_base; ++cnt)
-	printf (ngettext ("  [%*" PRIuFAST8 "]  %hhu argument\n",
-			  "  [%*" PRIuFAST8 "]  %hhu arguments\n",
-			  (int) linep[cnt - 1]),
-		opcode_base_l10, cnt, linep[cnt - 1]);
-      linep += opcode_base - 1;
-
-      if (unlikely (linep >= lineendp))
-	goto invalid_unit;
-
-      Dwarf_Off str_offsets_base = str_offsets_base_off (dbg, NULL);
-
-      puts (_("\nDirectory table:"));
-      if (version > 4)
-	{
-	  struct encpair { uint16_t desc; uint16_t form; };
-	  struct encpair enc[256];
-
-	  printf (_("      ["));
-	  if ((size_t) (lineendp - linep) < 1)
-	    goto invalid_data;
-	  unsigned char directory_entry_format_count = *linep++;
-	  for (int i = 0; i < directory_entry_format_count; i++)
-	    {
-	      uint16_t desc, form;
-	      if ((size_t) (lineendp - linep) < 1)
-		goto invalid_data;
-	      get_uleb128 (desc, linep, lineendp);
-	      if ((size_t) (lineendp - linep) < 1)
-		goto invalid_data;
-	      get_uleb128 (form, linep, lineendp);
-
-	      enc[i].desc = desc;
-	      enc[i].form = form;
-
-	      printf ("%s(%s)",
-		      dwarf_line_content_description_name (desc),
-		      dwarf_form_name (form));
-	      if (i + 1 < directory_entry_format_count)
-		printf (", ");
-	    }
-	  printf ("]\n");
-
-	  uint64_t directories_count;
-	  if ((size_t) (lineendp - linep) < 1)
-            goto invalid_data;
-	  get_uleb128 (directories_count, linep, lineendp);
-
-	  if (directory_entry_format_count == 0
-	      && directories_count != 0)
-	    goto invalid_data;
-
-	  for (uint64_t i = 0; i < directories_count; i++)
-	    {
-	      printf (" %-5" PRIu64 " ", i);
-	      for (int j = 0; j < directory_entry_format_count; j++)
-		{
-		  linep = print_form_data (dbg, enc[j].form,
-					   linep, lineendp, length,
-					   str_offsets_base);
-		  if (j + 1 < directory_entry_format_count)
-		    printf (", ");
-		}
-	      printf ("\n");
-	      if (linep >= lineendp)
-		goto invalid_unit;
-	    }
-	}
-      else
-	{
-	  while (linep < lineendp && *linep != 0)
-	    {
-	      unsigned char *endp = memchr (linep, '\0', lineendp - linep);
-	      if (unlikely (endp == NULL))
-		goto invalid_unit;
-
-	      printf (" %s\n", (char *) linep);
-
-	      linep = endp + 1;
-	    }
-	  if (linep >= lineendp || *linep != 0)
-	    goto invalid_unit;
-	  /* Skip the final NUL byte.  */
-	  ++linep;
-	}
-
-      if (unlikely (linep >= lineendp))
-	goto invalid_unit;
-
-      puts (_("\nFile name table:"));
-      if (version > 4)
-	{
-	  struct encpair { uint16_t desc; uint16_t form; };
-	  struct encpair enc[256];
-
-	  printf (_("      ["));
-	  if ((size_t) (lineendp - linep) < 1)
-	    goto invalid_data;
-	  unsigned char file_name_format_count = *linep++;
-	  for (int i = 0; i < file_name_format_count; i++)
-	    {
-	      uint64_t desc, form;
-	      if ((size_t) (lineendp - linep) < 1)
-		goto invalid_data;
-	      get_uleb128 (desc, linep, lineendp);
-	      if ((size_t) (lineendp - linep) < 1)
-		goto invalid_data;
-	      get_uleb128 (form, linep, lineendp);
-
-	      if (! libdw_valid_user_form (form))
-		goto invalid_data;
-
-	      enc[i].desc = desc;
-	      enc[i].form = form;
-
-	      printf ("%s(%s)",
-		      dwarf_line_content_description_name (desc),
-		      dwarf_form_name (form));
-	      if (i + 1 < file_name_format_count)
-		printf (", ");
-	    }
-	  printf ("]\n");
-
-	  uint64_t file_name_count;
-	  if ((size_t) (lineendp - linep) < 1)
-            goto invalid_data;
-	  get_uleb128 (file_name_count, linep, lineendp);
-
-	  if (file_name_format_count == 0
-	      && file_name_count != 0)
-	    goto invalid_data;
-
-	  for (uint64_t i = 0; i < file_name_count; i++)
-	    {
-	      printf (" %-5" PRIu64 " ", i);
-	      for (int j = 0; j < file_name_format_count; j++)
-		{
-		  linep = print_form_data (dbg, enc[j].form,
-					   linep, lineendp, length,
-					   str_offsets_base);
-		  if (j + 1 < file_name_format_count)
-		    printf (", ");
-		}
-	      printf ("\n");
-	      if (linep > lineendp)
-		goto invalid_unit;
-	    }
-	}
-      else
-	{
-	  puts (_(" Entry Dir   Time      Size      Name"));
-	  for (unsigned int cnt = 1; linep < lineendp && *linep != 0; ++cnt)
-	    {
-	      /* First comes the file name.  */
-	      char *fname = (char *) linep;
-	      unsigned char *endp = memchr (fname, '\0', lineendp - linep);
-	      if (unlikely (endp == NULL))
-		goto invalid_unit;
-	      linep = endp + 1;
-
-	      /* Then the index.  */
-	      unsigned int diridx;
-	      if (lineendp - linep < 1)
-		goto invalid_unit;
-	      get_uleb128 (diridx, linep, lineendp);
-
-	      /* Next comes the modification time.  */
-	      unsigned int mtime;
-	      if (lineendp - linep < 1)
-		goto invalid_unit;
-	      get_uleb128 (mtime, linep, lineendp);
-
-	      /* Finally the length of the file.  */
-	      unsigned int fsize;
-	      if (lineendp - linep < 1)
-		goto invalid_unit;
-	      get_uleb128 (fsize, linep, lineendp);
-
-	      printf (" %-5u %-5u %-9u %-9u %s\n",
-		      cnt, diridx, mtime, fsize, fname);
-	    }
-	  if (linep >= lineendp || *linep != '\0')
-	    goto invalid_unit;
-	  /* Skip the final NUL byte.  */
-	  ++linep;
-	}
-
-      unsigned int debug_str_offset = 0;
-      if (unlikely (linep == header_start + header_length - 4))
-	{
-	  /* CUBINs contain an unsigned 4-byte offset */
-	  debug_str_offset = read_4ubyte_unaligned_inc (dbg, linep);
-	}
-
-      if (linep == lineendp)
-	{
-	  puts (_("\nNo line number statements."));
-	  continue;
-	}
-
-      puts (_("\nLine number statements:"));
-      Dwarf_Word address = 0;
-      unsigned int op_index = 0;
-      size_t line = 1;
-      uint_fast8_t is_stmt = default_is_stmt;
-
-      /* Apply the "operation advance" from a special opcode
-	 or DW_LNS_advance_pc (as per DWARF4 6.2.5.1).  */
-      unsigned int op_addr_advance;
-#define advance_pc(op_advance) run_advance_pc(op_advance, minimum_instr_len, \
-                      max_ops_per_instr, &op_addr_advance, &address, &op_index)
-
-      if (max_ops_per_instr == 0)
-	{
-	  error (0, 0,
-		 _("invalid maximum operations per instruction is zero"));
-	  linep = lineendp;
-	  continue;
-	}
-
-      while (linep < lineendp)
-	{
-	  size_t offset = linep - (const unsigned char *) data->d_buf;
-	  unsigned int u128;
-	  int s128;
-
-	  /* Read the opcode.  */
-	  unsigned int opcode = *linep++;
-
-	  printf (" [%6" PRIx64 "]", (uint64_t)offset);
-	  /* Is this a special opcode?  */
-	  if (likely (opcode >= opcode_base))
-	    {
-	      if (unlikely (line_range == 0))
-		goto invalid_unit;
-
-	      /* Yes.  Handling this is quite easy since the opcode value
-		 is computed with
-
-		 opcode = (desired line increment - line_base)
-			   + (line_range * address advance) + opcode_base
-	      */
-	      int line_increment = (line_base
-				    + (opcode - opcode_base) % line_range);
-
-	      /* Perform the increments.  */
-	      line += line_increment;
-	      advance_pc ((opcode - opcode_base) / line_range);
-
-	      printf (_(" special opcode %u: address+%u = "),
-		      opcode, op_addr_advance);
-	      print_dwarf_addr (dwflmod, 0, address, address);
-	      if (op_index > 0)
-		printf (_(", op_index = %u, line%+d = %zu\n"),
-			op_index, line_increment, line);
-	      else
-		printf (_(", line%+d = %zu\n"),
-			line_increment, line);
-	    }
-	  else if (opcode == 0)
-	    {
-	      /* This an extended opcode.  */
-	      if (unlikely (linep + 2 > lineendp))
-		goto invalid_unit;
-
-	      /* The length.  */
-	      unsigned int len = *linep++;
-
-	      if (unlikely (linep + len > lineendp))
-		goto invalid_unit;
-
-	      /* The sub-opcode.  */
-	      opcode = *linep++;
-
-	      printf (_(" extended opcode %u: "), opcode);
-
-	      switch (opcode)
-		{
-		case DW_LNE_end_sequence:
-		  puts (_(" end of sequence"));
-
-		  /* Reset the registers we care about.  */
-		  address = 0;
-		  op_index = 0;
-		  line = 1;
-		  is_stmt = default_is_stmt;
-		  break;
-
-		case DW_LNE_set_address:
-		  op_index = 0;
-		  if (unlikely ((size_t) (lineendp - linep) < address_size))
-		    goto invalid_unit;
-		  if (address_size == 4)
-		    address = read_4ubyte_unaligned_inc (dbg, linep);
-		  else
-		    address = read_8ubyte_unaligned_inc (dbg, linep);
-		  {
-		    printf (_(" set address to "));
-		    print_dwarf_addr (dwflmod, 0, address, address);
-		    printf ("\n");
-		  }
-		  break;
-
-		case DW_LNE_define_file:
-		  {
-		    char *fname = (char *) linep;
-		    unsigned char *endp = memchr (linep, '\0',
-						  lineendp - linep);
-		    if (unlikely (endp == NULL))
-		      goto invalid_unit;
-		    linep = endp + 1;
-
-		    unsigned int diridx;
-		    if (lineendp - linep < 1)
-		      goto invalid_unit;
-		    get_uleb128 (diridx, linep, lineendp);
-		    Dwarf_Word mtime;
-		    if (lineendp - linep < 1)
-		      goto invalid_unit;
-		    get_uleb128 (mtime, linep, lineendp);
-		    Dwarf_Word filelength;
-		    if (lineendp - linep < 1)
-		      goto invalid_unit;
-		    get_uleb128 (filelength, linep, lineendp);
-
-		    printf (_("\
- define new file: dir=%u, mtime=%" PRIu64 ", length=%" PRIu64 ", name=%s\n"),
-			    diridx, (uint64_t) mtime, (uint64_t) filelength,
-			    fname);
-		  }
-		  break;
-
-		case DW_LNE_set_discriminator:
-		  /* Takes one ULEB128 parameter, the discriminator.  */
-		  if (unlikely (standard_opcode_lengths[opcode] != 1
-				|| lineendp - linep < 1))
-		    goto invalid_unit;
-
-		  get_uleb128 (u128, linep, lineendp);
-		  printf (_(" set discriminator to %u\n"), u128);
-		  break;
-
-		case DW_LNE_NVIDIA_inlined_call:
-		  {
-		    if (unlikely (linep >= lineendp))
-		      goto invalid_data;
-
-		    unsigned int context;
-		    get_uleb128 (context, linep, lineendp);
-
-		    if (unlikely (linep >= lineendp))
-		      goto invalid_data;
-
-		    unsigned int function_name;
-		    get_uleb128 (function_name, linep, lineendp);
-		    function_name += debug_str_offset;
-
-		    Elf_Data *str_data = dbg->sectiondata[IDX_debug_str];
-		    char *function_str;
-		    if (str_data == NULL || function_name >= str_data->d_size
-			|| memchr (str_data->d_buf + function_name, '\0',
-				   str_data->d_size - function_name) == NULL)
-		      function_str = "???";
-		    else
-		      function_str = (char *) str_data->d_buf + function_name;
-
-		    printf (_(" set inlined context %u,"
-		              " function name %s (0x%x)\n"),
-			    context, function_str, function_name);
-		    break;
-		  }
-
-		case DW_LNE_NVIDIA_set_function_name:
-		  {
-		    if (unlikely (linep >= lineendp))
-		      goto invalid_data;
-
-		    unsigned int function_name;
-		    get_uleb128 (function_name, linep, lineendp);
-		    function_name += debug_str_offset;
-
-		    Elf_Data *str_data = dbg->sectiondata[IDX_debug_str];
-		    char *function_str;
-		    if (str_data == NULL || function_name >= str_data->d_size
-			|| memchr (str_data->d_buf + function_name, '\0',
-				   str_data->d_size - function_name) == NULL)
-		      function_str = "???";
-		    else
-		      function_str = (char *) str_data->d_buf + function_name;
-
-		    printf (_(" set function name %s (0x%x)\n"),
-			    function_str, function_name);
-		  }
-		  break;
-
-		default:
-		  /* Unknown, ignore it.  */
-		  puts (_(" unknown opcode"));
-		  linep += len - 1;
-		  break;
-		}
-	    }
-	  else if (opcode <= DW_LNS_set_isa)
-	    {
-	      /* This is a known standard opcode.  */
-	      switch (opcode)
-		{
-		case DW_LNS_copy:
-		  /* Takes no argument.  */
-		  puts (_(" copy"));
-		  break;
-
-		case DW_LNS_advance_pc:
-		  /* Takes one uleb128 parameter which is added to the
-		     address.  */
-		  if (lineendp - linep < 1)
-		    goto invalid_unit;
-		  get_uleb128 (u128, linep, lineendp);
-		  advance_pc (u128);
-		  {
-		    printf (_(" advance address by %u to "),
-			    op_addr_advance);
-		    print_dwarf_addr (dwflmod, 0, address, address);
-		    if (op_index > 0)
-		      printf (_(", op_index to %u"), op_index);
-		    printf ("\n");
-		  }
-		  break;
-
-		case DW_LNS_advance_line:
-		  /* Takes one sleb128 parameter which is added to the
-		     line.  */
-		  if (lineendp - linep < 1)
-		    goto invalid_unit;
-		  get_sleb128 (s128, linep, lineendp);
-		  line += s128;
-		  printf (_("\
- advance line by constant %d to %" PRId64 "\n"),
-			  s128, (int64_t) line);
-		  break;
-
-		case DW_LNS_set_file:
-		  /* Takes one uleb128 parameter which is stored in file.  */
-		  if (lineendp - linep < 1)
-		    goto invalid_unit;
-		  get_uleb128 (u128, linep, lineendp);
-		  printf (_(" set file to %" PRIu64 "\n"),
-			  (uint64_t) u128);
-		  break;
-
-		case DW_LNS_set_column:
-		  /* Takes one uleb128 parameter which is stored in column.  */
-		  if (unlikely (standard_opcode_lengths[opcode] != 1
-				|| lineendp - linep < 1))
-		    goto invalid_unit;
-
-		  get_uleb128 (u128, linep, lineendp);
-		  printf (_(" set column to %" PRIu64 "\n"),
-			  (uint64_t) u128);
-		  break;
-
-		case DW_LNS_negate_stmt:
-		  /* Takes no argument.  */
-		  is_stmt = 1 - is_stmt;
-		  printf (_(" set '%s' to %" PRIuFAST8 "\n"),
-			  "is_stmt", is_stmt);
-		  break;
-
-		case DW_LNS_set_basic_block:
-		  /* Takes no argument.  */
-		  puts (_(" set basic block flag"));
-		  break;
-
-		case DW_LNS_const_add_pc:
-		  /* Takes no argument.  */
-
-		  if (unlikely (line_range == 0))
-		    goto invalid_unit;
-
-		  advance_pc ((255 - opcode_base) / line_range);
-		  {
-		    printf (_(" advance address by constant %u to "),
-			    op_addr_advance);
-		    print_dwarf_addr (dwflmod, 0, address, address);
-		    if (op_index > 0)
-		      printf (_(", op_index to %u"), op_index);
-		    printf ("\n");
-		  }
-		  break;
-
-		case DW_LNS_fixed_advance_pc:
-		  /* Takes one 16 bit parameter which is added to the
-		     address.  */
-		  if (unlikely (standard_opcode_lengths[opcode] != 1
-				|| lineendp - linep < 2))
-		    goto invalid_unit;
-
-		  u128 = read_2ubyte_unaligned_inc (dbg, linep);
-		  address += u128;
-		  op_index = 0;
-		  {
-		    printf (_("\
- advance address by fixed value %u to \n"),
-			    u128);
-		    print_dwarf_addr (dwflmod, 0, address, address);
-		    printf ("\n");
-		  }
-		  break;
-
-		case DW_LNS_set_prologue_end:
-		  /* Takes no argument.  */
-		  puts (_(" set prologue end flag"));
-		  break;
-
-		case DW_LNS_set_epilogue_begin:
-		  /* Takes no argument.  */
-		  puts (_(" set epilogue begin flag"));
-		  break;
-
-		case DW_LNS_set_isa:
-		  /* Takes one uleb128 parameter which is stored in isa.  */
-		  if (unlikely (standard_opcode_lengths[opcode] != 1
-				|| lineendp - linep < 1))
-		    goto invalid_unit;
-
-		  get_uleb128 (u128, linep, lineendp);
-		  printf (_(" set isa to %u\n"), u128);
-		  break;
-		}
-	    }
-	  else
-	    {
-	      /* This is a new opcode the generator but not we know about.
-		 Read the parameters associated with it but then discard
-		 everything.  Read all the parameters for this opcode.  */
-	      printf (ngettext (" unknown opcode with %" PRIu8 " parameter:",
-				" unknown opcode with %" PRIu8 " parameters:",
-				standard_opcode_lengths[opcode]),
-		      standard_opcode_lengths[opcode]);
-	      for (int n = standard_opcode_lengths[opcode];
-		   n > 0 && linep < lineendp; --n)
-		{
-		  get_uleb128 (u128, linep, lineendp);
-		  if (n != standard_opcode_lengths[opcode])
-		    putc_unlocked (',', stdout);
-		  printf (" %u", u128);
-		}
-
-	      /* Next round, ignore this opcode.  */
-	      continue;
-	    }
-	}
-    }
-
-  /* There must only be one data block.  */
-  assert (elf_getdata (scn, data) == NULL);
-}
-
-
-static void
-print_debug_loclists_section (Dwfl_Module *dwflmod,
-			      Ebl *ebl,
-			      GElf_Ehdr *ehdr __attribute__ ((unused)),
-			      Elf_Scn *scn, GElf_Shdr *shdr,
-			      Dwarf *dbg)
-{
-  printf (_("\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n"),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset);
-
-  Elf_Data *data = (dbg->sectiondata[IDX_debug_loclists]
-		    ?: elf_rawdata (scn, NULL));
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get .debug_loclists content: %s"),
-	     elf_errmsg (-1));
-      return;
-    }
-
-  /* For the listptr to get the base address/CU.  */
-  sort_listptr (&known_loclistsptr, "loclistsptr");
-  size_t listptr_idx = 0;
-
-  const unsigned char *readp = data->d_buf;
-  const unsigned char *const dataend = ((unsigned char *) data->d_buf
-					+ data->d_size);
-  while (readp < dataend)
-    {
-      if (unlikely (readp > dataend - 4))
-	{
-	invalid_data:
-	  error (0, 0, _("invalid data in section [%zu] '%s'"),
-		 elf_ndxscn (scn), section_name (ebl, shdr));
-	  return;
-	}
-
-      ptrdiff_t offset = readp - (unsigned char *) data->d_buf;
-      printf (_("Table at Offset 0x%" PRIx64 ":\n\n"),
-	      (uint64_t) offset);
-
-      uint64_t unit_length = read_4ubyte_unaligned_inc (dbg, readp);
-      unsigned int offset_size = 4;
-      if (unlikely (unit_length == 0xffffffff))
-	{
-	  if (unlikely (readp > dataend - 8))
-	    goto invalid_data;
-
-	  unit_length = read_8ubyte_unaligned_inc (dbg, readp);
-	  offset_size = 8;
-	}
-      printf (_(" Length:         %8" PRIu64 "\n"), unit_length);
-
-      /* We need at least 2-bytes + 1-byte + 1-byte + 4-bytes = 8
-	 bytes to complete the header.  And this unit cannot go beyond
-	 the section data.  */
-      if (readp > dataend - 8
-	  || unit_length < 8
-	  || unit_length > (uint64_t) (dataend - readp))
-	goto invalid_data;
-
-      const unsigned char *nexthdr = readp + unit_length;
-
-      uint16_t version = read_2ubyte_unaligned_inc (dbg, readp);
-      printf (_(" DWARF version:  %8" PRIu16 "\n"), version);
-
-      if (version != 5)
-	{
-	  error (0, 0, _("Unknown version"));
-	  goto next_table;
-	}
-
-      uint8_t address_size = *readp++;
-      printf (_(" Address size:   %8" PRIu64 "\n"),
-	      (uint64_t) address_size);
-
-      if (address_size != 4 && address_size != 8)
-	{
-	  error (0, 0, _("unsupported address size"));
-	  goto next_table;
-	}
-
-      uint8_t segment_size = *readp++;
-      printf (_(" Segment size:   %8" PRIu64 "\n"),
-	      (uint64_t) segment_size);
-
-      if (segment_size != 0)
-        {
-          error (0, 0, _("unsupported segment size"));
-          goto next_table;
-        }
-
-      uint32_t offset_entry_count = read_4ubyte_unaligned_inc (dbg, readp);
-      printf (_(" Offset entries: %8" PRIu64 "\n"),
-	      (uint64_t) offset_entry_count);
-
-      /* We need the CU that uses this unit to get the initial base address. */
-      Dwarf_Addr cu_base = 0;
-      struct Dwarf_CU *cu = NULL;
-      if (listptr_cu (&known_loclistsptr, &listptr_idx,
-		      (Dwarf_Off) offset,
-		      (Dwarf_Off) (nexthdr - (unsigned char *) data->d_buf),
-		      &cu_base, &cu)
-	  || split_dwarf_cu_base (dbg, &cu, &cu_base))
-	{
-	  Dwarf_Die cudie;
-	  if (dwarf_cu_die (cu, &cudie,
-			    NULL, NULL, NULL, NULL,
-			    NULL, NULL) == NULL)
-	    printf (_(" Unknown CU base: "));
-	  else
-	    printf (_(" CU [%6" PRIx64 "] base: "),
-		    dwarf_dieoffset (&cudie));
-	  print_dwarf_addr (dwflmod, address_size, cu_base, cu_base);
-	  printf ("\n");
-	}
-      else
-	printf (_(" Not associated with a CU.\n"));
-
-      printf ("\n");
-
-      const unsigned char *offset_array_start = readp;
-      if (offset_entry_count > 0)
-	{
-	  uint64_t max_entries = (unit_length - 8) / offset_size;
-	  if (offset_entry_count > max_entries)
-	    {
-	      error (0, 0,
-		     _("too many offset entries for unit length"));
-	      offset_entry_count = max_entries;
-	    }
-
-	  printf (_("  Offsets starting at 0x%" PRIx64 ":\n"),
-		  (uint64_t) (offset_array_start
-			      - (unsigned char *) data->d_buf));
-	  for (uint32_t idx = 0; idx < offset_entry_count; idx++)
-	    {
-	      printf ("   [%6" PRIu32 "] ", idx);
-	      if (offset_size == 4)
-		{
-		  uint32_t off = read_4ubyte_unaligned_inc (dbg, readp);
-		  printf ("0x%" PRIx32 "\n", off);
-		}
-	      else
-		{
-		  uint64_t off = read_8ubyte_unaligned_inc (dbg, readp);
-		  printf ("0x%" PRIx64 "\n", off);
-		}
-	    }
-	  printf ("\n");
-	}
-
-      Dwarf_Addr base = cu_base;
-      bool start_of_list = true;
-      while (readp < nexthdr)
-	{
-	  Dwarf_Off off = (Dwarf_Off) (readp - (unsigned char *) data->d_buf);
-	  if (listptr_attr (&known_loclistsptr, listptr_idx, off,
-			    DW_AT_GNU_locviews))
-	    {
-	      Dwarf_Off next_off = next_listptr_offset (&known_loclistsptr,
-							&listptr_idx, off);
-	      const unsigned char *locp = readp;
-	      const unsigned char *locendp;
-	      if (next_off == 0
-		  || next_off > (size_t) (nexthdr - ((const unsigned char *)
-						     data->d_buf)))
-		locendp = nexthdr;
-	      else
-		locendp = (const unsigned char *) data->d_buf + next_off;
-
-	      printf ("  Offset: %" PRIx64 ", Index: %" PRIx64 "\n",
-		      (uint64_t) (readp - (unsigned char *) data->d_buf),
-		      (uint64_t) (readp - offset_array_start));
-
-	      while (locp < locendp)
-		{
-		  uint64_t v1, v2;
-		  get_uleb128 (v1, locp, locendp);
-		  if (locp >= locendp)
-		    {
-		      printf (_("    <INVALID DATA>\n"));
-		      break;
-		    }
-		  get_uleb128 (v2, locp, locendp);
-		  printf ("    view pair %" PRId64 ", %" PRId64 "\n", v1, v2);
-		}
-
-	      printf ("\n");
-	      readp = (unsigned char *) locendp;
-	      continue;
-	    }
-
-	  uint8_t kind = *readp++;
-	  uint64_t op1, op2, len;
-
-	  /* Skip padding.  */
-	  if (start_of_list && kind == DW_LLE_end_of_list)
-	    continue;
-
-	  if (start_of_list)
-	    {
-	      base = cu_base;
-	      printf ("  Offset: %" PRIx64 ", Index: %" PRIx64 "\n",
-		      (uint64_t) (readp - (unsigned char *) data->d_buf - 1),
-		      (uint64_t) (readp - offset_array_start - 1));
-	      start_of_list = false;
-	    }
-
-	  printf ("    %s", dwarf_loc_list_encoding_name (kind));
-	  switch (kind)
-	    {
-	    case DW_LLE_end_of_list:
-	      start_of_list = true;
-	      printf ("\n\n");
-	      break;
-
-	    case DW_LLE_base_addressx:
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		{
-		invalid_entry:
-		  error (0, 0, _("invalid loclists data"));
-		  goto next_table;
-		}
-	      get_uleb128 (op1, readp, nexthdr);
-	      printf (" %" PRIx64 "\n", op1);
-	      if (! print_unresolved_addresses)
-		{
-		  Dwarf_Addr addr;
-		  if (get_indexed_addr (cu, op1, &addr) != 0)
-		    printf ("      ???\n");
-		  else
-		    {
-		      printf ("      ");
-		      print_dwarf_addr (dwflmod, address_size, addr, addr);
-		      printf ("\n");
-		    }
-		}
-	      break;
-
-	    case DW_LLE_startx_endx:
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_entry;
-	      get_uleb128 (op1, readp, nexthdr);
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_entry;
-	      get_uleb128 (op2, readp, nexthdr);
-	      printf (" %" PRIx64 ", %" PRIx64 "\n", op1, op2);
-	      if (! print_unresolved_addresses)
-		{
-		  Dwarf_Addr addr1;
-		  Dwarf_Addr addr2;
-		  if (get_indexed_addr (cu, op1, &addr1) != 0
-		      || get_indexed_addr (cu, op2, &addr2) != 0)
-		    {
-		      printf ("      ???..\n");
-		      printf ("      ???\n");
-		    }
-		  else
-		    {
-		      printf ("      ");
-		      print_dwarf_addr (dwflmod, address_size, addr1, addr1);
-		      printf ("..\n      ");
-		      print_dwarf_addr (dwflmod, address_size,
-					addr2 - 1, addr2);
-		      printf ("\n");
-		    }
-		}
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_entry;
-	      get_uleb128 (len, readp, nexthdr);
-	      if ((uint64_t) (nexthdr - readp) < len)
-		goto invalid_entry;
-	      print_ops (dwflmod, dbg, 8, 8, version,
-			 address_size, offset_size, cu, len, readp);
-	      readp += len;
-	      break;
-
-	    case DW_LLE_startx_length:
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_entry;
-	      get_uleb128 (op1, readp, nexthdr);
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_entry;
-	      get_uleb128 (op2, readp, nexthdr);
-	      printf (" %" PRIx64 ", %" PRIx64 "\n", op1, op2);
-	      if (! print_unresolved_addresses)
-		{
-		  Dwarf_Addr addr1;
-		  Dwarf_Addr addr2;
-		  if (get_indexed_addr (cu, op1, &addr1) != 0)
-		    {
-		      printf ("      ???..\n");
-		      printf ("      ???\n");
-		    }
-		  else
-		    {
-		      addr2 = addr1 + op2;
-		      printf ("      ");
-		      print_dwarf_addr (dwflmod, address_size, addr1, addr1);
-		      printf ("..\n      ");
-		      print_dwarf_addr (dwflmod, address_size,
-					addr2 - 1, addr2);
-		      printf ("\n");
-		    }
-		}
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_entry;
-	      get_uleb128 (len, readp, nexthdr);
-	      if ((uint64_t) (nexthdr - readp) < len)
-		goto invalid_entry;
-	      print_ops (dwflmod, dbg, 8, 8, version,
-			 address_size, offset_size, cu, len, readp);
-	      readp += len;
-	      break;
-
-	    case DW_LLE_offset_pair:
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_entry;
-	      get_uleb128 (op1, readp, nexthdr);
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_entry;
-	      get_uleb128 (op2, readp, nexthdr);
-	      printf (" %" PRIx64 ", %" PRIx64 "\n", op1, op2);
-	      if (! print_unresolved_addresses)
-		{
-		  op1 += base;
-		  op2 += base;
-		  printf ("      ");
-		  print_dwarf_addr (dwflmod, address_size, op1, op1);
-		  printf ("..\n      ");
-		  print_dwarf_addr (dwflmod, address_size, op2 - 1, op2);
-		  printf ("\n");
-		}
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_entry;
-	      get_uleb128 (len, readp, nexthdr);
-	      if ((uint64_t) (nexthdr - readp) < len)
-		goto invalid_entry;
-	      print_ops (dwflmod, dbg, 8, 8, version,
-			 address_size, offset_size, cu, len, readp);
-	      readp += len;
-	      break;
-
-	    case DW_LLE_default_location:
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_entry;
-	      get_uleb128 (len, readp, nexthdr);
-	      if ((uint64_t) (nexthdr - readp) < len)
-		goto invalid_entry;
-	      print_ops (dwflmod, dbg, 8, 8, version,
-			 address_size, offset_size, cu, len, readp);
-	      readp += len;
-	      break;
-
-	    case DW_LLE_base_address:
-	      if (address_size == 4)
-		{
-		  if ((uint64_t) (nexthdr - readp) < 4)
-		    goto invalid_entry;
-		  op1 = read_4ubyte_unaligned_inc (dbg, readp);
-		}
-	      else
-		{
-		  if ((uint64_t) (nexthdr - readp) < 8)
-		    goto invalid_entry;
-		  op1 = read_8ubyte_unaligned_inc (dbg, readp);
-		}
-	      base = op1;
-	      printf (" 0x%" PRIx64 "\n", base);
-	      if (! print_unresolved_addresses)
-		{
-		  printf ("      ");
-		  print_dwarf_addr (dwflmod, address_size, base, base);
-		  printf ("\n");
-		}
-	      break;
-
-	    case DW_LLE_start_end:
-	      if (address_size == 4)
-		{
-		  if ((uint64_t) (nexthdr - readp) < 8)
-		    goto invalid_entry;
-		  op1 = read_4ubyte_unaligned_inc (dbg, readp);
-		  op2 = read_4ubyte_unaligned_inc (dbg, readp);
-		}
-	      else
-		{
-		  if ((uint64_t) (nexthdr - readp) < 16)
-		    goto invalid_entry;
-		  op1 = read_8ubyte_unaligned_inc (dbg, readp);
-		  op2 = read_8ubyte_unaligned_inc (dbg, readp);
-		}
-	      printf (" 0x%" PRIx64 "..0x%" PRIx64 "\n", op1, op2);
-	      if (! print_unresolved_addresses)
-		{
-		  printf ("      ");
-		  print_dwarf_addr (dwflmod, address_size, op1, op1);
-		  printf ("..\n      ");
-		  print_dwarf_addr (dwflmod, address_size, op2 - 1, op2);
-		  printf ("\n");
-		}
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_entry;
-	      get_uleb128 (len, readp, nexthdr);
-	      if ((uint64_t) (nexthdr - readp) < len)
-		goto invalid_entry;
-	      print_ops (dwflmod, dbg, 8, 8, version,
-			 address_size, offset_size, cu, len, readp);
-	      readp += len;
-	      break;
-
-	    case DW_LLE_start_length:
-	      if (address_size == 4)
-		{
-		  if ((uint64_t) (nexthdr - readp) < 4)
-		    goto invalid_entry;
-		  op1 = read_4ubyte_unaligned_inc (dbg, readp);
-		}
-	      else
-		{
-		  if ((uint64_t) (nexthdr - readp) < 8)
-		    goto invalid_entry;
-		  op1 = read_8ubyte_unaligned_inc (dbg, readp);
-		}
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_entry;
-	      get_uleb128 (op2, readp, nexthdr);
-	      printf (" 0x%" PRIx64 ", %" PRIx64 "\n", op1, op2);
-	      if (! print_unresolved_addresses)
-		{
-		  op2 = op1 + op2;
-		  printf ("      ");
-		  print_dwarf_addr (dwflmod, address_size, op1, op1);
-		  printf ("..\n      ");
-		  print_dwarf_addr (dwflmod, address_size, op2 - 1, op2);
-		  printf ("\n");
-		}
-	      if ((uint64_t) (nexthdr - readp) < 1)
-		goto invalid_entry;
-	      get_uleb128 (len, readp, nexthdr);
-	      if ((uint64_t) (nexthdr - readp) < len)
-		goto invalid_entry;
-	      print_ops (dwflmod, dbg, 8, 8, version,
-			 address_size, offset_size, cu, len, readp);
-	      readp += len;
-	      break;
-
-	    default:
-	      goto invalid_entry;
-	    }
-	}
-
-    next_table:
-      if (readp != nexthdr)
-	{
-          size_t padding = nexthdr - readp;
-          printf (_("   %zu padding bytes\n\n"), padding);
-	  readp = nexthdr;
-	}
-    }
-}
-
-
-static void
-print_debug_loc_section (Dwfl_Module *dwflmod,
-			 Ebl *ebl, GElf_Ehdr *ehdr,
-			 Elf_Scn *scn, GElf_Shdr *shdr, Dwarf *dbg)
-{
-  Elf_Data *data = (dbg->sectiondata[IDX_debug_loc]
-		    ?: elf_rawdata (scn, NULL));
-
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get .debug_loc content: %s"),
-	     elf_errmsg (-1));
-      return;
-    }
-
-  printf (_("\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n"),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset);
-
-  sort_listptr (&known_locsptr, "loclistptr");
-  size_t listptr_idx = 0;
-
-  uint_fast8_t address_size = ehdr->e_ident[EI_CLASS] == ELFCLASS32 ? 4 : 8;
-  uint_fast8_t offset_size = 4;
-
-  bool first = true;
-  Dwarf_Addr base = 0;
-  unsigned char *readp = data->d_buf;
-  unsigned char *const endp = (unsigned char *) data->d_buf + data->d_size;
-  Dwarf_CU *last_cu = NULL;
-  while (readp < endp)
-    {
-      ptrdiff_t offset = readp - (unsigned char *) data->d_buf;
-      Dwarf_CU *cu = last_cu;
-      unsigned int attr = 0;
-
-      if (first && skip_listptr_hole (&known_locsptr, &listptr_idx,
-				      &address_size, &offset_size, &base,
-				      &cu, offset, &readp, endp, &attr))
-	continue;
-
-      if (last_cu != cu)
-       {
-	Dwarf_Die cudie;
-	if (dwarf_cu_die (cu, &cudie,
-			  NULL, NULL, NULL, NULL,
-			  NULL, NULL) == NULL)
-	  printf (_("\n Unknown CU base: "));
-	else
-	  printf (_("\n CU [%6" PRIx64 "] base: "),
-		  dwarf_dieoffset (&cudie));
-	print_dwarf_addr (dwflmod, address_size, base, base);
-	printf ("\n");
-       }
-      last_cu = cu;
-
-      if (attr == DW_AT_GNU_locviews)
-	{
-	  Dwarf_Off next_off = next_listptr_offset (&known_locsptr,
-						    &listptr_idx, offset);
-	  const unsigned char *locp = readp;
-	  const unsigned char *locendp;
-	  if (next_off == 0
-	      || next_off > (size_t) (endp
-				      - (const unsigned char *) data->d_buf))
-	    locendp = endp;
-	  else
-	    locendp = (const unsigned char *) data->d_buf + next_off;
-
-	  while (locp < locendp)
-	    {
-	      uint64_t v1, v2;
-	      get_uleb128 (v1, locp, locendp);
-	      if (locp >= locendp)
-		{
-		  printf (_(" [%6tx]  <INVALID DATA>\n"), offset);
-		  break;
-		}
-	      get_uleb128 (v2, locp, locendp);
-	      if (first)		/* First view pair in a list.  */
-		printf (" [%6tx] ", offset);
-	      else
-		printf ("          ");
-	      printf ("view pair %" PRId64 ", %" PRId64 "\n", v1, v2);
-	      first = false;
-	    }
-
-	  first = true;
-	  readp = (unsigned char *) locendp;
-	  continue;
-	}
-
-      /* GNU DebugFission encoded addresses as addrx.  */
-      bool is_debugfission = ((cu != NULL
-			       || split_dwarf_cu_base (dbg, &cu, &base))
-			      && (cu->version < 5
-				  && cu->unit_type == DW_UT_split_compile));
-      if (!is_debugfission
-	  && unlikely (data->d_size - offset < (size_t) address_size * 2))
-        {
-	invalid_data:
-	  printf (_(" [%6tx]  <INVALID DATA>\n"), offset);
-	  break;
-	}
-
-      Dwarf_Addr begin;
-      Dwarf_Addr end;
-      bool use_base = true;
-      if (is_debugfission)
-	{
-	  const unsigned char *locp = readp;
-	  const unsigned char *locendp = readp + data->d_size;
-	  if (locp >= locendp)
-	    goto invalid_data;
-
-	  Dwarf_Word idx;
-	  unsigned char code = *locp++;
-	  switch (code)
-	    {
-	    case DW_LLE_GNU_end_of_list_entry:
-	      begin = 0;
-	      end = 0;
-	      break;
-
-	    case DW_LLE_GNU_base_address_selection_entry:
-	      if (locp >= locendp)
-		goto invalid_data;
-	      begin = (Dwarf_Addr) -1;
-	      get_uleb128 (idx, locp, locendp);
-	      if (get_indexed_addr (cu, idx, &end) != 0)
-		end = idx; /* ... */
-	      break;
-
-	    case DW_LLE_GNU_start_end_entry:
-	      if (locp >= locendp)
-		goto invalid_data;
-	      get_uleb128 (idx, locp, locendp);
-	      if (get_indexed_addr (cu, idx, &begin) != 0)
-		begin = idx; /* ... */
-	      if (locp >= locendp)
-		goto invalid_data;
-	      get_uleb128 (idx, locp, locendp);
-	      if (get_indexed_addr (cu, idx, &end) != 0)
-		end = idx; /* ... */
-	      use_base = false;
-	      break;
-
-	    case DW_LLE_GNU_start_length_entry:
-	      if (locp >= locendp)
-		goto invalid_data;
-	      get_uleb128 (idx, locp, locendp);
-	      if (get_indexed_addr (cu, idx, &begin) != 0)
-		begin = idx; /* ... */
-	      if (locendp - locp < 4)
-		goto invalid_data;
-	      end = read_4ubyte_unaligned_inc (dbg, locp);
-	      end += begin;
-	      use_base = false;
-	      break;
-
-	    default:
-		goto invalid_data;
-	    }
-
-	  readp = (unsigned char *) locp;
-	}
-      else if (address_size == 8)
-	{
-	  begin = read_8ubyte_unaligned_inc (dbg, readp);
-	  end = read_8ubyte_unaligned_inc (dbg, readp);
-	}
-      else
-	{
-	  begin = read_4ubyte_unaligned_inc (dbg, readp);
-	  end = read_4ubyte_unaligned_inc (dbg, readp);
-	  if (begin == (Dwarf_Addr) (uint32_t) -1)
-	    begin = (Dwarf_Addr) -1l;
-	}
-
-      if (begin == (Dwarf_Addr) -1l) /* Base address entry.  */
-	{
-	  if (first)
-	    printf (" [%6tx] ", offset);
-	  else
-	    printf ("          ");
-	  puts (_("base address"));
-	  printf ("          ");
-	  print_dwarf_addr (dwflmod, address_size, end, end);
-	  printf ("\n");
-	  base = end;
-	  first = false;
-	}
-      else if (begin == 0 && end == 0) /* End of list entry.  */
-	{
-	  if (first)
-	    printf (_(" [%6tx] empty list\n"), offset);
-	  first = true;
-	}
-      else
-	{
-	  /* We have a location expression entry.  */
-	  uint_fast16_t len = read_2ubyte_unaligned_inc (dbg, readp);
-
-	  if (first)		/* First entry in a list.  */
-	    printf (" [%6tx] ", offset);
-	  else
-	    printf ("          ");
-
-	  printf ("range %" PRIx64 ", %" PRIx64 "\n", begin, end);
-	  if (! print_unresolved_addresses)
-	    {
-	      Dwarf_Addr dab = use_base ? base + begin : begin;
-	      Dwarf_Addr dae = use_base ? base + end : end;
-	      printf ("          ");
-	      print_dwarf_addr (dwflmod, address_size, dab, dab);
-	      printf ("..\n          ");
-	      print_dwarf_addr (dwflmod, address_size, dae - 1, dae);
-	      printf ("\n");
-	    }
-
-	  if (endp - readp <= (ptrdiff_t) len)
-	    {
-	      fputs (_("   <INVALID DATA>\n"), stdout);
-	      break;
-	    }
-
-	  print_ops (dwflmod, dbg, 11, 11,
-		     cu != NULL ? cu->version : 3,
-		     address_size, offset_size, cu, len, readp);
-
-	  first = false;
-	  readp += len;
-	}
-    }
-}
-
-struct mac_culist
-{
-  Dwarf_Die die;
-  Dwarf_Off offset;
-  Dwarf_Files *files;
-  struct mac_culist *next;
-};
-
-
-static int
-mac_compare (const void *p1, const void *p2)
-{
-  struct mac_culist *m1 = (struct mac_culist *) p1;
-  struct mac_culist *m2 = (struct mac_culist *) p2;
-
-  if (m1->offset < m2->offset)
-    return -1;
-  if (m1->offset > m2->offset)
-    return 1;
-  return 0;
-}
-
-
-static void
-print_debug_macinfo_section (Dwfl_Module *dwflmod __attribute__ ((unused)),
-			     Ebl *ebl,
-			     GElf_Ehdr *ehdr __attribute__ ((unused)),
-			     Elf_Scn *scn, GElf_Shdr *shdr, Dwarf *dbg)
-{
-  printf (_("\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n"),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset);
-  putc_unlocked ('\n', stdout);
-
-  /* There is no function in libdw to iterate over the raw content of
-     the section but it is easy enough to do.  */
-  Elf_Data *data = (dbg->sectiondata[IDX_debug_macinfo]
-		    ?: elf_rawdata (scn, NULL));
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get macro information section data: %s"),
-	     elf_errmsg (-1));
-      return;
-    }
-
-  /* Get the source file information for all CUs.  */
-  Dwarf_Off offset;
-  Dwarf_Off ncu = 0;
-  size_t hsize;
-  struct mac_culist *culist = NULL;
-  size_t nculist = 0;
-  while (dwarf_nextcu (dbg, offset = ncu, &ncu, &hsize, NULL, NULL, NULL) == 0)
-    {
-      Dwarf_Die cudie;
-      if (dwarf_offdie (dbg, offset + hsize, &cudie) == NULL)
-	continue;
-
-      Dwarf_Attribute attr;
-      if (dwarf_attr (&cudie, DW_AT_macro_info, &attr) == NULL)
-	continue;
-
-      Dwarf_Word macoff;
-      if (dwarf_formudata (&attr, &macoff) != 0)
-	continue;
-
-      struct mac_culist *newp = (struct mac_culist *) alloca (sizeof (*newp));
-      newp->die = cudie;
-      newp->offset = macoff;
-      newp->files = NULL;
-      newp->next = culist;
-      culist = newp;
-      ++nculist;
-    }
-
-  /* Convert the list into an array for easier consumption.  */
-  struct mac_culist *cus = (struct mac_culist *) alloca ((nculist + 1)
-							 * sizeof (*cus));
-  /* Add sentinel.  */
-  cus[nculist].offset = data->d_size;
-  cus[nculist].files = (Dwarf_Files *) -1l;
-  if (nculist > 0)
-    {
-      for (size_t cnt = nculist - 1; culist != NULL; --cnt)
-	{
-	  assert (cnt < nculist);
-	  cus[cnt] = *culist;
-	  culist = culist->next;
-	}
-
-      /* Sort the array according to the offset in the .debug_macinfo
-	 section.  Note we keep the sentinel at the end.  */
-      qsort (cus, nculist, sizeof (*cus), mac_compare);
-    }
-
-  const unsigned char *readp = (const unsigned char *) data->d_buf;
-  const unsigned char *readendp = readp + data->d_size;
-  int level = 1;
-
-  while (readp < readendp)
-    {
-      unsigned int opcode = *readp++;
-      unsigned int u128;
-      unsigned int u128_2;
-      const unsigned char *endp;
-
-      switch (opcode)
-	{
-	case DW_MACINFO_define:
-	case DW_MACINFO_undef:
-	case DW_MACINFO_vendor_ext:
-	  /*  For the first two opcodes the parameters are
-		line, string
-	      For the latter
-		number, string.
-	      We can treat these cases together.  */
-	  get_uleb128 (u128, readp, readendp);
-
-	  endp = memchr (readp, '\0', readendp - readp);
-	  if (unlikely (endp == NULL))
-	    {
-	      printf (_("\
-%*s*** non-terminated string at end of section"),
-		      level, "");
-	      return;
-	    }
-
-	  if (opcode == DW_MACINFO_define)
-	    printf ("%*s#define %s, line %u\n",
-		    level, "", (char *) readp, u128);
-	  else if (opcode == DW_MACINFO_undef)
-	    printf ("%*s#undef %s, line %u\n",
-		    level, "", (char *) readp, u128);
-	  else
-	    printf (" #vendor-ext %s, number %u\n", (char *) readp, u128);
-
-	  readp = endp + 1;
-	  break;
-
-	case DW_MACINFO_start_file:
-	  /* The two parameters are line and file index, in this order.  */
-	  get_uleb128 (u128, readp, readendp);
-	  if (readendp - readp < 1)
-	    {
-	      printf (_("\
-%*s*** missing DW_MACINFO_start_file argument at end of section"),
-		      level, "");
-	      return;
-	    }
-	  get_uleb128 (u128_2, readp, readendp);
-
-	  /* Find the CU DIE for this file.  */
-	  size_t macoff = readp - (const unsigned char *) data->d_buf;
-	  const char *fname = "???";
-	  if (macoff >= cus[0].offset && cus[0].offset != data->d_size)
-	    {
-	      while (macoff >= cus[1].offset && cus[1].offset != data->d_size)
-		++cus;
-
-	      if (cus[0].files == NULL
-		  && dwarf_getsrcfiles (&cus[0].die, &cus[0].files, NULL) != 0)
-		cus[0].files = (Dwarf_Files *) -1l;
-
-	      if (cus[0].files != (Dwarf_Files *) -1l)
-		fname = (dwarf_filesrc (cus[0].files, u128_2, NULL, NULL)
-			 ?: "???");
-	    }
-
-	  printf ("%*sstart_file %u, [%u] %s\n",
-		  level, "", u128, u128_2, fname);
-	  ++level;
-	  break;
-
-	case DW_MACINFO_end_file:
-	  --level;
-	  printf ("%*send_file\n", level, "");
-	  /* Nothing more to do.  */
-	  break;
-
-	default:
-	  // XXX gcc seems to generate files with a trailing zero.
-	  if (unlikely (opcode != 0 || readp != readendp))
-	    printf ("%*s*** invalid opcode %u\n", level, "", opcode);
-	  break;
-	}
-    }
-}
-
-
-static void
-print_debug_macro_section (Dwfl_Module *dwflmod __attribute__ ((unused)),
-			   Ebl *ebl,
-			   GElf_Ehdr *ehdr __attribute__ ((unused)),
-			   Elf_Scn *scn, GElf_Shdr *shdr, Dwarf *dbg)
-{
-  printf (_("\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n"),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset);
-  putc_unlocked ('\n', stdout);
-
-  Elf_Data *data =  elf_getdata (scn, NULL);
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get macro information section data: %s"),
-	     elf_errmsg (-1));
-      return;
-    }
-
-  /* Get the source file information for all CUs.  Uses same
-     datastructure as macinfo.  But uses offset field to directly
-     match .debug_line offset.  And just stored in a list.  */
-  Dwarf_Off offset;
-  Dwarf_Off ncu = 0;
-  size_t hsize;
-  struct mac_culist *culist = NULL;
-  size_t nculist = 0;
-  while (dwarf_nextcu (dbg, offset = ncu, &ncu, &hsize, NULL, NULL, NULL) == 0)
-    {
-      Dwarf_Die cudie;
-      if (dwarf_offdie (dbg, offset + hsize, &cudie) == NULL)
-	continue;
-
-      Dwarf_Attribute attr;
-      if (dwarf_attr (&cudie, DW_AT_stmt_list, &attr) == NULL)
-	continue;
-
-      Dwarf_Word lineoff;
-      if (dwarf_formudata (&attr, &lineoff) != 0)
-	continue;
-
-      struct mac_culist *newp = (struct mac_culist *) alloca (sizeof (*newp));
-      newp->die = cudie;
-      newp->offset = lineoff;
-      newp->files = NULL;
-      newp->next = culist;
-      culist = newp;
-      ++nculist;
-    }
-
-  const unsigned char *readp = (const unsigned char *) data->d_buf;
-  const unsigned char *readendp = readp + data->d_size;
-
-  while (readp < readendp)
-    {
-      printf (_(" Offset:             0x%" PRIx64 "\n"),
-	      (uint64_t) (readp - (const unsigned char *) data->d_buf));
-
-      // Header, 2 byte version, 1 byte flag, optional .debug_line offset,
-      // optional vendor extension macro entry table.
-      if (readp + 2 > readendp)
-	{
-	invalid_data:
-	  error (0, 0, _("invalid data"));
-	  return;
-	}
-      const uint16_t vers = read_2ubyte_unaligned_inc (dbg, readp);
-      printf (_(" Version:            %" PRIu16 "\n"), vers);
-
-      // Version 4 is the GNU extension for DWARF4.  DWARF5 will use version
-      // 5 when it gets standardized.
-      if (vers != 4 && vers != 5)
-	{
-	  printf (_("  unknown version, cannot parse section\n"));
-	  return;
-	}
-
-      if (readp + 1 > readendp)
-	goto invalid_data;
-      const unsigned char flag = *readp++;
-      printf (_(" Flag:               0x%" PRIx8), flag);
-      if (flag != 0)
-	{
-	  printf (" (");
-	  if ((flag & 0x01) != 0)
-	    {
-	      printf ("offset_size");
-	      if ((flag & 0xFE) !=  0)
-		printf (", ");
-	    }
-	  if ((flag & 0x02) != 0)
-	    {
-	      printf ("debug_line_offset");
-	      if ((flag & 0xFC) !=  0)
-		printf (", ");
-	    }
-	  if ((flag & 0x04) != 0)
-	    {
-	      printf ("operands_table");
-	      if ((flag & 0xF8) !=  0)
-		printf (", ");
-	    }
-	  if ((flag & 0xF8) != 0)
-	    printf ("unknown");
-	  printf (")");
-	}
-      printf ("\n");
-
-      unsigned int offset_len = (flag & 0x01) ? 8 : 4;
-      printf (_(" Offset length:      %" PRIu8 "\n"), offset_len);
-      Dwarf_Off line_offset = -1;
-      if (flag & 0x02)
-	{
-	  if (offset_len == 8)
-	    line_offset = read_8ubyte_unaligned_inc (dbg, readp);
-	  else
-	    line_offset = read_4ubyte_unaligned_inc (dbg, readp);
-	  printf (_(" .debug_line offset: 0x%" PRIx64 "\n"),
-		  line_offset);
-	}
-
-      struct mac_culist *cu = NULL;
-      if (line_offset != (Dwarf_Off) -1)
-	{
-	  cu = culist;
-	  while (cu != NULL && line_offset != cu->offset)
-	    cu = cu->next;
-	}
-
-      Dwarf_Off str_offsets_base = str_offsets_base_off (dbg, (cu != NULL
-							       ? cu->die.cu
-							       : NULL));
-
-      const unsigned char *vendor[DW_MACRO_hi_user - DW_MACRO_lo_user + 1];
-      memset (vendor, 0, sizeof vendor);
-      if (flag & 0x04)
-	{
-	  // 1 byte length, for each item, 1 byte opcode, uleb128 number
-	  // of arguments, for each argument 1 byte form code.
-	  if (readp + 1 > readendp)
-	    goto invalid_data;
-	  unsigned int tlen = *readp++;
-	  printf (_("  extension opcode table, %" PRIu8 " items:\n"),
-		  tlen);
-	  for (unsigned int i = 0; i < tlen; i++)
-	    {
-	      if (readp + 1 > readendp)
-		goto invalid_data;
-	      unsigned int opcode = *readp++;
-	      printf (_("    [%" PRIx8 "]"), opcode);
-	      if (opcode < DW_MACRO_lo_user
-		  || opcode > DW_MACRO_hi_user)
-		goto invalid_data;
-	      // Record the start of description for this vendor opcode.
-	      // uleb128 nr args, 1 byte per arg form.
-	      vendor[opcode - DW_MACRO_lo_user] = readp;
-	      if (readp + 1 > readendp)
-		goto invalid_data;
-	      unsigned int args = *readp++;
-	      if (args > 0)
-		{
-		  printf (_(" %" PRIu8 " arguments:"), args);
-		  while (args > 0)
-		    {
-		      if (readp + 1 > readendp)
-			goto invalid_data;
-		      unsigned int form = *readp++;
-		      printf (" %s", dwarf_form_name (form));
-		      if (! libdw_valid_user_form (form))
-			goto invalid_data;
-		      args--;
-		      if (args > 0)
-			putchar_unlocked (',');
-		    }
-		}
-	      else
-		printf (_(" no arguments."));
-	      putchar_unlocked ('\n');
-	    }
-	}
-      putchar_unlocked ('\n');
-
-      int level = 1;
-      if (readp + 1 > readendp)
-	goto invalid_data;
-      unsigned int opcode = *readp++;
-      while (opcode != 0)
-	{
-	  unsigned int u128;
-	  unsigned int u128_2;
-	  const unsigned char *endp;
-	  uint64_t off;
-
-          switch (opcode)
-            {
-            case DW_MACRO_start_file:
-	      get_uleb128 (u128, readp, readendp);
-	      if (readp >= readendp)
-		goto invalid_data;
-	      get_uleb128 (u128_2, readp, readendp);
-
-	      /* Find the CU DIE that matches this line offset.  */
-	      const char *fname = "???";
-	      if (cu != NULL)
-		{
-		  if (cu->files == NULL
-		      && dwarf_getsrcfiles (&cu->die, &cu->files,
-					    NULL) != 0)
-		    cu->files = (Dwarf_Files *) -1l;
-
-		  if (cu->files != (Dwarf_Files *) -1l)
-		    fname = (dwarf_filesrc (cu->files, u128_2,
-					    NULL, NULL) ?: "???");
-		}
-	      printf ("%*sstart_file %u, [%u] %s\n",
-		      level, "", u128, u128_2, fname);
-	      ++level;
-	      break;
-
-	    case DW_MACRO_end_file:
-	      --level;
-	      printf ("%*send_file\n", level, "");
-	      break;
-
-	    case DW_MACRO_define:
-	      get_uleb128 (u128, readp, readendp);
-	      endp = memchr (readp, '\0', readendp - readp);
-	      if (endp == NULL)
-		goto invalid_data;
-	      printf ("%*s#define %s, line %u\n",
-		      level, "", readp, u128);
-	      readp = endp + 1;
-	      break;
-
-	    case DW_MACRO_undef:
-	      get_uleb128 (u128, readp, readendp);
-	      endp = memchr (readp, '\0', readendp - readp);
-	      if (endp == NULL)
-		goto invalid_data;
-	      printf ("%*s#undef %s, line %u\n",
-		      level, "", readp, u128);
-	      readp = endp + 1;
-	      break;
-
-	    case DW_MACRO_define_strp:
-	      get_uleb128 (u128, readp, readendp);
-	      if (readp + offset_len > readendp)
-		goto invalid_data;
-	      if (offset_len == 8)
-		off = read_8ubyte_unaligned_inc (dbg, readp);
-	      else
-		off = read_4ubyte_unaligned_inc (dbg, readp);
-	      printf ("%*s#define %s, line %u (indirect)\n",
-		      level, "", dwarf_getstring (dbg, off, NULL), u128);
-	      break;
-
-	    case DW_MACRO_undef_strp:
-	      get_uleb128 (u128, readp, readendp);
-	      if (readp + offset_len > readendp)
-		goto invalid_data;
-	      if (offset_len == 8)
-		off = read_8ubyte_unaligned_inc (dbg, readp);
-	      else
-		off = read_4ubyte_unaligned_inc (dbg, readp);
-	      printf ("%*s#undef %s, line %u (indirect)\n",
-		      level, "", dwarf_getstring (dbg, off, NULL), u128);
-	      break;
-
-	    case DW_MACRO_import:
-	      if (readp + offset_len > readendp)
-		goto invalid_data;
-	      if (offset_len == 8)
-		off = read_8ubyte_unaligned_inc (dbg, readp);
-	      else
-		off = read_4ubyte_unaligned_inc (dbg, readp);
-	      printf ("%*s#include offset 0x%" PRIx64 "\n",
-		      level, "", off);
-	      break;
-
-	    case DW_MACRO_define_sup:
-	      get_uleb128 (u128, readp, readendp);
-	      if (readp + offset_len > readendp)
-		goto invalid_data;
-	      printf ("%*s#define ", level, "");
-	      readp =  print_form_data (dbg, DW_FORM_strp_sup,
-					readp, readendp, offset_len,
-					str_offsets_base);
-	      printf (", line %u (sup)\n", u128);
-	      break;
-
-	    case DW_MACRO_undef_sup:
-	      get_uleb128 (u128, readp, readendp);
-	      if (readp + offset_len > readendp)
-		goto invalid_data;
-	      printf ("%*s#undef ", level, "");
-	      readp =  print_form_data (dbg, DW_FORM_strp_sup,
-					readp, readendp, offset_len,
-					str_offsets_base);
-	      printf (", line %u (sup)\n", u128);
-	      break;
-
-	    case DW_MACRO_import_sup:
-	      if (readp + offset_len > readendp)
-		goto invalid_data;
-	      if (offset_len == 8)
-		off = read_8ubyte_unaligned_inc (dbg, readp);
-	      else
-		off = read_4ubyte_unaligned_inc (dbg, readp);
-	      // XXX Needs support for reading from supplementary object file.
-	      printf ("%*s#include offset 0x%" PRIx64 " (sup)\n",
-		      level, "", off);
-	      break;
-
-	    case DW_MACRO_define_strx:
-	      get_uleb128 (u128, readp, readendp);
-	      if (readp + offset_len > readendp)
-		goto invalid_data;
-	      printf ("%*s#define ", level, "");
-	      readp =  print_form_data (dbg, DW_FORM_strx,
-					readp, readendp, offset_len,
-					str_offsets_base);
-	      printf (", line %u (strx)\n", u128);
-	      break;
-
-	    case DW_MACRO_undef_strx:
-	      get_uleb128 (u128, readp, readendp);
-	      if (readp + offset_len > readendp)
-		goto invalid_data;
-	      printf ("%*s#undef ", level, "");
-	      readp =  print_form_data (dbg, DW_FORM_strx,
-					readp, readendp, offset_len,
-					str_offsets_base);
-	      printf (", line %u (strx)\n", u128);
-	      break;
-
-	    default:
-	      printf ("%*svendor opcode 0x%" PRIx8, level, "", opcode);
-	      if (opcode < DW_MACRO_lo_user
-		  || opcode > DW_MACRO_lo_user
-		  || vendor[opcode - DW_MACRO_lo_user] == NULL)
-		goto invalid_data;
-
-	      const unsigned char *op_desc;
-	      op_desc = vendor[opcode - DW_MACRO_lo_user];
-
-	      // Just skip the arguments, we cannot really interpret them,
-	      // but print as much as we can.
-	      unsigned int args = *op_desc++;
-	      while (args > 0 && readp < readendp)
-		{
-		  unsigned int form = *op_desc++;
-		  readp = print_form_data (dbg, form, readp, readendp,
-					   offset_len, str_offsets_base);
-		  args--;
-		  if (args > 0)
-		    printf (", ");
-		}
-	      putchar_unlocked ('\n');
-	    }
-
-	  if (readp + 1 > readendp)
-	    goto invalid_data;
-	  opcode = *readp++;
-	  if (opcode == 0)
-	    putchar_unlocked ('\n');
-	}
-    }
-}
-
-
-/* Callback for printing global names.  */
-static int
-print_pubnames (Dwarf *dbg __attribute__ ((unused)), Dwarf_Global *global,
-		void *arg)
-{
-  int *np = (int *) arg;
-
-  printf (_(" [%5d] DIE offset: %6" PRId64
-		   ", CU DIE offset: %6" PRId64 ", name: %s\n"),
-	  (*np)++, global->die_offset, global->cu_offset, global->name);
-
-  return 0;
-}
-
-
-/* Print the known exported symbols in the DWARF section '.debug_pubnames'.  */
-static void
-print_debug_pubnames_section (Dwfl_Module *dwflmod __attribute__ ((unused)),
-			      Ebl *ebl,
-			      GElf_Ehdr *ehdr __attribute__ ((unused)),
-			      Elf_Scn *scn, GElf_Shdr *shdr, Dwarf *dbg)
-{
-  printf (_("\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n"),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset);
-
-  int n = 0;
-  (void) dwarf_getpubnames (dbg, print_pubnames, &n, 0);
-}
-
-/* Print the content of the DWARF string section '.debug_str'.  */
-static void
-print_debug_str_section (Dwfl_Module *dwflmod __attribute__ ((unused)),
-			 Ebl *ebl,
-			 GElf_Ehdr *ehdr __attribute__ ((unused)),
-			 Elf_Scn *scn, GElf_Shdr *shdr,
-			 Dwarf *dbg __attribute__ ((unused)))
-{
-  Elf_Data *data = elf_rawdata (scn, NULL);
-  const size_t sh_size = data ? data->d_size : 0;
-
-  /* Compute floor(log16(shdr->sh_size)).  */
-  GElf_Addr tmp = sh_size;
-  int digits = 1;
-  while (tmp >= 16)
-    {
-      ++digits;
-      tmp >>= 4;
-    }
-  digits = MAX (4, digits);
-
-  printf (_("\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n"
-		   " %*s  String\n"),
-	  elf_ndxscn (scn),
-	  section_name (ebl, shdr), (uint64_t) shdr->sh_offset,
-	  /* TRANS: the debugstr| prefix makes the string unique.  */
-	  digits + 2, sgettext ("debugstr|Offset"));
-
-  Dwarf_Off offset = 0;
-  while (offset < sh_size)
-    {
-      size_t len;
-      const char *str = (const char *) data->d_buf + offset;
-      const char *endp = memchr (str, '\0', sh_size - offset);
-      if (unlikely (endp == NULL))
-	{
-	  printf (_(" *** error, missing string terminator\n"));
-	  break;
-	}
-
-      printf (" [%*" PRIx64 "]  \"%s\"\n", digits, (uint64_t) offset, str);
-      len = endp - str;
-      offset += len + 1;
-    }
-}
-
-static void
-print_debug_str_offsets_section (Dwfl_Module *dwflmod __attribute__ ((unused)),
-				 Ebl *ebl,
-				 GElf_Ehdr *ehdr __attribute__ ((unused)),
-				 Elf_Scn *scn, GElf_Shdr *shdr, Dwarf *dbg)
-{
-  printf (_("\
-\nDWARF section [%2zu] '%s' at offset %#" PRIx64 ":\n"),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset);
-
-  if (shdr->sh_size == 0)
-    return;
-
-  /* We like to get the section from libdw to make sure they are relocated.  */
-  Elf_Data *data = (dbg->sectiondata[IDX_debug_str_offsets]
-		    ?: elf_rawdata (scn, NULL));
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get .debug_str_offsets section data: %s"),
-	     elf_errmsg (-1));
-      return;
-    }
-
-  size_t idx = 0;
-  sort_listptr (&known_stroffbases, "str_offsets");
-
-  const unsigned char *start = (const unsigned char *) data->d_buf;
-  const unsigned char *readp = start;
-  const unsigned char *readendp = ((const unsigned char *) data->d_buf
-				   + data->d_size);
-
-  while (readp < readendp)
-    {
-      /* Most string offset tables will have a header.  For split
-	 dwarf unit GNU DebugFission didn't add one.  But they were
-	 also only defined for split units (main or skeleton units
-	 didn't have indirect strings).  So if we don't have a
-	 DW_AT_str_offsets_base at all and this is offset zero, then
-	 just start printing offsets immediately, if this is a .dwo
-	 section.  */
-      Dwarf_Off off = (Dwarf_Off) (readp
-				   - (const unsigned char *) data->d_buf);
-
-      printf ("Table at offset %" PRIx64 " ", off);
-
-      struct listptr *listptr = get_listptr (&known_stroffbases, idx++);
-      const unsigned char *next_unitp = readendp;
-      uint8_t offset_size;
-      bool has_header;
-      if (listptr == NULL)
-	{
-	  /* This can happen for .dwo files.  There is only an header
-	     in the case this is a version 5 split DWARF file.  */
-	  Dwarf_CU *cu;
-	  uint8_t unit_type;
-	  if (dwarf_get_units (dbg, NULL, &cu, NULL, &unit_type,
-			       NULL, NULL) != 0)
-	    {
-	      error (0, 0, "Warning: Cannot find any DWARF unit.");
-	      /* Just guess some values.  */
-	      has_header = false;
-	      offset_size = 4;
-	    }
-	  else if (off == 0
-		   && (unit_type == DW_UT_split_type
-		       || unit_type == DW_UT_split_compile))
-	    {
-	      has_header = cu->version > 4;
-	      offset_size = cu->offset_size;
-	    }
-	  else
-	    {
-	      error (0, 0,
-		     "Warning: No CU references .debug_str_offsets after %"
-		     PRIx64, off);
-	      has_header = cu->version > 4;
-	      offset_size = cu->offset_size;
-	    }
-	  printf ("\n");
-	}
-      else
-	{
-	  /* This must be DWARF5, since GNU DebugFission didn't define
-	     DW_AT_str_offsets_base.  */
-	  has_header = true;
-
-	  Dwarf_Die cudie;
-	  if (dwarf_cu_die (listptr->cu, &cudie,
-			    NULL, NULL, NULL, NULL,
-			    NULL, NULL) == NULL)
-	    printf ("Unknown CU (%s):\n", dwarf_errmsg (-1));
-	  else
-	    printf ("for CU [%6" PRIx64 "]:\n", dwarf_dieoffset (&cudie));
-	}
-
-      if (has_header)
-	{
-	  uint64_t unit_length;
-	  uint16_t version;
-	  uint16_t padding;
-
-	  unit_length = read_4ubyte_unaligned_inc (dbg, readp);
-	  if (unlikely (unit_length == 0xffffffff))
-	    {
-	      if (unlikely (readp > readendp - 8))
-		{
-		invalid_data:
-		  error (0, 0, "Invalid data");
-		  return;
-		}
-	      unit_length = read_8ubyte_unaligned_inc (dbg, readp);
-	      offset_size = 8;
-	    }
-	  else
-	    offset_size = 4;
-
-	  printf ("\n");
-	  printf (_(" Length:        %8" PRIu64 "\n"),
-		  unit_length);
-	  printf (_(" Offset size:   %8" PRIu8 "\n"),
-		  offset_size);
-
-	  /* We need at least 2-bytes (version) + 2-bytes (padding) =
-	     4 bytes to complete the header.  And this unit cannot go
-	     beyond the section data.  */
-	  if (readp > readendp - 4
-	      || unit_length < 4
-	      || unit_length > (uint64_t) (readendp - readp))
-	    goto invalid_data;
-
-	  next_unitp = readp + unit_length;
-
-	  version = read_2ubyte_unaligned_inc (dbg, readp);
-	  printf (_(" DWARF version: %8" PRIu16 "\n"), version);
-
-	  if (version != 5)
-	    {
-	      error (0, 0, _("Unknown version"));
-	      goto next_unit;
-	    }
-
-	  padding = read_2ubyte_unaligned_inc (dbg, readp);
-	  printf (_(" Padding:       %8" PRIx16 "\n"), padding);
-
-	  if (listptr != NULL
-	      && listptr->offset != (Dwarf_Off) (readp - start))
-	    {
-	      error (0, 0, "String offsets index doesn't start after header");
-	      goto next_unit;
-	    }
-
-	  printf ("\n");
-	}
-
-      int digits = 1;
-      size_t offsets = (next_unitp - readp) / offset_size;
-      while (offsets >= 10)
-	{
-	  ++digits;
-	  offsets /= 10;
-	}
-
-      unsigned int uidx = 0;
-      size_t index_offset =  readp - (const unsigned char *) data->d_buf;
-      printf (" Offsets start at 0x%zx:\n", index_offset);
-      while (readp <= next_unitp - offset_size)
-	{
-	  Dwarf_Word offset;
-	  if (offset_size == 4)
-	    offset = read_4ubyte_unaligned_inc (dbg, readp);
-	  else
-	    offset = read_8ubyte_unaligned_inc (dbg, readp);
-	  const char *str = dwarf_getstring (dbg, offset, NULL);
-	  printf (" [%*u] [%*" PRIx64 "]  \"%s\"\n",
-		  digits, uidx++, (int) offset_size * 2, offset, str ?: "???");
-	}
-      printf ("\n");
-
-      if (readp != next_unitp)
-	error (0, 0, "extra %zd bytes at end of unit",
-	       (size_t) (next_unitp - readp));
-
-    next_unit:
-      readp = next_unitp;
-    }
-}
-
-
-/* Print the content of the call frame search table section
-   '.eh_frame_hdr'.  */
-static void
-print_debug_frame_hdr_section (Dwfl_Module *dwflmod __attribute__ ((unused)),
-			       Ebl *ebl __attribute__ ((unused)),
-			       GElf_Ehdr *ehdr __attribute__ ((unused)),
-			       Elf_Scn *scn, GElf_Shdr *shdr, Dwarf *dbg)
-{
-  printf (_("\
-\nCall frame search table section [%2zu] '.eh_frame_hdr':\n"),
-	  elf_ndxscn (scn));
-
-  Elf_Data *data = elf_rawdata (scn, NULL);
-
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get %s content: %s"),
-	     ".eh_frame_hdr", elf_errmsg (-1));
-      return;
-    }
-
-  const unsigned char *readp = data->d_buf;
-  const unsigned char *const dataend = ((unsigned char *) data->d_buf
-					+ data->d_size);
-
-  if (unlikely (readp + 4 > dataend))
-    {
-    invalid_data:
-      error (0, 0, _("invalid data"));
-      return;
-    }
-
-  unsigned int version = *readp++;
-  unsigned int eh_frame_ptr_enc = *readp++;
-  unsigned int fde_count_enc = *readp++;
-  unsigned int table_enc = *readp++;
-
-  printf (" version:          %u\n"
-	  " eh_frame_ptr_enc: %#x ",
-	  version, eh_frame_ptr_enc);
-  print_encoding_base ("", eh_frame_ptr_enc);
-  printf (" fde_count_enc:    %#x ", fde_count_enc);
-  print_encoding_base ("", fde_count_enc);
-  printf (" table_enc:        %#x ", table_enc);
-  print_encoding_base ("", table_enc);
-
-  uint64_t eh_frame_ptr = 0;
-  if (eh_frame_ptr_enc != DW_EH_PE_omit)
-    {
-      readp = read_encoded (eh_frame_ptr_enc, readp, dataend, &eh_frame_ptr,
-			    dbg);
-      if (unlikely (readp == NULL))
-	goto invalid_data;
-
-      printf (" eh_frame_ptr:     %#" PRIx64, eh_frame_ptr);
-      if ((eh_frame_ptr_enc & 0x70) == DW_EH_PE_pcrel)
-	printf (" (offset: %#" PRIx64 ")",
-		/* +4 because of the 4 byte header of the section.  */
-		(uint64_t) shdr->sh_offset + 4 + eh_frame_ptr);
-
-      putchar_unlocked ('\n');
-    }
-
-  uint64_t fde_count = 0;
-  if (fde_count_enc != DW_EH_PE_omit)
-    {
-      readp = read_encoded (fde_count_enc, readp, dataend, &fde_count, dbg);
-      if (unlikely (readp == NULL))
-	goto invalid_data;
-
-      printf (" fde_count:        %" PRIu64 "\n", fde_count);
-    }
-
-  if (fde_count == 0 || table_enc == DW_EH_PE_omit)
-    return;
-
-  puts (" Table:");
-
-  /* Optimize for the most common case.  */
-  if (table_enc == (DW_EH_PE_datarel | DW_EH_PE_sdata4))
-    while (fde_count > 0 && readp + 8 <= dataend)
-      {
-	int32_t initial_location = read_4sbyte_unaligned_inc (dbg, readp);
-	uint64_t initial_offset = ((uint64_t) shdr->sh_offset
-				   + (int64_t) initial_location);
-	int32_t address = read_4sbyte_unaligned_inc (dbg, readp);
-	// XXX Possibly print symbol name or section offset for initial_offset
-	printf ("  %#" PRIx32 " (offset: %#6" PRIx64 ") -> %#" PRIx32
-		" fde=[%6" PRIx64 "]\n",
-		initial_location, initial_offset,
-		address, address - (eh_frame_ptr + 4));
-      }
-  else
-    while (0 && readp < dataend)
-      {
-
-      }
-}
-
-
-/* Print the content of the exception handling table section
-   '.eh_frame_hdr'.  */
-static void
-print_debug_exception_table (Dwfl_Module *dwflmod __attribute__ ((unused)),
-			     Ebl *ebl __attribute__ ((unused)),
-			     GElf_Ehdr *ehdr __attribute__ ((unused)),
-			     Elf_Scn *scn,
-			     GElf_Shdr *shdr __attribute__ ((unused)),
-			     Dwarf *dbg __attribute__ ((unused)))
-{
-  printf (_("\
-\nException handling table section [%2zu] '.gcc_except_table':\n"),
-	  elf_ndxscn (scn));
-
-  Elf_Data *data = elf_rawdata (scn, NULL);
-
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get %s content: %s"),
-	     ".gcc_except_table", elf_errmsg (-1));
-      return;
-    }
-
-  const unsigned char *readp = data->d_buf;
-  const unsigned char *const dataend = readp + data->d_size;
-
-  if (unlikely (readp + 1 > dataend))
-    {
-    invalid_data:
-      error (0, 0, _("invalid data"));
-      return;
-    }
-  unsigned int lpstart_encoding = *readp++;
-  printf (_(" LPStart encoding:    %#x "), lpstart_encoding);
-  print_encoding_base ("", lpstart_encoding);
-  if (lpstart_encoding != DW_EH_PE_omit)
-    {
-      uint64_t lpstart;
-      readp = read_encoded (lpstart_encoding, readp, dataend, &lpstart, dbg);
-      printf (" LPStart:             %#" PRIx64 "\n", lpstart);
-    }
-
-  if (unlikely (readp + 1 > dataend))
-    goto invalid_data;
-  unsigned int ttype_encoding = *readp++;
-  printf (_(" TType encoding:      %#x "), ttype_encoding);
-  print_encoding_base ("", ttype_encoding);
-  const unsigned char *ttype_base = NULL;
-  if (ttype_encoding != DW_EH_PE_omit)
-    {
-      unsigned int ttype_base_offset;
-      get_uleb128 (ttype_base_offset, readp, dataend);
-      printf (" TType base offset:   %#x\n", ttype_base_offset);
-      if ((size_t) (dataend - readp) > ttype_base_offset)
-        ttype_base = readp + ttype_base_offset;
-    }
-
-  if (unlikely (readp + 1 > dataend))
-    goto invalid_data;
-  unsigned int call_site_encoding = *readp++;
-  printf (_(" Call site encoding:  %#x "), call_site_encoding);
-  print_encoding_base ("", call_site_encoding);
-  unsigned int call_site_table_len;
-  get_uleb128 (call_site_table_len, readp, dataend);
-
-  const unsigned char *const action_table = readp + call_site_table_len;
-  if (unlikely (action_table > dataend))
-    goto invalid_data;
-  unsigned int u = 0;
-  unsigned int max_action = 0;
-  while (readp < action_table)
-    {
-      if (u == 0)
-	puts (_("\n Call site table:"));
-
-      uint64_t call_site_start;
-      readp = read_encoded (call_site_encoding, readp, dataend,
-			    &call_site_start, dbg);
-      uint64_t call_site_length;
-      readp = read_encoded (call_site_encoding, readp, dataend,
-			    &call_site_length, dbg);
-      uint64_t landing_pad;
-      readp = read_encoded (call_site_encoding, readp, dataend,
-			    &landing_pad, dbg);
-      unsigned int action;
-      get_uleb128 (action, readp, dataend);
-      max_action = MAX (action, max_action);
-      printf (_(" [%4u] Call site start:   %#" PRIx64 "\n"
-		       "        Call site length:  %" PRIu64 "\n"
-		       "        Landing pad:       %#" PRIx64 "\n"
-		       "        Action:            %u\n"),
-	      u++, call_site_start, call_site_length, landing_pad, action);
-    }
-  if (readp != action_table)
-    goto invalid_data;
-
-  unsigned int max_ar_filter = 0;
-  if (max_action > 0)
-    {
-      puts ("\n Action table:");
-
-      size_t maxdata = (size_t) (dataend - action_table);
-      if (max_action > maxdata || maxdata - max_action < 1)
-	{
-	invalid_action_table:
-	  fputs (_("   <INVALID DATA>\n"), stdout);
-	  return;
-	}
-
-      const unsigned char *const action_table_end
-	= action_table + max_action + 1;
-
-      u = 0;
-      do
-	{
-	  int ar_filter;
-	  get_sleb128 (ar_filter, readp, action_table_end);
-	  if (ar_filter > 0 && (unsigned int) ar_filter > max_ar_filter)
-	    max_ar_filter = ar_filter;
-	  int ar_disp;
-	  if (readp >= action_table_end)
-	    goto invalid_action_table;
-	  get_sleb128 (ar_disp, readp, action_table_end);
-
-	  printf (" [%4u] ar_filter:  % d\n"
-		  "        ar_disp:    % -5d",
-		  u, ar_filter, ar_disp);
-	  if (abs (ar_disp) & 1)
-	    printf (" -> [%4u]\n", u + (ar_disp + 1) / 2);
-	  else if (ar_disp != 0)
-	    puts (" -> ???");
-	  else
-	    putchar_unlocked ('\n');
-	  ++u;
-	}
-      while (readp < action_table_end);
-    }
-
-  if (max_ar_filter > 0 && ttype_base != NULL)
-    {
-      unsigned char dsize;
-      puts ("\n TType table:");
-
-      // XXX Not *4, size of encoding;
-      switch (ttype_encoding & 7)
-	{
-	case DW_EH_PE_udata2:
-	case DW_EH_PE_sdata2:
-	  dsize = 2;
-	  break;
-	case DW_EH_PE_udata4:
-	case DW_EH_PE_sdata4:
-	  dsize = 4;
-	  break;
-	case DW_EH_PE_udata8:
-	case DW_EH_PE_sdata8:
-	  dsize = 8;
-	  break;
-	default:
-	  dsize = 0;
-	  error (1, 0, _("invalid TType encoding"));
-	}
-
-      if (max_ar_filter
-	  > (size_t) (ttype_base - (const unsigned char *) data->d_buf) / dsize)
-	goto invalid_data;
-
-      readp = ttype_base - max_ar_filter * dsize;
-      do
-	{
-	  uint64_t ttype;
-	  readp = read_encoded (ttype_encoding, readp, ttype_base, &ttype,
-				dbg);
-	  printf (" [%4u] %#" PRIx64 "\n", max_ar_filter--, ttype);
-	}
-      while (readp < ttype_base);
-    }
-}
-
-/* Print the content of the '.gdb_index' section.
-   http://sourceware.org/gdb/current/onlinedocs/gdb/Index-Section-Format.html
-*/
-static void
-print_gdb_index_section (Dwfl_Module *dwflmod, Ebl *ebl,
-			 GElf_Ehdr *ehdr __attribute__ ((unused)),
-			 Elf_Scn *scn, GElf_Shdr *shdr, Dwarf *dbg)
-{
-  printf (_("\nGDB section [%2zu] '%s' at offset %#" PRIx64
-		   " contains %" PRId64 " bytes :\n"),
-	  elf_ndxscn (scn), section_name (ebl, shdr),
-	  (uint64_t) shdr->sh_offset, (uint64_t) shdr->sh_size);
-
-  Elf_Data *data = elf_rawdata (scn, NULL);
-
-  if (unlikely (data == NULL))
-    {
-      error (0, 0, _("cannot get %s content: %s"),
-	     ".gdb_index", elf_errmsg (-1));
-      return;
-    }
-
-  // .gdb_index is always in little endian.
-  Dwarf dummy_dbg = { .other_byte_order = MY_ELFDATA != ELFDATA2LSB };
-  dbg = &dummy_dbg;
-
-  const unsigned char *readp = data->d_buf;
-  const unsigned char *const dataend = readp + data->d_size;
-
-  if (unlikely (readp + 4 > dataend))
-    {
-    invalid_data:
-      error (0, 0, _("invalid data"));
-      return;
-    }
-
-  int32_t vers = read_4ubyte_unaligned (dbg, readp);
-  printf (_(" Version:         %" PRId32 "\n"), vers);
-
-  // The only difference between version 4 and version 5 is the
-  // hash used for generating the table.  Version 6 contains symbols
-  // for inlined functions, older versions didn't.  Version 7 adds
-  // symbol kinds.  Version 8 just indicates that it correctly includes
-  // TUs for symbols.
-  if (vers < 4 || vers > 8)
-    {
-      printf (_("  unknown version, cannot parse section\n"));
-      return;
-    }
-
-  readp += 4;
-  if (unlikely (readp + 4 > dataend))
-    goto invalid_data;
-
-  uint32_t cu_off = read_4ubyte_unaligned (dbg, readp);
-  printf (_(" CU offset:       %#" PRIx32 "\n"), cu_off);
-
-  readp += 4;
-  if (unlikely (readp + 4 > dataend))
-    goto invalid_data;
-
-  uint32_t tu_off = read_4ubyte_unaligned (dbg, readp);
-  printf (_(" TU offset:       %#" PRIx32 "\n"), tu_off);
-
-  readp += 4;
-  if (unlikely (readp + 4 > dataend))
-    goto invalid_data;
-
-  uint32_t addr_off = read_4ubyte_unaligned (dbg, readp);
-  printf (_(" address offset:  %#" PRIx32 "\n"), addr_off);
-
-  readp += 4;
-  if (unlikely (readp + 4 > dataend))
-    goto invalid_data;
-
-  uint32_t sym_off = read_4ubyte_unaligned (dbg, readp);
-  printf (_(" symbol offset:   %#" PRIx32 "\n"), sym_off);
-
-  readp += 4;
-  if (unlikely (readp + 4 > dataend))
-    goto invalid_data;
-
-  uint32_t const_off = read_4ubyte_unaligned (dbg, readp);
-  printf (_(" constant offset: %#" PRIx32 "\n"), const_off);
-
-  if (unlikely ((size_t) (dataend - (const unsigned char *) data->d_buf)
-		< const_off))
-    goto invalid_data;
-
-  readp = data->d_buf + cu_off;
-
-  const unsigned char *nextp = data->d_buf + tu_off;
-  if (tu_off >= data->d_size)
-    goto invalid_data;
-
-  size_t cu_nr = (nextp - readp) / 16;
-
-  printf (_("\n CU list at offset %#" PRIx32
-		   " contains %zu entries:\n"),
-	  cu_off, cu_nr);
-
-  size_t n = 0;
-  while (dataend - readp >= 16 && n < cu_nr)
-    {
-      uint64_t off = read_8ubyte_unaligned (dbg, readp);
-      readp += 8;
-
-      uint64_t len = read_8ubyte_unaligned (dbg, readp);
-      readp += 8;
-
-      printf (" [%4zu] start: %0#8" PRIx64
-	      ", length: %5" PRIu64 "\n", n, off, len);
-      n++;
-    }
-
-  readp = data->d_buf + tu_off;
-  nextp = data->d_buf + addr_off;
-  if (addr_off >= data->d_size)
-    goto invalid_data;
-
-  size_t tu_nr = (nextp - readp) / 24;
-
-  printf (_("\n TU list at offset %#" PRIx32
-		   " contains %zu entries:\n"),
-	  tu_off, tu_nr);
-
-  n = 0;
-  while (dataend - readp >= 24 && n < tu_nr)
-    {
-      uint64_t off = read_8ubyte_unaligned (dbg, readp);
-      readp += 8;
-
-      uint64_t type = read_8ubyte_unaligned (dbg, readp);
-      readp += 8;
-
-      uint64_t sig = read_8ubyte_unaligned (dbg, readp);
-      readp += 8;
-
-      printf (" [%4zu] CU offset: %5" PRId64
-	      ", type offset: %5" PRId64
-	      ", signature: %0#8" PRIx64 "\n", n, off, type, sig);
-      n++;
-    }
-
-  readp = data->d_buf + addr_off;
-  nextp = data->d_buf + sym_off;
-  if (sym_off >= data->d_size)
-    goto invalid_data;
-
-  size_t addr_nr = (nextp - readp) / 20;
-
-  printf (_("\n Address list at offset %#" PRIx32
-		   " contains %zu entries:\n"),
-	  addr_off, addr_nr);
-
-  n = 0;
-  while (dataend - readp >= 20 && n < addr_nr)
-    {
-      uint64_t low = read_8ubyte_unaligned (dbg, readp);
-      readp += 8;
-
-      uint64_t high = read_8ubyte_unaligned (dbg, readp);
-      readp += 8;
-
-      uint32_t idx = read_4ubyte_unaligned (dbg, readp);
-      readp += 4;
-
-      printf (" [%4zu] ", n);
-      print_dwarf_addr (dwflmod, 8, low, low);
-      printf ("..");
-      print_dwarf_addr (dwflmod, 8, high - 1, high);
-      printf (", CU index: %5" PRId32 "\n", idx);
-      n++;
-    }
-
-  const unsigned char *const_start = data->d_buf + const_off;
-  if (const_off >= data->d_size)
-    goto invalid_data;
-
-  readp = data->d_buf + sym_off;
-  nextp = const_start;
-  size_t sym_nr = (nextp - readp) / 8;
-
-  printf (_("\n Symbol table at offset %#" PRIx32
-		   " contains %zu slots:\n"),
-	  addr_off, sym_nr);
-
-  n = 0;
-  while (dataend - readp >= 8 && n < sym_nr)
-    {
-      uint32_t name = read_4ubyte_unaligned (dbg, readp);
-      readp += 4;
-
-      uint32_t vector = read_4ubyte_unaligned (dbg, readp);
-      readp += 4;
-
-      if (name != 0 || vector != 0)
-	{
-	  const unsigned char *sym = const_start + name;
-	  if (unlikely ((size_t) (dataend - const_start) < name
-			|| memchr (sym, '\0', dataend - sym) == NULL))
-	    goto invalid_data;
-
-	  printf (" [%4zu] symbol: %s, CUs: ", n, sym);
-
-	  const unsigned char *readcus = const_start + vector;
-	  if (unlikely ((size_t) (dataend - const_start) < vector))
-	    goto invalid_data;
-	  uint32_t cus = read_4ubyte_unaligned (dbg, readcus);
-	  while (cus--)
-	    {
-	      uint32_t cu_kind, cu, kind;
-	      bool is_static;
-	      readcus += 4;
-	      if (unlikely (readcus + 4 > dataend))
-		goto invalid_data;
-	      cu_kind = read_4ubyte_unaligned (dbg, readcus);
-	      cu = cu_kind & ((1 << 24) - 1);
-	      kind = (cu_kind >> 28) & 7;
-	      is_static = cu_kind & (1U << 31);
-	      if (cu > cu_nr - 1)
-		printf ("%" PRId32 "T", cu - (uint32_t) cu_nr);
-	      else
-		printf ("%" PRId32, cu);
-	      if (kind != 0)
-		{
-		  printf (" (");
-		  switch (kind)
-		    {
-		    case 1:
-		      printf ("type");
-		      break;
-		    case 2:
-		      printf ("var");
-		      break;
-		    case 3:
-		      printf ("func");
-		      break;
-		    case 4:
-		      printf ("other");
-		      break;
-		    default:
-		      printf ("unknown-0x%" PRIx32, kind);
-		      break;
-		    }
-		  printf (":%c)", (is_static ? 'S' : 'G'));
-		}
-	      if (cus > 0)
-		printf (", ");
-	    }
-	  printf ("\n");
-	}
-      n++;
-    }
-}
-
-/* Returns true and sets split DWARF CU id if there is a split compile
-   unit in the given Dwarf, and no non-split units are found (before it).  */
-static bool
-is_split_dwarf (Dwarf *dbg, uint64_t *id, Dwarf_CU **split_cu)
-{
-  Dwarf_CU *cu = NULL;
-  while (dwarf_get_units (dbg, cu, &cu, NULL, NULL, NULL, NULL) == 0)
-    {
-      uint8_t unit_type;
-      if (dwarf_cu_info (cu, NULL, &unit_type, NULL, NULL,
-			 id, NULL, NULL) != 0)
-	return false;
-
-      if (unit_type != DW_UT_split_compile && unit_type != DW_UT_split_type)
-	return false;
-
-      /* We really only care about the split compile unit, the types
-	 should be fine and self sufficient.  Also they don't have an
-	 id that we can match with a skeleton unit.  */
-      if (unit_type == DW_UT_split_compile)
-	{
-	  *split_cu = cu;
-	  return true;
-	}
-    }
-
-  return false;
-}
-
-/* Check that there is one and only one Dwfl_Module, return in arg.  */
-static int
-getone_dwflmod (Dwfl_Module *dwflmod,
-	       void **userdata __attribute__ ((unused)),
-	       const char *name __attribute__ ((unused)),
-	       Dwarf_Addr base __attribute__ ((unused)),
-	       void *arg)
-{
-  Dwfl_Module **m = (Dwfl_Module **) arg;
-  if (*m != NULL)
-    return DWARF_CB_ABORT;
-  *m = dwflmod;
-  return DWARF_CB_OK;
-}
-
-static void
-print_debug (Dwfl_Module *dwflmod, Ebl *ebl, GElf_Ehdr *ehdr)
-{
-  /* Used for skeleton file, if necessary for split DWARF.  */
-  Dwfl *skel_dwfl = NULL;
-  Dwfl_Module *skel_mod = NULL;
-  char *skel_name = NULL;
-  Dwarf *split_dbg = NULL;
-  Dwarf_CU *split_cu = NULL;
-
-  /* Before we start the real work get a debug context descriptor.  */
-  Dwarf_Addr dwbias;
-  Dwarf *dbg = dwfl_module_getdwarf (dwflmod, &dwbias);
-  Dwarf dummy_dbg =
-    {
-      .elf = ebl->elf,
-      .other_byte_order = MY_ELFDATA != ehdr->e_ident[EI_DATA]
-    };
-  if (dbg == NULL)
-    {
-      if ((print_debug_sections & ~(section_exception|section_frame)) != 0)
-	error (0, 0, _("cannot get debug context descriptor: %s"),
-	       dwfl_errmsg (-1));
-      dbg = &dummy_dbg;
-    }
-  else
-    {
-      /* If we are asked about a split dwarf (.dwo) file, use the user
-	 provided, or find the corresponding skeleton file. If we got
-	 a skeleton file, replace the given dwflmod and dbg, with one
-	 derived from the skeleton file to provide enough context.  */
-      uint64_t split_id;
-      if (is_split_dwarf (dbg, &split_id, &split_cu))
-	{
-	  if (dwarf_skeleton != NULL)
-	    skel_name = strdup (dwarf_skeleton);
-	  else
-	    {
-	      /* Replace file.dwo with file.o and see if that matches. */
-	      const char *fname;
-	      dwfl_module_info (dwflmod, NULL, NULL, NULL, NULL, NULL,
-				&fname, NULL);
-	      if (fname != NULL)
-		{
-		  size_t flen = strlen (fname);
-		  if (flen > 4 && strcmp (".dwo", fname + flen - 4) == 0)
-		    {
-		      skel_name = strdup (fname);
-		      if (skel_name != NULL)
-			{
-			  skel_name[flen - 3] = 'o';
-			  skel_name[flen - 2] = '\0';
-			}
-		    }
-		}
-	    }
-
-	  if (skel_name != NULL)
-	    {
-	      int skel_fd = open (skel_name, O_RDONLY);
-	      if (skel_fd == -1)
-		fprintf (stderr, "Warning: Couldn't open DWARF skeleton file"
-			 " '%s'\n", skel_name);
-	      else
-		skel_dwfl = create_dwfl (skel_fd, skel_name);
-
-	      if (skel_dwfl != NULL)
-		{
-		  if (dwfl_getmodules (skel_dwfl, &getone_dwflmod,
-				       &skel_mod, 0) != 0)
-		    {
-		      fprintf (stderr, "Warning: Bad DWARF skeleton,"
-			       " multiple modules '%s'\n", skel_name);
-		      dwfl_end (skel_dwfl);
-		      skel_mod = NULL;
-		    }
-		}
-	      else if (skel_fd != -1)
-		fprintf (stderr, "Warning: Couldn't create skeleton dwfl for"
-			 " '%s': %s\n", skel_name, dwfl_errmsg (-1));
-
-	      if (skel_mod != NULL)
-		{
-		  Dwarf *skel_dbg = dwfl_module_getdwarf (skel_mod, &dwbias);
-		  if (skel_dbg != NULL)
-		    {
-		      /* First check the skeleton CU DIE, only fetch
-			 the split DIE if we know the id matches to
-			 not unnecessary search for any split DIEs we
-			 don't need. */
-		      Dwarf_CU *cu = NULL;
-		      while (dwarf_get_units (skel_dbg, cu, &cu,
-					      NULL, NULL, NULL, NULL) == 0)
-			{
-			  uint8_t unit_type;
-			  uint64_t skel_id;
-			  if (dwarf_cu_info (cu, NULL, &unit_type, NULL, NULL,
-					     &skel_id, NULL, NULL) == 0
-			      && unit_type == DW_UT_skeleton
-			      && split_id == skel_id)
-			    {
-			      Dwarf_Die subdie;
-			      if (dwarf_cu_info (cu, NULL, NULL, NULL,
-						 &subdie,
-						 NULL, NULL, NULL) == 0
-				  && dwarf_tag (&subdie) != DW_TAG_invalid)
-				{
-				  split_dbg = dwarf_cu_getdwarf (subdie.cu);
-				  if (split_dbg == NULL)
-				    fprintf (stderr,
-					     "Warning: Couldn't get split_dbg:"
-					     " %s\n", dwarf_errmsg (-1));
-				  break;
-				}
-			      else
-				{
-				  /* Everything matches up, but not
-				     according to libdw. Which means
-				     the user knew better.  So...
-				     Terrible hack... We can never
-				     destroy the underlying dwfl
-				     because it would free the wrong
-				     Dwarfs... So we leak memory...*/
-				  if (cu->split == NULL
-				      && dwarf_skeleton != NULL)
-				    {
-				      do_not_close_dwfl = true;
-				      __libdw_link_skel_split (cu, split_cu);
-				      split_dbg = dwarf_cu_getdwarf (split_cu);
-				      break;
-				    }
-				  else
-				    fprintf (stderr, "Warning: Couldn't get"
-					     " skeleton subdie: %s\n",
-					     dwarf_errmsg (-1));
-				}
-			    }
-			}
-		      if (split_dbg == NULL)
-			fprintf (stderr, "Warning: '%s' didn't contain a skeleton for split id %" PRIx64 "\n", skel_name, split_id);
-		    }
-		  else
-		    fprintf (stderr, "Warning: Couldn't get skeleton DWARF:"
-			     " %s\n", dwfl_errmsg (-1));
-		}
-	    }
-
-	  if (split_dbg != NULL)
-	    {
-	      dbg = split_dbg;
-	      dwflmod = skel_mod;
-	    }
-	  else if (skel_name == NULL)
-	    fprintf (stderr,
-		     "Warning: split DWARF file, but no skeleton found.\n");
-	}
-      else if (dwarf_skeleton != NULL)
-	fprintf (stderr, "Warning: DWARF skeleton given,"
-		 " but not a split DWARF file\n");
-    }
-
-  /* Get the section header string table index.  */
-  size_t shstrndx;
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  /* If the .debug_info section is listed as implicitly required then
-     we must make sure to handle it before handling any other debug
-     section.  Various other sections depend on the CU DIEs being
-     scanned (silently) first.  */
-  bool implicit_info = (implicit_debug_sections & section_info) != 0;
-  bool explicit_info = (print_debug_sections & section_info) != 0;
-  if (implicit_info)
-    {
-      Elf_Scn *scn = NULL;
-      while ((scn = elf_nextscn (ebl->elf, scn)) != NULL)
-	{
-	  GElf_Shdr shdr_mem;
-	  GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-
-	  if (shdr != NULL && shdr->sh_type == SHT_PROGBITS)
-	    {
-	      const char *name = elf_strptr (ebl->elf, shstrndx,
-					     shdr->sh_name);
-	      if (name == NULL)
-		continue;
-
-	      if (strcmp (name, ".debug_info") == 0
-		  || strcmp (name, ".debug_info.dwo") == 0
-		  || strcmp (name, ".zdebug_info") == 0
-		  || strcmp (name, ".zdebug_info.dwo") == 0
-		  || strcmp (name, ".gnu.debuglto_.debug_info") == 0)
-		{
-		  print_debug_info_section (dwflmod, ebl, ehdr,
-					    scn, shdr, dbg);
-		  break;
-		}
-	    }
-	}
-      print_debug_sections &= ~section_info;
-      implicit_debug_sections &= ~section_info;
-    }
-
-  /* Look through all the sections for the debugging sections to print.  */
-  Elf_Scn *scn = NULL;
-  while ((scn = elf_nextscn (ebl->elf, scn)) != NULL)
-    {
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-
-      if (shdr != NULL && shdr->sh_type == SHT_PROGBITS)
-	{
-	  static const struct
-	  {
-	    const char *name;
-	    enum section_e bitmask;
-	    void (*fp) (Dwfl_Module *, Ebl *,
-			GElf_Ehdr *, Elf_Scn *, GElf_Shdr *, Dwarf *);
-	  } debug_sections[] =
-	    {
-#define NEW_SECTION(name) \
-	      { ".debug_" #name, section_##name, print_debug_##name##_section }
-	      NEW_SECTION (abbrev),
-	      NEW_SECTION (addr),
-	      NEW_SECTION (aranges),
-	      NEW_SECTION (frame),
-	      NEW_SECTION (info),
-	      NEW_SECTION (types),
-	      NEW_SECTION (line),
-	      NEW_SECTION (loc),
-	      /* loclists is loc for DWARF5.  */
-	      { ".debug_loclists", section_loc,
-		print_debug_loclists_section },
-	      NEW_SECTION (pubnames),
-	      NEW_SECTION (str),
-	      /* A DWARF5 specialised debug string section.  */
-	      { ".debug_line_str", section_str,
-		print_debug_str_section },
-	      /* DWARF5 string offsets table.  */
-	      { ".debug_str_offsets", section_str,
-		print_debug_str_offsets_section },
-	      NEW_SECTION (macinfo),
-	      NEW_SECTION (macro),
-	      NEW_SECTION (ranges),
-	      /* rnglists is ranges for DWARF5.  */
-	      { ".debug_rnglists", section_ranges,
-		print_debug_rnglists_section },
-	      { ".eh_frame", section_frame | section_exception,
-		print_debug_frame_section },
-	      { ".eh_frame_hdr", section_frame | section_exception,
-		print_debug_frame_hdr_section },
-	      { ".gcc_except_table", section_frame | section_exception,
-		print_debug_exception_table },
-	      { ".gdb_index", section_gdb_index, print_gdb_index_section }
-	    };
-	  const int ndebug_sections = (sizeof (debug_sections)
-				       / sizeof (debug_sections[0]));
-	  const char *name = elf_strptr (ebl->elf, shstrndx,
-					 shdr->sh_name);
-	  if (name == NULL)
-	    continue;
-
-	  int n;
-	  for (n = 0; n < ndebug_sections; ++n)
-	    {
-	      size_t dbglen = strlen (debug_sections[n].name);
-	      size_t scnlen = strlen (name);
-	      if ((strncmp (name, debug_sections[n].name, dbglen) == 0
-		   && (dbglen == scnlen
-		       || (scnlen == dbglen + 4
-			   && strstr (name, ".dwo") == name + dbglen)))
-		  || (name[0] == '.' && name[1] == 'z'
-		      && debug_sections[n].name[1] == 'd'
-		      && strncmp (&name[2], &debug_sections[n].name[1],
-				  dbglen - 1) == 0
-		      && (scnlen == dbglen + 1
-			  || (scnlen == dbglen + 5
-			      && strstr (name, ".dwo") == name + dbglen + 1)))
-		  || (scnlen > 14 /* .gnu.debuglto_ prefix. */
-		      && startswith (name, ".gnu.debuglto_")
-		      && strcmp (&name[14], debug_sections[n].name) == 0)
-)
-		{
-		  if ((print_debug_sections | implicit_debug_sections)
-		      & debug_sections[n].bitmask)
-		    debug_sections[n].fp (dwflmod, ebl, ehdr, scn, shdr, dbg);
-		  break;
-		}
-	    }
-	}
-    }
-
-  dwfl_end (skel_dwfl);
-  free (skel_name);
-
-  /* Turn implicit and/or explicit back on in case we go over another file.  */
-  if (implicit_info)
-    implicit_debug_sections |= section_info;
-  if (explicit_info)
-    print_debug_sections |= section_info;
-
-  reset_listptr (&known_locsptr);
-  reset_listptr (&known_loclistsptr);
-  reset_listptr (&known_rangelistptr);
-  reset_listptr (&known_rnglistptr);
-  reset_listptr (&known_addrbases);
-  reset_listptr (&known_stroffbases);
-}
-
-
-#define ITEM_INDENT		4
-#define WRAP_COLUMN		75
-
-/* Print "NAME: FORMAT", wrapping when output text would make the line
-   exceed WRAP_COLUMN.  Unpadded numbers look better for the core items
-   but this function is also used for registers which should be printed
-   aligned.  Fortunately registers output uses fixed fields width (such
-   as %11d) for the alignment.
-
-   Line breaks should not depend on the particular values although that
-   may happen in some cases of the core items.  */
-
-static unsigned int
-__attribute__ ((format (printf, 6, 7)))
-print_core_item (unsigned int colno, char sep, unsigned int wrap,
-		 size_t name_width, const char *name, const char *format, ...)
-{
-  size_t len = strlen (name);
-  if (name_width < len)
-    name_width = len;
-
-  char *out;
-  va_list ap;
-  va_start (ap, format);
-  int out_len = vasprintf (&out, format, ap);
-  va_end (ap);
-  if (out_len == -1)
-    error (EXIT_FAILURE, 0, _("memory exhausted"));
-
-  size_t n = name_width + sizeof ": " - 1 + out_len;
-
-  if (colno == 0)
-    {
-      printf ("%*s", ITEM_INDENT, "");
-      colno = ITEM_INDENT + n;
-    }
-  else if (colno + 2 + n < wrap)
-    {
-      printf ("%c ", sep);
-      colno += 2 + n;
-    }
-  else
-    {
-      printf ("\n%*s", ITEM_INDENT, "");
-      colno = ITEM_INDENT + n;
-    }
-
-  printf ("%s: %*s%s", name, (int) (name_width - len), "", out);
-
-  free (out);
-
-  return colno;
-}
-
-static const void *
-convert (Elf *core, Elf_Type type, uint_fast16_t count,
-	 void *value, const void *data, size_t size)
-{
-  Elf_Data valuedata =
-    {
-      .d_type = type,
-      .d_buf = value,
-      .d_size = size ?: gelf_fsize (core, type, count, EV_CURRENT),
-      .d_version = EV_CURRENT,
-    };
-  Elf_Data indata =
-    {
-      .d_type = type,
-      .d_buf = (void *) data,
-      .d_size = valuedata.d_size,
-      .d_version = EV_CURRENT,
-    };
-
-  Elf_Data *d = (gelf_getclass (core) == ELFCLASS32
-		 ? elf32_xlatetom : elf64_xlatetom)
-    (&valuedata, &indata, elf_getident (core, NULL)[EI_DATA]);
-  if (d == NULL)
-    error (EXIT_FAILURE, 0,
-	   _("cannot convert core note data: %s"), elf_errmsg (-1));
-
-  return data + indata.d_size;
-}
-
-typedef uint8_t GElf_Byte;
-
-static unsigned int
-handle_core_item (Elf *core, const Ebl_Core_Item *item, const void *desc,
-		  unsigned int colno, size_t *repeated_size)
-{
-  uint_fast16_t count = item->count ?: 1;
-  /* Ebl_Core_Item count is always a small number.
-     Make sure the backend didn't put in some large bogus value.  */
-  assert (count < 128);
-
-#define TYPES								      \
-  DO_TYPE (BYTE, Byte, "0x%.2" PRIx8, "%" PRId8);			      \
-  DO_TYPE (HALF, Half, "0x%.4" PRIx16, "%" PRId16);			      \
-  DO_TYPE (WORD, Word, "0x%.8" PRIx32, "%" PRId32);			      \
-  DO_TYPE (SWORD, Sword, "%" PRId32, "%" PRId32);			      \
-  DO_TYPE (XWORD, Xword, "0x%.16" PRIx64, "%" PRId64);			      \
-  DO_TYPE (SXWORD, Sxword, "%" PRId64, "%" PRId64)
-
-#define DO_TYPE(NAME, Name, hex, dec) GElf_##Name Name
-  typedef union { TYPES; } value_t;
-  void *data = alloca (count * sizeof (value_t));
-#undef DO_TYPE
-
-#define DO_TYPE(NAME, Name, hex, dec) \
-    GElf_##Name *value_##Name __attribute__((unused)) = data
-  TYPES;
-#undef DO_TYPE
-
-  size_t size = gelf_fsize (core, item->type, count, EV_CURRENT);
-  size_t convsize = size;
-  if (repeated_size != NULL)
-    {
-      if (*repeated_size > size && (item->format == 'b' || item->format == 'B'))
-	{
-	  data = alloca (*repeated_size);
-	  count *= *repeated_size / size;
-	  convsize = count * size;
-	  *repeated_size -= convsize;
-	}
-      else if (item->count != 0 || item->format != '\n')
-	*repeated_size -= size;
-    }
-
-  convert (core, item->type, count, data, desc + item->offset, convsize);
-
-  Elf_Type type = item->type;
-  if (type == ELF_T_ADDR)
-    type = gelf_getclass (core) == ELFCLASS32 ? ELF_T_WORD : ELF_T_XWORD;
-
-  switch (item->format)
-    {
-    case 'd':
-      assert (count == 1);
-      switch (type)
-	{
-#define DO_TYPE(NAME, Name, hex, dec)					      \
-	  case ELF_T_##NAME:						      \
-	    colno = print_core_item (colno, ',', WRAP_COLUMN,		      \
-				     0, item->name, dec, value_##Name[0]); \
-	    break
-	  TYPES;
-#undef DO_TYPE
-	default:
-	  abort ();
-	}
-      break;
-
-    case 'x':
-      assert (count == 1);
-      switch (type)
-	{
-#define DO_TYPE(NAME, Name, hex, dec)					      \
-	  case ELF_T_##NAME:						      \
-	    colno = print_core_item (colno, ',', WRAP_COLUMN,		      \
-				     0, item->name, hex, value_##Name[0]);      \
-	    break
-	  TYPES;
-#undef DO_TYPE
-	default:
-	  abort ();
-	}
-      break;
-
-    case 'b':
-    case 'B':
-      assert (size % sizeof (unsigned int) == 0);
-      unsigned int nbits = count * size * 8;
-      unsigned int pop = 0;
-      for (const unsigned int *i = data; (void *) i < data + count * size; ++i)
-	pop += __builtin_popcount (*i);
-      bool negate = pop > nbits / 2;
-      const unsigned int bias = item->format == 'b';
-
-      {
-	char printed[(negate ? nbits - pop : pop) * 16 + 1];
-	char *p = printed;
-	*p = '\0';
-
-	if (BYTE_ORDER != LITTLE_ENDIAN && size > sizeof (unsigned int))
-	  {
-	    assert (size == sizeof (unsigned int) * 2);
-	    for (unsigned int *i = data;
-		 (void *) i < data + count * size; i += 2)
-	      {
-		unsigned int w = i[1];
-		i[1] = i[0];
-		i[0] = w;
-	      }
-	  }
-
-	unsigned int lastbit = 0;
-	unsigned int run = 0;
-	for (const unsigned int *i = data;
-	     (void *) i < data + count * size; ++i)
-	  {
-	    unsigned int bit = ((void *) i - data) * 8;
-	    unsigned int w = negate ? ~*i : *i;
-	    while (w != 0)
-	      {
-		/* Note that a right shift equal to (or greater than)
-		   the number of bits of w is undefined behaviour.  In
-		   particular when the least significant bit is bit 32
-		   (w = 0x8000000) then w >>= n is undefined.  So
-		   explicitly handle that case separately.  */
-		unsigned int n = ffs (w);
-		if (n < sizeof (w) * 8)
-		  w >>= n;
-		else
-		  w = 0;
-		bit += n;
-
-		if (lastbit != 0 && lastbit + 1 == bit)
-		  ++run;
-		else
-		  {
-		    if (lastbit == 0)
-		      p += sprintf (p, "%u", bit - bias);
-		    else if (run == 0)
-		      p += sprintf (p, ",%u", bit - bias);
-		    else
-		      p += sprintf (p, "-%u,%u", lastbit - bias, bit - bias);
-		    run = 0;
-		  }
-
-		lastbit = bit;
-	      }
-	  }
-	if (lastbit > 0 && run > 0 && lastbit + 1 != nbits)
-	  p += sprintf (p, "-%u", lastbit - bias);
-
-	colno = print_core_item (colno, ',', WRAP_COLUMN, 0, item->name,
-				 negate ? "~<%s>" : "<%s>", printed);
-      }
-      break;
-
-    case 'T':
-    case (char) ('T'|0x80):
-      assert (count == 2);
-      Dwarf_Word sec;
-      Dwarf_Word usec;
-      switch (type)
-	{
-#define DO_TYPE(NAME, Name, hex, dec)					      \
-	  case ELF_T_##NAME:						      \
-	    sec = value_##Name[0];					      \
-	    usec = value_##Name[1];					      \
-	    break
-	  TYPES;
-#undef DO_TYPE
-	default:
-	  abort ();
-	}
-      if (unlikely (item->format == (char) ('T'|0x80)))
-	{
-	  /* This is a hack for an ill-considered 64-bit ABI where
-	     tv_usec is actually a 32-bit field with 32 bits of padding
-	     rounding out struct timeval.  We've already converted it as
-	     a 64-bit field.  For little-endian, this just means the
-	     high half is the padding; it's presumably zero, but should
-	     be ignored anyway.  For big-endian, it means the 32-bit
-	     field went into the high half of USEC.  */
-	  GElf_Ehdr ehdr_mem;
-	  GElf_Ehdr *ehdr = gelf_getehdr (core, &ehdr_mem);
-	  if (likely (ehdr->e_ident[EI_DATA] == ELFDATA2MSB))
-	    usec >>= 32;
-	  else
-	    usec &= UINT32_MAX;
-	}
-      colno = print_core_item (colno, ',', WRAP_COLUMN, 0, item->name,
-			       "%" PRIu64 ".%.6" PRIu64, sec, usec);
-      break;
-
-    case 'c':
-      assert (count == 1);
-      colno = print_core_item (colno, ',', WRAP_COLUMN, 0, item->name,
-			       "%c", value_Byte[0]);
-      break;
-
-    case 's':
-      colno = print_core_item (colno, ',', WRAP_COLUMN, 0, item->name,
-			       "%.*s", (int) count, value_Byte);
-      break;
-
-    case '\n':
-      /* This is a list of strings separated by '\n'.  */
-      assert (item->count == 0);
-      assert (repeated_size != NULL);
-      assert (item->name == NULL);
-      if (unlikely (item->offset >= *repeated_size))
-	break;
-
-      const char *s = desc + item->offset;
-      size = *repeated_size - item->offset;
-      *repeated_size = 0;
-      while (size > 0)
-	{
-	  const char *eol = memchr (s, '\n', size);
-	  int len = size;
-	  if (eol != NULL)
-	    len = eol - s;
-	  printf ("%*s%.*s\n", ITEM_INDENT, "", len, s);
-	  if (eol == NULL)
-	    break;
-	  size -= eol + 1 - s;
-	  s = eol + 1;
-	}
-
-      colno = WRAP_COLUMN;
-      break;
-
-    case 'h':
-      break;
-
-    default:
-      error (0, 0, "XXX not handling format '%c' for %s",
-	     item->format, item->name);
-      break;
-    }
-
-#undef TYPES
-
-  return colno;
-}
-
-
-/* Sort items by group, and by layout offset within each group.  */
-static int
-compare_core_items (const void *a, const void *b)
-{
-  const Ebl_Core_Item *const *p1 = a;
-  const Ebl_Core_Item *const *p2 = b;
-  const Ebl_Core_Item *item1 = *p1;
-  const Ebl_Core_Item *item2 = *p2;
-
-  return ((item1->group == item2->group ? 0
-	   : strcmp (item1->group, item2->group))
-	  ?: (int) item1->offset - (int) item2->offset);
-}
-
-/* Sort item groups by layout offset of the first item in the group.  */
-static int
-compare_core_item_groups (const void *a, const void *b)
-{
-  const Ebl_Core_Item *const *const *p1 = a;
-  const Ebl_Core_Item *const *const *p2 = b;
-  const Ebl_Core_Item *const *group1 = *p1;
-  const Ebl_Core_Item *const *group2 = *p2;
-  const Ebl_Core_Item *item1 = *group1;
-  const Ebl_Core_Item *item2 = *group2;
-
-  return (int) item1->offset - (int) item2->offset;
-}
-
-static unsigned int
-handle_core_items (Elf *core, const void *desc, size_t descsz,
-		   const Ebl_Core_Item *items, size_t nitems)
-{
-  if (nitems == 0)
-    return 0;
-  unsigned int colno = 0;
-
-  /* FORMAT '\n' makes sense to be present only as a single item as it
-     processes all the data of a note.  FORMATs 'b' and 'B' have a special case
-     if present as a single item but they can be also processed with other
-     items below.  */
-  if (nitems == 1 && (items[0].format == '\n' || items[0].format == 'b'
-		      || items[0].format == 'B'))
-    {
-      assert (items[0].offset == 0);
-      size_t size = descsz;
-      colno = handle_core_item (core, items, desc, colno, &size);
-      /* If SIZE is not zero here there is some remaining data.  But we do not
-	 know how to process it anyway.  */
-      return colno;
-    }
-  for (size_t i = 0; i < nitems; ++i)
-    assert (items[i].format != '\n');
-
-  /* Sort to collect the groups together.  */
-  const Ebl_Core_Item *sorted_items[nitems];
-  for (size_t i = 0; i < nitems; ++i)
-    sorted_items[i] = &items[i];
-  qsort (sorted_items, nitems, sizeof sorted_items[0], &compare_core_items);
-
-  /* Collect the unique groups and sort them.  */
-  const Ebl_Core_Item **groups[nitems];
-  groups[0] = &sorted_items[0];
-  size_t ngroups = 1;
-  for (size_t i = 1; i < nitems; ++i)
-    if (sorted_items[i]->group != sorted_items[i - 1]->group
-	&& strcmp (sorted_items[i]->group, sorted_items[i - 1]->group))
-      groups[ngroups++] = &sorted_items[i];
-  qsort (groups, ngroups, sizeof groups[0], &compare_core_item_groups);
-
-  /* Write out all the groups.  */
-  const void *last = desc;
-  do
-    {
-      for (size_t i = 0; i < ngroups; ++i)
-	{
-	  for (const Ebl_Core_Item **item = groups[i];
-	       (item < &sorted_items[nitems]
-		&& ((*item)->group == groups[i][0]->group
-		    || !strcmp ((*item)->group, groups[i][0]->group)));
-	       ++item)
-	    colno = handle_core_item (core, *item, desc, colno, NULL);
-
-	  /* Force a line break at the end of the group.  */
-	  colno = WRAP_COLUMN;
-	}
-
-      if (descsz == 0)
-	break;
-
-      /* This set of items consumed a certain amount of the note's data.
-	 If there is more data there, we have another unit of the same size.
-	 Loop to print that out too.  */
-      const Ebl_Core_Item *item = &items[nitems - 1];
-      size_t eltsz = item->offset + gelf_fsize (core, item->type,
-						item->count ?: 1, EV_CURRENT);
-
-      int reps = -1;
-      do
-	{
-	  ++reps;
-	  desc += eltsz;
-	  descsz -= eltsz;
-	}
-      while (descsz >= eltsz && !memcmp (desc, last, eltsz));
-
-      if (reps == 1)
-	{
-	  /* For just one repeat, print it unabridged twice.  */
-	  desc -= eltsz;
-	  descsz += eltsz;
-	}
-      else if (reps > 1)
-	printf (_("\n%*s... <repeats %u more times> ..."),
-		ITEM_INDENT, "", reps);
-
-      last = desc;
-    }
-  while (descsz > 0);
-
-  return colno;
-}
-
-static unsigned int
-handle_bit_registers (const Ebl_Register_Location *regloc, const void *desc,
-		      unsigned int colno)
-{
-  desc += regloc->offset;
-
-  abort ();			/* XXX */
-  return colno;
-}
-
-
-static unsigned int
-handle_core_register (Ebl *ebl, Elf *core, int maxregname,
-		      const Ebl_Register_Location *regloc, const void *desc,
-		      unsigned int colno)
-{
-  if (regloc->bits % 8 != 0)
-    return handle_bit_registers (regloc, desc, colno);
-
-  desc += regloc->offset;
-
-  for (int reg = regloc->regno; reg < regloc->regno + regloc->count; ++reg)
-    {
-      char name[REGNAMESZ];
-      int bits;
-      int type;
-      register_info (ebl, reg, regloc, name, &bits, &type);
-
-#define TYPES								      \
-      BITS (8, BYTE, "%4" PRId8, "0x%.2" PRIx8);			      \
-      BITS (16, HALF, "%6" PRId16, "0x%.4" PRIx16);			      \
-      BITS (32, WORD, "%11" PRId32, " 0x%.8" PRIx32);			      \
-      BITS (64, XWORD, "%20" PRId64, "  0x%.16" PRIx64)
-
-#define BITS(bits, xtype, sfmt, ufmt)				\
-      uint##bits##_t b##bits; int##bits##_t b##bits##s
-      union { TYPES; uint64_t b128[2]; } value;
-#undef	BITS
-
-      switch (type)
-	{
-	case DW_ATE_unsigned:
-	case DW_ATE_signed:
-	case DW_ATE_address:
-	  switch (bits)
-	    {
-#define BITS(bits, xtype, sfmt, ufmt)					      \
-	    case bits:							      \
-	      desc = convert (core, ELF_T_##xtype, 1, &value, desc, 0);	      \
-	      if (type == DW_ATE_signed)				      \
-		colno = print_core_item (colno, ' ', WRAP_COLUMN,	      \
-					 maxregname, name,		      \
-					 sfmt, value.b##bits##s);	      \
-	      else							      \
-		colno = print_core_item (colno, ' ', WRAP_COLUMN,	      \
-					 maxregname, name,		      \
-					 ufmt, value.b##bits);		      \
-	      break
-
-	    TYPES;
-
-	    case 128:
-	      assert (type == DW_ATE_unsigned);
-	      desc = convert (core, ELF_T_XWORD, 2, &value, desc, 0);
-	      int be = elf_getident (core, NULL)[EI_DATA] == ELFDATA2MSB;
-	      colno = print_core_item (colno, ' ', WRAP_COLUMN,
-				       maxregname, name,
-				       "0x%.16" PRIx64 "%.16" PRIx64,
-				       value.b128[!be], value.b128[be]);
-	      break;
-
-	    default:
-	      abort ();
-#undef	BITS
-	    }
-	  break;
-
-	default:
-	  /* Print each byte in hex, the whole thing in native byte order.  */
-	  assert (bits % 8 == 0);
-	  const uint8_t *bytes = desc;
-	  desc += bits / 8;
-	  char hex[bits / 4 + 1];
-	  hex[bits / 4] = '\0';
-	  int incr = 1;
-	  if (elf_getident (core, NULL)[EI_DATA] == ELFDATA2LSB)
-	    {
-	      bytes += bits / 8 - 1;
-	      incr = -1;
-	    }
-	  size_t idx = 0;
-	  for (char *h = hex; bits > 0; bits -= 8, idx += incr)
-	    {
-	      *h++ = "0123456789abcdef"[bytes[idx] >> 4];
-	      *h++ = "0123456789abcdef"[bytes[idx] & 0xf];
-	    }
-	  colno = print_core_item (colno, ' ', WRAP_COLUMN,
-				   maxregname, name, "0x%s", hex);
-	  break;
-	}
-      desc += regloc->pad;
-
-#undef TYPES
-    }
-
-  return colno;
-}
-
-
-struct register_info
-{
-  const Ebl_Register_Location *regloc;
-  const char *set;
-  char name[REGNAMESZ];
-  int regno;
-  int bits;
-  int type;
-};
-
-static int
-register_bitpos (const struct register_info *r)
-{
-  return (r->regloc->offset * 8
-	  + ((r->regno - r->regloc->regno)
-	     * (r->regloc->bits + r->regloc->pad * 8)));
-}
-
-static int
-compare_sets_by_info (const struct register_info *r1,
-		      const struct register_info *r2)
-{
-  return ((int) r2->bits - (int) r1->bits
-	  ?: register_bitpos (r1) - register_bitpos (r2));
-}
-
-/* Sort registers by set, and by size and layout offset within each set.  */
-static int
-compare_registers (const void *a, const void *b)
-{
-  const struct register_info *r1 = a;
-  const struct register_info *r2 = b;
-
-  /* Unused elements sort last.  */
-  if (r1->regloc == NULL)
-    return r2->regloc == NULL ? 0 : 1;
-  if (r2->regloc == NULL)
-    return -1;
-
-  return ((r1->set == r2->set ? 0 : strcmp (r1->set, r2->set))
-	  ?: compare_sets_by_info (r1, r2));
-}
-
-/* Sort register sets by layout offset of the first register in the set.  */
-static int
-compare_register_sets (const void *a, const void *b)
-{
-  const struct register_info *const *p1 = a;
-  const struct register_info *const *p2 = b;
-  return compare_sets_by_info (*p1, *p2);
-}
-
-static inline bool
-same_set (const struct register_info *a,
-	  const struct register_info *b,
-	  const struct register_info *regs,
-	  size_t maxnreg)
-{
-  return (a < &regs[maxnreg] && a->regloc != NULL
-	  && b < &regs[maxnreg] && b->regloc != NULL
-	  && a->bits == b->bits
-	  && (a->set == b->set || !strcmp (a->set, b->set)));
-}
-
-static unsigned int
-handle_core_registers (Ebl *ebl, Elf *core, const void *desc,
-		       const Ebl_Register_Location *reglocs, size_t nregloc)
-{
-  if (nregloc == 0)
-    return 0;
-
-  ssize_t maxnreg = ebl_register_info (ebl, 0, NULL, 0, NULL, NULL, NULL, NULL);
-  if (maxnreg <= 0)
-    {
-      for (size_t i = 0; i < nregloc; ++i)
-	if (maxnreg < reglocs[i].regno + reglocs[i].count)
-	  maxnreg = reglocs[i].regno + reglocs[i].count;
-      assert (maxnreg > 0);
-    }
-
-  struct register_info regs[maxnreg];
-  memset (regs, 0, sizeof regs);
-
-  /* Sort to collect the sets together.  */
-  int maxreg = 0;
-  for (size_t i = 0; i < nregloc; ++i)
-    for (int reg = reglocs[i].regno;
-	 reg < reglocs[i].regno + reglocs[i].count;
-	 ++reg)
-      {
-	assert (reg < maxnreg);
-	if (reg > maxreg)
-	  maxreg = reg;
-	struct register_info *info = &regs[reg];
-	info->regloc = &reglocs[i];
-	info->regno = reg;
-	info->set = register_info (ebl, reg, &reglocs[i],
-				   info->name, &info->bits, &info->type);
-      }
-  qsort (regs, maxreg + 1, sizeof regs[0], &compare_registers);
-
-  /* Collect the unique sets and sort them.  */
-  struct register_info *sets[maxreg + 1];
-  sets[0] = &regs[0];
-  size_t nsets = 1;
-  for (int i = 1; i <= maxreg; ++i)
-    if (regs[i].regloc != NULL
-	&& !same_set (&regs[i], &regs[i - 1], regs, maxnreg))
-      sets[nsets++] = &regs[i];
-  qsort (sets, nsets, sizeof sets[0], &compare_register_sets);
-
-  /* Write out all the sets.  */
-  unsigned int colno = 0;
-  for (size_t i = 0; i < nsets; ++i)
-    {
-      /* Find the longest name of a register in this set.  */
-      size_t maxname = 0;
-      const struct register_info *end;
-      for (end = sets[i]; same_set (sets[i], end, regs, maxnreg); ++end)
-	{
-	  size_t len = strlen (end->name);
-	  if (len > maxname)
-	    maxname = len;
-	}
-
-      for (const struct register_info *reg = sets[i];
-	   reg < end;
-	   reg += reg->regloc->count ?: 1)
-	colno = handle_core_register (ebl, core, maxname,
-				      reg->regloc, desc, colno);
-
-      /* Force a line break at the end of the group.  */
-      colno = WRAP_COLUMN;
-    }
-
-  return colno;
-}
-
-static void
-handle_auxv_note (Ebl *ebl, Elf *core, GElf_Word descsz, GElf_Off desc_pos)
-{
-  Elf_Data *data = elf_getdata_rawchunk (core, desc_pos, descsz, ELF_T_AUXV);
-  if (data == NULL)
-  elf_error:
-    error (EXIT_FAILURE, 0,
-	   _("cannot convert core note data: %s"), elf_errmsg (-1));
-
-  const size_t nauxv = descsz / gelf_fsize (core, ELF_T_AUXV, 1, EV_CURRENT);
-  for (size_t i = 0; i < nauxv; ++i)
-    {
-      GElf_auxv_t av_mem;
-      GElf_auxv_t *av = gelf_getauxv (data, i, &av_mem);
-      if (av == NULL)
-	goto elf_error;
-
-      const char *name;
-      const char *fmt;
-      if (ebl_auxv_info (ebl, av->a_type, &name, &fmt) == 0)
-	{
-	  /* Unknown type.  */
-	  if (av->a_un.a_val == 0)
-	    printf ("    %" PRIu64 "\n", av->a_type);
-	  else
-	    printf ("    %" PRIu64 ": %#" PRIx64 "\n",
-		    av->a_type, av->a_un.a_val);
-	}
-      else
-	switch (fmt[0])
-	  {
-	  case '\0':		/* Normally zero.  */
-	    if (av->a_un.a_val == 0)
-	      {
-		printf ("    %s\n", name);
-		break;
-	      }
-	    FALLTHROUGH;
-	  case 'x':		/* hex */
-	  case 'p':		/* address */
-	  case 's':		/* address of string */
-	    printf ("    %s: %#" PRIx64 "\n", name, av->a_un.a_val);
-	    break;
-	  case 'u':
-	    printf ("    %s: %" PRIu64 "\n", name, av->a_un.a_val);
-	    break;
-	  case 'd':
-	    printf ("    %s: %" PRId64 "\n", name, av->a_un.a_val);
-	    break;
-
-	  case 'b':
-	    printf ("    %s: %#" PRIx64 "  ", name, av->a_un.a_val);
-	    GElf_Xword bit = 1;
-	    const char *pfx = "<";
-	    for (const char *p = fmt + 1; *p != 0; p = strchr (p, '\0') + 1)
-	      {
-		if (av->a_un.a_val & bit)
-		  {
-		    printf ("%s%s", pfx, p);
-		    pfx = " ";
-		  }
-		bit <<= 1;
-	      }
-	    printf (">\n");
-	    break;
-
-	  default:
-	    abort ();
-	  }
-    }
-}
-
-static bool
-buf_has_data (unsigned char const *ptr, unsigned char const *end, size_t sz)
-{
-  return ptr < end && (size_t) (end - ptr) >= sz;
-}
-
-static bool
-buf_read_int (Elf *core, unsigned char const **ptrp, unsigned char const *end,
-	      int *retp)
-{
-  if (! buf_has_data (*ptrp, end, 4))
-    return false;
-
-  *ptrp = convert (core, ELF_T_WORD, 1, retp, *ptrp, 4);
-  return true;
-}
-
-static bool
-buf_read_ulong (Elf *core, unsigned char const **ptrp, unsigned char const *end,
-		uint64_t *retp)
-{
-  size_t sz = gelf_fsize (core, ELF_T_ADDR, 1, EV_CURRENT);
-  if (! buf_has_data (*ptrp, end, sz))
-    return false;
-
-  union
-  {
-    uint64_t u64;
-    uint32_t u32;
-  } u;
-
-  *ptrp = convert (core, ELF_T_ADDR, 1, &u, *ptrp, sz);
-
-  if (sz == 4)
-    *retp = u.u32;
-  else
-    *retp = u.u64;
-  return true;
-}
-
-static void
-handle_siginfo_note (Elf *core, GElf_Word descsz, GElf_Off desc_pos)
-{
-  Elf_Data *data = elf_getdata_rawchunk (core, desc_pos, descsz, ELF_T_BYTE);
-  if (data == NULL)
-    error (EXIT_FAILURE, 0,
-	   _("cannot convert core note data: %s"), elf_errmsg (-1));
-
-  unsigned char const *ptr = data->d_buf;
-  unsigned char const *const end = data->d_buf + data->d_size;
-
-  /* Siginfo head is three ints: signal number, error number, origin
-     code.  */
-  int si_signo, si_errno, si_code;
-  if (! buf_read_int (core, &ptr, end, &si_signo)
-      || ! buf_read_int (core, &ptr, end, &si_errno)
-      || ! buf_read_int (core, &ptr, end, &si_code))
-    {
-    fail:
-      printf ("    Not enough data in NT_SIGINFO note.\n");
-      return;
-    }
-
-  /* Next is a pointer-aligned union of structures.  On 64-bit
-     machines, that implies a word of padding.  */
-  if (gelf_getclass (core) == ELFCLASS64)
-    ptr += 4;
-
-  printf ("    si_signo: %d, si_errno: %d, si_code: %d\n",
-	  si_signo, si_errno, si_code);
-
-  if (si_code > 0)
-    switch (si_signo)
-      {
-      case CORE_SIGILL:
-      case CORE_SIGFPE:
-      case CORE_SIGSEGV:
-      case CORE_SIGBUS:
-	{
-	  uint64_t addr;
-	  if (! buf_read_ulong (core, &ptr, end, &addr))
-	    goto fail;
-	  printf ("    fault address: %#" PRIx64 "\n", addr);
-	  break;
-	}
-      default:
-	;
-      }
-  else if (si_code == CORE_SI_USER)
-    {
-      int pid, uid;
-      if (! buf_read_int (core, &ptr, end, &pid)
-	  || ! buf_read_int (core, &ptr, end, &uid))
-	goto fail;
-      printf ("    sender PID: %d, sender UID: %d\n", pid, uid);
-    }
-}
-
-static void
-handle_file_note (Elf *core, GElf_Word descsz, GElf_Off desc_pos)
-{
-  Elf_Data *data = elf_getdata_rawchunk (core, desc_pos, descsz, ELF_T_BYTE);
-  if (data == NULL)
-    error (EXIT_FAILURE, 0,
-	   _("cannot convert core note data: %s"), elf_errmsg (-1));
-
-  unsigned char const *ptr = data->d_buf;
-  unsigned char const *const end = data->d_buf + data->d_size;
-
-  uint64_t count, page_size;
-  if (! buf_read_ulong (core, &ptr, end, &count)
-      || ! buf_read_ulong (core, &ptr, end, &page_size))
-    {
-    fail:
-      printf ("    Not enough data in NT_FILE note.\n");
-      return;
-    }
-
-  size_t addrsize = gelf_fsize (core, ELF_T_ADDR, 1, EV_CURRENT);
-  uint64_t maxcount = (size_t) (end - ptr) / (3 * addrsize);
-  if (count > maxcount)
-    goto fail;
-
-  /* Where file names are stored.  */
-  unsigned char const *const fstart = ptr + 3 * count * addrsize;
-  char const *fptr = (char *) fstart;
-
-  printf ("    %" PRId64 " files:\n", count);
-  for (uint64_t i = 0; i < count; ++i)
-    {
-      uint64_t mstart, mend, moffset;
-      if (! buf_read_ulong (core, &ptr, fstart, &mstart)
-	  || ! buf_read_ulong (core, &ptr, fstart, &mend)
-	  || ! buf_read_ulong (core, &ptr, fstart, &moffset))
-	goto fail;
-
-      const char *fnext = memchr (fptr, '\0', (char *) end - fptr);
-      if (fnext == NULL)
-	goto fail;
-
-      int ct = printf ("      %08" PRIx64 "-%08" PRIx64
-		       " %08" PRIx64 " %" PRId64,
-		       mstart, mend, moffset * page_size, mend - mstart);
-      printf ("%*s%s\n", ct > 50 ? 3 : 53 - ct, "", fptr);
-
-      fptr = fnext + 1;
-    }
-}
-
-static void
-handle_core_note (Ebl *ebl, const GElf_Nhdr *nhdr,
-		  const char *name, const void *desc)
-{
-  GElf_Word regs_offset;
-  size_t nregloc;
-  const Ebl_Register_Location *reglocs;
-  size_t nitems;
-  const Ebl_Core_Item *items;
-
-  if (! ebl_core_note (ebl, nhdr, name, desc,
-		       &regs_offset, &nregloc, &reglocs, &nitems, &items))
-    return;
-
-  /* Pass 0 for DESCSZ when there are registers in the note,
-     so that the ITEMS array does not describe the whole thing.
-     For non-register notes, the actual descsz might be a multiple
-     of the unit size, not just exactly the unit size.  */
-  unsigned int colno = handle_core_items (ebl->elf, desc,
-					  nregloc == 0 ? nhdr->n_descsz : 0,
-					  items, nitems);
-  if (colno != 0)
-    putchar_unlocked ('\n');
-
-  colno = handle_core_registers (ebl, ebl->elf, desc + regs_offset,
-				 reglocs, nregloc);
-  if (colno != 0)
-    putchar_unlocked ('\n');
-}
-
-static void
-handle_notes_data (Ebl *ebl, const GElf_Ehdr *ehdr,
-		   GElf_Off start, Elf_Data *data)
-{
-  fputs_unlocked (_("  Owner          Data size  Type\n"), stdout);
-
-  if (data == NULL)
-    goto bad_note;
-
-  size_t offset = 0;
-  GElf_Nhdr nhdr;
-  size_t name_offset;
-  size_t desc_offset;
-  while (offset < data->d_size
-	 && (offset = gelf_getnote (data, offset,
-				    &nhdr, &name_offset, &desc_offset)) > 0)
-    {
-      const char *name = nhdr.n_namesz == 0 ? "" : data->d_buf + name_offset;
-      const char *desc = data->d_buf + desc_offset;
-
-      /* GNU Build Attributes are weird, they store most of their data
-	 into the owner name field.  Extract just the owner name
-	 prefix here, then use the rest later as data.  */
-      bool is_gnu_build_attr
-	= startswith (name, ELF_NOTE_GNU_BUILD_ATTRIBUTE_PREFIX);
-      const char *print_name = (is_gnu_build_attr
-				? ELF_NOTE_GNU_BUILD_ATTRIBUTE_PREFIX : name);
-      size_t print_namesz = (is_gnu_build_attr
-			     ? strlen (print_name) : nhdr.n_namesz);
-
-      char buf[100];
-      char buf2[100];
-      printf (_("  %-13.*s  %9" PRId32 "  %s\n"),
-	      (int) print_namesz, print_name, nhdr.n_descsz,
-	      ehdr->e_type == ET_CORE
-	      ? ebl_core_note_type_name (ebl, nhdr.n_type,
-					 buf, sizeof (buf))
-	      : ebl_object_note_type_name (ebl, name, nhdr.n_type,
-					   nhdr.n_descsz,
-					   buf2, sizeof (buf2)));
-
-      /* Filter out invalid entries.  */
-      if (memchr (name, '\0', nhdr.n_namesz) != NULL
-	  /* XXX For now help broken Linux kernels.  */
-	  || 1)
-	{
-	  if (ehdr->e_type == ET_CORE)
-	    {
-	      if (nhdr.n_type == NT_AUXV
-		  && (nhdr.n_namesz == 4 /* Broken old Linux kernels.  */
-		      || (nhdr.n_namesz == 5 && name[4] == '\0'))
-		  && !memcmp (name, "CORE", 4))
-		handle_auxv_note (ebl, ebl->elf, nhdr.n_descsz,
-				  start + desc_offset);
-	      else if (nhdr.n_namesz == 5 && strcmp (name, "CORE") == 0)
-		switch (nhdr.n_type)
-		  {
-		  case NT_SIGINFO:
-		    handle_siginfo_note (ebl->elf, nhdr.n_descsz,
-					 start + desc_offset);
-		    break;
-
-		  case NT_FILE:
-		    handle_file_note (ebl->elf, nhdr.n_descsz,
-				      start + desc_offset);
-		    break;
-
-		  default:
-		    handle_core_note (ebl, &nhdr, name, desc);
-		  }
-	      else
-		handle_core_note (ebl, &nhdr, name, desc);
-	    }
-	  else
-	    ebl_object_note (ebl, nhdr.n_namesz, name, nhdr.n_type,
-			     nhdr.n_descsz, desc);
-	}
-    }
-
-  if (offset == data->d_size)
-    return;
-
- bad_note:
-  error (0, 0,
-	 _("cannot get content of note: %s"),
-	 data != NULL ? "garbage data" : elf_errmsg (-1));
-}
-
-static void
-handle_notes (Ebl *ebl, GElf_Ehdr *ehdr)
-{
-  /* If we have section headers, just look for SHT_NOTE sections.
-     In a debuginfo file, the program headers are not reliable.  */
-  if (shnum != 0)
-    {
-      /* Get the section header string table index.  */
-      size_t shstrndx;
-      if (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0)
-	error (EXIT_FAILURE, 0,
-	       _("cannot get section header string table index"));
-
-      Elf_Scn *scn = NULL;
-      while ((scn = elf_nextscn (ebl->elf, scn)) != NULL)
-	{
-	  GElf_Shdr shdr_mem;
-	  GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-
-	  if (shdr == NULL || shdr->sh_type != SHT_NOTE)
-	    /* Not what we are looking for.  */
-	    continue;
-
-	  if (notes_section != NULL)
-	    {
-	      char *sname = elf_strptr (ebl->elf, shstrndx, shdr->sh_name);
-	      if (sname == NULL || strcmp (sname, notes_section) != 0)
-		continue;
-	    }
-
-	  printf (_("\
-\nNote section [%2zu] '%s' of %" PRIu64 " bytes at offset %#0" PRIx64 ":\n"),
-		  elf_ndxscn (scn),
-		  elf_strptr (ebl->elf, shstrndx, shdr->sh_name),
-		  shdr->sh_size, shdr->sh_offset);
-
-	  handle_notes_data (ebl, ehdr, shdr->sh_offset,
-			     elf_getdata (scn, NULL));
-	}
-      return;
-    }
-
-  /* We have to look through the program header to find the note
-     sections.  There can be more than one.  */
-  for (size_t cnt = 0; cnt < phnum; ++cnt)
-    {
-      GElf_Phdr mem;
-      GElf_Phdr *phdr = gelf_getphdr (ebl->elf, cnt, &mem);
-
-      if (phdr == NULL || phdr->p_type != PT_NOTE)
-	/* Not what we are looking for.  */
-	continue;
-
-      printf (_("\
-\nNote segment of %" PRIu64 " bytes at offset %#0" PRIx64 ":\n"),
-	      phdr->p_filesz, phdr->p_offset);
-
-      handle_notes_data (ebl, ehdr, phdr->p_offset,
-			 elf_getdata_rawchunk (ebl->elf,
-					       phdr->p_offset, phdr->p_filesz,
-					       (phdr->p_align == 8
-						? ELF_T_NHDR8 : ELF_T_NHDR)));
-    }
-}
-
-
-static void
-hex_dump (const uint8_t *data, size_t len)
-{
-  size_t pos = 0;
-  while (pos < len)
-    {
-      printf ("  0x%08zx ", pos);
-
-      const size_t chunk = MIN (len - pos, 16);
-
-      for (size_t i = 0; i < chunk; ++i)
-	if (i % 4 == 3)
-	  printf ("%02x ", data[pos + i]);
-	else
-	  printf ("%02x", data[pos + i]);
-
-      if (chunk < 16)
-	printf ("%*s", (int) ((16 - chunk) * 2 + (16 - chunk + 3) / 4), "");
-
-      for (size_t i = 0; i < chunk; ++i)
-	{
-	  unsigned char b = data[pos + i];
-	  printf ("%c", isprint (b) ? b : '.');
-	}
-
-      putchar ('\n');
-      pos += chunk;
-    }
-}
-
-static void
-dump_data_section (Elf_Scn *scn, const GElf_Shdr *shdr, const char *name)
-{
-  if (shdr->sh_size == 0 || shdr->sh_type == SHT_NOBITS)
-    printf (_("\nSection [%zu] '%s' has no data to dump.\n"),
-	    elf_ndxscn (scn), name);
-  else
-    {
-      if (print_decompress)
-	{
-	  /* We try to decompress the section, but keep the old shdr around
-	     so we can show both the original shdr size and the uncompressed
-	     data size.   */
-	  if ((shdr->sh_flags & SHF_COMPRESSED) != 0)
-	    {
-	      if (elf_compress (scn, 0, 0) < 0)
-		printf ("WARNING: %s [%zd]\n",
-			_("Couldn't uncompress section"),
-			elf_ndxscn (scn));
-	    }
-	  else if (startswith (name, ".zdebug"))
-	    {
-	      if (elf_compress_gnu (scn, 0, 0) < 0)
-		printf ("WARNING: %s [%zd]\n",
-			_("Couldn't uncompress section"),
-			elf_ndxscn (scn));
-	    }
-	}
-
-      Elf_Data *data = elf_rawdata (scn, NULL);
-      if (data == NULL)
-	error (0, 0, _("cannot get data for section [%zu] '%s': %s"),
-	       elf_ndxscn (scn), name, elf_errmsg (-1));
-      else
-	{
-	  if (data->d_size == shdr->sh_size)
-	    printf (_("\nHex dump of section [%zu] '%s', %" PRIu64
-			     " bytes at offset %#0" PRIx64 ":\n"),
-		    elf_ndxscn (scn), name,
-		    shdr->sh_size, shdr->sh_offset);
-	  else
-	    printf (_("\nHex dump of section [%zu] '%s', %" PRIu64
-			     " bytes (%zd uncompressed) at offset %#0"
-			     PRIx64 ":\n"),
-		    elf_ndxscn (scn), name,
-		    shdr->sh_size, data->d_size, shdr->sh_offset);
-	  hex_dump (data->d_buf, data->d_size);
-	}
-    }
-}
-
-static void
-print_string_section (Elf_Scn *scn, const GElf_Shdr *shdr, const char *name)
-{
-  if (shdr->sh_size == 0 || shdr->sh_type == SHT_NOBITS)
-    printf (_("\nSection [%zu] '%s' has no strings to dump.\n"),
-	    elf_ndxscn (scn), name);
-  else
-    {
-      if (print_decompress)
-	{
-	  /* We try to decompress the section, but keep the old shdr around
-	     so we can show both the original shdr size and the uncompressed
-	     data size.  */
-	  if ((shdr->sh_flags & SHF_COMPRESSED) != 0)
-	    {
-	      if (elf_compress (scn, 0, 0) < 0)
-		printf ("WARNING: %s [%zd]\n",
-			_("Couldn't uncompress section"),
-			elf_ndxscn (scn));
-	    }
-	  else if (startswith (name, ".zdebug"))
-	    {
-	      if (elf_compress_gnu (scn, 0, 0) < 0)
-		printf ("WARNING: %s [%zd]\n",
-			_("Couldn't uncompress section"),
-			elf_ndxscn (scn));
-	    }
-	}
-
-      Elf_Data *data = elf_rawdata (scn, NULL);
-      if (data == NULL)
-	error (0, 0, _("cannot get data for section [%zu] '%s': %s"),
-	       elf_ndxscn (scn), name, elf_errmsg (-1));
-      else
-	{
-	  if (data->d_size == shdr->sh_size)
-	    printf (_("\nString section [%zu] '%s' contains %" PRIu64
-			     " bytes at offset %#0" PRIx64 ":\n"),
-		    elf_ndxscn (scn), name,
-		    shdr->sh_size, shdr->sh_offset);
-	  else
-	    printf (_("\nString section [%zu] '%s' contains %" PRIu64
-			     " bytes (%zd uncompressed) at offset %#0"
-			     PRIx64 ":\n"),
-		    elf_ndxscn (scn), name,
-		    shdr->sh_size, data->d_size, shdr->sh_offset);
-
-	  const char *start = data->d_buf;
-	  const char *const limit = start + data->d_size;
-	  do
-	    {
-	      const char *end = memchr (start, '\0', limit - start);
-	      const size_t pos = start - (const char *) data->d_buf;
-	      if (unlikely (end == NULL))
-		{
-		  printf ("  [%6zx]- %.*s\n",
-			  pos, (int) (limit - start), start);
-		  break;
-		}
-	      printf ("  [%6zx]  %s\n", pos, start);
-	      start = end + 1;
-	    } while (start < limit);
-	}
-    }
-}
-
-static void
-for_each_section_argument (Elf *elf, const struct section_argument *list,
-			   void (*dump) (Elf_Scn *scn, const GElf_Shdr *shdr,
-					 const char *name))
-{
-  /* Get the section header string table index.  */
-  size_t shstrndx;
-  if (elf_getshdrstrndx (elf, &shstrndx) < 0)
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  for (const struct section_argument *a = list; a != NULL; a = a->next)
-    {
-      Elf_Scn *scn;
-      GElf_Shdr shdr_mem;
-      const char *name = NULL;
-
-      char *endp = NULL;
-      unsigned long int shndx = strtoul (a->arg, &endp, 0);
-      if (endp != a->arg && *endp == '\0')
-	{
-	  scn = elf_getscn (elf, shndx);
-	  if (scn == NULL)
-	    {
-	      error (0, 0, _("\nsection [%lu] does not exist"), shndx);
-	      continue;
-	    }
-
-	  if (gelf_getshdr (scn, &shdr_mem) == NULL)
-	    error (EXIT_FAILURE, 0, _("cannot get section header: %s"),
-		   elf_errmsg (-1));
-	  name = elf_strptr (elf, shstrndx, shdr_mem.sh_name);
-	  (*dump) (scn, &shdr_mem, name);
-	}
-      else
-	{
-	  /* Need to look up the section by name.  */
-	  scn = NULL;
-	  bool found = false;
-	  while ((scn = elf_nextscn (elf, scn)) != NULL)
-	    {
-	      if (gelf_getshdr (scn, &shdr_mem) == NULL)
-		continue;
-	      name = elf_strptr (elf, shstrndx, shdr_mem.sh_name);
-	      if (name == NULL)
-		continue;
-	      if (!strcmp (name, a->arg))
-		{
-		  found = true;
-		  (*dump) (scn, &shdr_mem, name);
-		}
-	    }
-
-	  if (unlikely (!found) && !a->implicit)
-	    error (0, 0, _("\nsection '%s' does not exist"), a->arg);
-	}
-    }
-}
-
-static void
-dump_data (Ebl *ebl)
-{
-  for_each_section_argument (ebl->elf, dump_data_sections, &dump_data_section);
-}
-
-static void
-dump_strings (Ebl *ebl)
-{
-  for_each_section_argument (ebl->elf, string_sections, &print_string_section);
-}
-
-static void
-print_strings (Ebl *ebl)
-{
-  /* Get the section header string table index.  */
-  size_t shstrndx;
-  if (unlikely (elf_getshdrstrndx (ebl->elf, &shstrndx) < 0))
-    error (EXIT_FAILURE, 0,
-	   _("cannot get section header string table index"));
-
-  Elf_Scn *scn;
-  GElf_Shdr shdr_mem;
-  const char *name;
-  scn = NULL;
-  while ((scn = elf_nextscn (ebl->elf, scn)) != NULL)
-    {
-      if (gelf_getshdr (scn, &shdr_mem) == NULL)
-	continue;
-
-      if (shdr_mem.sh_type != SHT_PROGBITS
-	  || !(shdr_mem.sh_flags & SHF_STRINGS))
-	continue;
-
-      name = elf_strptr (ebl->elf, shstrndx, shdr_mem.sh_name);
-      if (name == NULL)
-	continue;
-
-      print_string_section (scn, &shdr_mem, name);
-    }
-}
-
-static void
-dump_archive_index (Elf *elf, const char *fname)
-{
-  size_t narsym;
-  const Elf_Arsym *arsym = elf_getarsym (elf, &narsym);
-  if (arsym == NULL)
-    {
-      int result = elf_errno ();
-      if (unlikely (result != ELF_E_NO_INDEX))
-	error (EXIT_FAILURE, 0,
-	       _("cannot get symbol index of archive '%s': %s"),
-	       fname, elf_errmsg (result));
-      else
-	printf (_("\nArchive '%s' has no symbol index\n"), fname);
-      return;
-    }
-
-  printf (_("\nIndex of archive '%s' has %zu entries:\n"),
-	  fname, narsym);
-
-  size_t as_off = 0;
-  for (const Elf_Arsym *s = arsym; s < &arsym[narsym - 1]; ++s)
-    {
-      if (s->as_off != as_off)
-	{
-	  as_off = s->as_off;
-
-	  Elf *subelf = NULL;
-	  if (unlikely (elf_rand (elf, as_off) == 0)
-	      || unlikely ((subelf = elf_begin (-1, ELF_C_READ_MMAP, elf))
-			   == NULL))
-#if __GLIBC__ < 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ < 7)
-	    while (1)
-#endif
-	      error (EXIT_FAILURE, 0,
-		     _("cannot extract member at offset %zu in '%s': %s"),
-		     as_off, fname, elf_errmsg (-1));
-
-	  const Elf_Arhdr *h = elf_getarhdr (subelf);
-
-	  printf (_("Archive member '%s' contains:\n"), h->ar_name);
-
-	  elf_end (subelf);
-	}
-
-      printf ("\t%s\n", s->as_name);
-    }
-}
-
-#include "debugpred.h"
diff --git a/src/strings.c b/src/strings.c
deleted file mode 100644
index eb278f8e3f4102d8390c10aefcafd7a18cf9c1dd..0000000000000000000000000000000000000000
--- a/src/strings.c
+++ /dev/null
@@ -1,747 +0,0 @@
-/* Print the strings of printable characters in files.
-   Copyright (C) 2005-2010, 2012, 2014 Red Hat, Inc.
-   This file is part of elfutils.
-   Written by Ulrich Drepper <drepper@redhat.com>, 2005.
-
-   This file is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   elfutils is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#include <argp.h>
-#include <assert.h>
-#include <ctype.h>
-#include <endian.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <gelf.h>
-#include <inttypes.h>
-#include <libintl.h>
-#include <locale.h>
-#include <stdbool.h>
-#include <stdio.h>
-#include <stdio_ext.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-
-#include <libeu.h>
-#include <system.h>
-#include <printversion.h>
-
-#ifndef MAP_POPULATE
-# define MAP_POPULATE 0
-#endif
-
-
-/* Prototypes of local functions.  */
-static int read_fd (int fd, const char *fname, off_t fdlen);
-static int read_elf (Elf *elf, int fd, const char *fname, off_t fdlen);
-
-
-/* Name and version of program.  */
-ARGP_PROGRAM_VERSION_HOOK_DEF = print_version;
-
-/* Bug report address.  */
-ARGP_PROGRAM_BUG_ADDRESS_DEF = PACKAGE_BUGREPORT;
-
-/* Definitions of arguments for argp functions.  */
-static const struct argp_option options[] =
-{
-  { NULL, 0, NULL, 0, N_("Output Selection:"), 0 },
-  { "all", 'a', NULL, 0, N_("Scan entire file, not only loaded sections"), 0 },
-  { "bytes", 'n', "MIN-LEN", 0,
-    N_("Only NUL-terminated sequences of MIN-LEN characters or more are printed"), 0 },
-  { "encoding", 'e', "SELECTOR", 0, N_("\
-Select character size and endianness: s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit"),
-    0},
-  { "print-file-name", 'f', NULL, 0,
-    N_("Print name of the file before each string."), 0 },
-  { "radix", 't', "{o,d,x}", 0,
-    N_("Print location of the string in base 8, 10, or 16 respectively."), 0 },
-  { NULL, 'o', NULL, 0, N_("Alias for --radix=o"), 0 },
-
-  { NULL, 0, NULL, 0, N_("Miscellaneous:"), 0 },
-  { NULL, 0, NULL, 0, NULL, 0 }
-};
-
-/* Short description of program.  */
-static const char doc[] = N_("\
-Print the strings of printable characters in files.");
-
-/* Strings for arguments in help texts.  */
-static const char args_doc[] = N_("[FILE...]");
-
-/* Prototype for option handler.  */
-static error_t parse_opt (int key, char *arg, struct argp_state *state);
-
-/* Data structure to communicate with argp functions.  */
-static struct argp argp =
-{
-  options, parse_opt, args_doc, doc, NULL, NULL, NULL
-};
-
-
-/* Global variables.  */
-
-/* True if whole file and not only loaded sections are looked at.  */
-static bool entire_file;
-
-/* Minimum length of any sequence reported.  */
-static size_t min_len = 4;
-
-/* Number of bytes per character.  */
-static size_t bytes_per_char = 1;
-
-/* Minimum length of any sequence reported in bytes.  */
-static size_t min_len_bytes;
-
-/* True if multibyte characters are in big-endian order.  */
-static bool big_endian;
-
-/* True unless 7-bit ASCII are expected.  */
-static bool char_7bit;
-
-/* True if file names should be printed before strings.  */
-static bool print_file_name;
-
-/* Radix for printed numbers.  */
-static enum
-{
-  radix_none = 0,
-  radix_decimal,
-  radix_hex,
-  radix_octal
-} radix = radix_none;
-
-
-/* Page size in use.  */
-static size_t ps;
-
-
-/* Mapped parts of the ELF file.  */
-static unsigned char *elfmap;
-static unsigned char *elfmap_base;
-static size_t elfmap_size;
-static off_t elfmap_off;
-
-
-int
-main (int argc, char *argv[])
-{
-  /* We use no threads.  */
-  __fsetlocking (stdin, FSETLOCKING_BYCALLER);
-  __fsetlocking (stdout, FSETLOCKING_BYCALLER);
-
-  /* Set locale.  */
-  (void) setlocale (LC_ALL, "");
-
-  /* Make sure the message catalog can be found.  */
-  (void) bindtextdomain (PACKAGE_TARNAME, LOCALEDIR);
-
-  /* Initialize the message catalog.  */
-  (void) textdomain (PACKAGE_TARNAME);
-
-  /* Parse and process arguments.  */
-  int remaining;
-  (void) argp_parse (&argp, argc, argv, 0, &remaining, NULL);
-
-  /* Tell the library which version we are expecting.  */
-  elf_version (EV_CURRENT);
-
-  /* Determine the page size.  We will likely need it a couple of times.  */
-  ps = sysconf (_SC_PAGESIZE);
-
-  struct stat st;
-  int result = 0;
-  if (remaining == argc)
-    /* We read from standard input.  This we cannot do for a
-       structured file.  */
-    result = read_fd (STDIN_FILENO,
-		      print_file_name ? "{standard input}" : NULL,
-		      (fstat (STDIN_FILENO, &st) == 0 && S_ISREG (st.st_mode))
-		      ? st.st_size : INT64_C (0x7fffffffffffffff));
-  else
-    do
-      {
-	int fd = (strcmp (argv[remaining], "-") == 0
-		  ? STDIN_FILENO : open (argv[remaining], O_RDONLY));
-	if (unlikely (fd == -1))
-	  {
-	    error (0, errno, _("cannot open '%s'"), argv[remaining]);
-	    result = 1;
-	  }
-	else
-	  {
-	    const char *fname = print_file_name ? argv[remaining] : NULL;
-	    int fstat_fail = fstat (fd, &st);
-	    off_t fdlen = (fstat_fail
-			     ? INT64_C (0x7fffffffffffffff) : st.st_size);
-	    if (fdlen > (off_t) min_len_bytes)
-	      {
-		Elf *elf = NULL;
-		if (entire_file
-		    || fstat_fail
-		    || !S_ISREG (st.st_mode)
-		    || (elf = elf_begin (fd, ELF_C_READ, NULL)) == NULL
-		    || elf_kind (elf) != ELF_K_ELF)
-		  result |= read_fd (fd, fname, fdlen);
-		else
-		  result |= read_elf (elf, fd, fname, fdlen);
-
-		/* This call will succeed even if ELF is NULL.  */
-		elf_end (elf);
-	      }
-
-	    if (strcmp (argv[remaining], "-") != 0)
-	      close (fd);
-	  }
-
-	if (elfmap != NULL && elfmap != MAP_FAILED)
-	  munmap (elfmap, elfmap_size);
-	elfmap = NULL;
-      }
-    while (++remaining < argc);
-
-  return result;
-}
-
-
-/* Handle program arguments.  */
-static error_t
-parse_opt (int key, char *arg,
-	   struct argp_state *state __attribute__ ((unused)))
-{
-  switch (key)
-    {
-    case 'a':
-      entire_file = true;
-      break;
-
-    case 'e':
-      /* We expect a string of one character.  */
-      switch (arg[1] != '\0' ? '\0' : arg[0])
-	{
-	case 's':
-	case 'S':
-	  char_7bit = arg[0] == 's';
-	  bytes_per_char = 1;
-	  break;
-
-	case 'b':
-	case 'B':
-	  big_endian = true;
-	  FALLTHROUGH;
-
-	case 'l':
-	case 'L':
-	  bytes_per_char = isupper (arg[0]) ? 4 : 2;
-	  break;
-
-	default:
-	  error (0, 0, _("invalid value '%s' for %s parameter"),
-		 arg, "-e");
-	  argp_help (&argp, stderr, ARGP_HELP_SEE, "strings");
-	  return ARGP_ERR_UNKNOWN;
-	}
-      break;
-
-    case 'f':
-      print_file_name = true;
-      break;
-
-    case 'n':
-      min_len = atoi (arg);
-      break;
-
-    case 'o':
-      goto octfmt;
-
-    case 't':
-      switch (arg[0])
-	{
-	case 'd':
-	  radix = radix_decimal;
-	  break;
-
-	case 'o':
-	octfmt:
-	  radix = radix_octal;
-	  break;
-
-	case 'x':
-	  radix = radix_hex;
-	  break;
-
-	default:
-	  error (0, 0, _("invalid value '%s' for %s parameter"),
-		 arg, "-t");
-	  argp_help (&argp, stderr, ARGP_HELP_SEE, "strings");
-	  return ARGP_ERR_UNKNOWN;
-	}
-      break;
-
-    case ARGP_KEY_FINI:
-      /* Compute the length in bytes of any match.  */
-      if (min_len <= 0 || min_len > INT_MAX / bytes_per_char)
-	error (EXIT_FAILURE, 0,
-	       _("invalid minimum length of matched string size"));
-      min_len_bytes = min_len * bytes_per_char;
-      break;
-
-    default:
-      return ARGP_ERR_UNKNOWN;
-    }
-  return 0;
-}
-
-
-static void
-process_chunk_mb (const char *fname, const unsigned char *buf, off_t to,
-		  size_t len, char **unprinted)
-{
-  size_t curlen = *unprinted == NULL ? 0 : strlen (*unprinted);
-  const unsigned char *start = buf;
-  while (len >= bytes_per_char)
-    {
-      uint32_t ch;
-
-      if (bytes_per_char == 2)
-	{
-	  if (big_endian)
-	    ch = buf[0] << 8 | buf[1];
-	  else
-	    ch = buf[1] << 8 | buf[0];
-	}
-      else
-	{
-	  if (big_endian)
-	    ch = buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3];
-	  else
-	    ch = buf[3] << 24 | buf[2] << 16 | buf[1] << 8 | buf[0];
-	}
-
-      if (ch <= 255 && (isprint (ch) || ch == '\t'))
-	{
-	  ++buf;
-	  ++curlen;
-	}
-      else
-	{
-	  if (curlen >= min_len)
-	    {
-	      /* We found a match.  */
-	      if (unlikely (fname != NULL))
-		{
-		  fputs_unlocked (fname, stdout);
-		  fputs_unlocked (": ", stdout);
-		}
-
-	      if (unlikely (radix != radix_none))
-		printf ((radix == radix_octal ? "%7" PRIo64 " "
-			 : (radix == radix_decimal ? "%7" PRId64 " "
-			    : "%7" PRIx64 " ")),
-			(int64_t) to - len - (buf - start));
-
-	      if (unlikely (*unprinted != NULL))
-		{
-		  fputs_unlocked (*unprinted, stdout);
-		  free (*unprinted);
-		  *unprinted = NULL;
-		}
-
-	      /* There is no sane way of printing the string.  If we
-		 assume the file data is encoded in UCS-2/UTF-16 or
-		 UCS-4/UTF-32 respectively we could covert the string.
-		 But there is no such guarantee.  */
-	      fwrite_unlocked (start, 1, buf - start, stdout);
-	      putc_unlocked ('\n', stdout);
-	    }
-
-	  start = ++buf;
-	  curlen =  0;
-
-	  if (len <= min_len)
-	    break;
-	}
-
-      --len;
-    }
-
-  if (curlen != 0)
-    *unprinted = xstrndup ((const char *) start, curlen);
-}
-
-
-static void
-process_chunk (const char *fname, const unsigned char *buf, off_t to,
-	       size_t len, char **unprinted)
-{
-  /* We are not going to slow the check down for the 2- and 4-byte
-     encodings.  Handle them special.  */
-  if (unlikely (bytes_per_char != 1))
-    {
-      process_chunk_mb (fname, buf, to, len, unprinted);
-      return;
-    }
-
-  size_t curlen = *unprinted == NULL ? 0 : strlen (*unprinted);
-  const unsigned char *start = buf;
-  while (len > 0)
-    {
-      if ((isprint (*buf) || *buf == '\t') && (! char_7bit || *buf <= 127))
-	{
-	  ++buf;
-	  ++curlen;
-	}
-      else
-	{
-	  if (curlen >= min_len)
-	    {
-	      /* We found a match.  */
-	      if (likely (fname != NULL))
-		{
-		  fputs_unlocked (fname, stdout);
-		  fputs_unlocked (": ", stdout);
-		}
-
-	      if (likely (radix != radix_none))
-		printf ((radix == radix_octal ? "%7" PRIo64 " "
-			 : (radix == radix_decimal ? "%7" PRId64 " "
-			    : "%7" PRIx64 " ")),
-			(int64_t) to - len - (buf - start));
-
-	      if (unlikely (*unprinted != NULL))
-		{
-		  fputs_unlocked (*unprinted, stdout);
-		  free (*unprinted);
-		  *unprinted = NULL;
-		}
-	      fwrite_unlocked (start, 1, buf - start, stdout);
-	      putc_unlocked ('\n', stdout);
-	    }
-
-	  start = ++buf;
-	  curlen =  0;
-
-	  if (len <= min_len)
-	    break;
-	}
-
-      --len;
-    }
-
-  if (curlen != 0)
-    *unprinted = xstrndup ((const char *) start, curlen);
-}
-
-
-/* Map a file in as large chunks as possible.  */
-static void *
-map_file (int fd, off_t start_off, off_t fdlen, size_t *map_sizep)
-{
-  /* Maximum size we mmap.  We use an #ifdef to avoid overflows on
-     32-bit machines.  64-bit machines these days do not have usable
-     address spaces larger than about 43 bits.  Not that any file
-     should be that large.  */
-# if SIZE_MAX > 0xffffffff
-  const size_t mmap_max = 0x4000000000lu;
-# else
-  const size_t mmap_max = 0x40000000lu;
-# endif
-
-  /* Try to mmap the file.  */
-  size_t map_size = MIN ((off_t) mmap_max, fdlen);
-  const size_t map_size_min = MAX (MAX (SIZE_MAX / 16, 2 * ps),
-				   roundup (2 * min_len_bytes + 1, ps));
-  void *mem;
-  while (1)
-    {
-      /* We map the memory for reading only here.  Since we will
-	 always look at every byte of the file it makes sense to
-	 use MAP_POPULATE.  */
-      mem = mmap (NULL, map_size, PROT_READ, MAP_PRIVATE | MAP_POPULATE,
-		  fd, start_off);
-      if (mem != MAP_FAILED)
-	{
-	  /* We will go through the mapping sequentially.  */
-	  (void) posix_madvise (mem, map_size, POSIX_MADV_SEQUENTIAL);
-	  break;
-	}
-      if (errno != EINVAL && errno != ENOMEM)
-	/* This is an error other than the lack of address space.  */
-	break;
-
-      /* Maybe the size of the mapping is too big.  Try again.  */
-      map_size /= 2;
-      if (map_size < map_size_min)
-	/* That size should have fit.  */
-	break;
-    }
-
-  *map_sizep = map_size;
-  return mem;
-}
-
-
-/* Read the file without mapping.  */
-static int
-read_block_no_mmap (int fd, const char *fname, off_t from, off_t fdlen)
-{
-  char *unprinted = NULL;
-#define CHUNKSIZE 65536
-  unsigned char *buf = xmalloc (CHUNKSIZE + min_len_bytes
-				+ bytes_per_char - 1);
-  size_t ntrailer = 0;
-  int result = 0;
-  while (fdlen > 0)
-    {
-      ssize_t n = TEMP_FAILURE_RETRY (read (fd, buf + ntrailer,
-					    MIN (fdlen, CHUNKSIZE)));
-      if (n == 0)
-	{
-	  /* There are less than MIN_LEN+1 bytes left so there cannot be
-	     another match.  */
-	  assert (unprinted == NULL || ntrailer == 0);
-	  break;
-	}
-      if (unlikely (n < 0))
-	{
-	  /* Something went wrong.  */
-	  result = 1;
-	  break;
-	}
-
-      /* Account for the number of bytes read in this round.  */
-      fdlen -= n;
-
-      /* Do not use the signed N value.  Note that the addition cannot
-	 overflow.  */
-      size_t nb = (size_t) n + ntrailer;
-      if (nb >= min_len_bytes)
-	{
-	  /* We only use complete characters.  */
-	  nb &= ~(bytes_per_char - 1);
-
-	  process_chunk (fname, buf, from + nb, nb, &unprinted);
-
-	  /* If the last bytes of the buffer (modulo the character
-	     size) have been printed we are not copying them.  */
-	  size_t to_keep = unprinted != NULL ? 0 : min_len_bytes;
-
-	  memmove (buf, buf + nb - to_keep, to_keep);
-	  ntrailer = to_keep;
-	  from += nb;
-	}
-      else
-	ntrailer = nb;
-    }
-
-  free (buf);
-
-  /* Don't print anything we collected so far.  There is no
-     terminating NUL byte.  */
-  free (unprinted);
-
-  return result;
-}
-
-
-static int
-read_block (int fd, const char *fname, off_t fdlen, off_t from, off_t to)
-{
-  if (elfmap == NULL)
-    {
-      /* We need a completely new mapping.  */
-      elfmap_off = from & ~(ps - 1);
-      elfmap_base = elfmap = map_file (fd, elfmap_off, fdlen, &elfmap_size);
-
-      if (unlikely (elfmap == MAP_FAILED))
-	/* Let the kernel know we are going to read everything in sequence.  */
-	(void) posix_fadvise (fd, 0, 0, POSIX_FADV_SEQUENTIAL);
-    }
-
-  if (unlikely (elfmap == MAP_FAILED))
-    {
-      /* Read from the file descriptor.  For this we must position the
-	 read pointer.  */
-      // XXX Eventually add flag which avoids this if the position
-      // XXX is known to match.
-      if (from != 0 && lseek (fd, from, SEEK_SET) != from)
-	error (EXIT_FAILURE, errno, _("lseek failed"));
-
-      return read_block_no_mmap (fd, fname, from, to - from);
-    }
-
-  assert ((off_t) min_len_bytes < fdlen);
-
-  if (to < (off_t) elfmap_off || from > (off_t) (elfmap_off + elfmap_size))
-    {
-      /* The existing mapping cannot fit at all.  Map the new area.
-	 We always map the full range of ELFMAP_SIZE bytes even if
-	 this extend beyond the end of the file.  The Linux kernel
-	 handles this OK if the access pages are not touched.  */
-      elfmap_off = from & ~(ps - 1);
-      if (mmap (elfmap, elfmap_size, PROT_READ,
-		MAP_PRIVATE | MAP_POPULATE | MAP_FIXED, fd, from)
-	  == MAP_FAILED)
-	error (EXIT_FAILURE, errno, _("re-mmap failed"));
-      elfmap_base = elfmap;
-    }
-
-  char *unprinted = NULL;
-
-  /* Use the existing mapping as much as possible.  If necessary, map
-     new pages.  */
-  if (from >= (off_t) elfmap_off
-      && from < (off_t) (elfmap_off + elfmap_size))
-    /* There are at least a few bytes in this mapping which we can
-       use.  */
-    process_chunk (fname, elfmap_base + (from - elfmap_off),
-		   MIN (to, (off_t) (elfmap_off + elfmap_size)),
-		   MIN (to, (off_t) (elfmap_off + elfmap_size)) - from,
-		   &unprinted);
-
-  if (to > (off_t) (elfmap_off + elfmap_size))
-    {
-      unsigned char *remap_base = elfmap_base;
-      size_t read_now = elfmap_size - (elfmap_base - elfmap);
-
-      assert (from >= (off_t) elfmap_off
-	      && from < (off_t) (elfmap_off + elfmap_size));
-      off_t handled_to = elfmap_off + elfmap_size;
-      assert (elfmap == elfmap_base
-	      || (elfmap_base - elfmap
-		  == (ptrdiff_t) ((min_len_bytes + ps - 1) & ~(ps - 1))));
-      if (elfmap == elfmap_base)
-	{
-	  size_t keep_area = (min_len_bytes + ps - 1) & ~(ps - 1);
-	  assert (elfmap_size >= keep_area + ps);
-	  /* The keep area is used for the content of the previous
-	     buffer we have to keep.  This means copying those bytes
-	     and for this we have to make the data writable.  */
-	  if (unlikely (mprotect (elfmap, keep_area, PROT_READ | PROT_WRITE)
-			!= 0))
-	    error (EXIT_FAILURE, errno, _("mprotect failed"));
-
-	  elfmap_base = elfmap + keep_area;
-	}
-
-      while (1)
-	{
-	  /* Map the rest of the file, eventually again in pieces.
-	     We speed things up with a nice Linux feature.  Note
-	     that we have at least two pages mapped.  */
-	  size_t to_keep = unprinted != NULL ? 0 : min_len_bytes;
-
-	  assert (read_now >= to_keep);
-	  memmove (elfmap_base - to_keep,
-		   remap_base + read_now - to_keep, to_keep);
-	  remap_base = elfmap_base;
-
-	  assert ((elfmap_size - (elfmap_base - elfmap)) % bytes_per_char
-		  == 0);
-	  read_now = MIN (to - handled_to,
-			  (ptrdiff_t) elfmap_size - (elfmap_base - elfmap));
-
-	  assert (handled_to % ps == 0);
-	  assert (handled_to % bytes_per_char == 0);
-	  if (mmap (remap_base, read_now, PROT_READ,
-		    MAP_PRIVATE | MAP_POPULATE | MAP_FIXED, fd, handled_to)
-	      == MAP_FAILED)
-	    error (EXIT_FAILURE, errno, _("re-mmap failed"));
-	  elfmap_off = handled_to;
-
-	  process_chunk (fname, remap_base - to_keep,
-			 elfmap_off + (read_now & ~(bytes_per_char - 1)),
-			 to_keep + (read_now & ~(bytes_per_char - 1)),
-			 &unprinted);
-	  handled_to += read_now;
-	  if (handled_to >= to)
-	    break;
-	}
-    }
-
-  /* Don't print anything we collected so far.  There is no
-     terminating NUL byte.  */
-  free (unprinted);
-
-  return 0;
-}
-
-
-static int
-read_fd (int fd, const char *fname, off_t fdlen)
-{
-  return read_block (fd, fname, fdlen, 0, fdlen);
-}
-
-
-static int
-read_elf (Elf *elf, int fd, const char *fname, off_t fdlen)
-{
-  assert (fdlen >= 0);
-
-  /* We will look at each section separately.  The ELF file is not
-     mmapped.  The libelf implementation will load the needed parts on
-     demand.  Since we only iterate over the section header table the
-     memory consumption at this stage is kept minimal.  */
-  Elf_Scn *scn = elf_nextscn (elf, NULL);
-  if (scn == NULL)
-    return read_fd (fd, fname, fdlen);
-
-  int result = 0;
-  do
-    {
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-
-      /* Only look in sections which are loaded at runtime and
-	 actually have content.  */
-      if (shdr != NULL && shdr->sh_type != SHT_NOBITS
-	  && (shdr->sh_flags & SHF_ALLOC) != 0)
-	{
-	  if (shdr->sh_offset > (Elf64_Off) fdlen
-	      || fdlen - shdr->sh_offset < shdr->sh_size)
-	    {
-	      size_t strndx = 0;
-	      const char *sname;
-	      if (unlikely (elf_getshdrstrndx (elf, &strndx) < 0))
-		sname = "<unknown>";
-	      else
-		sname = elf_strptr (elf, strndx, shdr->sh_name) ?: "<unknown>";
-	      error (0, 0,
-		     _("Skipping section %zd '%s' data outside file"),
-		     elf_ndxscn (scn), sname);
-	      result = 1;
-	    }
-	  else
-	    result |= read_block (fd, fname, fdlen, shdr->sh_offset,
-				  shdr->sh_offset + shdr->sh_size);
-	}
-    }
-  while ((scn = elf_nextscn (elf, scn)) != NULL);
-
-  if (elfmap != NULL && elfmap != MAP_FAILED)
-    munmap (elfmap, elfmap_size);
-  elfmap = NULL;
-
-  return result;
-}
-
-
-#include "debugpred.h"
diff --git a/src/strip.c b/src/strip.c
deleted file mode 100644
index 3dc3b5c952f0fa3ef1269a37158fcf5fe8aeed2d..0000000000000000000000000000000000000000
--- a/src/strip.c
+++ /dev/null
@@ -1,2775 +0,0 @@
-/* Discard section not used at runtime from object files.
-   Copyright (C) 2000-2012, 2014, 2015, 2016, 2017, 2018 Red Hat, Inc.
-   This file is part of elfutils.
-   Written by Ulrich Drepper <drepper@redhat.com>, 2000.
-
-   This file is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   elfutils is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#include <argp.h>
-#include <alloca.h>
-#include <assert.h>
-#include <byteswap.h>
-#include <endian.h>
-#include <fcntl.h>
-#include <libgen.h>
-#include <fnmatch.h>
-#include <gelf.h>
-#include <libelf.h>
-#include <libintl.h>
-#include <locale.h>
-#include <stdbool.h>
-#include <stdio.h>
-#include <stdio_ext.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/stat.h>
-#include <sys/time.h>
-
-#include <elf-knowledge.h>
-#include <libebl.h>
-#include "libdwelf.h"
-#include <libeu.h>
-#include <system.h>
-#include <printversion.h>
-
-typedef uint8_t GElf_Byte;
-
-/* Name and version of program.  */
-ARGP_PROGRAM_VERSION_HOOK_DEF = print_version;
-
-/* Bug report address.  */
-ARGP_PROGRAM_BUG_ADDRESS_DEF = PACKAGE_BUGREPORT;
-
-
-/* Values for the parameters which have no short form.  */
-#define OPT_REMOVE_COMMENT	0x100
-#define OPT_PERMISSIVE		0x101
-#define OPT_STRIP_SECTIONS	0x102
-#define OPT_RELOC_DEBUG 	0x103
-#define OPT_KEEP_SECTION 	0x104
-#define OPT_RELOC_DEBUG_ONLY    0x105
-
-
-/* Definitions of arguments for argp functions.  */
-static const struct argp_option options[] =
-{
-  { NULL, 0, NULL, 0, N_("Output selection:"), 0 },
-  { "output", 'o', "FILE", 0, N_("Place stripped output into FILE"), 0 },
-  { NULL, 'f', "FILE", 0, N_("Extract the removed sections into FILE"), 0 },
-  { NULL, 'F', "FILE", 0, N_("Embed name FILE instead of -f argument"), 0 },
-
-  { NULL, 0, NULL, 0, N_("Output options:"), 0 },
-  { "strip-all", 's', NULL, OPTION_HIDDEN, NULL, 0 },
-  { "strip-debug", 'g', NULL, 0, N_("Remove all debugging symbols"), 0 },
-  { NULL, 'd', NULL, OPTION_ALIAS, NULL, 0 },
-  { NULL, 'S', NULL, OPTION_ALIAS, NULL, 0 },
-  { "strip-sections", OPT_STRIP_SECTIONS, NULL, 0,
-    N_("Remove section headers (not recommended)"), 0 },
-  { "preserve-dates", 'p', NULL, 0,
-    N_("Copy modified/access timestamps to the output"), 0 },
-  { "reloc-debug-sections", OPT_RELOC_DEBUG, NULL, 0,
-    N_("Resolve all trivial relocations between debug sections if the removed sections are placed in a debug file (only relevant for ET_REL files, operation is not reversible, needs -f)"), 0 },
-  { "reloc-debug-sections-only", OPT_RELOC_DEBUG_ONLY, NULL, 0,
-    N_("Similar to --reloc-debug-sections, but resolve all trivial relocations between debug sections in place.  No other stripping is performed (operation is not reversible, incompatible with -f, -g, --remove-comment and --remove-section)"), 0 },
-  { "remove-comment", OPT_REMOVE_COMMENT, NULL, 0,
-    N_("Remove .comment section"), 0 },
-  { "remove-section", 'R', "SECTION", 0, N_("Remove the named section.  SECTION is an extended wildcard pattern.  May be given more than once.  Only non-allocated sections can be removed."), 0 },
-  { "keep-section", OPT_KEEP_SECTION, "SECTION", 0, N_("Keep the named section.  SECTION is an extended wildcard pattern.  May be given more than once."), 0 },
-  { "permissive", OPT_PERMISSIVE, NULL, 0,
-    N_("Relax a few rules to handle slightly broken ELF files"), 0 },
-  { NULL, 0, NULL, 0, NULL, 0 }
-};
-
-/* Short description of program.  */
-static const char doc[] = N_("Discard symbols from object files.");
-
-/* Strings for arguments in help texts.  */
-static const char args_doc[] = N_("[FILE...]");
-
-/* Prototype for option handler.  */
-static error_t parse_opt (int key, char *arg, struct argp_state *state);
-
-/* Data structure to communicate with argp functions.  */
-static struct argp argp =
-{
-  options, parse_opt, args_doc, doc, NULL, NULL, NULL
-};
-
-
-/* Print symbols in file named FNAME.  */
-static int process_file (const char *fname);
-
-/* Handle one ELF file.  */
-static int handle_elf (int fd, Elf *elf, const char *prefix,
-		       const char *fname, mode_t mode, struct timespec tvp[2]);
-
-/* Handle all files contained in the archive.  */
-static int handle_ar (int fd, Elf *elf, const char *prefix, const char *fname,
-		      struct timespec tvp[2]) __attribute__ ((unused));
-
-static int debug_fd = -1;
-static char *tmp_debug_fname = NULL;
-
-/* Close debug file descriptor, if opened. And remove temporary debug file.  */
-static void cleanup_debug (void);
-
-#define INTERNAL_ERROR(fname) \
-  do { \
-    cleanup_debug (); \
-    error (EXIT_FAILURE, 0, _("%s: INTERNAL ERROR %d (%s): %s"),      \
-	   fname, __LINE__, PACKAGE_VERSION, elf_errmsg (-1)); \
-  } while (0)
-
-
-/* Name of the output file.  */
-static const char *output_fname;
-
-/* Name of the debug output file.  */
-static const char *debug_fname;
-
-/* Name to pretend the debug output file has.  */
-static const char *debug_fname_embed;
-
-/* If true output files shall have same date as the input file.  */
-static bool preserve_dates;
-
-/* If true .comment sections will be removed.  */
-static bool remove_comment;
-
-/* If true remove all debug sections.  */
-static bool remove_debug;
-
-/* If true remove all section headers.  */
-static bool remove_shdrs;
-
-/* If true relax some ELF rules for input files.  */
-static bool permissive;
-
-/* If true perform relocations between debug sections.  */
-static bool reloc_debug;
-
-/* If true perform relocations between debug sections only.  */
-static bool reloc_debug_only;
-
-/* Sections the user explicitly wants to keep or remove.  */
-struct section_pattern
-{
-  char *pattern;
-  struct section_pattern *next;
-};
-
-static struct section_pattern *keep_secs = NULL;
-static struct section_pattern *remove_secs = NULL;
-
-static void
-add_pattern (struct section_pattern **patterns, const char *pattern)
-{
-  struct section_pattern *p = xmalloc (sizeof *p);
-  p->pattern = xstrdup (pattern);
-  p->next = *patterns;
-  *patterns = p;
-}
-
-static void
-free_sec_patterns (struct section_pattern *patterns)
-{
-  struct section_pattern *pattern = patterns;
-  while (pattern != NULL)
-    {
-      struct section_pattern *p = pattern;
-      pattern = p->next;
-      free (p->pattern);
-      free (p);
-    }
-}
-
-static void
-free_patterns (void)
-{
-  free_sec_patterns (keep_secs);
-  free_sec_patterns (remove_secs);
-}
-
-static bool
-section_name_matches (struct section_pattern *patterns, const char *name)
-{
-  struct section_pattern *pattern = patterns;
-  while (pattern != NULL)
-    {
-      if (fnmatch (pattern->pattern, name, FNM_EXTMATCH) == 0)
-	return true;
-      pattern = pattern->next;
-    }
-  return false;
-}
-
-
-int
-main (int argc, char *argv[])
-{
-  int remaining;
-  int result = 0;
-
-  /* We use no threads here which can interfere with handling a stream.  */
-  __fsetlocking (stdin, FSETLOCKING_BYCALLER);
-  __fsetlocking (stdout, FSETLOCKING_BYCALLER);
-  __fsetlocking (stderr, FSETLOCKING_BYCALLER);
-
-  /* Set locale.  */
-  setlocale (LC_ALL, "");
-
-  /* Make sure the message catalog can be found.  */
-  bindtextdomain (PACKAGE_TARNAME, LOCALEDIR);
-
-  /* Initialize the message catalog.  */
-  textdomain (PACKAGE_TARNAME);
-
-  /* Parse and process arguments.  */
-  if (argp_parse (&argp, argc, argv, 0, &remaining, NULL) != 0)
-    return EXIT_FAILURE;
-
-  if (reloc_debug && debug_fname == NULL)
-    error (EXIT_FAILURE, 0,
-	   _("--reloc-debug-sections used without -f"));
-
-  if (reloc_debug_only &&
-      (debug_fname != NULL || remove_secs != NULL
-       || remove_comment == true || remove_debug == true))
-    error (EXIT_FAILURE, 0,
-	   _("--reloc-debug-sections-only incompatible with -f, -g, --remove-comment and --remove-section"));
-
-  /* Tell the library which version we are expecting.  */
-  elf_version (EV_CURRENT);
-
-  if (remaining == argc)
-    /* The user didn't specify a name so we use a.out.  */
-    result = process_file ("a.out");
-  else
-    {
-      /* If we have seen the '-o' or '-f' option there must be exactly one
-	 input file.  */
-      if ((output_fname != NULL || debug_fname != NULL)
-	  && remaining + 1 < argc)
-	error (EXIT_FAILURE, 0, _("\
-Only one input file allowed together with '-o' and '-f'"));
-
-      /* Process all the remaining files.  */
-      do
-	result |= process_file (argv[remaining]);
-      while (++remaining < argc);
-    }
-
-  free_patterns ();
-  return result;
-}
-
-
-/* Handle program arguments.  */
-static error_t
-parse_opt (int key, char *arg, struct argp_state *state)
-{
-  switch (key)
-    {
-    case 'f':
-      if (debug_fname != NULL)
-	{
-	  error (0, 0, _("-f option specified twice"));
-	  return EINVAL;
-	}
-      debug_fname = arg;
-      break;
-
-    case 'F':
-      if (debug_fname_embed != NULL)
-	{
-	  error (0, 0, _("-F option specified twice"));
-	  return EINVAL;
-	}
-      debug_fname_embed = arg;
-      break;
-
-    case 'o':
-      if (output_fname != NULL)
-	{
-	  error (0, 0, _("-o option specified twice"));
-	  return EINVAL;
-	}
-      output_fname = arg;
-      break;
-
-    case 'p':
-      preserve_dates = true;
-      break;
-
-    case OPT_RELOC_DEBUG:
-      reloc_debug = true;
-      break;
-
-    case OPT_RELOC_DEBUG_ONLY:
-      reloc_debug_only = true;
-      break;
-
-    case OPT_REMOVE_COMMENT:
-      remove_comment = true;
-      break;
-
-    case 'R':
-      if (fnmatch (arg, ".comment", FNM_EXTMATCH) == 0)
-	remove_comment = true;
-      add_pattern (&remove_secs, arg);
-      break;
-
-    case OPT_KEEP_SECTION:
-      add_pattern (&keep_secs, arg);
-      break;
-
-    case 'g':
-    case 'd':
-    case 'S':
-      remove_debug = true;
-      break;
-
-    case OPT_STRIP_SECTIONS:
-      remove_shdrs = true;
-      break;
-
-    case OPT_PERMISSIVE:
-      permissive = true;
-      break;
-
-    case 's':			/* Ignored for compatibility.  */
-      break;
-
-    case ARGP_KEY_SUCCESS:
-      if (remove_comment == true
-	  && section_name_matches (keep_secs, ".comment"))
-	{
-	  argp_error (state,
-		      _("cannot both keep and remove .comment section"));
-	  return EINVAL;
-	}
-      break;
-
-    default:
-      return ARGP_ERR_UNKNOWN;
-    }
-  return 0;
-}
-
-static const char *
-secndx_name (Elf *elf, size_t ndx)
-{
-  size_t shstrndx;
-  GElf_Shdr mem;
-  Elf_Scn *sec = elf_getscn (elf, ndx);
-  GElf_Shdr *shdr = gelf_getshdr (sec, &mem);
-  if (shdr == NULL || elf_getshdrstrndx (elf, &shstrndx) < 0)
-    return "???";
-  return elf_strptr (elf, shstrndx, shdr->sh_name) ?: "???";
-}
-
-/* Get the extended section index table data for a symbol table section.  */
-static Elf_Data *
-get_xndxdata (Elf *elf, Elf_Scn *symscn)
-{
-  Elf_Data *xndxdata = NULL;
-  GElf_Shdr shdr_mem;
-  GElf_Shdr *shdr = gelf_getshdr (symscn, &shdr_mem);
-  if (shdr != NULL && shdr->sh_type == SHT_SYMTAB)
-    {
-      size_t scnndx = elf_ndxscn (symscn);
-      Elf_Scn *xndxscn = NULL;
-      while ((xndxscn = elf_nextscn (elf, xndxscn)) != NULL)
-	{
-	  GElf_Shdr xndxshdr_mem;
-	  GElf_Shdr *xndxshdr = gelf_getshdr (xndxscn, &xndxshdr_mem);
-
-	  if (xndxshdr != NULL
-	      && xndxshdr->sh_type == SHT_SYMTAB_SHNDX
-	      && xndxshdr->sh_link == scnndx)
-	    {
-	      xndxdata = elf_getdata (xndxscn, NULL);
-	      break;
-	    }
-	}
-    }
-
-  return xndxdata;
-}
-
-/* Updates the shdrstrndx for the given Elf by updating the Ehdr and
-   possibly the section zero extension field.  Returns zero on success.  */
-static int
-update_shdrstrndx (Elf *elf, size_t shdrstrndx)
-{
-  GElf_Ehdr ehdr;
-  if (gelf_getehdr (elf, &ehdr) == 0)
-    return 1;
-
-  if (shdrstrndx < SHN_LORESERVE)
-    ehdr.e_shstrndx = shdrstrndx;
-  else
-    {
-      ehdr.e_shstrndx = SHN_XINDEX;
-      Elf_Scn *scn0 = elf_getscn (elf, 0);
-      GElf_Shdr shdr0_mem;
-      GElf_Shdr *shdr0 = gelf_getshdr (scn0, &shdr0_mem);
-      if (shdr0 == NULL)
-	return 1;
-
-      shdr0->sh_link = shdrstrndx;
-      if (gelf_update_shdr (scn0, shdr0) == 0)
-	return 1;
-    }
-
-  if (unlikely (gelf_update_ehdr (elf, &ehdr) == 0))
-    return 1;
-
-  return 0;
-}
-
-
-/* Apply one relocation.  Returns true when trivial
-   relocation actually done.  */
-static bool
-relocate (Elf *elf, GElf_Addr offset, const GElf_Sxword addend,
-	  Elf_Data *tdata, unsigned int ei_data, const char *fname,
-	  bool is_rela, GElf_Sym *sym, int addsub, Elf_Type type)
-{
-  /* These are the types we can relocate.  */
-#define TYPES   DO_TYPE (BYTE, Byte); DO_TYPE (HALF, Half);		\
-      DO_TYPE (WORD, Word); DO_TYPE (SWORD, Sword);		\
-      DO_TYPE (XWORD, Xword); DO_TYPE (SXWORD, Sxword)
-
-  size_t size;
-
-#define DO_TYPE(NAME, Name) GElf_##Name Name;
-  union { TYPES; } tmpbuf;
-#undef DO_TYPE
-
-  switch (type)
-    {
-#define DO_TYPE(NAME, Name)				\
-      case ELF_T_##NAME:			\
-	size = sizeof (GElf_##Name);	\
-	tmpbuf.Name = 0;			\
-	break;
-      TYPES;
-#undef DO_TYPE
-    default:
-      return false;
-    }
-
-  if (offset > tdata->d_size
-      || tdata->d_size - offset < size)
-    {
-      cleanup_debug ();
-      error (EXIT_FAILURE, 0, _("bad relocation"));
-    }
-
-  /* When the symbol value is zero then for SHT_REL
-     sections this is all that needs to be checked.
-     The addend is contained in the original data at
-     the offset already.  So if the (section) symbol
-     address is zero and the given addend is zero
-     just remove the relocation, it isn't needed
-     anymore.  */
-  if (addend == 0 && sym->st_value == 0)
-    return true;
-
-  Elf_Data tmpdata =
-    {
-      .d_type = type,
-      .d_buf = &tmpbuf,
-      .d_size = size,
-      .d_version = EV_CURRENT,
-    };
-  Elf_Data rdata =
-    {
-      .d_type = type,
-      .d_buf = tdata->d_buf + offset,
-      .d_size = size,
-      .d_version = EV_CURRENT,
-    };
-
-  GElf_Addr value = sym->st_value;
-  if (is_rela)
-    {
-      /* For SHT_RELA sections we just take the
-	 given addend and add it to the value.  */
-      value += addend;
-      /* For ADD/SUB relocations we need to fetch the
-	 current section contents.  */
-      if (addsub != 0)
-	{
-	  Elf_Data *d = gelf_xlatetom (elf, &tmpdata,
-				       &rdata,
-				       ei_data);
-	  if (d == NULL)
-	    INTERNAL_ERROR (fname);
-	  assert (d == &tmpdata);
-	}
-    }
-  else
-    {
-      /* For SHT_REL sections we have to peek at
-	 what is already in the section at the given
-	 offset to get the addend.  */
-      Elf_Data *d = gelf_xlatetom (elf, &tmpdata,
-				   &rdata,
-				   ei_data);
-      if (d == NULL)
-	INTERNAL_ERROR (fname);
-      assert (d == &tmpdata);
-    }
-
-  switch (type)
-    {
-#define DO_TYPE(NAME, Name)					 \
-      case ELF_T_##NAME:				 \
-	if (addsub < 0)				 \
-	  tmpbuf.Name -= (GElf_##Name) value;	 \
-	else					 \
-	  tmpbuf.Name += (GElf_##Name) value;	 \
-	break;
-      TYPES;
-#undef DO_TYPE
-    default:
-      abort ();
-    }
-
-  /* Now finally put in the new value.  */
-  Elf_Data *s = gelf_xlatetof (elf, &rdata,
-			       &tmpdata,
-			       ei_data);
-  if (s == NULL)
-    INTERNAL_ERROR (fname);
-  assert (s == &rdata);
-
-  return true;
-}
-
-/* Remove any relocations between debug sections in ET_REL
-   for the debug file when requested.  These relocations are always
-   zero based between the unallocated sections.  */
-static void
-remove_debug_relocations (Ebl *ebl, Elf *elf, GElf_Ehdr *ehdr,
-			  const char *fname, size_t shstrndx)
-{
-  Elf_Scn *scn = NULL;
-  while ((scn = elf_nextscn (elf, scn)) != NULL)
-    {
-      /* We need the actual section and header from the elf
-	 not just the cached original in shdr_info because we
-	 might want to change the size.  */
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-      if (shdr->sh_type == SHT_REL || shdr->sh_type == SHT_RELA)
-	{
-	  /* Make sure that this relocation section points to a
-	     section to relocate with contents, that isn't
-	     allocated and that is a debug section.  */
-	  Elf_Scn *tscn = elf_getscn (elf, shdr->sh_info);
-	  GElf_Shdr tshdr_mem;
-	  GElf_Shdr *tshdr = gelf_getshdr (tscn, &tshdr_mem);
-	  if (tshdr->sh_type == SHT_NOBITS
-	      || tshdr->sh_size == 0
-	      || (tshdr->sh_flags & SHF_ALLOC) != 0)
-	    continue;
-
-	  const char *tname =  elf_strptr (elf, shstrndx,
-					   tshdr->sh_name);
-	  if (! tname || ! ebl_debugscn_p (ebl, tname))
-	    continue;
-
-	  /* OK, lets relocate all trivial cross debug section
-	     relocations. */
-	  Elf_Data *reldata = elf_getdata (scn, NULL);
-	  if (reldata == NULL || reldata->d_buf == NULL)
-	    INTERNAL_ERROR (fname);
-
-	  /* Make sure we adjust the uncompressed debug data
-	     (and recompress if necessary at the end).  */
-	  GElf_Chdr tchdr;
-	  int tcompress_type = 0;
-	  bool is_gnu_compressed = false;
-	  if (startswith (tname, ".zdebug"))
-	    {
-	      is_gnu_compressed = true;
-	      if (elf_compress_gnu (tscn, 0, 0) != 1)
-		INTERNAL_ERROR (fname);
-	    }
-	  else
-	    {
-	      if (gelf_getchdr (tscn, &tchdr) != NULL)
-		{
-		  tcompress_type = tchdr.ch_type;
-		  if (elf_compress (tscn, 0, 0) != 1)
-		    INTERNAL_ERROR (fname);
-		}
-	    }
-
-	  Elf_Data *tdata = elf_getdata (tscn, NULL);
-	  if (tdata == NULL || tdata->d_buf == NULL
-	      || tdata->d_type != ELF_T_BYTE)
-	    INTERNAL_ERROR (fname);
-
-	  /* Pick up the symbol table and shndx table to
-	     resolve relocation symbol indexes.  */
-	  Elf64_Word symt = shdr->sh_link;
-	  Elf_Data *symdata, *xndxdata;
-	  Elf_Scn * symscn = elf_getscn (elf, symt);
-	  symdata = elf_getdata (symscn, NULL);
-	  xndxdata = get_xndxdata (elf, symscn);
-	  if (symdata == NULL)
-	    INTERNAL_ERROR (fname);
-
-	  if (shdr->sh_entsize == 0)
-	    INTERNAL_ERROR (fname);
-
-	  size_t nrels = shdr->sh_size / shdr->sh_entsize;
-	  size_t next = 0;
-	  const bool is_rela = (shdr->sh_type == SHT_RELA);
-	  const unsigned int ei_data = ehdr->e_ident[EI_DATA];
-
-	  for (size_t relidx = 0; relidx < nrels; ++relidx)
-	    {
-	      int rtype, symndx, offset, addend;
-	      union { GElf_Rela rela; GElf_Rel rel; } mem;
-	      void *rel_p; /* Pointer to either rela or rel above */
-
-	      if (is_rela)
-		{
-		  GElf_Rela *r = gelf_getrela (reldata, relidx, &mem.rela);
-		  offset = r->r_offset;
-		  addend = r->r_addend;
-		  rtype = GELF_R_TYPE (r->r_info);
-		  symndx = GELF_R_SYM (r->r_info);
-		  rel_p = r;
-		}
-	      else
-		{
-		  GElf_Rel *r = gelf_getrel (reldata, relidx, &mem.rel);
-		  offset = r->r_offset;
-		  addend = 0;
-		  rtype = GELF_R_TYPE (r->r_info);
-		  symndx = GELF_R_SYM (r->r_info);
-		  rel_p = r;
-		}
-
-	      /* R_*_NONE relocs can always just be removed.  */
-	      if (rtype == 0)
-		continue;
-
-	      /* We only do simple absolute relocations.  */
-	      int addsub = 0;
-	      Elf_Type type = ebl_reloc_simple_type (ebl, rtype, &addsub);
-	      if (type == ELF_T_NUM)
-		goto relocate_failed;
-
-	      /* And only for relocations against other debug sections.  */
-	      GElf_Sym sym_mem;
-	      Elf32_Word xndx;
-	      GElf_Sym *sym = gelf_getsymshndx (symdata, xndxdata,
-						symndx, &sym_mem,
-						  &xndx);
-	      Elf32_Word sec = (sym->st_shndx == SHN_XINDEX
-				? xndx : sym->st_shndx);
-
-	      bool dbg_scn = ebl_debugscn_p (ebl, secndx_name (elf, sec));
-
-	      if (!dbg_scn)
-		goto relocate_failed;
-
-	      if (! relocate (elf, offset, addend,
-			    tdata, ei_data, fname, is_rela,
-			    sym, addsub, type))
-	      goto relocate_failed;
-
-	      continue; /* Next */
-
-relocate_failed:
-	      if (relidx != next)
-		{
-		  int updated;
-		  if (is_rela)
-		    updated = gelf_update_rela (reldata, next, rel_p);
-		  else
-		    updated = gelf_update_rel (reldata, next, rel_p);
-		  if (updated == 0)
-		    INTERNAL_ERROR (fname);
-		}
-	      ++next;
-	    }
-
-	  nrels = next;
-	  shdr->sh_size = reldata->d_size = nrels * shdr->sh_entsize;
-	  if (gelf_update_shdr (scn, shdr) == 0)
-	    INTERNAL_ERROR (fname);
-
-	  if (is_gnu_compressed)
-	    {
-	      if (elf_compress_gnu (tscn, 1, ELF_CHF_FORCE) != 1)
-		INTERNAL_ERROR (fname);
-	    }
-	  else if (tcompress_type != 0)
-	    {
-	      if (elf_compress (tscn, tcompress_type, ELF_CHF_FORCE) != 1)
-		INTERNAL_ERROR (fname);
-	    }
-	}
-    }
-}
-
-static int
-process_file (const char *fname)
-{
-  /* If we have to preserve the modify and access timestamps get them
-     now.  We cannot use fstat() after opening the file since the open
-     would change the access time.  */
-  struct stat pre_st;
-  struct timespec tv[2];
- again:
-  if (preserve_dates)
-    {
-      if (stat (fname, &pre_st) != 0)
-	{
-	  error (0, errno, _("cannot stat input file '%s'"), fname);
-	  return 1;
-	}
-
-      /* If we have to preserve the timestamp, we need it in the
-	 format utimes() understands.  */
-      tv[0] = pre_st.st_atim;
-      tv[1] = pre_st.st_mtim;
-    }
-
-  /* Open the file.  */
-  int fd = open (fname, output_fname == NULL ? O_RDWR : O_RDONLY);
-  if (fd == -1)
-    {
-      error (0, errno, _("while opening '%s'"), fname);
-      return 1;
-    }
-
-  /* We always use fstat() even if we called stat() before.  This is
-     done to make sure the information returned by stat() is for the
-     same file.  */
-  struct stat st;
-  if (fstat (fd, &st) != 0)
-    {
-      error (0, errno, _("cannot stat input file '%s'"), fname);
-      return 1;
-    }
-  /* Paranoid mode on.  */
-  if (preserve_dates
-      && (st.st_ino != pre_st.st_ino || st.st_dev != pre_st.st_dev))
-    {
-      /* We detected a race.  Try again.  */
-      close (fd);
-      goto again;
-    }
-
-  /* Now get the ELF descriptor.  */
-  Elf *elf = elf_begin (fd, output_fname == NULL ? ELF_C_RDWR : ELF_C_READ,
-			NULL);
-  int result;
-  switch (elf_kind (elf))
-    {
-    case ELF_K_ELF:
-      result = handle_elf (fd, elf, NULL, fname, st.st_mode & ACCESSPERMS,
-			   preserve_dates ? tv : NULL);
-      break;
-
-    case ELF_K_AR:
-      /* It is not possible to strip the content of an archive direct
-	 the output to a specific file.  */
-      if (unlikely (output_fname != NULL || debug_fname != NULL))
-	{
-	  error (0, 0, _("%s: cannot use -o or -f when stripping archive"),
-		 fname);
-	  result = 1;
-	}
-      else
-	{
-	  /* We would like to support ar archives, but currently it just
-	     doesn't work at all since we call elf_clone on the members
-	     which doesn't really support ar members.
-	     result = handle_ar (fd, elf, NULL, fname,
-				 preserve_dates ? tv : NULL);
-	   */
-	  error (0, 0, _("%s: no support for stripping archive"),
-		 fname);
-	  result = 1;
-	}
-      break;
-
-    default:
-      error (0, 0, _("%s: File format not recognized"), fname);
-      result = 1;
-      break;
-    }
-
-  if (unlikely (elf_end (elf) != 0))
-    INTERNAL_ERROR (fname);
-
-  close (fd);
-
-  return result;
-}
-
-/* Processing for --reloc-debug-sections-only.  */
-static int
-handle_debug_relocs (Elf *elf, Ebl *ebl, Elf *new_elf,
-		     GElf_Ehdr *ehdr, const char *fname, size_t shstrndx,
-		     GElf_Off *last_offset, GElf_Xword *last_size)
-{
-
-  /* Copy over the ELF header.  */
-  if (gelf_update_ehdr (new_elf, ehdr) == 0)
-    {
-      error (0, 0, "couldn't update new ehdr: %s", elf_errmsg (-1));
-      return 1;
-    }
-
-  /* Copy over sections and record end of allocated sections.  */
-  GElf_Off lastoffset = 0;
-  Elf_Scn *scn = NULL;
-  while ((scn = elf_nextscn (elf, scn)) != NULL)
-    {
-      /* Get the header.  */
-      GElf_Shdr shdr;
-      if (gelf_getshdr (scn, &shdr) == NULL)
-	{
-	  error (0, 0, "couldn't get shdr: %s", elf_errmsg (-1));
-	  return 1;
-	}
-
-      /* Create new section.  */
-      Elf_Scn *new_scn = elf_newscn (new_elf);
-      if (new_scn == NULL)
-	{
-	  error (0, 0, "couldn't create new section: %s", elf_errmsg (-1));
-	  return 1;
-	}
-
-      if (gelf_update_shdr (new_scn, &shdr) == 0)
-	{
-	  error (0, 0, "couldn't update shdr: %s", elf_errmsg (-1));
-	  return 1;
-	}
-
-      /* Copy over section data.  */
-      Elf_Data *data = NULL;
-      while ((data = elf_getdata (scn, data)) != NULL)
-	{
-	  Elf_Data *new_data = elf_newdata (new_scn);
-	  if (new_data == NULL)
-	    {
-	      error (0, 0, "couldn't create new section data: %s",
-		     elf_errmsg (-1));
-	      return 1;
-	    }
-	  *new_data = *data;
-	}
-
-      /* Record last offset of allocated section.  */
-      if ((shdr.sh_flags & SHF_ALLOC) != 0)
-	{
-	  GElf_Off filesz = (shdr.sh_type != SHT_NOBITS
-			     ? shdr.sh_size : 0);
-	  if (lastoffset < shdr.sh_offset + filesz)
-	    lastoffset = shdr.sh_offset + filesz;
-	}
-    }
-
-  /* Make sure section header name table is setup correctly, we'll
-     need it to determine whether to relocate sections.  */
-  if (update_shdrstrndx (new_elf, shstrndx) != 0)
-    {
-      error (0, 0, "error updating shdrstrndx: %s", elf_errmsg (-1));
-      return 1;
-    }
-
-  /* Adjust the relocation sections.  */
-  remove_debug_relocations (ebl, new_elf, ehdr, fname, shstrndx);
-
-  /* Adjust the offsets of the non-allocated sections, so they come after
-     the allocated sections.  */
-  scn = NULL;
-  while ((scn = elf_nextscn (new_elf, scn)) != NULL)
-    {
-      /* Get the header.  */
-      GElf_Shdr shdr;
-      if (gelf_getshdr (scn, &shdr) == NULL)
-	{
-	  error (0, 0, "couldn't get shdr: %s", elf_errmsg (-1));
-	  return 1;
-	}
-
-      /* Adjust non-allocated section offsets to be after any allocated.  */
-      if ((shdr.sh_flags & SHF_ALLOC) == 0)
-	{
-	  shdr.sh_offset = ((lastoffset + shdr.sh_addralign - 1)
-			    & ~((GElf_Off) (shdr.sh_addralign - 1)));
-	  if (gelf_update_shdr (scn, &shdr) == 0)
-	    {
-	      error (0, 0, "couldn't update shdr: %s", elf_errmsg (-1));
-	      return 1;
-	    }
-
-	  GElf_Off filesz = (shdr.sh_type != SHT_NOBITS
-			     ? shdr.sh_size : 0);
-	  lastoffset = shdr.sh_offset + filesz;
-	  *last_offset = shdr.sh_offset;
-	  *last_size = filesz;
-	}
-    }
-
-  return 0;
-}
-
-/* Update section headers when the data size has changed.
-   We also update the SHT_NOBITS section in the debug
-   file so that the section headers match in sh_size.  */
-static inline void
-update_section_size (Elf_Scn *scn,
-		     const Elf_Data *newdata,
-		     Elf *debugelf,
-		     size_t cnt,
-		     const char *fname)
-{
-  GElf_Shdr shdr_mem;
-  GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-  shdr->sh_size = newdata->d_size;
-  if (gelf_update_shdr (scn, shdr) == 0)
-    INTERNAL_ERROR (fname);
-  if (debugelf != NULL)
-    {
-      /* libelf will use d_size to set sh_size.  */
-      Elf_Data *debugdata = elf_getdata (elf_getscn (debugelf,
-						     cnt), NULL);
-      if (debugdata == NULL)
-	INTERNAL_ERROR (fname);
-      debugdata->d_size = newdata->d_size;
-    }
-}
-
-/* Maximum size of array allocated on stack.  */
-#define MAX_STACK_ALLOC	(400 * 1024)
-
-static int
-handle_elf (int fd, Elf *elf, const char *prefix, const char *fname,
-	    mode_t mode, struct timespec tvp[2])
-{
-  size_t prefix_len = prefix == NULL ? 0 : strlen (prefix);
-  size_t fname_len = strlen (fname) + 1;
-  char *fullname = alloca (prefix_len + 1 + fname_len);
-  char *cp = fullname;
-  Elf *debugelf = NULL;
-  tmp_debug_fname = NULL;
-  int result = 0;
-  size_t shdridx = 0;
-  GElf_Off lastsec_offset = 0;
-  Elf64_Xword lastsec_size = 0;
-  size_t shstrndx;
-  struct shdr_info
-  {
-    Elf_Scn *scn;
-    GElf_Shdr shdr;
-    Elf_Data *data;
-    Elf_Data *debug_data;
-    const char *name;
-    Elf32_Word idx;		/* Index in new file.  */
-    Elf32_Word old_sh_link;	/* Original value of shdr.sh_link.  */
-    Elf32_Word symtab_idx;
-    Elf32_Word version_idx;
-    Elf32_Word group_idx;
-    Elf32_Word group_cnt;
-    Elf_Scn *newscn;
-    Dwelf_Strent *se;
-    Elf32_Word *newsymidx;
-  } *shdr_info = NULL;
-  Elf_Scn *scn;
-  size_t cnt;
-  size_t idx;
-  bool changes;
-  GElf_Ehdr newehdr_mem;
-  GElf_Ehdr *newehdr;
-  GElf_Ehdr debugehdr_mem;
-  GElf_Ehdr *debugehdr;
-  Dwelf_Strtab *shst = NULL;
-  Elf_Data debuglink_crc_data;
-  bool any_symtab_changes = false;
-  Elf_Data *shstrtab_data = NULL;
-  void *debuglink_buf = NULL;
-
-  /* Create the full name of the file.  */
-  if (prefix != NULL)
-    {
-      cp = mempcpy (cp, prefix, prefix_len);
-      *cp++ = ':';
-    }
-  memcpy (cp, fname, fname_len);
-
-  /* If we are not replacing the input file open a new file here.  */
-  if (output_fname != NULL)
-    {
-      fd = open (output_fname, O_RDWR | O_CREAT, mode);
-      if (unlikely (fd == -1))
-	{
-	  error (0, errno, _("cannot open '%s'"), output_fname);
-	  return 1;
-	}
-    }
-
-  debug_fd = -1;
-
-  /* Get the EBL handling.  Removing all debugging symbols with the -g
-     option or resolving all relocations between debug sections with
-     the --reloc-debug-sections option are currently the only reasons
-     we need EBL so don't open the backend unless necessary.  */
-  Ebl *ebl = NULL;
-  if (remove_debug || reloc_debug || reloc_debug_only)
-    {
-      ebl = ebl_openbackend (elf);
-      if (ebl == NULL)
-	{
-	  error (0, errno, _("cannot open EBL backend"));
-	  result = 1;
-	  goto fail;
-	}
-    }
-
-  /* Open the additional file the debug information will be stored in.  */
-  if (debug_fname != NULL)
-    {
-      /* Create a temporary file name.  We do not want to overwrite
-	 the debug file if the file would not contain any
-	 information.  */
-      size_t debug_fname_len = strlen (debug_fname);
-      tmp_debug_fname = xmalloc (debug_fname_len + sizeof (".XXXXXX"));
-      strcpy (mempcpy (tmp_debug_fname, debug_fname, debug_fname_len),
-	      ".XXXXXX");
-
-      debug_fd = mkstemp (tmp_debug_fname);
-      if (unlikely (debug_fd == -1))
-	{
-	  error (0, errno, _("cannot open '%s'"), debug_fname);
-	  result = 1;
-	  goto fail;
-	}
-    }
-
-  /* Get the information from the old file.  */
-  GElf_Ehdr ehdr_mem;
-  GElf_Ehdr *ehdr = gelf_getehdr (elf, &ehdr_mem);
-  if (ehdr == NULL)
-    INTERNAL_ERROR (fname);
-
-  /* Get the section header string table index.  */
-  if (unlikely (elf_getshdrstrndx (elf, &shstrndx) < 0))
-    {
-      cleanup_debug ();
-      error (EXIT_FAILURE, 0,
-	     _("cannot get section header string table index"));
-    }
-
-  /* Get the number of phdrs in the old file.  */
-  size_t phnum;
-  if (elf_getphdrnum (elf, &phnum) != 0)
-    {
-      cleanup_debug ();
-      error (EXIT_FAILURE, 0, _("cannot get number of phdrs"));
-    }
-
-  /* We now create a new ELF descriptor for the same file.  We
-     construct it almost exactly in the same way with some information
-     dropped.  */
-  Elf *newelf;
-  if (output_fname != NULL)
-    newelf = elf_begin (fd, ELF_C_WRITE_MMAP, NULL);
-  else
-    newelf = elf_clone (elf, ELF_C_EMPTY);
-
-  if (unlikely (gelf_newehdr (newelf, gelf_getclass (elf)) == 0))
-    {
-      error (0, 0, _("cannot create new ehdr for file '%s': %s"),
-	     output_fname ?: fname, elf_errmsg (-1));
-      goto fail;
-    }
-
-  /* Copy over the old program header if needed.  */
-  if (phnum > 0)
-    {
-      if (unlikely (gelf_newphdr (newelf, phnum) == 0))
-	{
-	  error (0, 0, _("cannot create new phdr for file '%s': %s"),
-		 output_fname ?: fname, elf_errmsg (-1));
-	  goto fail;
-	}
-
-      for (cnt = 0; cnt < phnum; ++cnt)
-	{
-	  GElf_Phdr phdr_mem;
-	  GElf_Phdr *phdr = gelf_getphdr (elf, cnt, &phdr_mem);
-	  if (phdr == NULL
-	      || unlikely (gelf_update_phdr (newelf, cnt, phdr) == 0))
-	    INTERNAL_ERROR (fname);
-	}
-    }
-
-  if (reloc_debug_only)
-    {
-      if (handle_debug_relocs (elf, ebl, newelf, ehdr, fname, shstrndx,
-			       &lastsec_offset, &lastsec_size) != 0)
-	{
-	  result = 1;
-	  goto fail_close;
-	}
-      idx = shstrndx;
-      goto done; /* Skip all actual stripping operations.  */
-    }
-
-  if (debug_fname != NULL)
-    {
-      /* Also create an ELF descriptor for the debug file */
-      debugelf = elf_begin (debug_fd, ELF_C_WRITE, NULL);
-      if (unlikely (gelf_newehdr (debugelf, gelf_getclass (elf)) == 0))
-	{
-	  error (0, 0, _("cannot create new ehdr for file '%s': %s"),
-		 debug_fname, elf_errmsg (-1));
-	  goto fail_close;
-	}
-
-      /* Copy over the old program header if needed.  */
-      if (phnum > 0)
-	{
-	  if (unlikely (gelf_newphdr (debugelf, phnum) == 0))
-	    {
-	      error (0, 0, _("cannot create new phdr for file '%s': %s"),
-		     debug_fname, elf_errmsg (-1));
-	      goto fail_close;
-	    }
-
-	  for (cnt = 0; cnt < phnum; ++cnt)
-	    {
-	      GElf_Phdr phdr_mem;
-	      GElf_Phdr *phdr = gelf_getphdr (elf, cnt, &phdr_mem);
-	      if (phdr == NULL
-		  || unlikely (gelf_update_phdr (debugelf, cnt, phdr) == 0))
-		INTERNAL_ERROR (fname);
-	    }
-	}
-    }
-
-  /* Number of sections.  */
-  size_t shnum;
-  if (unlikely (elf_getshdrnum (elf, &shnum) < 0))
-    {
-      error (0, 0, _("cannot determine number of sections: %s"),
-	     elf_errmsg (-1));
-      goto fail_close;
-    }
-
-  if (shstrndx >= shnum)
-    goto illformed;
-
-#define elf_assert(test) do { if (!(test)) goto illformed; } while (0)
-
-  /* Storage for section information.  We leave room for two more
-     entries since we unconditionally create a section header string
-     table.  Maybe some weird tool created an ELF file without one.
-     The other one is used for the debug link section.  */
-  if ((shnum + 2) * sizeof (struct shdr_info) > MAX_STACK_ALLOC)
-    shdr_info = xcalloc (shnum + 2, sizeof (struct shdr_info));
-  else
-    {
-      shdr_info = (struct shdr_info *) alloca ((shnum + 2)
-					       * sizeof (struct shdr_info));
-      memset (shdr_info, '\0', (shnum + 2) * sizeof (struct shdr_info));
-    }
-
-  /* Track whether allocated sections all come before non-allocated ones.  */
-  bool seen_allocated = false;
-  bool seen_unallocated = false;
-  bool mixed_allocated_unallocated = false;
-
-  /* Prepare section information data structure.  */
-  scn = NULL;
-  cnt = 1;
-  while ((scn = elf_nextscn (elf, scn)) != NULL)
-    {
-      /* This should always be true (i.e., there should not be any
-	 holes in the numbering).  */
-      elf_assert (elf_ndxscn (scn) == cnt);
-
-      shdr_info[cnt].scn = scn;
-
-      /* Get the header.  */
-      if (gelf_getshdr (scn, &shdr_info[cnt].shdr) == NULL)
-	INTERNAL_ERROR (fname);
-
-      /* Normally (in non-ET_REL files) we see all allocated sections first,
-	 then all non-allocated.  */
-      if ((shdr_info[cnt].shdr.sh_flags & SHF_ALLOC) == 0)
-	seen_unallocated = true;
-      else
-	{
-	  if (seen_unallocated && seen_allocated)
-	    mixed_allocated_unallocated = true;
-	  seen_allocated = true;
-	}
-
-      /* Get the name of the section.  */
-      shdr_info[cnt].name = elf_strptr (elf, shstrndx,
-					shdr_info[cnt].shdr.sh_name);
-      if (shdr_info[cnt].name == NULL)
-	{
-	illformed:
-	  error (0, 0, _("illformed file '%s'"), fname);
-	  goto fail_close;
-	}
-
-      /* Sanity check the user.  */
-      if (section_name_matches (remove_secs, shdr_info[cnt].name))
-	{
-	  if ((shdr_info[cnt].shdr.sh_flags & SHF_ALLOC) != 0)
-	    {
-	      error (0, 0,
-		     _("Cannot remove allocated section '%s'"),
-		     shdr_info[cnt].name);
-	      result = 1;
-	      goto fail_close;
-	    }
-
-	  if (section_name_matches (keep_secs, shdr_info[cnt].name))
-	    {
-	      error (0, 0,
-		     _("Cannot both keep and remove section '%s'"),
-		     shdr_info[cnt].name);
-	      result = 1;
-	      goto fail_close;
-	    }
-	}
-
-      /* Mark them as present but not yet investigated.  */
-      shdr_info[cnt].idx = 1;
-
-      /* Remember the shdr.sh_link value.  */
-      shdr_info[cnt].old_sh_link = shdr_info[cnt].shdr.sh_link;
-      if (shdr_info[cnt].old_sh_link >= shnum)
-	goto illformed;
-
-      /* Sections in files other than relocatable object files which
-	 not loaded can be freely moved by us.  In theory we can also
-	 freely move around allocated nobits sections.  But we don't
-	 to keep the layout of all allocated sections as similar as
-	 possible to the original file.  In relocatable object files
-	 everything can be moved.  */
-      if (phnum == 0
-	  || (shdr_info[cnt].shdr.sh_flags & SHF_ALLOC) == 0)
-	shdr_info[cnt].shdr.sh_offset = 0;
-
-      /* If this is an extended section index table store an
-	 appropriate reference.  */
-      if (unlikely (shdr_info[cnt].shdr.sh_type == SHT_SYMTAB_SHNDX))
-	{
-	  elf_assert (shdr_info[shdr_info[cnt].shdr.sh_link].symtab_idx == 0);
-	  shdr_info[shdr_info[cnt].shdr.sh_link].symtab_idx = cnt;
-	}
-      else if (unlikely (shdr_info[cnt].shdr.sh_type == SHT_GROUP))
-	{
-	  /* Cross-reference the sections contained in the section
-	     group.  */
-	  shdr_info[cnt].data = elf_getdata (shdr_info[cnt].scn, NULL);
-	  if (shdr_info[cnt].data == NULL
-	      || shdr_info[cnt].data->d_size < sizeof (Elf32_Word))
-	    INTERNAL_ERROR (fname);
-
-	  /* XXX Fix for unaligned access.  */
-	  Elf32_Word *grpref = (Elf32_Word *) shdr_info[cnt].data->d_buf;
-	  size_t inner;
-	  for (inner = 1;
-	       inner < shdr_info[cnt].data->d_size / sizeof (Elf32_Word);
-	       ++inner)
-	    {
-	      if (grpref[inner] < shnum)
-		shdr_info[grpref[inner]].group_idx = cnt;
-	      else
-		goto illformed;
-	    }
-
-	  if (inner == 1 || (inner == 2 && (grpref[0] & GRP_COMDAT) == 0))
-	    /* If the section group contains only one element and this
-	       is n COMDAT section we can drop it right away.  */
-	    shdr_info[cnt].idx = 0;
-	  else
-	    shdr_info[cnt].group_cnt = inner - 1;
-	}
-      else if (unlikely (shdr_info[cnt].shdr.sh_type == SHT_GNU_versym))
-	{
-	  elf_assert (shdr_info[shdr_info[cnt].shdr.sh_link].version_idx == 0);
-	  shdr_info[shdr_info[cnt].shdr.sh_link].version_idx = cnt;
-	}
-
-      /* If this section is part of a group make sure it is not
-	 discarded right away.  */
-      if ((shdr_info[cnt].shdr.sh_flags & SHF_GROUP) != 0)
-	{
-	  elf_assert (shdr_info[cnt].group_idx != 0);
-
-	  if (shdr_info[shdr_info[cnt].group_idx].idx == 0)
-	    {
-	      /* The section group section might be removed.
-		 Don't remove the SHF_GROUP flag.  The section is
-		 either also removed, in which case the flag doesn't matter.
-		 Or it moves with the group into the debug file, then
-		 it will be reconnected with the new group and should
-		 still have the flag set.  */
-	      shdr_info[cnt].group_idx = 0;
-	    }
-	}
-
-      /* Increment the counter.  */
-      ++cnt;
-    }
-
-  /* Now determine which sections can go away.  The general rule is that
-     all sections which are not used at runtime are stripped out.  But
-     there are a few exceptions:
-
-     - special sections named ".comment" and ".note" are kept
-     - OS or architecture specific sections are kept since we might not
-       know how to handle them
-     - if a section is referred to from a section which is not removed
-       in the sh_link or sh_info element it cannot be removed either
-     - the user might have explicitly said to remove or keep a section
-  */
-  for (cnt = 1; cnt < shnum; ++cnt)
-    /* Check whether the section can be removed.  Since we will create
-       a new .shstrtab assume it will be removed too.  */
-    if (remove_shdrs ? !(shdr_info[cnt].shdr.sh_flags & SHF_ALLOC)
-	: (ebl_section_strip_p (ebl, &shdr_info[cnt].shdr,
-				shdr_info[cnt].name, remove_comment,
-				remove_debug)
-	   || cnt == shstrndx
-	   || section_name_matches (remove_secs, shdr_info[cnt].name)))
-      {
-	/* The user might want to explicitly keep this one.  */
-	if (section_name_matches (keep_secs, shdr_info[cnt].name))
-	  continue;
-
-	/* For now assume this section will be removed.  */
-	shdr_info[cnt].idx = 0;
-
-	idx = shdr_info[cnt].group_idx;
-	while (idx != 0)
-	  {
-	    /* The section group data is already loaded.  */
-	    elf_assert (shdr_info[idx].data != NULL
-			&& shdr_info[idx].data->d_buf != NULL
-			&& shdr_info[idx].data->d_size >= sizeof (Elf32_Word));
-
-	    /* If the references section group is a normal section
-	       group and has one element remaining, or if it is an
-	       empty COMDAT section group it is removed.  */
-	    bool is_comdat = (((Elf32_Word *) shdr_info[idx].data->d_buf)[0]
-			      & GRP_COMDAT) != 0;
-
-	    --shdr_info[idx].group_cnt;
-	    if ((!is_comdat && shdr_info[idx].group_cnt == 1)
-		|| (is_comdat && shdr_info[idx].group_cnt == 0))
-	      {
-		shdr_info[idx].idx = 0;
-		/* Continue recursively.  */
-		idx = shdr_info[idx].group_idx;
-	      }
-	    else
-	      break;
-	  }
-      }
-
-  /* Mark the SHT_NULL section as handled.  */
-  shdr_info[0].idx = 2;
-
-
-  /* Handle exceptions: section groups and cross-references.  We might
-     have to repeat this a few times since the resetting of the flag
-     might propagate.  */
-  do
-    {
-      changes = false;
-
-      for (cnt = 1; cnt < shnum; ++cnt)
-	{
-	  if (shdr_info[cnt].idx == 0)
-	    {
-	      /* If a relocation section is marked as being removed make
-		 sure the section it is relocating is removed, too.  */
-	      if (shdr_info[cnt].shdr.sh_type == SHT_REL
-		   || shdr_info[cnt].shdr.sh_type == SHT_RELA)
-		{
-		  if (shdr_info[cnt].shdr.sh_info >= shnum)
-		    goto illformed;
-		  else if (shdr_info[shdr_info[cnt].shdr.sh_info].idx != 0)
-		    shdr_info[cnt].idx = 1;
-		}
-
-	      /* If a group section is marked as being removed make
-		 sure all the sections it contains are being removed, too.  */
-	      if (shdr_info[cnt].shdr.sh_type == SHT_GROUP)
-		{
-		  Elf32_Word *grpref;
-		  grpref = (Elf32_Word *) shdr_info[cnt].data->d_buf;
-		  for (size_t in = 1;
-		       in < shdr_info[cnt].data->d_size / sizeof (Elf32_Word);
-		       ++in)
-		    if (grpref[in] < shnum)
-		      {
-			if (shdr_info[grpref[in]].idx != 0)
-			  {
-			    shdr_info[cnt].idx = 1;
-			    break;
-			  }
-		      }
-		    else
-		      goto illformed;
-		}
-	    }
-
-	  if (shdr_info[cnt].idx == 1)
-	    {
-	      /* The content of symbol tables we don't remove must not
-		 reference any section which we do remove.  Otherwise
-		 we cannot remove the section.  */
-	      if (debug_fname != NULL
-		  && shdr_info[cnt].debug_data == NULL
-		  && (shdr_info[cnt].shdr.sh_type == SHT_DYNSYM
-		      || shdr_info[cnt].shdr.sh_type == SHT_SYMTAB))
-		{
-		  /* Make sure the data is loaded.  */
-		  if (shdr_info[cnt].data == NULL)
-		    {
-		      shdr_info[cnt].data
-			= elf_getdata (shdr_info[cnt].scn, NULL);
-		      if (shdr_info[cnt].data == NULL)
-			INTERNAL_ERROR (fname);
-		    }
-		  Elf_Data *symdata = shdr_info[cnt].data;
-
-		  /* If there is an extended section index table load it
-		     as well.  */
-		  if (shdr_info[cnt].symtab_idx != 0
-		      && shdr_info[shdr_info[cnt].symtab_idx].data == NULL)
-		    {
-		      elf_assert (shdr_info[cnt].shdr.sh_type == SHT_SYMTAB);
-
-		      shdr_info[shdr_info[cnt].symtab_idx].data
-			= elf_getdata (shdr_info[shdr_info[cnt].symtab_idx].scn,
-				       NULL);
-		      if (shdr_info[shdr_info[cnt].symtab_idx].data == NULL)
-			INTERNAL_ERROR (fname);
-		    }
-		  Elf_Data *xndxdata
-		    = shdr_info[shdr_info[cnt].symtab_idx].data;
-
-		  /* Go through all symbols and make sure the section they
-		     reference is not removed.  */
-		  size_t elsize = gelf_fsize (elf, ELF_T_SYM, 1, EV_CURRENT);
-
-		  for (size_t inner = 0;
-		       inner < shdr_info[cnt].data->d_size / elsize;
-		       ++inner)
-		    {
-		      GElf_Sym sym_mem;
-		      Elf32_Word xndx;
-		      GElf_Sym *sym = gelf_getsymshndx (symdata, xndxdata,
-							inner, &sym_mem,
-							&xndx);
-		      if (sym == NULL)
-			INTERNAL_ERROR (fname);
-
-		      size_t scnidx = sym->st_shndx;
-		      if (scnidx == SHN_UNDEF || scnidx >= shnum
-			  || (scnidx >= SHN_LORESERVE
-			      && scnidx <= SHN_HIRESERVE
-			      && scnidx != SHN_XINDEX)
-			  /* Don't count in the section symbols.  */
-			  || GELF_ST_TYPE (sym->st_info) == STT_SECTION)
-			/* This is no section index, leave it alone.  */
-			continue;
-		      else if (scnidx == SHN_XINDEX)
-			scnidx = xndx;
-
-		      if (scnidx >= shnum)
-			goto illformed;
-
-		      if (shdr_info[scnidx].idx == 0)
-			/* This symbol table has a real symbol in
-			   a discarded section.  So preserve the
-			   original table in the debug file.  Unless
-			   it is a redundant data marker to a debug
-			   (data only) section.  */
-			if (! (ebl_section_strip_p (ebl,
-						    &shdr_info[scnidx].shdr,
-						    shdr_info[scnidx].name,
-						    remove_comment,
-						    remove_debug)
-			       && ebl_data_marker_symbol (ebl, sym,
-					elf_strptr (elf,
-						    shdr_info[cnt].shdr.sh_link,
-						    sym->st_name))))
-			  shdr_info[cnt].debug_data = symdata;
-		    }
-		}
-
-	      /* Cross referencing happens:
-		 - for the cases the ELF specification says.  That are
-		   + SHT_DYNAMIC in sh_link to string table
-		   + SHT_HASH in sh_link to symbol table
-		   + SHT_REL and SHT_RELA in sh_link to symbol table
-		   + SHT_SYMTAB and SHT_DYNSYM in sh_link to string table
-		   + SHT_GROUP in sh_link to symbol table
-		   + SHT_SYMTAB_SHNDX in sh_link to symbol table
-		   Other (OS or architecture-specific) sections might as
-		   well use this field so we process it unconditionally.
-		 - references inside section groups
-		 - specially marked references in sh_info if the SHF_INFO_LINK
-		 flag is set
-	      */
-
-	      if (shdr_info[shdr_info[cnt].shdr.sh_link].idx == 0)
-		{
-		  shdr_info[shdr_info[cnt].shdr.sh_link].idx = 1;
-		  changes |= shdr_info[cnt].shdr.sh_link < cnt;
-		}
-
-	      /* Handle references through sh_info.  */
-	      if (SH_INFO_LINK_P (&shdr_info[cnt].shdr))
-		{
-		  if (shdr_info[cnt].shdr.sh_info >= shnum)
-		    goto illformed;
-		  else if ( shdr_info[shdr_info[cnt].shdr.sh_info].idx == 0)
-		    {
-		      shdr_info[shdr_info[cnt].shdr.sh_info].idx = 1;
-		      changes |= shdr_info[cnt].shdr.sh_info < cnt;
-		    }
-		}
-
-	      /* Mark the section as investigated.  */
-	      shdr_info[cnt].idx = 2;
-	    }
-
-	  if (debug_fname != NULL
-	      && (shdr_info[cnt].idx == 0 || shdr_info[cnt].debug_data != NULL))
-	    {
-	      /* This section is being preserved in the debug file.
-		 Sections it refers to must be preserved there too.
-
-		 In this pass we mark sections to be preserved in both
-		 files by setting the .debug_data pointer to the original
-		 file's .data pointer.  Below, we'll copy the section
-		 contents.  */
-	      size_t shdr_indices[2] = { shdr_info[cnt].shdr.sh_link, 0 };
-	      int n = 1;
-
-	      if (SH_INFO_LINK_P (&shdr_info[cnt].shdr))
-		{
-		  shdr_indices[1] = shdr_info[cnt].shdr.sh_info;
-		  n++;
-		}
-
-	      for (int j = 0; j < n; j++)
-		{
-		  size_t i = shdr_indices[j];
-		  if (i != 0 && i < shnum + 2 && shdr_info[i].idx != 0
-		      && shdr_info[i].debug_data == NULL)
-		    {
-		      if (shdr_info[i].data == NULL)
-			shdr_info[i].data = elf_getdata (shdr_info[i].scn, NULL);
-		      if (shdr_info[i].data == NULL)
-			INTERNAL_ERROR (fname);
-
-		      shdr_info[i].debug_data = shdr_info[i].data;
-		      changes |= i < cnt;
-		    }
-		}
-	    }
-	}
-    }
-  while (changes);
-
-  /* Copy the removed sections to the debug output file.
-     The ones that are not removed in the stripped file are SHT_NOBITS.  */
-  if (debug_fname != NULL)
-    {
-      for (cnt = 1; cnt < shnum; ++cnt)
-	{
-	  scn = elf_newscn (debugelf);
-	  if (scn == NULL)
-	    {
-	      cleanup_debug ();
-	      error (EXIT_FAILURE, 0,
-		     _("while generating output file: %s"),
-		     elf_errmsg (-1));
-	    }
-
-	  bool discard_section = (shdr_info[cnt].idx > 0
-				  && shdr_info[cnt].debug_data == NULL
-				  && shdr_info[cnt].shdr.sh_type != SHT_NOTE
-				  && shdr_info[cnt].shdr.sh_type != SHT_GROUP
-				  && cnt != shstrndx);
-
-	  /* Set the section header in the new file.  */
-	  GElf_Shdr debugshdr = shdr_info[cnt].shdr;
-	  if (discard_section)
-	    debugshdr.sh_type = SHT_NOBITS;
-
-	  if (unlikely (gelf_update_shdr (scn, &debugshdr) == 0))
-	    /* There cannot be any overflows.  */
-	    INTERNAL_ERROR (fname);
-
-	  /* Get the data from the old file if necessary. */
-	  if (shdr_info[cnt].data == NULL)
-	    {
-	      shdr_info[cnt].data = elf_getdata (shdr_info[cnt].scn, NULL);
-	      if (shdr_info[cnt].data == NULL)
-		INTERNAL_ERROR (fname);
-	    }
-
-	  /* Set the data.  This is done by copying from the old file.  */
-	  Elf_Data *debugdata = elf_newdata (scn);
-	  if (debugdata == NULL)
-	    INTERNAL_ERROR (fname);
-
-	  /* Copy the structure.  This data may be modified in place
-	     before we write out the file.  */
-	  *debugdata = *shdr_info[cnt].data;
-	  if (discard_section)
-	    debugdata->d_buf = NULL;
-	  else if (shdr_info[cnt].debug_data != NULL
-		   || shdr_info[cnt].shdr.sh_type == SHT_GROUP)
-	    {
-	      /* Copy the original data before it gets modified.  */
-	      shdr_info[cnt].debug_data = debugdata;
-	      if (debugdata->d_buf == NULL)
-		INTERNAL_ERROR (fname);
-	      debugdata->d_buf = memcpy (xmalloc (debugdata->d_size),
-					 debugdata->d_buf, debugdata->d_size);
-	    }
-	}
-
-      /* Finish the ELF header.  Fill in the fields not handled by
-	 libelf from the old file.  */
-      debugehdr = gelf_getehdr (debugelf, &debugehdr_mem);
-      if (debugehdr == NULL)
-	INTERNAL_ERROR (fname);
-
-      memcpy (debugehdr->e_ident, ehdr->e_ident, EI_NIDENT);
-      debugehdr->e_type = ehdr->e_type;
-      debugehdr->e_machine = ehdr->e_machine;
-      debugehdr->e_version = ehdr->e_version;
-      debugehdr->e_entry = ehdr->e_entry;
-      debugehdr->e_flags = ehdr->e_flags;
-
-      if (unlikely (gelf_update_ehdr (debugelf, debugehdr) == 0))
-	{
-	  error (0, 0, _("%s: error while updating ELF header: %s"),
-		 debug_fname, elf_errmsg (-1));
-	  result = 1;
-	  goto fail_close;
-	}
-
-      size_t shdrstrndx;
-      if (elf_getshdrstrndx (elf, &shdrstrndx) < 0)
-	{
-	  error (0, 0, _("%s: error while getting shdrstrndx: %s"),
-		 fname, elf_errmsg (-1));
-	  result = 1;
-	  goto fail_close;
-	}
-
-      if (update_shdrstrndx (debugelf, shdrstrndx) != 0)
-	{
-	  error (0, 0, _("%s: error updating shdrstrndx: %s"),
-		 debug_fname, elf_errmsg (-1));
-	  result = 1;
-	  goto fail_close;
-	}
-    }
-
-  /* Although we always create a new section header string table we
-     don't explicitly mark the existing one as unused.  It can still
-     be used through a symbol table section we are keeping.  If not it
-     will already be marked as unused.  */
-
-  /* We need a string table for the section headers.  */
-  shst = dwelf_strtab_init (true);
-  if (shst == NULL)
-    {
-      cleanup_debug ();
-      error (EXIT_FAILURE, errno, _("while preparing output for '%s'"),
-	     output_fname ?: fname);
-    }
-
-  /* Assign new section numbers.  */
-  shdr_info[0].idx = 0;
-  for (cnt = idx = 1; cnt < shnum; ++cnt)
-    if (shdr_info[cnt].idx > 0)
-      {
-	shdr_info[cnt].idx = idx++;
-
-	/* Create a new section.  */
-	shdr_info[cnt].newscn = elf_newscn (newelf);
-	if (shdr_info[cnt].newscn == NULL)
-	  {
-	    cleanup_debug ();
-	    error (EXIT_FAILURE, 0,
-		   _("while generating output file: %s"),
-		   elf_errmsg (-1));
-	  }
-
-	elf_assert (elf_ndxscn (shdr_info[cnt].newscn) == shdr_info[cnt].idx);
-
-	/* Add this name to the section header string table.  */
-	shdr_info[cnt].se = dwelf_strtab_add (shst, shdr_info[cnt].name);
-      }
-
-  /* Test whether we are doing anything at all.  Either all removable
-     sections are already gone.  Or the only section we would remove is
-     the .shstrtab section which we would add again.  */
-  bool removing_sections = !(cnt == idx
-			     || (cnt == idx + 1
-				 && shdr_info[shstrndx].idx == 0));
-  if (output_fname == NULL && !removing_sections)
-      goto fail_close;
-
-  /* Create the reference to the file with the debug info (if any).  */
-  if (debug_fname != NULL && !remove_shdrs && removing_sections)
-    {
-      /* Add the section header string table section name.  */
-      shdr_info[cnt].se = dwelf_strtab_add_len (shst, ".gnu_debuglink", 15);
-      shdr_info[cnt].idx = idx++;
-
-      /* Create the section header.  */
-      shdr_info[cnt].shdr.sh_type = SHT_PROGBITS;
-      shdr_info[cnt].shdr.sh_flags = 0;
-      shdr_info[cnt].shdr.sh_addr = 0;
-      shdr_info[cnt].shdr.sh_link = SHN_UNDEF;
-      shdr_info[cnt].shdr.sh_info = SHN_UNDEF;
-      shdr_info[cnt].shdr.sh_entsize = 0;
-      shdr_info[cnt].shdr.sh_addralign = 4;
-      /* We set the offset to zero here.  Before we write the ELF file the
-	 field must have the correct value.  This is done in the final
-	 loop over all section.  Then we have all the information needed.  */
-      shdr_info[cnt].shdr.sh_offset = 0;
-
-      /* Create the section.  */
-      shdr_info[cnt].newscn = elf_newscn (newelf);
-      if (shdr_info[cnt].newscn == NULL)
-	{
-	  cleanup_debug ();
-	  error (EXIT_FAILURE, 0,
-		 _("while create section header section: %s"),
-		 elf_errmsg (-1));
-	}
-      elf_assert (elf_ndxscn (shdr_info[cnt].newscn) == shdr_info[cnt].idx);
-
-      shdr_info[cnt].data = elf_newdata (shdr_info[cnt].newscn);
-      if (shdr_info[cnt].data == NULL)
-	{
-	  cleanup_debug ();
-	  error (EXIT_FAILURE, 0, _("cannot allocate section data: %s"),
-		 elf_errmsg (-1));
-	}
-
-      char *debug_basename = basename (debug_fname_embed ?: debug_fname);
-      off_t crc_offset = strlen (debug_basename) + 1;
-      /* Align to 4 byte boundary */
-      crc_offset = ((crc_offset - 1) & ~3) + 4;
-
-      shdr_info[cnt].data->d_align = 4;
-      shdr_info[cnt].shdr.sh_size = shdr_info[cnt].data->d_size
-	= crc_offset + 4;
-      debuglink_buf = xcalloc (1, shdr_info[cnt].data->d_size);
-      shdr_info[cnt].data->d_buf = debuglink_buf;
-
-      strcpy (shdr_info[cnt].data->d_buf, debug_basename);
-
-      /* Cache this Elf_Data describing the CRC32 word in the section.
-	 We'll fill this in when we have written the debug file.  */
-      debuglink_crc_data = *shdr_info[cnt].data;
-      debuglink_crc_data.d_buf = ((char *) debuglink_crc_data.d_buf
-				  + crc_offset);
-      debuglink_crc_data.d_size = 4;
-
-      /* One more section done.  */
-      ++cnt;
-    }
-
-  /* Index of the section header table in the shdr_info array.  */
-  shdridx = cnt;
-
-  /* Add the section header string table section name.  */
-  shdr_info[cnt].se = dwelf_strtab_add_len (shst, ".shstrtab", 10);
-  shdr_info[cnt].idx = idx;
-
-  /* Create the section header.  */
-  shdr_info[cnt].shdr.sh_type = SHT_STRTAB;
-  shdr_info[cnt].shdr.sh_flags = 0;
-  shdr_info[cnt].shdr.sh_addr = 0;
-  shdr_info[cnt].shdr.sh_link = SHN_UNDEF;
-  shdr_info[cnt].shdr.sh_info = SHN_UNDEF;
-  shdr_info[cnt].shdr.sh_entsize = 0;
-  /* We set the offset to zero here.  Before we write the ELF file the
-     field must have the correct value.  This is done in the final
-     loop over all section.  Then we have all the information needed.  */
-  shdr_info[cnt].shdr.sh_offset = 0;
-  shdr_info[cnt].shdr.sh_addralign = 1;
-
-  /* Create the section.  */
-  shdr_info[cnt].newscn = elf_newscn (newelf);
-  if (shdr_info[cnt].newscn == NULL)
-    {
-      cleanup_debug ();
-      error (EXIT_FAILURE, 0,
-	     _("while create section header section: %s"),
-	     elf_errmsg (-1));
-    }
-  elf_assert (elf_ndxscn (shdr_info[cnt].newscn) == idx);
-
-  /* Finalize the string table and fill in the correct indices in the
-     section headers.  */
-  shstrtab_data = elf_newdata (shdr_info[cnt].newscn);
-  if (shstrtab_data == NULL)
-    {
-      cleanup_debug ();
-      error (EXIT_FAILURE, 0,
-	     _("while create section header string table: %s"),
-	     elf_errmsg (-1));
-    }
-  if (dwelf_strtab_finalize (shst, shstrtab_data) == NULL)
-    {
-      cleanup_debug ();
-      error (EXIT_FAILURE, 0,
-	     _("no memory to create section header string table"));
-    }
-
-  /* We have to set the section size.  */
-  shdr_info[cnt].shdr.sh_size = shstrtab_data->d_size;
-
-  /* Update the section information.  */
-  GElf_Off lastoffset = 0;
-  for (cnt = 1; cnt <= shdridx; ++cnt)
-    if (shdr_info[cnt].idx > 0)
-      {
-	Elf_Data *newdata;
-
-	scn = elf_getscn (newelf, shdr_info[cnt].idx);
-	elf_assert (scn != NULL);
-
-	/* Update the name.  */
-	shdr_info[cnt].shdr.sh_name = dwelf_strent_off (shdr_info[cnt].se);
-
-	/* Update the section header from the input file.  Some fields
-	   might be section indices which now have to be adjusted.  Keep
-	   the index to the "current" sh_link in case we need it to lookup
-	   symbol table names.  */
-	size_t sh_link = shdr_info[cnt].shdr.sh_link;
-	if (shdr_info[cnt].shdr.sh_link != 0)
-	  shdr_info[cnt].shdr.sh_link =
-	    shdr_info[shdr_info[cnt].shdr.sh_link].idx;
-
-	if (shdr_info[cnt].shdr.sh_type == SHT_GROUP)
-	  {
-	    elf_assert (shdr_info[cnt].data != NULL
-			&& shdr_info[cnt].data->d_buf != NULL);
-
-	    Elf32_Word *grpref = (Elf32_Word *) shdr_info[cnt].data->d_buf;
-	    /* First word is the section group flag.
-	       Followed by section indexes, that need to be renumbered.  */
-	    for (size_t inner = 1;
-		 inner < shdr_info[cnt].data->d_size / sizeof (Elf32_Word);
-		 ++inner)
-	      if (grpref[inner] < shnum)
-		grpref[inner] = shdr_info[grpref[inner]].idx;
-	      else
-		goto illformed;
-	  }
-
-	/* Handle the SHT_REL, SHT_RELA, and SHF_INFO_LINK flag.  */
-	if (SH_INFO_LINK_P (&shdr_info[cnt].shdr))
-	  shdr_info[cnt].shdr.sh_info =
-	    shdr_info[shdr_info[cnt].shdr.sh_info].idx;
-
-	/* Get the data from the old file if necessary.  We already
-	   created the data for the section header string table.  */
-	if (cnt < shnum)
-	  {
-	    if (shdr_info[cnt].data == NULL)
-	      {
-		shdr_info[cnt].data = elf_getdata (shdr_info[cnt].scn, NULL);
-		if (shdr_info[cnt].data == NULL)
-		  INTERNAL_ERROR (fname);
-	      }
-
-	    /* Set the data.  This is done by copying from the old file.  */
-	    newdata = elf_newdata (scn);
-	    if (newdata == NULL)
-	      INTERNAL_ERROR (fname);
-
-	    /* Copy the structure.  */
-	    *newdata = *shdr_info[cnt].data;
-
-	    /* We know the size.  */
-	    shdr_info[cnt].shdr.sh_size = shdr_info[cnt].data->d_size;
-
-	    /* We have to adjust symbol tables.  The st_shndx member might
-	       have to be updated.  */
-	    if (shdr_info[cnt].shdr.sh_type == SHT_DYNSYM
-		|| shdr_info[cnt].shdr.sh_type == SHT_SYMTAB)
-	      {
-		Elf_Data *versiondata = NULL;
-		Elf_Data *shndxdata = NULL;
-
-		size_t elsize = gelf_fsize (elf, ELF_T_SYM, 1, EV_CURRENT);
-
-		if (shdr_info[cnt].symtab_idx != 0)
-		  {
-		    elf_assert (shdr_info[cnt].shdr.sh_type == SHT_SYMTAB_SHNDX);
-		    /* This section has extended section information.
-		       We have to modify that information, too.  */
-		    shndxdata = elf_getdata (shdr_info[shdr_info[cnt].symtab_idx].scn,
-					     NULL);
-
-		    elf_assert (shndxdata != NULL
-				&& shndxdata->d_buf != NULL
-				&& ((shndxdata->d_size / sizeof (Elf32_Word))
-				    >= shdr_info[cnt].data->d_size / elsize));
-		  }
-
-		if (shdr_info[cnt].version_idx != 0)
-		  {
-		    elf_assert (shdr_info[cnt].shdr.sh_type == SHT_DYNSYM);
-		    /* This section has associated version
-		       information.  We have to modify that
-		       information, too.  */
-		    versiondata = elf_getdata (shdr_info[shdr_info[cnt].version_idx].scn,
-					       NULL);
-
-		    elf_assert (versiondata != NULL
-				&& versiondata->d_buf != NULL
-				&& ((versiondata->d_size / sizeof (GElf_Versym))
-				    >= shdr_info[cnt].data->d_size / elsize));
-		  }
-
-		shdr_info[cnt].newsymidx
-		  = xcalloc (shdr_info[cnt].data->d_size / elsize,
-			     sizeof (Elf32_Word));
-
-		bool last_was_local = true;
-		size_t destidx;
-		size_t inner;
-		for (destidx = inner = 1;
-		     inner < shdr_info[cnt].data->d_size / elsize;
-		     ++inner)
-		  {
-		    Elf32_Word sec;
-		    GElf_Sym sym_mem;
-		    Elf32_Word xshndx;
-		    GElf_Sym *sym = gelf_getsymshndx (shdr_info[cnt].data,
-						      shndxdata, inner,
-						      &sym_mem, &xshndx);
-		    if (sym == NULL)
-		      INTERNAL_ERROR (fname);
-
-		    if (sym->st_shndx == SHN_UNDEF
-			|| (sym->st_shndx >= SHN_LORESERVE
-			    && sym->st_shndx != SHN_XINDEX))
-		      {
-			/* This is no section index, leave it alone
-			   unless it is moved.  */
-			if (destidx != inner
-			    && gelf_update_symshndx (shdr_info[cnt].data,
-						     shndxdata,
-						     destidx, sym,
-						     xshndx) == 0)
-			  INTERNAL_ERROR (fname);
-
-			shdr_info[cnt].newsymidx[inner] = destidx++;
-
-			if (last_was_local
-			    && GELF_ST_BIND (sym->st_info) != STB_LOCAL)
-			  {
-			    last_was_local = false;
-			    shdr_info[cnt].shdr.sh_info = destidx - 1;
-			  }
-
-			continue;
-		      }
-
-		    /* Get the full section index, if necessary from the
-		       XINDEX table.  */
-		    if (sym->st_shndx == SHN_XINDEX)
-		      elf_assert (shndxdata != NULL
-				  && shndxdata->d_buf != NULL);
-		    size_t sidx = (sym->st_shndx != SHN_XINDEX
-				   ? sym->st_shndx : xshndx);
-		    elf_assert (sidx < shnum);
-		    sec = shdr_info[sidx].idx;
-
-		    if (sec != 0)
-		      {
-			GElf_Section nshndx;
-			Elf32_Word nxshndx;
-
-			if (sec < SHN_LORESERVE)
-			  {
-			    nshndx = sec;
-			    nxshndx = 0;
-			  }
-			else
-			  {
-			    nshndx = SHN_XINDEX;
-			    nxshndx = sec;
-			  }
-
-			elf_assert (sec < SHN_LORESERVE || shndxdata != NULL);
-
-			if ((inner != destidx || nshndx != sym->st_shndx
-			     || (shndxdata != NULL && nxshndx != xshndx))
-			    && (sym->st_shndx = nshndx,
-				gelf_update_symshndx (shdr_info[cnt].data,
-						      shndxdata,
-						      destidx, sym,
-						      nxshndx) == 0))
-			  INTERNAL_ERROR (fname);
-
-			shdr_info[cnt].newsymidx[inner] = destidx++;
-
-			if (last_was_local
-			    && GELF_ST_BIND (sym->st_info) != STB_LOCAL)
-			  {
-			    last_was_local = false;
-			    shdr_info[cnt].shdr.sh_info = destidx - 1;
-			  }
-		      }
-		    else if ((shdr_info[cnt].shdr.sh_flags & SHF_ALLOC) != 0
-			     && GELF_ST_TYPE (sym->st_info) != STT_SECTION
-			     && shdr_info[sidx].shdr.sh_type != SHT_GROUP)
-		      {
-			/* Removing a real symbol from an allocated
-			   symbol table is hard and probably a
-			   mistake.  Really removing it means
-			   rewriting the dynamic segment and hash
-			   sections.  Just warn and set the symbol
-			   section to UNDEF.  */
-			error (0, 0,
-			       _("Cannot remove symbol [%zd] from allocated symbol table [%zd]"), inner, cnt);
-			sym->st_shndx = SHN_UNDEF;
-			if (gelf_update_sym (shdr_info[cnt].data, destidx,
-					     sym) == 0)
-			  INTERNAL_ERROR (fname);
-			shdr_info[cnt].newsymidx[inner] = destidx++;
-		      }
-		    else if (debug_fname != NULL
-			     && shdr_info[cnt].debug_data == NULL)
-		      /* The symbol points to a section that is discarded
-			 but isn't preserved in the debug file. Check that
-			 this is a section or group signature symbol
-			 for a section which has been removed.  Or a special
-			 data marker symbol to a debug section.  */
-		      {
-			elf_assert (GELF_ST_TYPE (sym->st_info) == STT_SECTION
-				    || ((shdr_info[sidx].shdr.sh_type
-					 == SHT_GROUP)
-					&& (shdr_info[sidx].shdr.sh_info
-					    == inner))
-				    || ebl_data_marker_symbol (ebl, sym,
-						elf_strptr (elf, sh_link,
-							    sym->st_name)));
-		      }
-		  }
-
-		if (destidx != inner)
-		  {
-		    /* The size of the symbol table changed.  */
-		    shdr_info[cnt].shdr.sh_size = newdata->d_size
-		      = destidx * elsize;
-		    any_symtab_changes = true;
-		  }
-		else
-		  {
-		    /* The symbol table didn't really change.  */
-		    free (shdr_info[cnt].newsymidx);
-		    shdr_info[cnt].newsymidx = NULL;
-		  }
-	      }
-	  }
-
-	/* If we have to, compute the offset of the section.
-	   If allocate and unallocated sections are mixed, we only update
-	   the allocated ones now.  The unallocated ones come second.  */
-	if (! mixed_allocated_unallocated
-	    || (shdr_info[cnt].shdr.sh_flags & SHF_ALLOC) != 0)
-	  {
-	    if (shdr_info[cnt].shdr.sh_offset == 0)
-	      shdr_info[cnt].shdr.sh_offset
-		= ((lastoffset + shdr_info[cnt].shdr.sh_addralign - 1)
-		   & ~((GElf_Off) (shdr_info[cnt].shdr.sh_addralign - 1)));
-
-	    /* Set the section header in the new file.  */
-	    if (unlikely (gelf_update_shdr (scn, &shdr_info[cnt].shdr) == 0))
-	      /* There cannot be any overflows.  */
-	      INTERNAL_ERROR (fname);
-
-	    /* Remember the last section written so far.  */
-	    GElf_Off filesz = (shdr_info[cnt].shdr.sh_type != SHT_NOBITS
-			       ? shdr_info[cnt].shdr.sh_size : 0);
-	    if (lastoffset < shdr_info[cnt].shdr.sh_offset + filesz)
-	      lastoffset = shdr_info[cnt].shdr.sh_offset + filesz;
-	  }
-      }
-
-  /* We might have to update the unallocated sections after we done the
-     allocated ones.  lastoffset is set to right after the last allocated
-     section.  */
-  if (mixed_allocated_unallocated)
-    for (cnt = 1; cnt <= shdridx; ++cnt)
-      if (shdr_info[cnt].idx > 0)
-	{
-	  scn = elf_getscn (newelf, shdr_info[cnt].idx);
-	  if ((shdr_info[cnt].shdr.sh_flags & SHF_ALLOC) == 0)
-	    {
-	      if (shdr_info[cnt].shdr.sh_offset == 0)
-		shdr_info[cnt].shdr.sh_offset
-		  = ((lastoffset + shdr_info[cnt].shdr.sh_addralign - 1)
-		     & ~((GElf_Off) (shdr_info[cnt].shdr.sh_addralign - 1)));
-
-	      /* Set the section header in the new file.  */
-	      if (unlikely (gelf_update_shdr (scn, &shdr_info[cnt].shdr) == 0))
-		/* There cannot be any overflows.  */
-		INTERNAL_ERROR (fname);
-
-	      /* Remember the last section written so far.  */
-	      GElf_Off filesz = (shdr_info[cnt].shdr.sh_type != SHT_NOBITS
-				 ? shdr_info[cnt].shdr.sh_size : 0);
-	      if (lastoffset < shdr_info[cnt].shdr.sh_offset + filesz)
-		lastoffset = shdr_info[cnt].shdr.sh_offset + filesz;
-	    }
-	}
-
-  /* Adjust symbol references if symbol tables changed.  */
-  if (any_symtab_changes)
-    /* Find all relocation sections which use this symbol table.  */
-    for (cnt = 1; cnt <= shdridx; ++cnt)
-      {
-	struct shdr_info *info = &shdr_info[cnt];
-	if (info->idx == 0 && debug_fname == NULL)
-	  /* Ignore sections which are discarded.  When we are saving a
-	     relocation section in a separate debug file, we must fix up
-	     the symbol table references.  */
-	  continue;
-
-	const Elf32_Word symtabidx = info->old_sh_link;
-	elf_assert (symtabidx < shnum + 2);
-	const Elf32_Word *const newsymidx = shdr_info[symtabidx].newsymidx;
-
-	/* If the symbol table hasn't changed, do not do anything.  */
-	if (newsymidx == NULL)
-	  continue;
-
-	/* If the symbol table is not discarded, but additionally
-	   duplicated in the separate debug file and this section
-	   is discarded, don't adjust anything.  */
-	if (info->idx == 0 && shdr_info[symtabidx].debug_data != NULL)
-	  continue;
-
-	switch (info->shdr.sh_type)
-	  {
-	  case SHT_REL:
-	  case SHT_RELA:
-	    scn = (info->idx == 0
-		   ? elf_getscn (debugelf, cnt)
-		   : elf_getscn (newelf, info->idx));
-	    Elf_Data *d = elf_getdata (scn, NULL);
-	    elf_assert (d != NULL && d->d_buf != NULL
-			&& info->shdr.sh_entsize != 0);
-	    size_t nrels = (info->shdr.sh_size / info->shdr.sh_entsize);
-
-	    size_t symsize = gelf_fsize (elf, ELF_T_SYM, 1, EV_CURRENT);
-	    const Elf32_Word symidxn = (shdr_info[symtabidx].data->d_size
-					/ symsize);
-	    if (info->shdr.sh_type == SHT_REL)
-	      for (size_t relidx = 0; relidx < nrels; ++relidx)
-		{
-		  GElf_Rel rel_mem;
-		  if (gelf_getrel (d, relidx, &rel_mem) == NULL)
-		    INTERNAL_ERROR (fname);
-
-		  size_t symidx = GELF_R_SYM (rel_mem.r_info);
-		  elf_assert (symidx < symidxn);
-		  if (newsymidx[symidx] != symidx)
-		    {
-		      rel_mem.r_info
-			= GELF_R_INFO (newsymidx[symidx],
-				       GELF_R_TYPE (rel_mem.r_info));
-
-		      if (gelf_update_rel (d, relidx, &rel_mem) == 0)
-			INTERNAL_ERROR (fname);
-		    }
-		}
-	    else
-	      for (size_t relidx = 0; relidx < nrels; ++relidx)
-		{
-		  GElf_Rela rel_mem;
-		  if (gelf_getrela (d, relidx, &rel_mem) == NULL)
-		    INTERNAL_ERROR (fname);
-
-		  size_t symidx = GELF_R_SYM (rel_mem.r_info);
-		  elf_assert (symidx < symidxn);
-		  if (newsymidx[symidx] != symidx)
-		    {
-		      rel_mem.r_info
-			= GELF_R_INFO (newsymidx[symidx],
-				       GELF_R_TYPE (rel_mem.r_info));
-
-		      if (gelf_update_rela (d, relidx, &rel_mem) == 0)
-			INTERNAL_ERROR (fname);
-		    }
-		}
-	    break;
-
-	  case SHT_HASH:
-	    /* We have to recompute the hash table.  */
-
-	    elf_assert (info->idx > 0);
-
-	    /* The hash section in the new file.  */
-	    scn = elf_getscn (newelf, info->idx);
-
-	    /* The symbol table data.  */
-	    Elf_Data *symd = elf_getdata (elf_getscn (newelf,
-						      shdr_info[symtabidx].idx),
-					  NULL);
-	    elf_assert (symd != NULL && symd->d_buf != NULL);
-
-	    /* The hash table data.  */
-	    Elf_Data *hashd = elf_getdata (scn, NULL);
-	    elf_assert (hashd != NULL && hashd->d_buf != NULL);
-
-	    if (info->shdr.sh_entsize == sizeof (Elf32_Word))
-	      {
-		/* Sane arches first.  */
-		elf_assert (hashd->d_size >= 2 * sizeof (Elf32_Word));
-		Elf32_Word *bucket = (Elf32_Word *) hashd->d_buf;
-
-		size_t strshndx = shdr_info[symtabidx].old_sh_link;
-		size_t elsize = gelf_fsize (elf, ELF_T_SYM, 1, EV_CURRENT);
-
-		Elf32_Word nchain = bucket[1];
-		Elf32_Word nbucket = bucket[0];
-		uint64_t used_buf = ((2ULL + nchain + nbucket)
-				     * sizeof (Elf32_Word));
-		elf_assert (used_buf <= hashd->d_size);
-
-		/* Adjust the nchain value.  The symbol table size
-		   changed.  We keep the same size for the bucket array.  */
-		bucket[1] = symd->d_size / elsize;
-		bucket += 2;
-		Elf32_Word *chain = bucket + nbucket;
-
-		/* New size of the section.  */
-		size_t n_size = ((2 + symd->d_size / elsize + nbucket)
-				 * sizeof (Elf32_Word));
-		elf_assert (n_size <= hashd->d_size);
-		hashd->d_size = n_size;
-		update_section_size (scn, hashd, debugelf, cnt, fname);
-
-		/* Clear the arrays.  */
-		memset (bucket, '\0',
-			(symd->d_size / elsize + nbucket)
-			* sizeof (Elf32_Word));
-
-		for (size_t inner = shdr_info[symtabidx].shdr.sh_info;
-		     inner < symd->d_size / elsize; ++inner)
-		  {
-		    GElf_Sym sym_mem;
-		    GElf_Sym *sym = gelf_getsym (symd, inner, &sym_mem);
-		    elf_assert (sym != NULL);
-
-		    const char *name = elf_strptr (elf, strshndx,
-						   sym->st_name);
-		    elf_assert (name != NULL && nbucket != 0);
-		    size_t hidx = elf_hash (name) % nbucket;
-
-		    if (bucket[hidx] == 0)
-		      bucket[hidx] = inner;
-		    else
-		      {
-			hidx = bucket[hidx];
-
-			while (chain[hidx] != 0 && chain[hidx] < nchain)
-			  hidx = chain[hidx];
-
-			chain[hidx] = inner;
-		      }
-		  }
-	      }
-	    else
-	      {
-		/* Alpha and S390 64-bit use 64-bit SHT_HASH entries.  */
-		elf_assert (info->shdr.sh_entsize == sizeof (Elf64_Xword));
-
-		Elf64_Xword *bucket = (Elf64_Xword *) hashd->d_buf;
-
-		size_t strshndx = shdr_info[symtabidx].old_sh_link;
-		size_t elsize = gelf_fsize (elf, ELF_T_SYM, 1, EV_CURRENT);
-
-		elf_assert (symd->d_size >= 2 * sizeof (Elf64_Xword));
-		Elf64_Xword nbucket = bucket[0];
-		Elf64_Xword nchain = bucket[1];
-		uint64_t maxwords = hashd->d_size / sizeof (Elf64_Xword);
-		elf_assert (maxwords >= 2
-			    && maxwords - 2 >= nbucket
-			    && maxwords - 2 - nbucket >= nchain);
-
-		/* Adjust the nchain value.  The symbol table size
-		   changed.  We keep the same size for the bucket array.  */
-		bucket[1] = symd->d_size / elsize;
-		bucket += 2;
-		Elf64_Xword *chain = bucket + nbucket;
-
-		/* New size of the section.  */
-		size_t n_size = ((2 + symd->d_size / elsize + nbucket)
-				 * sizeof (Elf64_Xword));
-		elf_assert (n_size <= hashd->d_size);
-		hashd->d_size = n_size;
-		update_section_size (scn, hashd, debugelf, cnt, fname);
-
-		/* Clear the arrays.  */
-		memset (bucket, '\0',
-			(symd->d_size / elsize + nbucket)
-			* sizeof (Elf64_Xword));
-
-		for (size_t inner = shdr_info[symtabidx].shdr.sh_info;
-		     inner < symd->d_size / elsize; ++inner)
-		  {
-		    GElf_Sym sym_mem;
-		    GElf_Sym *sym = gelf_getsym (symd, inner, &sym_mem);
-		    elf_assert (sym != NULL);
-
-		    const char *name = elf_strptr (elf, strshndx,
-						   sym->st_name);
-		    elf_assert (name != NULL && nbucket != 0);
-		    size_t hidx = elf_hash (name) % nbucket;
-
-		    if (bucket[hidx] == 0)
-		      bucket[hidx] = inner;
-		    else
-		      {
-			hidx = bucket[hidx];
-
-			while (chain[hidx] != 0 && chain[hidx] < nchain)
-			  hidx = chain[hidx];
-
-			chain[hidx] = inner;
-		      }
-		  }
-	      }
-	    break;
-
-	  case SHT_GNU_versym:
-	    /* If the symbol table changed we have to adjust the entries.  */
-	    elf_assert (info->idx > 0);
-
-	    /* The symbol version section in the new file.  */
-	    scn = elf_getscn (newelf, info->idx);
-
-	    /* The symbol table data.  */
-	    symd = elf_getdata (elf_getscn (newelf, shdr_info[symtabidx].idx),
-				NULL);
-	    elf_assert (symd != NULL && symd->d_buf != NULL);
-	    size_t symz = gelf_fsize (elf, ELF_T_SYM, 1, EV_CURRENT);
-	    const Elf32_Word syms = (shdr_info[symtabidx].data->d_size / symz);
-
-	    /* The version symbol data.  */
-	    Elf_Data *verd = elf_getdata (scn, NULL);
-	    elf_assert (verd != NULL && verd->d_buf != NULL);
-
-	    /* The symbol version array.  */
-	    GElf_Half *verstab = (GElf_Half *) verd->d_buf;
-
-	    /* Walk through the list and */
-	    size_t elsize = gelf_fsize (elf, verd->d_type, 1, EV_CURRENT);
-	    Elf32_Word vers = verd->d_size / elsize;
-	    for (size_t inner = 1; inner < vers && inner < syms; ++inner)
-	      if (newsymidx[inner] != 0 && newsymidx[inner] < vers)
-		/* Overwriting the same array works since the
-		   reordering can only move entries to lower indices
-		   in the array.  */
-		verstab[newsymidx[inner]] = verstab[inner];
-
-	    /* New size of the section.  */
-	    verd->d_size = gelf_fsize (newelf, verd->d_type,
-				       symd->d_size
-				       / gelf_fsize (elf, symd->d_type, 1,
-						     EV_CURRENT),
-				       EV_CURRENT);
-	    update_section_size (scn, verd, debugelf, cnt, fname);
-	    break;
-
-	  case SHT_GROUP:
-	    /* Yes, the symbol table changed.
-	       Update the section header of the section group.  */
-	    scn = elf_getscn (newelf, info->idx);
-	    GElf_Shdr shdr_mem;
-	    GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-	    elf_assert (shdr != NULL);
-
-	    size_t symsz = gelf_fsize (elf, ELF_T_SYM, 1, EV_CURRENT);
-	    const Elf32_Word symn = (shdr_info[symtabidx].data->d_size
-				     / symsz);
-	    elf_assert (shdr->sh_info < symn);
-	    shdr->sh_info = newsymidx[shdr->sh_info];
-
-	    (void) gelf_update_shdr (scn, shdr);
-	    break;
-	  }
-      }
-
-  /* Remove any relocations between debug sections in ET_REL
-     for the debug file when requested.  These relocations are always
-     zero based between the unallocated sections.  */
-  if (debug_fname != NULL && removing_sections
-      && reloc_debug && ehdr->e_type == ET_REL)
-    remove_debug_relocations (ebl, debugelf, ehdr, fname, shstrndx);
-
-  /* Now that we have done all adjustments to the data,
-     we can actually write out the debug file.  */
-  if (debug_fname != NULL && removing_sections)
-    {
-      /* Finally write the file.  */
-      if (unlikely (elf_update (debugelf, ELF_C_WRITE) == -1))
-	{
-	  error (0, 0, _("while writing '%s': %s"),
-		 tmp_debug_fname, elf_errmsg (-1));
-	  result = 1;
-	  goto fail_close;
-	}
-
-      /* Create the real output file.  First rename, then change the
-	 mode.  */
-      if (rename (tmp_debug_fname, debug_fname) != 0
-	  || fchmod (debug_fd, mode) != 0)
-	{
-	  error (0, errno, _("while creating '%s'"), debug_fname);
-	  result = 1;
-	  goto fail_close;
-	}
-
-      /* The temporary file does not exist anymore.  */
-      free (tmp_debug_fname);
-      tmp_debug_fname = NULL;
-
-      if (!remove_shdrs)
-	{
-	  uint32_t debug_crc;
-	  Elf_Data debug_crc_data =
-	    {
-	      .d_type = ELF_T_WORD,
-	      .d_buf = &debug_crc,
-	      .d_size = sizeof (debug_crc),
-	      .d_version = EV_CURRENT
-	    };
-
-	  /* Compute the checksum which we will add to the executable.  */
-	  if (crc32_file (debug_fd, &debug_crc) != 0)
-	    {
-	      error (0, errno, _("\
-while computing checksum for debug information"));
-	      unlink (debug_fname);
-	      result = 1;
-	      goto fail_close;
-	    }
-
-	  /* Store it in the debuglink section data.  */
-	  if (unlikely (gelf_xlatetof (newelf, &debuglink_crc_data,
-				       &debug_crc_data, ehdr->e_ident[EI_DATA])
-			!= &debuglink_crc_data))
-	    INTERNAL_ERROR (fname);
-	}
-    }
-
-  lastsec_offset = shdr_info[shdridx].shdr.sh_offset;
-  lastsec_size = shdr_info[shdridx].shdr.sh_size;
-
- done:
-  /* Finally finish the ELF header.  Fill in the fields not handled by
-     libelf from the old file.  */
-  newehdr = gelf_getehdr (newelf, &newehdr_mem);
-  if (newehdr == NULL)
-    INTERNAL_ERROR (fname);
-
-  memcpy (newehdr->e_ident, ehdr->e_ident, EI_NIDENT);
-  newehdr->e_type = ehdr->e_type;
-  newehdr->e_machine = ehdr->e_machine;
-  newehdr->e_version = ehdr->e_version;
-  newehdr->e_entry = ehdr->e_entry;
-  newehdr->e_flags = ehdr->e_flags;
-  newehdr->e_phoff = ehdr->e_phoff;
-
-  /* We need to position the section header table.  */
-  const size_t offsize = gelf_fsize (elf, ELF_T_OFF, 1, EV_CURRENT);
-  newehdr->e_shoff = ((lastsec_offset + lastsec_size + offsize - 1)
-		      & ~((GElf_Off) (offsize - 1)));
-  newehdr->e_shentsize = gelf_fsize (elf, ELF_T_SHDR, 1, EV_CURRENT);
-
-  if (gelf_update_ehdr (newelf, newehdr) == 0)
-    {
-      error (0, 0, _("%s: error while creating ELF header: %s"),
-	     output_fname ?: fname, elf_errmsg (-1));
-      cleanup_debug ();
-      return 1;
-    }
-
-  /* The new section header string table index.  */
-  if (update_shdrstrndx (newelf, idx) != 0)
-    {
-      error (0, 0, _("%s: error updating shdrstrndx: %s"),
-	     output_fname ?: fname, elf_errmsg (-1));
-      cleanup_debug ();
-      return 1;
-    }
-
-  /* We have everything from the old file.  */
-  if (elf_cntl (elf, ELF_C_FDDONE) != 0)
-    {
-      error (0, 0, _("%s: error while reading the file: %s"),
-	     fname, elf_errmsg (-1));
-      cleanup_debug ();
-      return 1;
-    }
-
-  /* The ELF library better follows our layout when this is not a
-     relocatable object file.  */
-  elf_flagelf (newelf, ELF_C_SET,
-	       (phnum > 0 ? ELF_F_LAYOUT : 0)
-	       | (permissive ? ELF_F_PERMISSIVE : 0));
-
-  /* Finally write the file.  */
-  if (elf_update (newelf, ELF_C_WRITE) == -1)
-    {
-      error (0, 0, _("while writing '%s': %s"),
-	     output_fname ?: fname, elf_errmsg (-1));
-      result = 1;
-    }
-
-  if (remove_shdrs)
-    {
-      /* libelf can't cope without the section headers being properly intact.
-	 So we just let it write them normally, and then we nuke them later.  */
-
-      if (newehdr->e_ident[EI_CLASS] == ELFCLASS32)
-	{
-	  assert (offsetof (Elf32_Ehdr, e_shentsize) + sizeof (Elf32_Half)
-		  == offsetof (Elf32_Ehdr, e_shnum));
-	  assert (offsetof (Elf32_Ehdr, e_shnum) + sizeof (Elf32_Half)
-		  == offsetof (Elf32_Ehdr, e_shstrndx));
-	  const Elf32_Off zero_off = 0;
-	  const Elf32_Half zero[3] = { 0, 0, SHN_UNDEF };
-	  if (pwrite_retry (fd, &zero_off, sizeof zero_off,
-			    offsetof (Elf32_Ehdr, e_shoff)) != sizeof zero_off
-	      || (pwrite_retry (fd, zero, sizeof zero,
-				offsetof (Elf32_Ehdr, e_shentsize))
-		  != sizeof zero)
-	      || ftruncate (fd, lastsec_offset) < 0)
-	    {
-	      error (0, errno, _("while writing '%s'"),
-		     output_fname ?: fname);
-	      result = 1;
-	    }
-	}
-      else
-	{
-	  assert (offsetof (Elf64_Ehdr, e_shentsize) + sizeof (Elf64_Half)
-		  == offsetof (Elf64_Ehdr, e_shnum));
-	  assert (offsetof (Elf64_Ehdr, e_shnum) + sizeof (Elf64_Half)
-		  == offsetof (Elf64_Ehdr, e_shstrndx));
-	  const Elf64_Off zero_off = 0;
-	  const Elf64_Half zero[3] = { 0, 0, SHN_UNDEF };
-	  if (pwrite_retry (fd, &zero_off, sizeof zero_off,
-			    offsetof (Elf64_Ehdr, e_shoff)) != sizeof zero_off
-	      || (pwrite_retry (fd, zero, sizeof zero,
-				offsetof (Elf64_Ehdr, e_shentsize))
-		  != sizeof zero)
-	      || ftruncate (fd, lastsec_offset) < 0)
-	    {
-	      error (0, errno, _("while writing '%s'"),
-		     output_fname ?: fname);
-	      result = 1;
-	    }
-	}
-    }
-
- fail_close:
-  if (shdr_info != NULL)
-    {
-      /* For some sections we might have created an table to map symbol
-	 table indices.  Or we might kept (original) data around to put
-	 into the .debug file.  */
-      for (cnt = 1; cnt <= shdridx; ++cnt)
-	{
-	  free (shdr_info[cnt].newsymidx);
-	  if (shdr_info[cnt].debug_data != NULL)
-	    free (shdr_info[cnt].debug_data->d_buf);
-	}
-
-      /* Free data we allocated for the .gnu_debuglink section. */
-      free (debuglink_buf);
-
-      /* Free the memory.  */
-      if ((shnum + 2) * sizeof (struct shdr_info) > MAX_STACK_ALLOC)
-	free (shdr_info);
-    }
-
-  /* Free other resources.  */
-  if (shstrtab_data != NULL)
-    free (shstrtab_data->d_buf);
-  if (shst != NULL)
-    dwelf_strtab_free (shst);
-
-  /* That was it.  Close the descriptors.  */
-  if (elf_end (newelf) != 0)
-    {
-      error (0, 0, _("error while finishing '%s': %s"),
-	     output_fname ?: fname, elf_errmsg (-1));
-      result = 1;
-    }
-
-  if (debugelf != NULL && elf_end (debugelf) != 0)
-    {
-      error (0, 0, _("error while finishing '%s': %s"), debug_fname,
-	     elf_errmsg (-1));
-      result = 1;
-    }
-
- fail:
-  /* Close the EBL backend.  */
-  if (ebl != NULL)
-    ebl_closebackend (ebl);
-
-  cleanup_debug ();
-
-  /* If requested, preserve the timestamp.  */
-  if (tvp != NULL)
-    {
-      if (futimens (fd, tvp) != 0)
-	{
-	  error (0, errno, _("\
-cannot set access and modification date of '%s'"),
-		 output_fname ?: fname);
-	  result = 1;
-	}
-    }
-
-  /* Close the file descriptor if we created a new file.  */
-  if (output_fname != NULL)
-    {
-      close (fd);
-      if (result != 0)
-       unlink (output_fname);
-    }
-
-  return result;
-}
-
-static void
-cleanup_debug (void)
-{
-  if (debug_fd >= 0)
-    {
-      if (tmp_debug_fname != NULL)
-	{
-	  unlink (tmp_debug_fname);
-	  free (tmp_debug_fname);
-	  tmp_debug_fname = NULL;
-	}
-      close (debug_fd);
-      debug_fd = -1;
-    }
-}
-
-static int
-handle_ar (int fd, Elf *elf, const char *prefix, const char *fname,
-	   struct timespec tvp[2])
-{
-  size_t prefix_len = prefix == NULL ? 0 : strlen (prefix);
-  size_t fname_len = strlen (fname) + 1;
-  char new_prefix[prefix_len + 1 + fname_len];
-  char *cp = new_prefix;
-
-  /* Create the full name of the file.  */
-  if (prefix != NULL)
-    {
-      cp = mempcpy (cp, prefix, prefix_len);
-      *cp++ = ':';
-    }
-  memcpy (cp, fname, fname_len);
-
-
-  /* Process all the files contained in the archive.  */
-  Elf *subelf;
-  Elf_Cmd cmd = ELF_C_RDWR;
-  int result = 0;
-  while ((subelf = elf_begin (fd, cmd, elf)) != NULL)
-    {
-      /* The the header for this element.  */
-      Elf_Arhdr *arhdr = elf_getarhdr (subelf);
-
-      if (elf_kind (subelf) == ELF_K_ELF)
-	result |= handle_elf (fd, subelf, new_prefix, arhdr->ar_name, 0, NULL);
-      else if (elf_kind (subelf) == ELF_K_AR)
-	result |= handle_ar (fd, subelf, new_prefix, arhdr->ar_name, NULL);
-
-      /* Get next archive element.  */
-      cmd = elf_next (subelf);
-      if (unlikely (elf_end (subelf) != 0))
-	INTERNAL_ERROR (fname);
-    }
-
-  if (tvp != NULL)
-    {
-      if (unlikely (futimens (fd, tvp) != 0))
-	{
-	  error (0, errno, _("\
-cannot set access and modification date of '%s'"), fname);
-	  result = 1;
-	}
-    }
-
-  if (unlikely (close (fd) != 0))
-    error (EXIT_FAILURE, errno, _("while closing '%s'"), fname);
-
-  return result;
-}
-
-
-#include "debugpred.h"
diff --git a/src/unstrip.c b/src/unstrip.c
deleted file mode 100644
index aacc9aad55f79bdf52501cd7fda7de2c110086a9..0000000000000000000000000000000000000000
--- a/src/unstrip.c
+++ /dev/null
@@ -1,2630 +0,0 @@
-/* Combine stripped files with separate symbols and debug information.
-   Copyright (C) 2007-2012, 2014, 2015 Red Hat, Inc.
-   This file is part of elfutils.
-   Written by Roland McGrath <roland@redhat.com>, 2007.
-
-   This file is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   elfutils is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* TODO:
-
-  * SHX_XINDEX
-
-  * prelink vs .debug_* linked addresses
-
- */
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#include <argp.h>
-#include <assert.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <fnmatch.h>
-#include <libintl.h>
-#include <locale.h>
-#include <stdbool.h>
-#include <stdio.h>
-#include <stdio_ext.h>
-#include <inttypes.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/stat.h>
-
-#include <gelf.h>
-#include <libebl.h>
-#include <libdwfl.h>
-#include "system.h"
-#include "libdwelf.h"
-#include "libeu.h"
-#include "printversion.h"
-
-/* Name and version of program.  */
-ARGP_PROGRAM_VERSION_HOOK_DEF = print_version;
-
-/* Bug report address.  */
-ARGP_PROGRAM_BUG_ADDRESS_DEF = PACKAGE_BUGREPORT;
-
-/* Definitions of arguments for argp functions.  */
-static const struct argp_option options[] =
-{
-  /* Group 2 will follow group 1 from dwfl_standard_argp.  */
-  { "match-file-names", 'f', NULL, 0,
-    N_("Match MODULE against file names, not module names"), 2 },
-  { "ignore-missing", 'i', NULL, 0, N_("Silently skip unfindable files"), 0 },
-
-  { NULL, 0, NULL, 0, N_("Output options:"), 0 },
-  { "output", 'o', "FILE", 0, N_("Place output into FILE"), 0 },
-  { "output-directory", 'd', "DIRECTORY",
-    0, N_("Create multiple output files under DIRECTORY"), 0 },
-  { "module-names", 'm', NULL, 0, N_("Use module rather than file names"), 0 },
-  { "all", 'a', NULL, 0,
-    N_("Create output for modules that have no separate debug information"),
-    0 },
-  { "relocate", 'R', NULL, 0,
-    N_("Apply relocations to section contents in ET_REL files"), 0 },
-  { "list-only", 'n', NULL, 0,
-    N_("Only list module and file names, build IDs"), 0 },
- { "force", 'F', NULL, 0,
-    N_("Force combining files even if some ELF headers don't seem to match"),
-   0 },
-  { NULL, 0, NULL, 0, NULL, 0 }
-};
-
-struct arg_info
-{
-  const char *output_file;
-  const char *output_dir;
-  Dwfl *dwfl;
-  char **args;
-  bool list;
-  bool all;
-  bool ignore;
-  bool modnames;
-  bool match_files;
-  bool relocate;
-  bool force;
-};
-
-/* Handle program arguments.  */
-static error_t
-parse_opt (int key, char *arg, struct argp_state *state)
-{
-  struct arg_info *info = state->input;
-
-  switch (key)
-    {
-    case ARGP_KEY_INIT:
-      state->child_inputs[0] = &info->dwfl;
-      break;
-
-    case 'o':
-      if (info->output_file != NULL)
-	{
-	  argp_error (state, _("-o option specified twice"));
-	  return EINVAL;
-	}
-      info->output_file = arg;
-      break;
-
-    case 'd':
-      if (info->output_dir != NULL)
-	{
-	  argp_error (state, _("-d option specified twice"));
-	  return EINVAL;
-	}
-      info->output_dir = arg;
-      break;
-
-    case 'm':
-      info->modnames = true;
-      break;
-    case 'f':
-      info->match_files = true;
-      break;
-    case 'a':
-      info->all = true;
-      break;
-    case 'i':
-      info->ignore = true;
-      break;
-    case 'n':
-      info->list = true;
-      break;
-    case 'R':
-      info->relocate = true;
-      break;
-    case 'F':
-      info->force = true;
-      break;
-
-    case ARGP_KEY_ARGS:
-    case ARGP_KEY_NO_ARGS:
-      /* We "consume" all the arguments here.  */
-      info->args = &state->argv[state->next];
-
-      if (info->output_file != NULL && info->output_dir != NULL)
-	{
-	  argp_error (state, _("only one of -o or -d allowed"));
-	  return EINVAL;
-	}
-
-      if (info->list && (info->dwfl == NULL
-			 || info->output_dir != NULL
-			 || info->output_file != NULL))
-	{
-	  argp_error (state,
-		      _("-n cannot be used with explicit files or -o or -d"));
-	  return EINVAL;
-	}
-
-      if (info->output_dir != NULL)
-	{
-	  struct stat st;
-	  error_t fail = 0;
-	  if (stat (info->output_dir, &st) < 0)
-	    fail = errno;
-	  else if (!S_ISDIR (st.st_mode))
-	    fail = ENOTDIR;
-	  if (fail)
-	    {
-	      argp_failure (state, EXIT_FAILURE, fail,
-			    _("output directory '%s'"), info->output_dir);
-	      return fail;
-	    }
-	}
-
-      if (info->dwfl == NULL)
-	{
-	  if (state->next + 2 != state->argc)
-	    {
-	      argp_error (state, _("exactly two file arguments are required"));
-	      return EINVAL;
-	    }
-
-	  if (info->ignore || info->all || info->modnames || info->relocate)
-	    {
-	      argp_error (state, _("\
--m, -a, -R, and -i options not allowed with explicit files"));
-	      return EINVAL;
-	    }
-
-	  /* Bail out immediately to prevent dwfl_standard_argp's parser
-	     from defaulting to "-e a.out".  */
-	  return ENOSYS;
-	}
-      else if (info->output_file == NULL && info->output_dir == NULL
-	       && !info->list)
-	{
-	  argp_error (state,
-		      _("-o or -d is required when using implicit files"));
-	  return EINVAL;
-	}
-      break;
-
-    default:
-      return ARGP_ERR_UNKNOWN;
-    }
-  return 0;
-}
-
-#define ELF_CHECK(call, msg)						      \
-  do									      \
-    {									      \
-      if (unlikely (!(call)))						      \
-	error (EXIT_FAILURE, 0, msg, elf_errmsg (-1));			      \
-    } while (0)
-
-/* Copy INELF to newly-created OUTELF, exit via error for any problems.  */
-static void
-copy_elf (Elf *outelf, Elf *inelf)
-{
-  ELF_CHECK (gelf_newehdr (outelf, gelf_getclass (inelf)),
-	     _("cannot create ELF header: %s"));
-
-  size_t shstrndx;
-  ELF_CHECK (elf_getshdrstrndx (inelf, &shstrndx) == 0,
-	     _("cannot get shdrstrndx:%s"));
-
-  GElf_Ehdr ehdr_mem;
-  GElf_Ehdr *ehdr = gelf_getehdr (inelf, &ehdr_mem);
-  ELF_CHECK (ehdr != NULL, _("cannot get ELF header: %s"));
-  if (shstrndx < SHN_LORESERVE)
-    ehdr->e_shstrndx = shstrndx;
-  else
-    {
-      ehdr->e_shstrndx = SHN_XINDEX;
-      Elf_Scn *scn0 = elf_getscn (outelf, 0);
-      GElf_Shdr shdr0_mem;
-      GElf_Shdr *shdr0 = gelf_getshdr (scn0, &shdr0_mem);
-      ELF_CHECK (shdr0 != NULL,
-		 _("cannot get new zero section: %s"));
-      shdr0->sh_link = shstrndx;
-      ELF_CHECK (gelf_update_shdr (scn0, shdr0),
-		 _("cannot update new zero section: %s"));
-    }
-
-  ELF_CHECK (gelf_update_ehdr (outelf, ehdr),
-	     _("cannot copy ELF header: %s"));
-
-  size_t phnum;
-  ELF_CHECK (elf_getphdrnum (inelf, &phnum) == 0,
-	     _("cannot get number of program headers: %s"));
-
-  if (phnum > 0)
-    {
-      ELF_CHECK (gelf_newphdr (outelf, phnum),
-		 _("cannot create program headers: %s"));
-
-      GElf_Phdr phdr_mem;
-      for (size_t i = 0; i < phnum; ++i)
-	ELF_CHECK (gelf_update_phdr (outelf, i,
-				     gelf_getphdr (inelf, i, &phdr_mem)),
-		   _("cannot copy program header: %s"));
-    }
-
-  Elf_Scn *scn = NULL;
-  while ((scn = elf_nextscn (inelf, scn)) != NULL)
-    {
-      Elf_Scn *newscn = elf_newscn (outelf);
-
-      GElf_Shdr shdr_mem;
-      ELF_CHECK (gelf_update_shdr (newscn, gelf_getshdr (scn, &shdr_mem)),
-		 _("cannot copy section header: %s"));
-
-      Elf_Data *data = elf_getdata (scn, NULL);
-      ELF_CHECK (data != NULL, _("cannot get section data: %s"));
-      Elf_Data *newdata = elf_newdata (newscn);
-      ELF_CHECK (newdata != NULL, _("cannot copy section data: %s"));
-      *newdata = *data;
-      elf_flagdata (newdata, ELF_C_SET, ELF_F_DIRTY);
-    }
-}
-
-/* Create directories containing PATH.  */
-static void
-make_directories (const char *path)
-{
-  const char *lastslash = strrchr (path, '/');
-  if (lastslash == NULL)
-    return;
-
-  while (lastslash > path && lastslash[-1] == '/')
-    --lastslash;
-  if (lastslash == path)
-    return;
-
-  char *dir = strndup (path, lastslash - path);
-  if (dir == NULL)
-    error(EXIT_FAILURE, errno, _("memory exhausted"));
-
-  while (mkdir (dir, ACCESSPERMS) < 0 && errno != EEXIST)
-    {
-      if (errno == ENOENT)
-        make_directories (dir);
-      else
-        error (EXIT_FAILURE, errno, _("cannot create directory '%s'"), dir);
-    }
-  free (dir);
-}
-
-/* Keep track of new section data we are creating, so we can free it
-   when done.  */
-struct data_list
-{
-  void *data;
-  struct data_list *next;
-};
-
-struct data_list *new_data_list;
-
-static void
-record_new_data (void *data)
-{
-  struct data_list *next = new_data_list;
-  new_data_list = xmalloc (sizeof (struct data_list));
-  new_data_list->data = data;
-  new_data_list->next = next;
-}
-
-static void
-free_new_data (void)
-{
-  struct data_list *list = new_data_list;
-  while (list != NULL)
-    {
-      struct data_list *next = list->next;
-      free (list->data);
-      free (list);
-      list = next;
-    }
-  new_data_list = NULL;
-}
-
-/* The binutils linker leaves gratuitous section symbols in .symtab
-   that strip has to remove.  Older linkers likewise include a
-   symbol for every section, even unallocated ones, in .dynsym.
-   Because of this, the related sections can shrink in the stripped
-   file from their original size.  Older versions of strip do not
-   adjust the sh_size field in the debuginfo file's SHT_NOBITS
-   version of the section header, so it can appear larger.  */
-static bool
-section_can_shrink (const GElf_Shdr *shdr)
-{
-  switch (shdr->sh_type)
-    {
-    case SHT_SYMTAB:
-    case SHT_DYNSYM:
-    case SHT_HASH:
-    case SHT_GNU_versym:
-      return true;
-    }
-  return false;
-}
-
-/* See if this symbol table has a leading section symbol for every single
-   section, in order.  The binutils linker produces this.  While we're here,
-   update each section symbol's st_value.  */
-static size_t
-symtab_count_leading_section_symbols (Elf *elf, Elf_Scn *scn, size_t shnum,
-				      Elf_Data *newsymdata)
-{
-  Elf_Data *data = elf_getdata (scn, NULL);
-  Elf_Data *shndxdata = NULL;	/* XXX */
-
-  for (size_t i = 1; i < shnum; ++i)
-    {
-      GElf_Sym sym_mem;
-      GElf_Word shndx = SHN_UNDEF;
-      GElf_Sym *sym = gelf_getsymshndx (data, shndxdata, i, &sym_mem, &shndx);
-      ELF_CHECK (sym != NULL, _("cannot get symbol table entry: %s"));
-
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (elf_getscn (elf, i), &shdr_mem);
-      ELF_CHECK (shdr != NULL, _("cannot get section header: %s"));
-
-      if (sym->st_shndx != SHN_XINDEX)
-	shndx = sym->st_shndx;
-
-      if (shndx != i || GELF_ST_TYPE (sym->st_info) != STT_SECTION)
-	return i;
-
-      sym->st_value = shdr->sh_addr;
-      if (sym->st_shndx != SHN_XINDEX)
-	shndx = SHN_UNDEF;
-      ELF_CHECK (gelf_update_symshndx (newsymdata, shndxdata, i, sym, shndx),
-		 _("cannot update symbol table: %s"));
-    }
-
-  return shnum;
-}
-
-static void
-update_shdr (Elf_Scn *outscn, GElf_Shdr *newshdr)
-{
-  ELF_CHECK (gelf_update_shdr (outscn, newshdr),
-	     _("cannot update section header: %s"));
-}
-
-/* We expanded the output section, so update its header.  */
-static void
-update_sh_size (Elf_Scn *outscn, const Elf_Data *data)
-{
-  GElf_Shdr shdr_mem;
-  GElf_Shdr *newshdr = gelf_getshdr (outscn, &shdr_mem);
-  ELF_CHECK (newshdr != NULL, _("cannot get section header: %s"));
-
-  newshdr->sh_size = data->d_size;
-
-  update_shdr (outscn, newshdr);
-}
-
-static inline void
-adjust_reloc (GElf_Xword *info,
-	      size_t map[], size_t map_size)
-{
-  size_t ndx = GELF_R_SYM (*info);
-  if (ndx != STN_UNDEF)
-    {
-      if (ndx > map_size)
-	error (EXIT_FAILURE, 0, "bad symbol ndx section");
-      *info = GELF_R_INFO (map[ndx - 1], GELF_R_TYPE (*info));
-    }
-}
-
-/* Update relocation sections using the symbol table.  */
-static void
-adjust_relocs (Elf_Scn *outscn, Elf_Scn *inscn, const GElf_Shdr *shdr,
-	       size_t map[], size_t map_size, const GElf_Shdr *symshdr)
-{
-  Elf_Data *data = elf_getdata (outscn, NULL);
-
-  switch (shdr->sh_type)
-    {
-    case SHT_REL:
-      if (shdr->sh_entsize == 0)
-	error (EXIT_FAILURE, 0, "REL section cannot have zero sh_entsize");
-
-      for (size_t i = 0; i < shdr->sh_size / shdr->sh_entsize; ++i)
-	{
-	  GElf_Rel rel_mem;
-	  GElf_Rel *rel = gelf_getrel (data, i, &rel_mem);
-	  ELF_CHECK (rel != NULL, _("gelf_getrel failed: %s"));
-	  adjust_reloc (&rel->r_info, map, map_size);
-	  ELF_CHECK (gelf_update_rel (data, i, rel),
-		     _("cannot update relocation: %s"));
-	}
-      break;
-
-    case SHT_RELA:
-      if (shdr->sh_entsize == 0)
-	error (EXIT_FAILURE, 0, "RELA section cannot have zero sh_entsize");
-
-      for (size_t i = 0; i < shdr->sh_size / shdr->sh_entsize; ++i)
-	{
-	  GElf_Rela rela_mem;
-	  GElf_Rela *rela = gelf_getrela (data, i, &rela_mem);
-	  ELF_CHECK (rela != NULL, _("gelf_getrela failed: %s"));
-	  adjust_reloc (&rela->r_info, map, map_size);
-	  ELF_CHECK (gelf_update_rela (data, i, rela),
-		     _("cannot update relocation: %s"));
-	}
-      break;
-
-    case SHT_GROUP:
-      {
-	GElf_Shdr shdr_mem;
-	GElf_Shdr *newshdr = gelf_getshdr (outscn, &shdr_mem);
-	ELF_CHECK (newshdr != NULL, _("cannot get section header: %s"));
-	if (newshdr->sh_info != STN_UNDEF)
-	  {
-	    newshdr->sh_info = map[newshdr->sh_info - 1];
-	    update_shdr (outscn, newshdr);
-	  }
-	break;
-      }
-
-    case SHT_HASH:
-      /* We must expand the table and rejigger its contents.  */
-      {
-	if (shdr->sh_entsize == 0)
-	  error (EXIT_FAILURE, 0, "HASH section cannot have zero sh_entsize");
-	if (symshdr->sh_entsize == 0)
-	  error (EXIT_FAILURE, 0, "Symbol table cannot have zero sh_entsize");
-	const size_t nsym = symshdr->sh_size / symshdr->sh_entsize;
-	const size_t onent = shdr->sh_size / shdr->sh_entsize;
-	if (data->d_size != shdr->sh_size)
-	  error (EXIT_FAILURE, 0, "HASH section has inconsistent size");
-
-#define CONVERT_HASH(Hash_Word)						      \
-	{								      \
-	  const Hash_Word *const old_hash = data->d_buf;		      \
-	  const size_t nbucket = old_hash[0];				      \
-	  const size_t nchain = old_hash[1];				      \
-	  const Hash_Word *const old_bucket = &old_hash[2];		      \
-	  const Hash_Word *const old_chain = &old_bucket[nbucket];	      \
-	  if (onent != 2 + nbucket + nchain)				      \
-	    error (EXIT_FAILURE, 0, "HASH section has inconsistent entsize"); \
-									      \
-	  const size_t nent = 2 + nbucket + nsym;			      \
-	  Hash_Word *const new_hash = xcalloc (nent, sizeof new_hash[0]);     \
-	  Hash_Word *const new_bucket = &new_hash[2];			      \
-	  Hash_Word *const new_chain = &new_bucket[nbucket];		      \
-									      \
-	  new_hash[0] = nbucket;					      \
-	  new_hash[1] = nsym;						      \
-	  for (size_t i = 0; i < nbucket; ++i)				      \
-	    if (old_bucket[i] != STN_UNDEF)				      \
-	      new_bucket[i] = map[old_bucket[i] - 1];			      \
-									      \
-	  for (size_t i = 1; i < nchain; ++i)				      \
-	    if (old_chain[i] != STN_UNDEF)				      \
-	      new_chain[map[i - 1]] = map[old_chain[i] - 1];		      \
-									      \
-	  record_new_data (new_hash);					\
-	  data->d_buf = new_hash;					      \
-	  data->d_size = nent * sizeof new_hash[0];			      \
-	}
-
-	switch (shdr->sh_entsize)
-	  {
-	  case 4:
-	    CONVERT_HASH (Elf32_Word);
-	    break;
-	  case 8:
-	    CONVERT_HASH (Elf64_Xword);
-	    break;
-	  default:
-	    abort ();
-	  }
-
-	elf_flagdata (data, ELF_C_SET, ELF_F_DIRTY);
-	update_sh_size (outscn, data);
-
-#undef	CONVERT_HASH
-      }
-      break;
-
-    case SHT_GNU_versym:
-      /* We must expand the table and move its elements around.  */
-      {
-	if (shdr->sh_entsize == 0)
-	  error (EXIT_FAILURE, 0,
-		 "GNU_versym section cannot have zero sh_entsize");
-	if (symshdr->sh_entsize == 0)
-	  error (EXIT_FAILURE, 0, "Symbol table cannot have zero sh_entsize");
-	const size_t nent = symshdr->sh_size / symshdr->sh_entsize;
-	const size_t onent = shdr->sh_size / shdr->sh_entsize;
-	assert (nent >= onent);
-
-	/* We don't bother using gelf_update_versym because there is
-	   really no conversion to be done.  */
-	assert (sizeof (Elf32_Versym) == sizeof (GElf_Versym));
-	assert (sizeof (Elf64_Versym) == sizeof (GElf_Versym));
-	GElf_Versym *versym = xcalloc (nent, sizeof versym[0]);
-
-	for (size_t i = 1; i < onent; ++i)
-	  {
-	    GElf_Versym *v = gelf_getversym (data, i, &versym[map[i - 1]]);
-	    ELF_CHECK (v != NULL, _("cannot get symbol version: %s"));
-	  }
-
-	record_new_data (versym);
-	data->d_buf = versym;
-	data->d_size = nent * sizeof versym[0];
-	elf_flagdata (data, ELF_C_SET, ELF_F_DIRTY);
-	update_sh_size (outscn, data);
-      }
-      break;
-
-    default:
-      error (EXIT_FAILURE, 0,
-	     _("unexpected section type in [%zu] with sh_link to symtab"),
-	     elf_ndxscn (inscn));
-    }
-}
-
-/* Adjust all the relocation sections in the file.  */
-static void
-adjust_all_relocs (Elf *elf, Elf_Scn *symtab, const GElf_Shdr *symshdr,
-		   size_t map[], size_t map_size)
-{
-  size_t new_sh_link = elf_ndxscn (symtab);
-  Elf_Scn *scn = NULL;
-  while ((scn = elf_nextscn (elf, scn)) != NULL)
-    if (scn != symtab)
-      {
-	GElf_Shdr shdr_mem;
-	GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-	ELF_CHECK (shdr != NULL, _("cannot get section header: %s"));
-	/* Don't redo SHT_GROUP, groups are in both the stripped and debug,
-	   it will already have been done by adjust_relocs for the
-	   stripped_symtab.  */
-	if (shdr->sh_type != SHT_NOBITS && shdr->sh_type != SHT_GROUP
-	    && shdr->sh_link == new_sh_link)
-	  adjust_relocs (scn, scn, shdr, map, map_size, symshdr);
-      }
-}
-
-/* The original file probably had section symbols for all of its
-   sections, even the unallocated ones.  To match it as closely as
-   possible, add in section symbols for the added sections.  */
-static Elf_Data *
-add_new_section_symbols (Elf_Scn *old_symscn, size_t old_shnum,
-			 Elf *elf, bool rel, Elf_Scn *symscn, size_t shnum)
-{
-  const size_t added = shnum - old_shnum;
-
-  GElf_Shdr shdr_mem;
-  GElf_Shdr *shdr = gelf_getshdr (symscn, &shdr_mem);
-  ELF_CHECK (shdr != NULL, _("cannot get section header: %s"));
-  if (shdr->sh_entsize == 0)
-    error (EXIT_FAILURE, 0, "Symbol table section cannot have zero sh_entsize");
-
-  const size_t nsym = shdr->sh_size / shdr->sh_entsize;
-  size_t symndx_map[nsym - 1];
-
-  shdr->sh_info += added;
-  shdr->sh_size += added * shdr->sh_entsize;
-  update_shdr (symscn, shdr);
-
-  Elf_Data *symdata = elf_getdata (symscn, NULL);
-  Elf_Data *shndxdata = NULL;	/* XXX */
-
-  symdata->d_size = shdr->sh_size;
-  symdata->d_buf = xmalloc (symdata->d_size);
-  record_new_data (symdata->d_buf);
-
-  /* Copy the existing section symbols.  */
-  Elf_Data *old_symdata = elf_getdata (old_symscn, NULL);
-  for (size_t i = 0; i < old_shnum; ++i)
-    {
-      GElf_Sym sym_mem;
-      GElf_Word shndx = SHN_UNDEF;
-      GElf_Sym *sym = gelf_getsymshndx (old_symdata, shndxdata,
-					i, &sym_mem, &shndx);
-      ELF_CHECK (sym != NULL, _("cannot get symbol table entry: %s"));
-      ELF_CHECK (gelf_update_symshndx (symdata, shndxdata, i,
-				       sym, shndx),
-		 _("cannot update symbol table: %s"));
-
-      if (i > 0)
-	symndx_map[i - 1] = i;
-    }
-
-  /* Add in the new section symbols.  */
-  for (size_t i = old_shnum; i < shnum; ++i)
-    {
-      GElf_Shdr i_shdr_mem;
-      GElf_Shdr *i_shdr = gelf_getshdr (elf_getscn (elf, i), &i_shdr_mem);
-      ELF_CHECK (i_shdr != NULL, _("cannot get section header: %s"));
-      GElf_Sym sym =
-	{
-	  .st_value = rel ? 0 : i_shdr->sh_addr,
-	  .st_info = GELF_ST_INFO (STB_LOCAL, STT_SECTION),
-	  .st_shndx = i < SHN_LORESERVE ? i : SHN_XINDEX
-	};
-      GElf_Word shndx = i < SHN_LORESERVE ? SHN_UNDEF : i;
-      ELF_CHECK (gelf_update_symshndx (symdata, shndxdata, i,
-				       &sym, shndx),
-		 _("cannot update symbol table: %s"));
-    }
-
-  /* Now copy the rest of the existing symbols.  */
-  for (size_t i = old_shnum; i < nsym; ++i)
-    {
-      GElf_Sym sym_mem;
-      GElf_Word shndx = SHN_UNDEF;
-      GElf_Sym *sym = gelf_getsymshndx (old_symdata, shndxdata,
-					i, &sym_mem, &shndx);
-      ELF_CHECK (sym != NULL, _("cannot get symbol table entry: %s"));
-      ELF_CHECK (gelf_update_symshndx (symdata, shndxdata,
-				       i + added, sym, shndx),
-		 _("cannot update symbol table: %s"));
-
-      symndx_map[i - 1] = i + added;
-    }
-
-  /* Adjust any relocations referring to the old symbol table.  */
-  adjust_all_relocs (elf, symscn, shdr, symndx_map, nsym - 1);
-
-  return symdata;
-}
-
-/* This has the side effect of updating STT_SECTION symbols' values,
-   in case of prelink adjustments.  */
-static Elf_Data *
-check_symtab_section_symbols (Elf *elf, bool rel, Elf_Scn *scn,
-			      size_t shnum, size_t shstrndx,
-			      Elf_Scn *oscn, size_t oshnum, size_t oshstrndx,
-			      size_t debuglink)
-{
-  size_t n = symtab_count_leading_section_symbols (elf, oscn, oshnum,
-						   elf_getdata (scn, NULL));
-
-  if (n == oshnum)
-    return add_new_section_symbols (oscn, n, elf, rel, scn, shnum);
-
-  if (n == oshstrndx || (n == debuglink && n == oshstrndx - 1))
-    return add_new_section_symbols (oscn, n, elf, rel, scn, shstrndx);
-
-  return NULL;
-}
-
-struct section
-{
-  Elf_Scn *scn;
-  const char *name;
-  const char *sig;
-  Elf_Scn *outscn;
-  Dwelf_Strent *strent;
-  GElf_Shdr shdr;
-};
-
-static int
-compare_alloc_sections (const struct section *s1, const struct section *s2,
-			bool rel)
-{
-  if (!rel)
-    {
-      /* Sort by address.  */
-      if (s1->shdr.sh_addr < s2->shdr.sh_addr)
-	return -1;
-      if (s1->shdr.sh_addr > s2->shdr.sh_addr)
-	return 1;
-    }
-
-  /* At the same address, preserve original section order.  */
-  return (ssize_t) elf_ndxscn (s1->scn) - (ssize_t) elf_ndxscn (s2->scn);
-}
-
-static int
-compare_unalloc_sections (const GElf_Shdr *shdr1, const GElf_Shdr *shdr2,
-			  const char *name1, const char *name2,
-			  const char *sig1, const char *sig2)
-{
-  /* Sort by sh_flags as an arbitrary ordering.  */
-  if (shdr1->sh_flags < shdr2->sh_flags)
-    return -1;
-  if (shdr1->sh_flags > shdr2->sh_flags)
-    return 1;
-
-  /* Sizes should be the same.  */
-  if (shdr1->sh_size < shdr2->sh_size)
-    return -1;
-  if (shdr1->sh_size > shdr2->sh_size)
-    return 1;
-
-  /* Are they both SHT_GROUP sections? Then compare signatures.  */
-  if (sig1 != NULL && sig2 != NULL)
-    return strcmp (sig1, sig2);
-
-  /* Sort by name as last resort.  */
-  return strcmp (name1, name2);
-}
-
-static int
-compare_sections (const void *a, const void *b, bool rel)
-{
-  const struct section *s1 = a;
-  const struct section *s2 = b;
-
-  /* Sort all non-allocated sections last.  */
-  if ((s1->shdr.sh_flags ^ s2->shdr.sh_flags) & SHF_ALLOC)
-    return (s1->shdr.sh_flags & SHF_ALLOC) ? -1 : 1;
-
-  return ((s1->shdr.sh_flags & SHF_ALLOC)
-	  ? compare_alloc_sections (s1, s2, rel)
-	  : compare_unalloc_sections (&s1->shdr, &s2->shdr,
-				      s1->name, s2->name,
-				      s1->sig, s2->sig));
-}
-
-static int
-compare_sections_rel (const void *a, const void *b)
-{
-  return compare_sections (a, b, true);
-}
-
-static int
-compare_sections_nonrel (const void *a, const void *b)
-{
-  return compare_sections (a, b, false);
-}
-
-
-struct symbol
-{
-  size_t *map;
-
-  union
-  {
-    const char *name;
-    Dwelf_Strent *strent;
-  };
-  union
-  {
-    struct
-    {
-      GElf_Addr value;
-      GElf_Xword size;
-      GElf_Word shndx;
-      union
-      {
-	struct
-	{
-	  uint8_t info;
-	  uint8_t other;
-	} info;
-	int16_t compare;
-      };
-    };
-
-    /* For a symbol discarded after first sort, this matches its better's
-       map pointer.  */
-    size_t *duplicate;
-  };
-};
-
-/* Collect input symbols into our internal form.  */
-static void
-collect_symbols (Elf *outelf, bool rel, Elf_Scn *symscn, Elf_Scn *strscn,
-		 const size_t nent, const GElf_Addr bias,
-		 const size_t scnmap[], struct symbol *table, size_t *map,
-		 struct section *split_bss)
-{
-  Elf_Data *symdata = elf_getdata (symscn, NULL);
-  ELF_CHECK (symdata != NULL, _("cannot get symbol section data: %s"));
-  Elf_Data *strdata = elf_getdata (strscn, NULL);
-  ELF_CHECK (strdata != NULL, _("cannot get string section data: %s"));
-  Elf_Data *shndxdata = NULL;	/* XXX */
-
-  for (size_t i = 1; i < nent; ++i)
-    {
-      GElf_Sym sym_mem;
-      GElf_Word shndx = SHN_UNDEF;
-      GElf_Sym *sym = gelf_getsymshndx (symdata, shndxdata, i,
-					&sym_mem, &shndx);
-      ELF_CHECK (sym != NULL, _("cannot get symbol table entry: %s"));
-      if (sym->st_shndx != SHN_XINDEX)
-	shndx = sym->st_shndx;
-
-      if (sym->st_name >= strdata->d_size
-	  || memrchr (strdata->d_buf + sym->st_name, '\0',
-		      strdata->d_size - sym->st_name) == NULL)
-	error (EXIT_FAILURE, 0,
-	       _("invalid string offset in symbol [%zu]"), i);
-
-      struct symbol *s = &table[i - 1];
-      s->map = &map[i - 1];
-      s->name = strdata->d_buf + sym->st_name;
-      s->value = sym->st_value + bias;
-      s->size = sym->st_size;
-      s->shndx = shndx;
-      s->info.info = sym->st_info;
-      s->info.other = sym->st_other;
-
-      if (scnmap != NULL && shndx != SHN_UNDEF && shndx < SHN_LORESERVE)
-	s->shndx = scnmap[shndx - 1];
-
-      if (GELF_ST_TYPE (s->info.info) == STT_SECTION && !rel)
-	{
-	  /* Update the value to match the output section.  */
-	  GElf_Shdr shdr_mem;
-	  GElf_Shdr *shdr = gelf_getshdr (elf_getscn (outelf, s->shndx),
-					  &shdr_mem);
-	  ELF_CHECK (shdr != NULL, _("cannot get section header: %s"));
-	  s->value = shdr->sh_addr;
-	}
-      else if (split_bss != NULL
-	       && s->value < split_bss->shdr.sh_addr
-	       && s->value >= split_bss[-1].shdr.sh_addr
-	       && shndx == elf_ndxscn (split_bss->outscn))
-	/* This symbol was in .bss and was split into .dynbss.  */
-	s->shndx = elf_ndxscn (split_bss[-1].outscn);
-    }
-}
-
-
-#define CMP(value)							      \
-  if (s1->value < s2->value)						      \
-    return -1;								      \
-  if (s1->value > s2->value)						      \
-    return 1
-
-/* Compare symbols with a consistent ordering,
-   but one only meaningful for equality.  */
-static int
-compare_symbols (const void *a, const void *b)
-{
-  const struct symbol *s1 = a;
-  const struct symbol *s2 = b;
-
-  CMP (value);
-  CMP (size);
-  CMP (shndx);
-
-  return (s1->compare - s2->compare) ?: strcmp (s1->name, s2->name);
-}
-
-/* Compare symbols for output order after slots have been assigned.  */
-static int
-compare_symbols_output (const void *a, const void *b)
-{
-  const struct symbol *s1 = a;
-  const struct symbol *s2 = b;
-  int cmp;
-
-  /* Sort discarded symbols last.  */
-  cmp = (s1->name == NULL) - (s2->name == NULL);
-
-  if (cmp == 0)
-    /* Local symbols must come first.  */
-    cmp = ((GELF_ST_BIND (s2->info.info) == STB_LOCAL)
-	   - (GELF_ST_BIND (s1->info.info) == STB_LOCAL));
-
-  if (cmp == 0)
-    /* binutils always puts section symbols first.  */
-    cmp = ((GELF_ST_TYPE (s2->info.info) == STT_SECTION)
-	   - (GELF_ST_TYPE (s1->info.info) == STT_SECTION));
-
-  if (cmp == 0)
-    {
-      if (GELF_ST_TYPE (s1->info.info) == STT_SECTION)
-	{
-	  /* binutils always puts section symbols in section index order.  */
-	  CMP (shndx);
-	  else if (s1 != s2)
-	    error (EXIT_FAILURE, 0, "section symbols in unexpected order");
-	}
-
-      /* Nothing really matters, so preserve the original order.  */
-      CMP (map);
-      else if (s1 != s2)
-	error (EXIT_FAILURE, 0, "found two identical symbols");
-    }
-
-  return cmp;
-}
-
-#undef CMP
-
-/* Return true if the flags of the sections match, ignoring the SHF_INFO_LINK
-   flag if the section contains relocation information.  */
-static bool
-sections_flags_match (Elf64_Xword sh_flags1, Elf64_Xword sh_flags2,
-		      Elf64_Word sh_type)
-{
-  if (sh_type == SHT_REL || sh_type == SHT_RELA)
-    {
-      sh_flags1 &= ~SHF_INFO_LINK;
-      sh_flags2 &= ~SHF_INFO_LINK;
-    }
-
-  return sh_flags1 == sh_flags2;
-}
-
-/* Return true iff the flags, size, and name match.  */
-static bool
-sections_match (const struct section *sections, size_t i,
-		const GElf_Shdr *shdr, const char *name)
-{
-  return (sections_flags_match (sections[i].shdr.sh_flags, shdr->sh_flags,
-				sections[i].shdr.sh_type)
-	  && (sections[i].shdr.sh_size == shdr->sh_size
-	      || (sections[i].shdr.sh_size < shdr->sh_size
-		  && section_can_shrink (&sections[i].shdr)))
-	  && !strcmp (sections[i].name, name));
-}
-
-/* Locate a matching allocated section in SECTIONS.  */
-static struct section *
-find_alloc_section (const GElf_Shdr *shdr, GElf_Addr bias, const char *name,
-		    struct section sections[], size_t nalloc)
-{
-  const GElf_Addr addr = shdr->sh_addr + bias;
-  size_t l = 0, u = nalloc;
-  while (l < u)
-    {
-      size_t i = (l + u) / 2;
-      if (addr < sections[i].shdr.sh_addr)
-	u = i;
-      else if (addr > sections[i].shdr.sh_addr)
-	l = i + 1;
-      else
-	{
-	  /* We've found allocated sections with this address.
-	     Find one with matching size, flags, and name.  */
-	  while (i > 0 && sections[i - 1].shdr.sh_addr == addr)
-	    --i;
-	  for (; i < nalloc && sections[i].shdr.sh_addr == addr;
-	       ++i)
-	    if (sections_match (sections, i, shdr, name))
-	      return &sections[i];
-	  break;
-	}
-    }
-  return NULL;
-}
-
-static inline const char *
-get_section_name (size_t ndx, const GElf_Shdr *shdr, const Elf_Data *shstrtab)
-{
-  if (shdr->sh_name >= shstrtab->d_size)
-    error (EXIT_FAILURE, 0, _("cannot read section [%zu] name: %s"),
-	   ndx, elf_errmsg (-1));
-  return shstrtab->d_buf + shdr->sh_name;
-}
-
-/* Returns the signature of a group section, or NULL if the given
-   section isn't a group.  */
-static const char *
-get_group_sig (Elf *elf, GElf_Shdr *shdr)
-{
-  if (shdr->sh_type != SHT_GROUP)
-    return NULL;
-
-  Elf_Scn *symscn = elf_getscn (elf, shdr->sh_link);
-  if (symscn == NULL)
-    error (EXIT_FAILURE, 0, _("bad sh_link for group section: %s"),
-	   elf_errmsg (-1));
-
-  GElf_Shdr symshdr_mem;
-  GElf_Shdr *symshdr = gelf_getshdr (symscn, &symshdr_mem);
-  if (symshdr == NULL)
-    error (EXIT_FAILURE, 0, _("couldn't get shdr for group section: %s"),
-	   elf_errmsg (-1));
-
-  Elf_Data *symdata = elf_getdata (symscn, NULL);
-  if (symdata == NULL)
-    error (EXIT_FAILURE, 0, _("bad data for group symbol section: %s"),
-	   elf_errmsg (-1));
-
-  GElf_Sym sym_mem;
-  GElf_Sym *sym = gelf_getsym (symdata, shdr->sh_info, &sym_mem);
-  if (sym == NULL)
-    error (EXIT_FAILURE, 0, _("couldn't get symbol for group section: %s"),
-	   elf_errmsg (-1));
-
-  const char *sig = elf_strptr (elf, symshdr->sh_link, sym->st_name);
-  if (sig == NULL)
-    error (EXIT_FAILURE, 0, _("bad symbol name for group section: %s"),
-	   elf_errmsg (-1));
-
-  return sig;
-}
-
-static inline bool
-check_match (bool match, Elf_Scn *scn, const char *name)
-{
-  if (!match)
-    {
-      error (0, 0, _("cannot find matching section for [%zu] '%s'"),
-	     elf_ndxscn (scn), name);
-      return true;
-    }
-
-  return false;
-}
-
-
-/* Fix things up when prelink has moved some allocated sections around
-   and the debuginfo file's section headers no longer match up.
-   This fills in SECTIONS[0..NALLOC-1].outscn or exits.
-   If there was a .bss section that was split into two sections
-   with the new one preceding it in sh_addr, we return that pointer.  */
-static struct section *
-find_alloc_sections_prelink (Elf *debug, Elf_Data *debug_shstrtab,
-			     Elf *main, const GElf_Ehdr *main_ehdr,
-			     Elf_Data *main_shstrtab, GElf_Addr bias,
-			     struct section *sections,
-			     size_t nalloc, size_t nsections)
-{
-  Elf_Scn *undo = NULL;
-  for (size_t i = nalloc; i < nsections; ++i)
-    {
-      const struct section *sec = &sections[i];
-      if (sec->shdr.sh_type == SHT_PROGBITS
-	  && !(sec->shdr.sh_flags & SHF_ALLOC)
-	  && !strcmp (sec->name, ".gnu.prelink_undo"))
-	{
-	  undo = sec->scn;
-	  break;
-	}
-    }
-
-  /* Find the original allocated sections before prelinking.  */
-  struct section *undo_sections = NULL;
-  size_t undo_nalloc = 0;
-  if (undo != NULL)
-    {
-      /* Clear assignments that might have been bogus.  */
-      for (size_t i = 0; i < nalloc; ++i)
-	sections[i].outscn = NULL;
-
-      Elf_Data *undodata = elf_rawdata (undo, NULL);
-      ELF_CHECK (undodata != NULL,
-		 _("cannot read '.gnu.prelink_undo' section: %s"));
-
-      union
-      {
-	Elf32_Ehdr e32;
-	Elf64_Ehdr e64;
-      } ehdr;
-      Elf_Data dst =
-	{
-	  .d_buf = &ehdr,
-	  .d_size = sizeof ehdr,
-	  .d_type = ELF_T_EHDR,
-	  .d_version = EV_CURRENT
-	};
-      Elf_Data src = *undodata;
-      src.d_size = gelf_fsize (main, ELF_T_EHDR, 1, EV_CURRENT);
-      src.d_type = ELF_T_EHDR;
-      ELF_CHECK (gelf_xlatetom (main, &dst, &src,
-				main_ehdr->e_ident[EI_DATA]) != NULL,
-		 _("cannot read '.gnu.prelink_undo' section: %s"));
-
-      uint_fast16_t phnum;
-      uint_fast16_t shnum;  /* prelink doesn't handle > SHN_LORESERVE.  */
-      if (ehdr.e32.e_ident[EI_CLASS] == ELFCLASS32)
-	{
-	  phnum = ehdr.e32.e_phnum;
-	  shnum = ehdr.e32.e_shnum;
-	}
-      else
-	{
-	  phnum = ehdr.e64.e_phnum;
-	  shnum = ehdr.e64.e_shnum;
-	}
-
-      bool class32 = ehdr.e32.e_ident[EI_CLASS] == ELFCLASS32;
-      size_t shsize = class32 ? sizeof (Elf32_Shdr) : sizeof (Elf64_Shdr);
-      if (unlikely (shnum == 0 || shnum > SIZE_MAX / shsize + 1))
-	error (EXIT_FAILURE, 0, _("overflow with shnum = %zu in '%s' section"),
-	       (size_t) shnum, ".gnu.prelink_undo");
-
-      --shnum;
-
-      size_t phsize = gelf_fsize (main, ELF_T_PHDR, phnum, EV_CURRENT);
-      src.d_buf += src.d_size + phsize;
-      src.d_size = gelf_fsize (main, ELF_T_SHDR, shnum, EV_CURRENT);
-      src.d_type = ELF_T_SHDR;
-      if ((size_t) (src.d_buf - undodata->d_buf) > undodata->d_size
-	  || undodata->d_size - (src.d_buf - undodata->d_buf) != src.d_size)
-	error (EXIT_FAILURE, 0, _("invalid contents in '%s' section"),
-	       ".gnu.prelink_undo");
-
-      const size_t shdr_bytes = shnum * shsize;
-      void *shdr = xmalloc (shdr_bytes);
-      dst.d_buf = shdr;
-      dst.d_size = shdr_bytes;
-      ELF_CHECK (gelf_xlatetom (main, &dst, &src,
-				main_ehdr->e_ident[EI_DATA]) != NULL,
-		 _("cannot read '.gnu.prelink_undo' section: %s"));
-
-      undo_sections = xmalloc (shnum * sizeof undo_sections[0]);
-      for (size_t i = 0; i < shnum; ++i)
-	{
-	  struct section *sec = &undo_sections[undo_nalloc];
-	  Elf32_Shdr (*s32)[shnum] = shdr;
-	  Elf64_Shdr (*s64)[shnum] = shdr;
-	  if (class32)
-	    {
-#define COPY(field) sec->shdr.field = (*s32)[i].field
-	      COPY (sh_name);
-	      COPY (sh_type);
-	      COPY (sh_flags);
-	      COPY (sh_addr);
-	      COPY (sh_offset);
-	      COPY (sh_size);
-	      COPY (sh_link);
-	      COPY (sh_info);
-	      COPY (sh_addralign);
-	      COPY (sh_entsize);
-#undef	COPY
-	    }
-	  else
-	    sec->shdr = (*s64)[i];
-	  if (sec->shdr.sh_flags & SHF_ALLOC)
-	    {
-	      sec->shdr.sh_addr += bias;
-	      sec->name = get_section_name (i + 1, &sec->shdr, main_shstrtab);
-	      sec->scn = elf_getscn (main, i + 1); /* Really just for ndx.  */
-	      sec->outscn = NULL;
-	      sec->strent = NULL;
-	      sec->sig = get_group_sig (main, &sec->shdr);
-	      ++undo_nalloc;
-	    }
-	}
-      qsort (undo_sections, undo_nalloc,
-	     sizeof undo_sections[0], compare_sections_nonrel);
-      free (shdr);
-    }
-
-  bool fail = false;
-  Elf_Scn *scn = NULL;
-  while ((scn = elf_nextscn (debug, scn)) != NULL)
-    {
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-      ELF_CHECK (shdr != NULL, _("cannot get section header: %s"));
-
-      if (!(shdr->sh_flags & SHF_ALLOC))
-	continue;
-
-      const char *name = get_section_name (elf_ndxscn (scn), shdr,
-					   debug_shstrtab);
-
-      if (undo_sections != NULL)
-	{
-	  struct section *sec = find_alloc_section (shdr, 0, name,
-						    undo_sections,
-						    undo_nalloc);
-	  if (sec != NULL)
-	    {
-	      sec->outscn = scn;
-	      continue;
-	    }
-	}
-
-      /* If there is no prelink info, we are just here to find
-	 the sections to give error messages about.  */
-      for (size_t i = 0; shdr != NULL && i < nalloc; ++i)
-	if (sections[i].outscn == scn)
-	  shdr = NULL;
-      fail |= check_match (shdr == NULL, scn, name);
-    }
-
-  if (fail)
-    exit (EXIT_FAILURE);
-
-  /* Now we have lined up output sections for each of the original sections
-     before prelinking.  Translate those to the prelinked sections.
-     This matches what prelink's undo_sections does.  */
-  struct section *split_bss = NULL;
-  for (size_t i = 0; i < undo_nalloc; ++i)
-    {
-      const struct section *undo_sec = &undo_sections[i];
-
-      const char *name = undo_sec->name;
-      scn = undo_sec->scn; /* This is just for elf_ndxscn.  */
-
-      for (size_t j = 0; j < nalloc; ++j)
-	{
-	  struct section *sec = &sections[j];
-#define RELA_SCALED(field) \
-	  (2 * sec->shdr.field == 3 * undo_sec->shdr.field)
-	  if (sec->outscn == NULL
-	      && sec->shdr.sh_name == undo_sec->shdr.sh_name
-	      && sec->shdr.sh_flags == undo_sec->shdr.sh_flags
-	      && sec->shdr.sh_addralign == undo_sec->shdr.sh_addralign
-	      && (((sec->shdr.sh_type == undo_sec->shdr.sh_type
-		    && sec->shdr.sh_entsize == undo_sec->shdr.sh_entsize
-		    && (sec->shdr.sh_size == undo_sec->shdr.sh_size
-			|| (sec->shdr.sh_size > undo_sec->shdr.sh_size
-			    && main_ehdr->e_type == ET_EXEC
-			    && !strcmp (sec->name, ".dynstr"))))
-		   || (sec->shdr.sh_size == undo_sec->shdr.sh_size
-		       && ((sec->shdr.sh_entsize == undo_sec->shdr.sh_entsize
-			    && undo_sec->shdr.sh_type == SHT_NOBITS)
-			   || undo_sec->shdr.sh_type == SHT_PROGBITS)
-		       && !strcmp (sec->name, ".plt")))
-		  || (sec->shdr.sh_type == SHT_RELA
-		      && undo_sec->shdr.sh_type == SHT_REL
-		      && RELA_SCALED (sh_entsize) && RELA_SCALED (sh_size))
-		  || (sec->shdr.sh_entsize == undo_sec->shdr.sh_entsize
-		      && (sec->shdr.sh_type == undo_sec->shdr.sh_type
-			  || (sec->shdr.sh_type == SHT_PROGBITS
-			      && undo_sec->shdr.sh_type == SHT_NOBITS))
-		      && sec->shdr.sh_size <= undo_sec->shdr.sh_size
-		      && (!strcmp (sec->name, ".bss")
-			  || !strcmp (sec->name, ".sbss"))
-		      && (sec->shdr.sh_size == undo_sec->shdr.sh_size
-			  || (split_bss = sec) > sections))))
-	    {
-	      sec->outscn = undo_sec->outscn;
-	      undo_sec = NULL;
-	      break;
-	    }
-	}
-
-      fail |= check_match (undo_sec == NULL, scn, name);
-    }
-
-  free (undo_sections);
-
-  if (fail)
-    exit (EXIT_FAILURE);
-
-  return split_bss;
-}
-
-/* Create new .shstrtab contents, subroutine of copy_elided_sections.
-   This can't be open coded there and still use variable-length auto arrays,
-   since the end of our block would free other VLAs too.  */
-static Elf_Data *
-new_shstrtab (Elf *unstripped, size_t unstripped_shnum,
-	      Elf_Data *shstrtab, size_t unstripped_shstrndx,
-	      struct section *sections, size_t stripped_shnum,
-	      Dwelf_Strtab *strtab)
-{
-  if (strtab == NULL)
-    return NULL;
-
-  Dwelf_Strent *unstripped_strent[unstripped_shnum];
-  memset (unstripped_strent, 0, sizeof unstripped_strent);
-  for (struct section *sec = sections;
-       sec < &sections[stripped_shnum - 1];
-       ++sec)
-    if (sec->outscn != NULL)
-      {
-	if (sec->strent == NULL)
-	  {
-	    sec->strent = dwelf_strtab_add (strtab, sec->name);
-	    ELF_CHECK (sec->strent != NULL,
-		       _("cannot add section name to string table: %s"));
-	  }
-	unstripped_strent[elf_ndxscn (sec->outscn) - 1] = sec->strent;
-      }
-
-  /* Add names of sections we aren't touching.  */
-  for (size_t i = 0; i < unstripped_shnum - 1; ++i)
-    if (unstripped_strent[i] == NULL)
-      {
-	Elf_Scn *scn = elf_getscn (unstripped, i + 1);
-	GElf_Shdr shdr_mem;
-	GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-	ELF_CHECK (shdr != NULL, _("cannot get section header: %s"));
-	const char *name = get_section_name (i + 1, shdr, shstrtab);
-	unstripped_strent[i] = dwelf_strtab_add (strtab, name);
-	ELF_CHECK (unstripped_strent[i] != NULL,
-		   _("cannot add section name to string table: %s"));
-      }
-    else
-      unstripped_strent[i] = NULL;
-
-  /* Now finalize the string table so we can get offsets.  */
-  Elf_Data *strtab_data = elf_getdata (elf_getscn (unstripped,
-						   unstripped_shstrndx), NULL);
-  ELF_CHECK (elf_flagdata (strtab_data, ELF_C_SET, ELF_F_DIRTY),
-	     _("cannot update section header string table data: %s"));
-  if (dwelf_strtab_finalize (strtab, strtab_data) == NULL)
-    error (EXIT_FAILURE, 0, "Not enough memory to create string table");
-
-  /* Update the sh_name fields of sections we aren't modifying later.  */
-  for (size_t i = 0; i < unstripped_shnum - 1; ++i)
-    if (unstripped_strent[i] != NULL)
-      {
-	Elf_Scn *scn = elf_getscn (unstripped, i + 1);
-	GElf_Shdr shdr_mem;
-	GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-	ELF_CHECK (shdr != NULL, _("cannot get section header: %s"));
-	shdr->sh_name = dwelf_strent_off (unstripped_strent[i]);
-	if (i + 1 == unstripped_shstrndx)
-	  shdr->sh_size = strtab_data->d_size;
-	update_shdr (scn, shdr);
-      }
-
-  return strtab_data;
-}
-
-/* Fill in any SHT_NOBITS sections in UNSTRIPPED by
-   copying their contents and sh_type from STRIPPED.  */
-static void
-copy_elided_sections (Elf *unstripped, Elf *stripped,
-		      const GElf_Ehdr *stripped_ehdr, GElf_Addr bias)
-{
-  size_t unstripped_shstrndx;
-  ELF_CHECK (elf_getshdrstrndx (unstripped, &unstripped_shstrndx) == 0,
-	     _("cannot get section header string table section index: %s"));
-
-  size_t stripped_shstrndx;
-  ELF_CHECK (elf_getshdrstrndx (stripped, &stripped_shstrndx) == 0,
-	     _("cannot get section header string table section index: %s"));
-
-  size_t unstripped_shnum;
-  ELF_CHECK (elf_getshdrnum (unstripped, &unstripped_shnum) == 0,
-	     _("cannot get section count: %s"));
-
-  size_t stripped_shnum;
-  ELF_CHECK (elf_getshdrnum (stripped, &stripped_shnum) == 0,
-	     _("cannot get section count: %s"));
-
-  if (unlikely (stripped_shnum > unstripped_shnum))
-    error (EXIT_FAILURE, 0, _("\
-more sections in stripped file than debug file -- arguments reversed?"));
-
-  if (unlikely (stripped_shnum == 0))
-    error (EXIT_FAILURE, 0, _("no sections in stripped file"));
-
-  /* Used as sanity check for allocated section offset, if the section
-     offset needs to be preserved.  We want to know the max size of the
-     ELF file, to check if any existing section offsets are OK.  */
-  int64_t max_off = -1;
-  if (stripped_ehdr->e_type != ET_REL)
-    {
-      elf_flagelf (stripped, ELF_C_SET, ELF_F_LAYOUT);
-      max_off = elf_update (stripped, ELF_C_NULL);
-    }
-
-  /* Cache the stripped file's section details.  */
-  struct section sections[stripped_shnum - 1];
-  Elf_Scn *scn = NULL;
-  while ((scn = elf_nextscn (stripped, scn)) != NULL)
-    {
-      size_t i = elf_ndxscn (scn) - 1;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &sections[i].shdr);
-      ELF_CHECK (shdr != NULL, _("cannot get section header: %s"));
-      sections[i].name = elf_strptr (stripped, stripped_shstrndx,
-				     shdr->sh_name);
-      if (sections[i].name == NULL)
-	error (EXIT_FAILURE, 0, _("cannot read section [%zu] name: %s"),
-	       elf_ndxscn (scn), elf_errmsg (-1));
-      sections[i].scn = scn;
-      sections[i].outscn = NULL;
-      sections[i].strent = NULL;
-      sections[i].sig = get_group_sig (stripped, shdr);
-    }
-
-  const struct section *stripped_symtab = NULL;
-
-  /* Sort the sections, allocated by address and others after.  */
-  qsort (sections, stripped_shnum - 1, sizeof sections[0],
-	 stripped_ehdr->e_type == ET_REL
-	 ? compare_sections_rel : compare_sections_nonrel);
-  size_t nalloc = stripped_shnum - 1;
-  while (nalloc > 0 && !(sections[nalloc - 1].shdr.sh_flags & SHF_ALLOC))
-    {
-      --nalloc;
-      if (sections[nalloc].shdr.sh_type == SHT_SYMTAB)
-	stripped_symtab = &sections[nalloc];
-    }
-
-  Elf_Data *shstrtab = elf_getdata (elf_getscn (unstripped,
-						unstripped_shstrndx), NULL);
-  ELF_CHECK (shstrtab != NULL,
-	     _("cannot read section header string table: %s"));
-
-  /* Match each debuginfo section with its corresponding stripped section.  */
-  bool check_prelink = false;
-  Elf_Scn *unstripped_symtab = NULL;
-  size_t unstripped_strndx = 0;
-  size_t alloc_avail = 0;
-  scn = NULL;
-  while ((scn = elf_nextscn (unstripped, scn)) != NULL)
-    {
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-      ELF_CHECK (shdr != NULL, _("cannot get section header: %s"));
-
-      if (shdr->sh_type == SHT_SYMTAB)
-	{
-	  unstripped_symtab = scn;
-	  unstripped_strndx = shdr->sh_link;
-	  continue;
-	}
-
-      const size_t ndx = elf_ndxscn (scn);
-      if (ndx == unstripped_shstrndx || ndx == unstripped_strndx)
-	continue;
-
-      const char *name = get_section_name (ndx, shdr, shstrtab);
-
-      struct section *sec = NULL;
-      if (shdr->sh_flags & SHF_ALLOC)
-	{
-	  if (stripped_ehdr->e_type != ET_REL)
-	    {
-	      /* Look for the section that matches.  */
-	      sec = find_alloc_section (shdr, bias, name, sections, nalloc);
-	      if (sec == NULL)
-		{
-		  /* We couldn't figure it out.  It may be a prelink issue.  */
-		  check_prelink = true;
-		  continue;
-		}
-	    }
-	  else
-	    {
-	      /* The sh_addr of allocated sections does not help us,
-		 but the order usually matches.  */
-	      if (likely (sections_match (sections, alloc_avail, shdr, name)))
-		sec = &sections[alloc_avail++];
-	      else
-		for (size_t i = alloc_avail + 1; i < nalloc; ++i)
-		  if (sections_match (sections, i, shdr, name))
-		    {
-		      sec = &sections[i];
-		      break;
-		    }
-	    }
-	}
-      else
-	{
-	  /* Locate a matching unallocated section in SECTIONS.  */
-	  const char *sig = get_group_sig (unstripped, shdr);
-	  size_t l = nalloc, u = stripped_shnum - 1;
-	  while (l < u)
-	    {
-	      size_t i = (l + u) / 2;
-	      struct section *section = &sections[i];
-	      int cmp = compare_unalloc_sections (shdr, &section->shdr,
-						  name, section->name,
-						  sig, section->sig);
-	      if (cmp < 0)
-		u = i;
-	      else if (cmp > 0)
-		l = i + 1;
-	      else
-		{
-		  sec = section;
-		  break;
-		}
-	    }
-
-	  if (sec == NULL)
-	    {
-	      /* An additional unallocated section is fine if not SHT_NOBITS.
-		 We looked it up anyway in case it's an unallocated section
-		 copied in both files (e.g. SHT_NOTE), and don't keep both.  */
-	      if (shdr->sh_type != SHT_NOBITS)
-		continue;
-
-	      /* Somehow some old .debug files wound up with SHT_NOBITS
-		 .comment sections, so let those pass.  */
-	      if (!strcmp (name, ".comment"))
-		continue;
-	    }
-	}
-
-      if (sec == NULL)
-	error (EXIT_FAILURE, 0,
-	       _("cannot find matching section for [%zu] '%s'"),
-	       elf_ndxscn (scn), name);
-
-      sec->outscn = scn;
-    }
-
-  /* If that failed due to changes made by prelink, we take another tack.
-     We keep track of a .bss section that was partly split into .dynbss
-     so that collect_symbols can update symbols' st_shndx fields.  */
-  struct section *split_bss = NULL;
-  if (check_prelink)
-    {
-      Elf_Data *data = elf_getdata (elf_getscn (stripped, stripped_shstrndx),
-				    NULL);
-      ELF_CHECK (data != NULL,
-		 _("cannot read section header string table: %s"));
-      split_bss = find_alloc_sections_prelink (unstripped, shstrtab,
-					       stripped, stripped_ehdr,
-					       data, bias, sections,
-					       nalloc, stripped_shnum - 1);
-    }
-
-  /* Make sure each main file section has a place to go.  */
-  const struct section *stripped_dynsym = NULL;
-  size_t debuglink = SHN_UNDEF;
-  size_t ndx_sec_num = stripped_shnum - 1;
-  size_t ndx_section[ndx_sec_num];
-  Dwelf_Strtab *strtab = NULL;
-  for (struct section *sec = sections;
-       sec < &sections[ndx_sec_num];
-       ++sec)
-    {
-      size_t secndx = elf_ndxscn (sec->scn);
-
-      if (sec->outscn == NULL)
-	{
-	  /* We didn't find any corresponding section for this.  */
-
-	  if (secndx == stripped_shstrndx)
-	    {
-	      /* We only need one .shstrtab.  */
-	      ndx_section[secndx - 1] = unstripped_shstrndx;
-	      continue;
-	    }
-
-	  if (unstripped_symtab != NULL && sec == stripped_symtab)
-	    {
-	      /* We don't need a second symbol table.  */
-	      ndx_section[secndx - 1] = elf_ndxscn (unstripped_symtab);
-	      continue;
-	    }
-
-	  if (unstripped_symtab != NULL && stripped_symtab != NULL
-	      && secndx == stripped_symtab->shdr.sh_link
-	      && unstripped_strndx != 0)
-	    {
-	      /* ... nor its string table.  */
-	      ndx_section[secndx - 1] = unstripped_strndx;
-	      continue;
-	    }
-
-	  if (!(sec->shdr.sh_flags & SHF_ALLOC)
-	      && !strcmp (sec->name, ".gnu_debuglink"))
-	    {
-	      /* This was created by stripping.  We don't want it.  */
-	      debuglink = secndx;
-	      ndx_section[secndx - 1] = SHN_UNDEF;
-	      continue;
-	    }
-
-	  sec->outscn = elf_newscn (unstripped);
-	  Elf_Data *newdata = elf_newdata (sec->outscn);
-	  ELF_CHECK (newdata != NULL && gelf_update_shdr (sec->outscn,
-							  &sec->shdr),
-		     _("cannot add new section: %s"));
-
-	  if (strtab == NULL)
-	    strtab = dwelf_strtab_init (true);
-	  sec->strent = dwelf_strtab_add (strtab, sec->name);
-	  ELF_CHECK (sec->strent != NULL,
-		     _("cannot add section name to string table: %s"));
-	}
-
-      /* Cache the mapping of original section indices to output sections.  */
-      ndx_section[secndx - 1] = elf_ndxscn (sec->outscn);
-    }
-
-  /* We added some sections, so we need a new shstrtab.  */
-  Elf_Data *strtab_data = new_shstrtab (unstripped, unstripped_shnum,
-					shstrtab, unstripped_shstrndx,
-					sections, stripped_shnum,
-					strtab);
-
-  /* Get the updated section count.  */
-  ELF_CHECK (elf_getshdrnum (unstripped, &unstripped_shnum) == 0,
-	     _("cannot get section count: %s"));
-
-  bool placed[unstripped_shnum - 1];
-  memset (placed, 0, sizeof placed);
-
-  /* Now update the output sections and copy in their data.  */
-  GElf_Off offset = 0;
-  for (const struct section *sec = sections;
-       sec < &sections[stripped_shnum - 1];
-       ++sec)
-    if (sec->outscn != NULL)
-      {
-	GElf_Shdr shdr_mem;
-	GElf_Shdr *shdr = gelf_getshdr (sec->outscn, &shdr_mem);
-	ELF_CHECK (shdr != NULL, _("cannot get section header: %s"));
-
-	/* In an ET_REL file under --relocate, the sh_addr of SHF_ALLOC
-	   sections will have been set nonzero by relocation.  This
-	   touched the shdrs of whichever file had the symtab.  sh_addr
-	   is still zero in the corresponding shdr.  The relocated
-	   address is what we want to use.  */
-	if (stripped_ehdr->e_type != ET_REL
-	    || !(shdr_mem.sh_flags & SHF_ALLOC)
-	    || shdr_mem.sh_addr == 0)
-	  shdr_mem.sh_addr = sec->shdr.sh_addr;
-
-	shdr_mem.sh_type = sec->shdr.sh_type;
-	shdr_mem.sh_size = sec->shdr.sh_size;
-	shdr_mem.sh_info = sec->shdr.sh_info;
-	shdr_mem.sh_link = sec->shdr.sh_link;
-
-	/* Buggy binutils objdump might have stripped the SHF_INFO_LINK
-	   put it back if necessary.  */
-	if ((sec->shdr.sh_type == SHT_REL || sec->shdr.sh_type == SHT_RELA)
-	    && sec->shdr.sh_flags != shdr_mem.sh_flags
-	    && (sec->shdr.sh_flags & SHF_INFO_LINK) != 0)
-	  shdr_mem.sh_flags |= SHF_INFO_LINK;
-
-	if (sec->shdr.sh_link != SHN_UNDEF)
-	  {
-	    if (sec->shdr.sh_link > ndx_sec_num)
-	      error (EXIT_FAILURE, 0,
-		     "section [%zd] has invalid sh_link %" PRId32,
-		     elf_ndxscn (sec->scn), sec->shdr.sh_link);
-	    shdr_mem.sh_link = ndx_section[sec->shdr.sh_link - 1];
-	  }
-	if (SH_INFO_LINK_P (&sec->shdr) && sec->shdr.sh_info != 0)
-	  {
-	    if (sec->shdr.sh_info > ndx_sec_num)
-	      error (EXIT_FAILURE, 0,
-		     "section [%zd] has invalid sh_info %" PRId32,
-		     elf_ndxscn (sec->scn), sec->shdr.sh_info);
-	    shdr_mem.sh_info = ndx_section[sec->shdr.sh_info - 1];
-	  }
-
-	if (strtab != NULL)
-	  shdr_mem.sh_name = dwelf_strent_off (sec->strent);
-
-	Elf_Data *indata = elf_getdata (sec->scn, NULL);
-	ELF_CHECK (indata != NULL, _("cannot get section data: %s"));
-	Elf_Data *outdata = elf_getdata (sec->outscn, NULL);
-	ELF_CHECK (outdata != NULL, _("cannot copy section data: %s"));
-	*outdata = *indata;
-	elf_flagdata (outdata, ELF_C_SET, ELF_F_DIRTY);
-
-	/* Preserve the file layout of the allocated sections.  */
-	if (stripped_ehdr->e_type != ET_REL && (shdr_mem.sh_flags & SHF_ALLOC))
-	  {
-	    if (max_off > 0 && sec->shdr.sh_offset > (Elf64_Off) max_off)
-		error (EXIT_FAILURE, 0,
-		       "allocated section offset too large [%zd] %" PRIx64,
-		       elf_ndxscn (sec->scn), sec->shdr.sh_offset);
-
-	    shdr_mem.sh_offset = sec->shdr.sh_offset;
-	    placed[elf_ndxscn (sec->outscn) - 1] = true;
-
-	    const GElf_Off end_offset = (shdr_mem.sh_offset
-					 + (shdr_mem.sh_type == SHT_NOBITS
-					    ? 0 : shdr_mem.sh_size));
-	    if (end_offset > offset)
-	      offset = end_offset;
-	  }
-
-	update_shdr (sec->outscn, &shdr_mem);
-
-	if (shdr_mem.sh_type == SHT_SYMTAB || shdr_mem.sh_type == SHT_DYNSYM)
-	  {
-	    /* We must adjust all the section indices in the symbol table.  */
-
-	    Elf_Data *shndxdata = NULL;	/* XXX */
-
-	    if (shdr_mem.sh_entsize == 0)
-	      error (EXIT_FAILURE, 0,
-		     "SYMTAB section cannot have zero sh_entsize");
-	    for (size_t i = 1; i < shdr_mem.sh_size / shdr_mem.sh_entsize; ++i)
-	      {
-		GElf_Sym sym_mem;
-		GElf_Word shndx = SHN_UNDEF;
-		GElf_Sym *sym = gelf_getsymshndx (outdata, shndxdata,
-						  i, &sym_mem, &shndx);
-		ELF_CHECK (sym != NULL,
-			   _("cannot get symbol table entry: %s"));
-		if (sym->st_shndx != SHN_XINDEX)
-		  shndx = sym->st_shndx;
-
-		if (shndx != SHN_UNDEF && shndx < SHN_LORESERVE)
-		  {
-		    if (shndx >= stripped_shnum)
-		      error (EXIT_FAILURE, 0,
-			     _("symbol [%zu] has invalid section index"), i);
-
-		    shndx = ndx_section[shndx - 1];
-		    if (shndx < SHN_LORESERVE)
-		      {
-			sym->st_shndx = shndx;
-			shndx = SHN_UNDEF;
-		      }
-		    else
-		      sym->st_shndx = SHN_XINDEX;
-
-		    ELF_CHECK (gelf_update_symshndx (outdata, shndxdata,
-						     i, sym, shndx),
-			       _("cannot update symbol table: %s"));
-		  }
-	      }
-
-	    if (shdr_mem.sh_type == SHT_SYMTAB)
-	      stripped_symtab = sec;
-	    if (shdr_mem.sh_type == SHT_DYNSYM)
-	      stripped_dynsym = sec;
-	  }
-
-	if (shdr_mem.sh_type == SHT_GROUP)
-	  {
-	    /* We must adjust all the section indices in the group.
-	       Skip the first word, which is the section group flag.
-	       Everything else is a section index.  */
-	    Elf32_Word *shndx = (Elf32_Word *) outdata->d_buf;
-	    for (size_t i = 1; i < shdr_mem.sh_size / sizeof (Elf32_Word); ++i)
-	      if (shndx[i]  == SHN_UNDEF || shndx[i] >= stripped_shnum)
-		error (EXIT_FAILURE, 0,
-		       _("group has invalid section index [%zd]"), i);
-	      else
-		shndx[i] = ndx_section[shndx[i] - 1];
-	  }
-      }
-
-  /* We may need to update the symbol table.  */
-  Elf_Data *symdata = NULL;
-  Dwelf_Strtab *symstrtab = NULL;
-  Elf_Data *symstrdata = NULL;
-  if (unstripped_symtab != NULL && (stripped_symtab != NULL
-				    || check_prelink /* Section adjustments. */
-				    || (stripped_ehdr->e_type != ET_REL
-					&& bias != 0)))
-    {
-      /* Merge the stripped file's symbol table into the unstripped one.  */
-      const size_t stripped_nsym = (stripped_symtab == NULL ? 1
-				    : (stripped_symtab->shdr.sh_size
-				       / (stripped_symtab->shdr.sh_entsize == 0
-					  ? 1
-					  : stripped_symtab->shdr.sh_entsize)));
-
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (unstripped_symtab, &shdr_mem);
-      ELF_CHECK (shdr != NULL, _("cannot get section header: %s"));
-      if (shdr->sh_entsize == 0)
-	error (EXIT_FAILURE, 0,
-	       "unstripped SYMTAB section cannot have zero sh_entsize");
-      const size_t unstripped_nsym = shdr->sh_size / shdr->sh_entsize;
-
-      /* First collect all the symbols from both tables.  */
-
-      const size_t total_syms = stripped_nsym - 1 + unstripped_nsym - 1;
-      struct symbol *symbols = xmalloc (total_syms * sizeof (struct symbol));
-      size_t *symndx_map = xmalloc (total_syms * sizeof (size_t));
-
-      if (stripped_symtab != NULL)
-	collect_symbols (unstripped, stripped_ehdr->e_type == ET_REL,
-			 stripped_symtab->scn,
-			 elf_getscn (stripped, stripped_symtab->shdr.sh_link),
-			 stripped_nsym, 0, ndx_section,
-			 symbols, symndx_map, NULL);
-
-      Elf_Scn *unstripped_strtab = elf_getscn (unstripped, shdr->sh_link);
-      collect_symbols (unstripped, stripped_ehdr->e_type == ET_REL,
-		       unstripped_symtab, unstripped_strtab, unstripped_nsym,
-		       stripped_ehdr->e_type == ET_REL ? 0 : bias, NULL,
-		       &symbols[stripped_nsym - 1],
-		       &symndx_map[stripped_nsym - 1], split_bss);
-
-      /* Next, sort our array of all symbols.  */
-      qsort (symbols, total_syms, sizeof symbols[0], compare_symbols);
-
-      /* Now we can weed out the duplicates.  Assign remaining symbols
-	 new slots, collecting a map from old indices to new.  */
-      size_t nsym = 0;
-      for (struct symbol *s = symbols; s < &symbols[total_syms]; ++s)
-	{
-	  /* Skip a section symbol for a removed section.  */
-	  if (s->shndx == SHN_UNDEF
-	      && GELF_ST_TYPE (s->info.info) == STT_SECTION)
-	    {
-	      s->name = NULL;	/* Mark as discarded. */
-	      *s->map = STN_UNDEF;
-	      s->duplicate = NULL;
-	      continue;
-	    }
-
-	  struct symbol *n = s;
-	  while (n + 1 < &symbols[total_syms] && !compare_symbols (s, n + 1))
-	    ++n;
-
-	  while (s < n)
-	    {
-	      /* This is a duplicate.  Its twin will get the next slot.  */
-	      s->name = NULL;	/* Mark as discarded. */
-	      s->duplicate = n->map;
-	      ++s;
-	    }
-
-	  /* Allocate the next slot.  */
-	  *s->map = ++nsym;
-	}
-
-      /* Now we sort again, to determine the order in the output.  */
-      qsort (symbols, total_syms, sizeof symbols[0], compare_symbols_output);
-
-      if (nsym < total_syms)
-	/* The discarded symbols are now at the end of the table.  */
-	assert (symbols[nsym].name == NULL);
-
-      /* Now a final pass updates the map with the final order,
-	 and builds up the new string table.  */
-      symstrtab = dwelf_strtab_init (true);
-      for (size_t i = 0; i < nsym; ++i)
-	{
-	  assert (symbols[i].name != NULL);
-	  assert (*symbols[i].map != 0);
-	  *symbols[i].map = 1 + i;
-	  symbols[i].strent = dwelf_strtab_add (symstrtab, symbols[i].name);
-	}
-
-      /* Scan the discarded symbols too, just to update their slots
-	 in SYMNDX_MAP to refer to their live duplicates.  */
-      for (size_t i = nsym; i < total_syms; ++i)
-	{
-	  assert (symbols[i].name == NULL);
-	  if (symbols[i].duplicate == NULL)
-	    assert (*symbols[i].map == STN_UNDEF);
-	  else
-	    {
-	      assert (*symbols[i].duplicate != STN_UNDEF);
-	      *symbols[i].map = *symbols[i].duplicate;
-	    }
-	}
-
-      /* Now we are ready to write the new symbol table.  */
-      symdata = elf_getdata (unstripped_symtab, NULL);
-      symstrdata = elf_getdata (unstripped_strtab, NULL);
-      Elf_Data *shndxdata = NULL;	/* XXX */
-
-      /* If symtab and the section header table share the string table
-	 add the section names to the strtab and then (after finalizing)
-	 fixup the section header sh_names.  Also dispose of the old data.  */
-      Dwelf_Strent *unstripped_strent[unstripped_shnum - 1];
-      if (unstripped_shstrndx == elf_ndxscn (unstripped_strtab))
-	{
-	  for (size_t i = 0; i < unstripped_shnum - 1; ++i)
-	    {
-	      Elf_Scn *sec = elf_getscn (unstripped, i + 1);
-	      GElf_Shdr mem;
-	      GElf_Shdr *hdr = gelf_getshdr (sec, &mem);
-	      const char *name = get_section_name (i + 1, hdr, shstrtab);
-	      unstripped_strent[i] = dwelf_strtab_add (symstrtab, name);
-	      ELF_CHECK (unstripped_strent[i] != NULL,
-			 _("cannot add section name to string table: %s"));
-	    }
-
-	  if (strtab != NULL)
-	    {
-	      dwelf_strtab_free (strtab);
-	      free (strtab_data->d_buf);
-	      strtab = NULL;
-	    }
-	}
-
-      if (dwelf_strtab_finalize (symstrtab, symstrdata) == NULL)
-	error (EXIT_FAILURE, 0, "Not enough memory to create symbol table");
-
-      elf_flagdata (symstrdata, ELF_C_SET, ELF_F_DIRTY);
-
-      /* And update the section header names if necessary.  */
-      if (unstripped_shstrndx == elf_ndxscn (unstripped_strtab))
-	{
-	  for (size_t i = 0; i < unstripped_shnum - 1; ++i)
-	    {
-	      Elf_Scn *sec = elf_getscn (unstripped, i + 1);
-	      GElf_Shdr mem;
-	      GElf_Shdr *hdr = gelf_getshdr (sec, &mem);
-	      shdr->sh_name = dwelf_strent_off (unstripped_strent[i]);
-	      update_shdr (sec, hdr);
-	    }
-	}
-
-      /* Now update the symtab shdr.  Reload symtab shdr because sh_name
-	 might have changed above. */
-      shdr = gelf_getshdr (unstripped_symtab, &shdr_mem);
-      ELF_CHECK (shdr != NULL, _("cannot get section header: %s"));
-
-      shdr->sh_size = symdata->d_size = (1 + nsym) * shdr->sh_entsize;
-      symdata->d_buf = xmalloc (symdata->d_size);
-      record_new_data (symdata->d_buf);
-
-      GElf_Sym sym;
-      memset (&sym, 0, sizeof sym);
-      ELF_CHECK (gelf_update_symshndx (symdata, shndxdata, 0, &sym, SHN_UNDEF),
-		 _("cannot update symbol table: %s"));
-
-      shdr->sh_info = 1;
-      for (size_t i = 0; i < nsym; ++i)
-	{
-	  struct symbol *s = &symbols[i];
-
-	  /* Fill in the symbol details.  */
-	  sym.st_name = dwelf_strent_off (s->strent);
-	  sym.st_value = s->value; /* Already biased to output address.  */
-	  sym.st_size = s->size;
-	  sym.st_shndx = s->shndx; /* Already mapped to output index.  */
-	  sym.st_info = s->info.info;
-	  sym.st_other = s->info.other;
-
-	  /* Keep track of the number of leading local symbols.  */
-	  if (GELF_ST_BIND (sym.st_info) == STB_LOCAL)
-	    {
-	      assert (shdr->sh_info == 1 + i);
-	      shdr->sh_info = 1 + i + 1;
-	    }
-
-	  ELF_CHECK (gelf_update_symshndx (symdata, shndxdata, 1 + i,
-					   &sym, SHN_UNDEF),
-		     _("cannot update symbol table: %s"));
-
-	}
-      elf_flagdata (symdata, ELF_C_SET, ELF_F_DIRTY);
-      update_shdr (unstripped_symtab, shdr);
-
-      if (stripped_symtab != NULL)
-	{
-	  /* Adjust any relocations referring to the old symbol table.  */
-	  const size_t old_sh_link = elf_ndxscn (stripped_symtab->scn);
-	  for (const struct section *sec = sections;
-	       sec < &sections[stripped_shnum - 1];
-	       ++sec)
-	    if (sec->outscn != NULL && sec->shdr.sh_link == old_sh_link)
-	      adjust_relocs (sec->outscn, sec->scn, &sec->shdr,
-			     symndx_map, total_syms, shdr);
-	}
-
-      /* Also adjust references to the other old symbol table.  */
-      adjust_all_relocs (unstripped, unstripped_symtab, shdr,
-			 &symndx_map[stripped_nsym - 1],
-			 total_syms - (stripped_nsym - 1));
-
-      free (symbols);
-      free (symndx_map);
-    }
-  else if (stripped_symtab != NULL && stripped_shnum != unstripped_shnum)
-    check_symtab_section_symbols (unstripped,
-				  stripped_ehdr->e_type == ET_REL,
-				  stripped_symtab->scn,
-				  unstripped_shnum, unstripped_shstrndx,
-				  stripped_symtab->outscn,
-				  stripped_shnum, stripped_shstrndx,
-				  debuglink);
-
-  if (stripped_dynsym != NULL)
-    (void) check_symtab_section_symbols (unstripped,
-					 stripped_ehdr->e_type == ET_REL,
-					 stripped_dynsym->outscn,
-					 unstripped_shnum,
-					 unstripped_shstrndx,
-					 stripped_dynsym->scn, stripped_shnum,
-					 stripped_shstrndx, debuglink);
-
-  /* We need to preserve the layout of the stripped file so the
-     phdrs will match up.  This requires us to do our own layout of
-     the added sections.  We do manual layout even for ET_REL just
-     so we can try to match what the original probably had.  */
-
-  elf_flagelf (unstripped, ELF_C_SET, ELF_F_LAYOUT);
-
-  if (offset == 0)
-    /* For ET_REL we are starting the layout from scratch.  */
-    offset = gelf_fsize (unstripped, ELF_T_EHDR, 1, EV_CURRENT);
-
-  bool skip_reloc = false;
-  do
-    {
-      skip_reloc = !skip_reloc;
-      for (size_t i = 0; i < unstripped_shnum - 1; ++i)
-	if (!placed[i])
-	  {
-	    scn = elf_getscn (unstripped, 1 + i);
-
-	    GElf_Shdr shdr_mem;
-	    GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-	    ELF_CHECK (shdr != NULL, _("cannot get section header: %s"));
-
-	    /* We must make sure we have read in the data of all sections
-	       beforehand and marked them to be written out.  When we're
-	       modifying the existing file in place, we might overwrite
-	       this part of the file before we get to handling the section.  */
-
-	    ELF_CHECK (elf_flagdata (elf_getdata (scn, NULL),
-				     ELF_C_SET, ELF_F_DIRTY),
-		       _("cannot read section data: %s"));
-
-	    if (skip_reloc
-		&& (shdr->sh_type == SHT_REL || shdr->sh_type == SHT_RELA))
-	      continue;
-
-	    GElf_Off align = shdr->sh_addralign ?: 1;
-	    offset = (offset + align - 1) & -align;
-	    shdr->sh_offset = offset;
-	    if (shdr->sh_type != SHT_NOBITS)
-	      offset += shdr->sh_size;
-
-	    update_shdr (scn, shdr);
-
-	    if (unstripped_shstrndx == 1 + i)
-	      {
-		/* Place the section headers immediately after
-		   .shstrtab, and update the ELF header.  */
-
-		GElf_Ehdr ehdr_mem;
-		GElf_Ehdr *ehdr = gelf_getehdr (unstripped, &ehdr_mem);
-		ELF_CHECK (ehdr != NULL, _("cannot get ELF header: %s"));
-
-		GElf_Off sh_align = gelf_getclass (unstripped) * 4;
-		offset = (offset + sh_align - 1) & -sh_align;
-		ehdr->e_shnum = unstripped_shnum;
-		ehdr->e_shoff = offset;
-		offset += unstripped_shnum * ehdr->e_shentsize;
-		ELF_CHECK (gelf_update_ehdr (unstripped, ehdr),
-			   _("cannot update ELF header: %s"));
-	      }
-
-	    placed[i] = true;
-	  }
-    }
-  while (skip_reloc);
-
-  size_t phnum;
-  ELF_CHECK (elf_getphdrnum (stripped, &phnum) == 0,
-	     _("cannot get number of program headers: %s"));
-
-  if (phnum > 0)
-    ELF_CHECK (gelf_newphdr (unstripped, phnum),
-	       _("cannot create program headers: %s"));
-
-  /* Copy each program header from the stripped file.  */
-  for (size_t i = 0; i < phnum; ++i)
-    {
-      GElf_Phdr phdr_mem;
-      GElf_Phdr *phdr = gelf_getphdr (stripped, i, &phdr_mem);
-      ELF_CHECK (phdr != NULL, _("cannot get program header: %s"));
-
-      ELF_CHECK (gelf_update_phdr (unstripped, i, phdr),
-		 _("cannot update program header: %s"));
-    }
-
-  /* Finally, write out the file.  */
-  ELF_CHECK (elf_update (unstripped, ELF_C_WRITE) > 0,
-	     _("cannot write output file: %s"));
-
-  if (strtab != NULL)
-    {
-      dwelf_strtab_free (strtab);
-      free (strtab_data->d_buf);
-    }
-
-  if (symstrtab != NULL)
-    {
-      dwelf_strtab_free (symstrtab);
-      free (symstrdata->d_buf);
-    }
-  free_new_data ();
-}
-
-/* Process one pair of files, already opened.  */
-static void
-handle_file (const char *output_file, bool create_dirs,
-	     Elf *stripped, const GElf_Ehdr *stripped_ehdr,
-	     Elf *unstripped)
-{
-  size_t phnum;
-  ELF_CHECK (elf_getphdrnum (stripped, &phnum) == 0,
-	     _("cannot get number of program headers: %s"));
-
-  /* Determine the address bias between the debuginfo file and the main
-     file, which may have been modified by prelinking.  */
-  GElf_Addr bias = 0;
-  if (unstripped != NULL)
-    for (size_t i = 0; i < phnum; ++i)
-      {
-	GElf_Phdr phdr_mem;
-	GElf_Phdr *phdr = gelf_getphdr (stripped, i, &phdr_mem);
-	ELF_CHECK (phdr != NULL, _("cannot get program header: %s"));
-	if (phdr->p_type == PT_LOAD)
-	  {
-	    GElf_Phdr unstripped_phdr_mem;
-	    GElf_Phdr *unstripped_phdr = gelf_getphdr (unstripped, i,
-						       &unstripped_phdr_mem);
-	    ELF_CHECK (unstripped_phdr != NULL,
-		       _("cannot get program header: %s"));
-	    bias = phdr->p_vaddr - unstripped_phdr->p_vaddr;
-	    break;
-	  }
-      }
-
-  /* One day we could adjust all the DWARF data (like prelink itself does).  */
-  if (bias != 0)
-    {
-      if (output_file == NULL)
-	error (0, 0, _("\
-DWARF data not adjusted for prelinking bias; consider prelink -u"));
-      else
-	error (0, 0, _("\
-DWARF data in '%s' not adjusted for prelinking bias; consider prelink -u"),
-	       output_file);
-    }
-
-  if (output_file == NULL)
-    /* Modify the unstripped file in place.  */
-    copy_elided_sections (unstripped, stripped, stripped_ehdr, bias);
-  else
-    {
-      if (create_dirs)
-	make_directories (output_file);
-
-      /* Copy the unstripped file and then modify it.  */
-      int outfd = open (output_file, O_RDWR | O_CREAT,
-			(stripped_ehdr->e_type == ET_REL
-			 ? DEFFILEMODE : ACCESSPERMS));
-      if (outfd < 0)
-	error (EXIT_FAILURE, errno, _("cannot open '%s'"), output_file);
-      Elf *outelf = elf_begin (outfd, ELF_C_WRITE, NULL);
-      ELF_CHECK (outelf != NULL, _("cannot create ELF descriptor: %s"));
-
-      if (unstripped == NULL)
-	{
-	  /* Actually, we are just copying out the main file as it is.  */
-	  copy_elf (outelf, stripped);
-	  if (stripped_ehdr->e_type != ET_REL)
-	    elf_flagelf (outelf, ELF_C_SET, ELF_F_LAYOUT);
-	  ELF_CHECK (elf_update (outelf, ELF_C_WRITE) > 0,
-		     _("cannot write output file: %s"));
-	}
-      else
-	{
-	  copy_elf (outelf, unstripped);
-	  copy_elided_sections (outelf, stripped, stripped_ehdr, bias);
-	}
-
-      elf_end (outelf);
-      close (outfd);
-    }
-}
-
-static int
-open_file (const char *file, bool writable)
-{
-  int fd = open (file, writable ? O_RDWR : O_RDONLY);
-  if (fd < 0)
-    error (EXIT_FAILURE, errno, _("cannot open '%s'"), file);
-  return fd;
-}
-
-/* Warn, and exit if not forced to continue, if some ELF header
-   sanity check for the stripped and unstripped files failed.  */
-static void
-warn (const char *msg, bool force,
-      const char *stripped_file, const char *unstripped_file)
-{
-  error (force ? 0 : EXIT_FAILURE, 0, "%s'%s' and '%s' %s%s.",
-	 force ? _("WARNING: ") : "",
-	 stripped_file, unstripped_file, msg,
-	 force ? "" : _(", use --force"));
-}
-
-/* Handle a pair of files we need to open by name.  */
-static void
-handle_explicit_files (const char *output_file, bool create_dirs, bool force,
-		       const char *stripped_file, const char *unstripped_file)
-{
-  int stripped_fd = open_file (stripped_file, false);
-  Elf *stripped = elf_begin (stripped_fd, ELF_C_READ, NULL);
-  GElf_Ehdr stripped_ehdr;
-  ELF_CHECK (gelf_getehdr (stripped, &stripped_ehdr),
-	     _("cannot create ELF descriptor: %s"));
-
-  int unstripped_fd = -1;
-  Elf *unstripped = NULL;
-  if (unstripped_file != NULL)
-    {
-      unstripped_fd = open_file (unstripped_file, output_file == NULL);
-      unstripped = elf_begin (unstripped_fd,
-			      (output_file == NULL ? ELF_C_RDWR : ELF_C_READ),
-			      NULL);
-      GElf_Ehdr unstripped_ehdr;
-      ELF_CHECK (gelf_getehdr (unstripped, &unstripped_ehdr),
-		 _("cannot create ELF descriptor: %s"));
-
-      if (memcmp (stripped_ehdr.e_ident,
-		  unstripped_ehdr.e_ident, EI_NIDENT) != 0)
-	warn (_("ELF header identification (e_ident) different"), force,
-	      stripped_file, unstripped_file);
-
-      if (stripped_ehdr.e_type != unstripped_ehdr.e_type)
-	warn (_("ELF header type (e_type) different"), force,
-	      stripped_file, unstripped_file);
-
-      if (stripped_ehdr.e_machine != unstripped_ehdr.e_machine)
-	warn (_("ELF header machine type (e_machine) different"), force,
-	      stripped_file, unstripped_file);
-
-      if (stripped_ehdr.e_phnum < unstripped_ehdr.e_phnum)
-	warn (_("stripped program header (e_phnum) smaller than unstripped"),
-	      force, stripped_file, unstripped_file);
-    }
-
-  handle_file (output_file, create_dirs, stripped, &stripped_ehdr, unstripped);
-
-  elf_end (stripped);
-  close (stripped_fd);
-
-  elf_end (unstripped);
-  close (unstripped_fd);
-}
-
-
-/* Handle a pair of files opened implicitly by libdwfl for one module.  */
-static void
-handle_dwfl_module (const char *output_file, bool create_dirs, bool force,
-		    Dwfl_Module *mod, bool all, bool ignore, bool relocate)
-{
-  GElf_Addr bias;
-  Elf *stripped = dwfl_module_getelf (mod, &bias);
-  if (stripped == NULL)
-    {
-      if (ignore)
-	return;
-
-      const char *file;
-      const char *modname = dwfl_module_info (mod, NULL, NULL, NULL,
-					      NULL, NULL, &file, NULL);
-      if (file == NULL)
-	error (EXIT_FAILURE, 0,
-	       _("cannot find stripped file for module '%s': %s"),
-	       modname, dwfl_errmsg (-1));
-      else
-	error (EXIT_FAILURE, 0,
-	       _("cannot open stripped file '%s' for module '%s': %s"),
-	       modname, file, dwfl_errmsg (-1));
-    }
-
-  Elf *debug = dwarf_getelf (dwfl_module_getdwarf (mod, &bias));
-  if (debug == NULL && !all)
-    {
-      if (ignore)
-	return;
-
-      const char *file;
-      const char *modname = dwfl_module_info (mod, NULL, NULL, NULL,
-					      NULL, NULL, NULL, &file);
-      if (file == NULL)
-	error (EXIT_FAILURE, 0,
-	       _("cannot find debug file for module '%s': %s"),
-	       modname, dwfl_errmsg (-1));
-      else
-	error (EXIT_FAILURE, 0,
-	       _("cannot open debug file '%s' for module '%s': %s"),
-	       modname, file, dwfl_errmsg (-1));
-    }
-
-  if (debug == stripped)
-    {
-      if (all)
-	debug = NULL;
-      else
-	{
-	  const char *file;
-	  const char *modname = dwfl_module_info (mod, NULL, NULL, NULL,
-						  NULL, NULL, &file, NULL);
-	  error (EXIT_FAILURE, 0, _("module '%s' file '%s' is not stripped"),
-		 modname, file);
-	}
-    }
-
-  GElf_Ehdr stripped_ehdr;
-  ELF_CHECK (gelf_getehdr (stripped, &stripped_ehdr),
-	     _("cannot create ELF descriptor: %s"));
-
-  if (stripped_ehdr.e_type == ET_REL)
-    {
-      if (!relocate)
-	{
-	  /* We can't use the Elf handles already open,
-	     because the DWARF sections have been relocated.  */
-
-	  const char *stripped_file = NULL;
-	  const char *unstripped_file = NULL;
-	  (void) dwfl_module_info (mod, NULL, NULL, NULL, NULL, NULL,
-				   &stripped_file, &unstripped_file);
-
-	  handle_explicit_files (output_file, create_dirs, force,
-				 stripped_file, unstripped_file);
-	  return;
-	}
-
-      /* Relocation is what we want!  This ensures that all sections that can
-	 get sh_addr values assigned have them, even ones not used in DWARF.
-	 They might still be used in the symbol table.  */
-      if (dwfl_module_relocations (mod) < 0)
-	error (EXIT_FAILURE, 0,
-	       _("cannot cache section addresses for module '%s': %s"),
-	       dwfl_module_info (mod, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-	       dwfl_errmsg (-1));
-    }
-
-  handle_file (output_file, create_dirs, stripped, &stripped_ehdr, debug);
-}
-
-/* Handle one module being written to the output directory.  */
-static void
-handle_output_dir_module (const char *output_dir, Dwfl_Module *mod, bool force,
-			  bool all, bool ignore, bool modnames, bool relocate)
-{
-  if (! modnames)
-    {
-      /* Make sure we've searched for the ELF file.  */
-      GElf_Addr bias;
-      (void) dwfl_module_getelf (mod, &bias);
-    }
-
-  const char *file;
-  const char *name = dwfl_module_info (mod, NULL, NULL, NULL,
-				       NULL, NULL, &file, NULL);
-
-  if (file == NULL && ignore)
-    return;
-
-  char *output_file = xasprintf ("%s/%s", output_dir, modnames ? name : file);
-
-  handle_dwfl_module (output_file, true, force, mod, all, ignore, relocate);
-
-  free (output_file);
-}
-
-
-static void
-list_module (Dwfl_Module *mod)
-{
-  /* Make sure we have searched for the files.  */
-  GElf_Addr bias;
-  bool have_elf = dwfl_module_getelf (mod, &bias) != NULL;
-  bool have_dwarf = dwfl_module_getdwarf (mod, &bias) != NULL;
-
-  const char *file;
-  const char *debug;
-  Dwarf_Addr start;
-  Dwarf_Addr end;
-  const char *name = dwfl_module_info (mod, NULL, &start, &end,
-				       NULL, NULL, &file, &debug);
-  if (file != NULL && debug != NULL && (debug == file || !strcmp (debug, file)))
-    debug = ".";
-
-  const unsigned char *id;
-  GElf_Addr id_vaddr;
-  int id_len = dwfl_module_build_id (mod, &id, &id_vaddr);
-
-  printf ("%#" PRIx64 "+%#" PRIx64 " ", start, end - start);
-
-  if (id_len > 0)
-    {
-      do
-	printf ("%02" PRIx8, *id++);
-      while (--id_len > 0);
-      if (id_vaddr != 0)
-	printf ("@%#" PRIx64, id_vaddr);
-    }
-  else
-    putchar ('-');
-
-  printf (" %s %s %s\n",
-	  file ?: have_elf ? "." : "-",
-	  debug ?: have_dwarf ? "." : "-",
-	  name);
-}
-
-
-struct match_module_info
-{
-  char **patterns;
-  Dwfl_Module *found;
-  bool match_files;
-};
-
-static int
-match_module (Dwfl_Module *mod,
-	      void **userdata __attribute__ ((unused)),
-	      const char *name,
-	      Dwarf_Addr start __attribute__ ((unused)),
-	      void *arg)
-{
-  struct match_module_info *info = arg;
-
-  if (info->patterns[0] == NULL) /* Match all.  */
-    {
-    match:
-      info->found = mod;
-      return DWARF_CB_ABORT;
-    }
-
-  if (info->match_files)
-    {
-      /* Make sure we've searched for the ELF file.  */
-      GElf_Addr bias;
-      (void) dwfl_module_getelf (mod, &bias);
-
-      const char *file;
-      const char *check = dwfl_module_info (mod, NULL, NULL, NULL,
-					    NULL, NULL, &file, NULL);
-      if (check == NULL || strcmp (check, name) != 0 || file == NULL)
-	return DWARF_CB_OK;
-
-      name = file;
-    }
-
-  for (char **p = info->patterns; *p != NULL; ++p)
-    if (fnmatch (*p, name, 0) == 0)
-      goto match;
-
-  return DWARF_CB_OK;
-}
-
-/* Handle files opened implicitly via libdwfl.  */
-static void
-handle_implicit_modules (const struct arg_info *info)
-{
-  struct match_module_info mmi = { info->args, NULL, info->match_files };
-  ptrdiff_t offset = dwfl_getmodules (info->dwfl, &match_module, &mmi, 0);
-  if (offset == 0)
-    error (EXIT_FAILURE, 0, _("no matching modules found"));
-
-  if (info->list)
-    do
-      list_module (mmi.found);
-    while ((offset = dwfl_getmodules (info->dwfl, &match_module, &mmi,
-				      offset)) > 0);
-  else if (info->output_dir == NULL)
-    {
-      if (dwfl_getmodules (info->dwfl, &match_module, &mmi, offset) != 0)
-	error (EXIT_FAILURE, 0, _("matched more than one module"));
-      handle_dwfl_module (info->output_file, false, info->force, mmi.found,
-			  info->all, info->ignore, info->relocate);
-    }
-  else
-    do
-      handle_output_dir_module (info->output_dir, mmi.found, info->force,
-				info->all, info->ignore,
-				info->modnames, info->relocate);
-    while ((offset = dwfl_getmodules (info->dwfl, &match_module, &mmi,
-				      offset)) > 0);
-}
-
-int
-main (int argc, char **argv)
-{
-  /* We use no threads here which can interfere with handling a stream.  */
-  __fsetlocking (stdin, FSETLOCKING_BYCALLER);
-  __fsetlocking (stdout, FSETLOCKING_BYCALLER);
-  __fsetlocking (stderr, FSETLOCKING_BYCALLER);
-
-  /* Set locale.  */
-  setlocale (LC_ALL, "");
-
-  /* Make sure the message catalog can be found.  */
-  bindtextdomain (PACKAGE_TARNAME, LOCALEDIR);
-
-  /* Initialize the message catalog.  */
-  textdomain (PACKAGE_TARNAME);
-
-  /* Parse and process arguments.  */
-  const struct argp_child argp_children[] =
-    {
-      {
-	.argp = dwfl_standard_argp (),
-	.header = N_("Input selection options:"),
-	.group = 1,
-      },
-      { .argp = NULL },
-    };
-  const struct argp argp =
-    {
-      .options = options,
-      .parser = parse_opt,
-      .children = argp_children,
-      .args_doc = N_("STRIPPED-FILE DEBUG-FILE\n[MODULE...]"),
-      .doc = N_("\
-Combine stripped files with separate symbols and debug information.\n\
-\n\
-The first form puts the result in DEBUG-FILE if -o was not given.\n\
-\n\
-MODULE arguments give file name patterns matching modules to process.\n\
-With -f these match the file name of the main (stripped) file \
-(slashes are never special), otherwise they match the simple module names.  \
-With no arguments, process all modules found.\n\
-\n\
-Multiple modules are written to files under OUTPUT-DIRECTORY, \
-creating subdirectories as needed.  \
-With -m these files have simple module names, otherwise they have the \
-name of the main file complete with directory underneath OUTPUT-DIRECTORY.\n\
-\n\
-With -n no files are written, but one line to standard output for each module:\
-\n\tSTART+SIZE BUILDID FILE DEBUGFILE MODULENAME\n\
-START and SIZE are hexadecimal giving the address bounds of the module.  \
-BUILDID is hexadecimal for the build ID bits, or - if no ID is known; \
-the hexadecimal may be followed by @0xADDR giving the address where the \
-ID resides if that is known.  \
-FILE is the file name found for the module, or - if none was found, \
-or . if an ELF image is available but not from any named file.  \
-DEBUGFILE is the separate debuginfo file name, \
-or - if no debuginfo was found, or . if FILE contains the debug information.\
-")
-    };
-
-  int remaining;
-  struct arg_info info = { .args = NULL };
-  error_t result = argp_parse (&argp, argc, argv, 0, &remaining, &info);
-  if (result == ENOSYS)
-    assert (info.dwfl == NULL);
-  else if (result)
-    return EXIT_FAILURE;
-  assert (info.args != NULL);
-
-  /* Tell the library which version we are expecting.  */
-  elf_version (EV_CURRENT);
-
-  if (info.dwfl == NULL)
-    {
-      assert (result == ENOSYS);
-
-      if (info.output_dir != NULL)
-	{
-	  char *file = xasprintf ("%s/%s", info.output_dir, info.args[0]);
-	  handle_explicit_files (file, true, info.force,
-				 info.args[0], info.args[1]);
-	  free (file);
-	}
-      else
-	handle_explicit_files (info.output_file, false, info.force,
-			       info.args[0], info.args[1]);
-    }
-  else
-    {
-      /* parse_opt checked this.  */
-      assert (info.output_file != NULL || info.output_dir != NULL || info.list);
-
-      handle_implicit_modules (&info);
-
-      dwfl_end (info.dwfl);
-    }
-
-  return 0;
-}
-
-
-#include "debugpred.h"
