/*
 * Copyright (c) 2023, kleines Filmr√∂llchen <filmroellchen@serenityos.org>
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */

#include "PropertyDefinition.h"
#include <AK/Forward.h>
#include <AK/HashTable.h>
#include <AK/LexicalPath.h>
#include <AK/SourceGenerator.h>
#include <AK/String.h>
#include <AK/Try.h>
#include <AK/Utf8View.h>
#include <LibCore/ArgsParser.h>
#include <LibCore/File.h>
#include <LibGUI/GML/Parser.h>
#include <LibGUI/UIDimensions.h>
#include <LibMain/Main.h>

enum class UseObjectConstructor : bool {
    No,
    Yes,
};

static ErrorOr<String> include_path_for(StringView widget_name, HashMap<String, WidgetProperties> const& property_definitions)
{
    auto const maybe_widget_properties = property_definitions.get(widget_name);
    if (!maybe_widget_properties.has_value()) {
        warnln("widget {} not found", widget_name);
        return Error::from_string_view("Widget not found in property definitions"sv);
    }
    auto const& widget_properties = maybe_widget_properties.value();
    return String::formatted("<{}>", widget_properties.header());
}

// Each entry is an include path, without the "#include" itself.
static ErrorOr<HashTable<String>> extract_necessary_includes(GUI::GML::Object const& gml_hierarchy, HashMap<String, WidgetProperties> const& property_definitions)
{
    HashTable<String> necessary_includes;
    TRY(necessary_includes.try_set(TRY(include_path_for(gml_hierarchy.name(), property_definitions))));
    if (gml_hierarchy.layout_object() != nullptr)
        TRY(necessary_includes.try_set(TRY(include_path_for(gml_hierarchy.layout_object()->name(), property_definitions))));

    TRY(gml_hierarchy.try_for_each_child_object([&](auto const& object) -> ErrorOr<void> {
        auto necessary_child_includes = TRY(extract_necessary_includes(object, property_definitions));
        for (auto const& include : necessary_child_includes)
            TRY(necessary_includes.try_set(include));
        return {};
    }));

    return necessary_includes;
}

static char const header[] = R"~~~(
/*
 * Auto-generated by the GML compiler
 */

)~~~";

static char const function_start[] = R"~~~(
// Creates a @main_class_name@ and initializes it.
// This function was auto-generated by the GML compiler.
ErrorOr<NonnullRefPtr<@main_class_name@>> @main_class_name@::try_create()
{
    RefPtr<::@main_class_name@> main_object;

)~~~";

static char const footer[] = R"~~~(
    return main_object.release_nonnull();
}
)~~~";

// Loads an object and assigns it to the RefPtr<Widget> variable named object_name.
// All loading happens in a separate block.
static ErrorOr<void> generate_loader_for_object(GUI::GML::Object const& gml_object, SourceGenerator generator, String object_name, size_t indentation, UseObjectConstructor use_object_constructor, HashMap<String, WidgetProperties> const& property_definitions)
{
    generator.set("object_name", object_name.to_byte_string());
    generator.set("class_name", gml_object.name());

    auto append = [&]<size_t N>(auto& generator, char const(&text)[N]) -> ErrorOr<void> {
        generator.append(TRY(String::repeated(' ', indentation * 4)).bytes_as_string_view());
        generator.appendln(text);
        return {};
    };

    generator.append(TRY(String::repeated(' ', (indentation - 1) * 4)).bytes_as_string_view());
    generator.appendln("{");
    if (use_object_constructor == UseObjectConstructor::Yes)
        TRY(append(generator, "@object_name@ = TRY(@class_name@::try_create());"));
    else
        TRY(append(generator, "@object_name@ = TRY(adopt_nonnull_ref_or_enomem(new (nothrow) ::@class_name@()));"));

    // Properties
    auto const maybe_widget_properties = property_definitions.get(gml_object.name());
    if (!maybe_widget_properties.has_value())
        return Error::from_string_view("Widget not found in property definitions"sv);
    auto const& widget_properties = maybe_widget_properties.value();
    TRY(gml_object.try_for_each_property([&](StringView key, NonnullRefPtr<GUI::GML::JsonValueNode> value) -> ErrorOr<void> {
        auto const maybe_property_definition = widget_properties.properties().get(key);
        if (!maybe_property_definition.has_value()) {
            // These errors are common and hard to track down, so we *definitely* want some extra context here.
            warnln("in object {}: undefined property {}", gml_object.name(), key);
            return Error::from_string_view("Undefined property"sv);
        }
        auto const& property_definition = maybe_property_definition.value();
        auto maybe_value_code = property_definition.type.generate_initializer_for(value);
        if (maybe_value_code.is_error()) {
            warnln("{}", maybe_value_code.error());
            return Error::from_string_view("Invalid property value"sv);
        }

        auto property_generator = generator.fork();
        property_generator.set("setter", property_definition.setter);
        property_generator.set("value", maybe_value_code.release_value());
        TRY(append(property_generator, R"~~~(@object_name@->@setter@(@value@);)~~~"));
        return {};
    }));
    generator.appendln("");

    // Layout
    if (gml_object.layout_object() != nullptr) {
        TRY(append(generator, "RefPtr<GUI::Layout> layout;"));
        TRY(generate_loader_for_object(*gml_object.layout_object(), generator.fork(), TRY(String::from_utf8("layout"sv)), indentation + 1, UseObjectConstructor::Yes, property_definitions));
        TRY(append(generator, "@object_name@->set_layout(layout.release_nonnull());"));
        generator.appendln("");
    }

    // Children
    size_t current_child_index = 0;
    auto next_child_name = [&]() {
        return String::formatted("{}_child_{}", object_name, current_child_index++);
    };
    TRY(gml_object.try_for_each_child_object([&](auto const& child) -> ErrorOr<void> {
        // Spacer is a pseudo-class that instead causes a call to `Widget::add_spacer` on the parent object.
        if (child.name() == "GUI::Layout::Spacer"sv) {
            TRY(append(generator, "@object_name@->add_spacer();"));
            return {};
        }

        auto child_generator = generator.fork();
        auto child_variable_name = TRY(next_child_name());
        child_generator.set("child_variable_name", child_variable_name.bytes_as_string_view());
        child_generator.set("child_class_name", child.name());
        TRY(append(child_generator, "RefPtr<::@child_class_name@> @child_variable_name@;"));
        TRY(generate_loader_for_object(child, child_generator.fork(), child_variable_name, indentation + 1, UseObjectConstructor::Yes, property_definitions));

        // Handle the current two special cases of child adding.
        if (gml_object.name() == "GUI::ScrollableContainerWidget"sv)
            TRY(append(child_generator, "static_ptr_cast<GUI::ScrollableContainerWidget>(@object_name@)->set_widget(*@child_variable_name@);"));
        else if (gml_object.name() == "GUI::TabWidget"sv)
            TRY(append(child_generator, "static_ptr_cast<GUI::TabWidget>(@object_name@)->add_widget(*@child_variable_name@);"));
        else
            TRY(append(child_generator, "TRY(@object_name@->try_add_child(*@child_variable_name@));"));
        child_generator.appendln("");
        return {};
    }));

    TRY(append(generator, "TRY(::GUI::initialize(*@object_name@));"));

    generator.append(TRY(String::repeated(' ', (indentation - 1) * 4)).bytes_as_string_view());
    generator.appendln("}");

    return {};
}

static ErrorOr<String> generate_cpp(NonnullRefPtr<GUI::GML::GMLFile> gml, HashMap<String, WidgetProperties> const& property_definitions)
{
    StringBuilder builder;
    SourceGenerator generator { builder };

    generator.append(header);

    auto const& main_class = gml->main_class();
    auto necessary_includes = TRY(extract_necessary_includes(main_class, property_definitions));
    static String const always_necessary_includes[] = {
        TRY(String::from_utf8("<AK/Error.h>"sv)),
        TRY(String::from_utf8("<AK/JsonValue.h>"sv)),
        TRY(String::from_utf8("<AK/NonnullRefPtr.h>"sv)),
        TRY(String::from_utf8("<AK/RefPtr.h>"sv)),
        TRY(String::from_utf8("<LibGfx/Font/FontWeight.h>"sv)),
        // For Gfx::ColorRole
        TRY(String::from_utf8("<LibGfx/SystemTheme.h>"sv)),
        TRY(String::from_utf8("<LibGUI/Widget.h>"sv)),
        // For Gfx::FontWeight
        TRY(String::from_utf8("<LibGfx/Font/FontDatabase.h>"sv)),
    };
    TRY(necessary_includes.try_set_from(always_necessary_includes));
    for (auto const& include : necessary_includes)
        generator.appendln(TRY(String::formatted("#include {}", include)).bytes_as_string_view());

    // FIXME: Use a UTF-8 aware function once possible.
    generator.set("main_class_name", main_class.name());
    generator.append(function_start);
    TRY(generate_loader_for_object(main_class, generator.fork(), "main_object"_string, 2, UseObjectConstructor::No, property_definitions));

    generator.append(footer);
    return builder.to_string();
}

ErrorOr<int> serenity_main(Main::Arguments arguments)
{
    Core::ArgsParser argument_parser;
    StringView gml_file_name;
    Vector<ByteString> property_files;
    argument_parser.add_option(property_files, "Property definition files to use", "property-definition", 0, "PROPERTY_DEFINITION");
    argument_parser.add_positional_argument(gml_file_name, "GML file to compile", "GML_FILE", Core::ArgsParser::Required::Yes);
    argument_parser.parse(arguments);

    JsonArray properties_json;
    for (auto const& property_file : property_files) {
        auto maybe_file = Core::File::open(property_file, Core::File::OpenMode::Read);
        if (maybe_file.is_error()) {
            warnln("Couldn't open property file {} ({}), skipping", property_file, maybe_file.error());
            continue;
        }
        auto properties_text = TRY(TRY(maybe_file)->read_until_eof());
        auto maybe_properties_json = JsonValue::from_string(properties_text);
        if (maybe_properties_json.is_error()) {
            warnln("property file {}: JSON error: {}", property_file, maybe_properties_json.release_error());
            continue;
        }
        if (!maybe_properties_json.value().is_array()) {
            warnln("property file {}: JSON error: does not contain a top-level array", property_file);
            continue;
        }
        auto new_properties_json = maybe_properties_json.release_value().as_array();
        for (auto const& value : new_properties_json.values()) {
            TRY(properties_json.append(value));
        }
    }

    auto maybe_new_properties = WidgetProperties::parse_properties(properties_json);
    if (maybe_new_properties.is_error()) {
        warnln("property definition error: {}", maybe_new_properties.release_error());
        return 1;
    }
    auto properties = maybe_new_properties.release_value();
    auto maybe_error = WidgetProperties::expand_inherited_properties(properties);
    if (maybe_error.is_error())
        warnln("property definition error: {}", maybe_error.release_error());

    auto gml_text = TRY(TRY(Core::File::open(gml_file_name, Core::File::OpenMode::Read))->read_until_eof());
    auto parsed_gml = TRY(GUI::GML::parse_gml(gml_text));
    auto generated_cpp = TRY(generate_cpp(parsed_gml, properties));
    outln("{}", generated_cpp);
    return 0;
}
